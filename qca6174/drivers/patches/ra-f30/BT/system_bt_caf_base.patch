diff --git a/Android.mk b/Android.mk
index 11aaa74..00e8261 100644
--- a/Android.mk
+++ b/Android.mk
@@ -23,6 +23,10 @@ endif
 
 bluetooth_CFLAGS += -DUSE_AUDIO_TRACK
 
+ifeq ($(BOARD_USES_WIPOWER),true)
+bluetooth_CFLAGS += -DWIPOWER_SUPPORTED
+endif
+
 bluetooth_CFLAGS += -DEXPORT_SYMBOL="__attribute__((visibility(\"default\")))"
 
 #
diff --git a/EventLogTags.logtags b/EventLogTags.logtags
new file mode 100644
index 0000000..dc1d239
--- /dev/null
+++ b/EventLogTags.logtags
@@ -0,0 +1,38 @@
+# The entries in this file map a sparse set of log tag numbers to tag names.
+# This is installed on the device, in /system/etc, and parsed by logcat.
+#
+# Tag numbers are decimal integers, from 0 to 2^31.  (Let's leave the
+# negative values alone for now.)
+#
+# Tag names are one or more ASCII letters and numbers or underscores, i.e.
+# "[A-Z][a-z][0-9]_".  Do not include spaces or punctuation (the former
+# impacts log readability, the latter makes regex searches more annoying).
+#
+# Tag numbers and names are separated by whitespace.  Blank lines and lines
+# starting with '#' are ignored.
+#
+# Optionally, after the tag names can be put a description for the value(s)
+# of the tag. Description are in the format
+#    (<name>|data type[|data unit])
+# Multiple values are separated by commas.
+#
+# The data type is a number from the following values:
+# 1: int
+# 2: long
+# 3: string
+# 4: list
+#
+# The data unit is a number taken from the following list:
+# 1: Number of objects
+# 2: Number of bytes
+# 3: Number of milliseconds
+# 4: Number of allocations
+# 5: Id
+# 6: Percent
+# Default value for data of type int/long is 2 (bytes).
+#
+# TODO: generate ".java" and ".h" files with integer constants from this file.
+
+1010000 bt_hci_timeout (opcode|1)
+1010001 bt_config_source (opcode|1)
+1010002 bt_hci_unknown_type (hci_type|1)
diff --git a/audio_a2dp_hw/audio_a2dp_hw.c b/audio_a2dp_hw/audio_a2dp_hw.c
index 4de0b0b..e901c26 100644
--- a/audio_a2dp_hw/audio_a2dp_hw.c
+++ b/audio_a2dp_hw/audio_a2dp_hw.c
@@ -672,8 +672,7 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
                          size_t bytes)
 {
     struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
-    int sent;
-    int us_delay;
+    int sent = -1;
     #ifdef BT_AUDIO_SYSTRACE_LOG
     char trace_buf[512];
     #endif
@@ -683,8 +682,8 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
     pthread_mutex_lock(&out->common.lock);
     if (out->common.state == AUDIO_A2DP_STATE_SUSPENDED ||
             out->common.state == AUDIO_A2DP_STATE_STOPPING) {
-        INFO("stream suspended or closing");
-        goto error;
+        DEBUG("stream suspended or closing");
+        goto finish;
     }
 
     /* only allow autostarting if we are in stopped or standby */
@@ -697,13 +696,13 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
         if (start_audio_datapath(&out->common) < 0)
 #endif
         {
-            goto error;
+            goto finish;
         }
     }
     else if (out->common.state != AUDIO_A2DP_STATE_STARTED)
     {
         ERROR("stream not in stopped or standby");
-        goto error;
+        goto finish;
     }
     #ifdef BT_AUDIO_SAMPLE_LOG
     if (outputpcmsamplefile)
@@ -752,26 +751,24 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
         } else {
             ERROR("write failed : stream suspended, avoid resetting state");
         }
-        goto error;
+        goto finish;
     }
 
+finish: ;
     const size_t frames = bytes / audio_stream_out_frame_size(stream);
     out->frames_rendered += frames;
     out->frames_presented += frames;
     pthread_mutex_unlock(&out->common.lock);
-    return bytes;
 
-error:
-    pthread_mutex_unlock(&out->common.lock);
-    us_delay = calc_audiotime(out->common.cfg, bytes);
-
-    DEBUG("emulate a2dp write delay (%d us)", us_delay);
-
-    usleep(us_delay);
+    // If send didn't work out, sleep to emulate write delay.
+    if (sent == -1) {
+        const int us_delay = calc_audiotime(out->common.cfg, bytes);
+        DEBUG("emulate a2dp write delay (%d us)", us_delay);
+        usleep(us_delay);
+    }
     return bytes;
 }
 
-
 static uint32_t out_get_sample_rate(const struct audio_stream *stream)
 {
     struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
@@ -1418,7 +1415,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     INFO("success");
     /* Delay to ensure Headset is in proper state when START is initiated
        from DUT immediately after the connection due to ongoing music playback. */
-    usleep(250000);
+    usleep(1000000);
     return 0;
 
 err_open:
diff --git a/audio_a2dp_hw/audio_a2dp_hw.h b/audio_a2dp_hw/audio_a2dp_hw.h
index 8c30b76..67fd212 100644
--- a/audio_a2dp_hw/audio_a2dp_hw.h
+++ b/audio_a2dp_hw/audio_a2dp_hw.h
@@ -65,7 +65,7 @@
 // 20 * 512 is not sufficient size to smooth the variability for some BT devices,
 // resulting in mixer sleep and throttling. We increase this to 28 * 512 to help
 // reduce the effect of variable data consumption.
-#define AUDIO_STREAM_OUTPUT_BUFFER_SZ      (28*512)
+#define AUDIO_STREAM_OUTPUT_BUFFER_SZ     (28*1024)
 
 // AUDIO_STREAM_OUTPUT_BUFFER_PERIODS controls how the socket buffer is divided
 // for AudioFlinger data delivery. The AudioFlinger mixer delivers data in chunks
@@ -104,6 +104,7 @@ typedef enum {
     A2DP_CTRL_ACK_SUCCESS,
     A2DP_CTRL_ACK_FAILURE,
     A2DP_CTRL_ACK_INCALL_FAILURE, /* Failure when in Call*/
+    A2DP_CTRL_ACK_DISCONNECT_IN_PROGRESS, /* Ack when Disconnection in Progress */
     A2DP_CTRL_ACK_UNSUPPORTED
 } tA2DP_CTRL_ACK;
 
@@ -124,6 +125,7 @@ struct a2dp_config {
 };
 
 /* move ctrl_fd outside output stream and keep open until HAL unloaded ? */
+#define  MAX_CODEC_CFG_SIZE  30
 
 struct a2dp_stream_common {
     pthread_mutex_t         lock;
@@ -132,7 +134,7 @@ struct a2dp_stream_common {
     size_t                  buffer_sz;
     struct a2dp_config      cfg;
     a2dp_state_t            state;
-    uint8_t                 codec_cfg[20];
+    uint8_t                 codec_cfg[MAX_CODEC_CFG_SIZE];
 };
 /*****************************************************************************
 **  Type definitions for callback functions
diff --git a/audio_a2dp_hw/bthost_ipc.c b/audio_a2dp_hw/bthost_ipc.c
index 7139cc5..5137e94 100644
--- a/audio_a2dp_hw/bthost_ipc.c
+++ b/audio_a2dp_hw/bthost_ipc.c
@@ -57,11 +57,15 @@
 
 
 static int bt_split_a2dp_enabled = 0;
+static int open_ctrl_chnl_fail_count = 0;
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
-#define STREAM_START_MAX_RETRY_COUNT 80 /* Retry for 8sec to address IOT issue*/
-#define CTRL_CHAN_RETRY_COUNT 3
+/* Below two values adds up to 8 sec retry to address IOT issues*/
+#define STREAM_START_MAX_RETRY_COUNT 10
+#define STREAM_START_MAX_RETRY_LOOPER 8
+
+#define CTRL_CHAN_RETRY_COUNT 1
 #define USEC_PER_SEC 1000000L
 #define SOCK_SEND_TIMEOUT_MS 2000  /* Timeout for sending */
 #define SOCK_RECV_TIMEOUT_MS 5000  /* Timeout for receiving */
@@ -99,6 +103,7 @@ audio_aac_encoder_config aac_codec;
 /*****************************************************************************
 **  Functions
 ******************************************************************************/
+static int check_a2dp_open_ready(struct a2dp_stream_common *common);
 void a2dp_open_ctrl_path(struct a2dp_stream_common *common);
 /*****************************************************************************
 **   Miscellaneous helper functions
@@ -172,7 +177,13 @@ static void* a2dp_codec_parser(uint8_t *codec_cfg, audio_format_t *codec_type)
     char byte,len;
     uint8_t *p_cfg = codec_cfg;
     INFO("%s",__func__);
-    if (codec_cfg[CODEC_OFFSET] == CODEC_TYPE_SBC)
+    if (codec_cfg[CODEC_OFFSET] == CODEC_TYPE_PCM)
+    {
+        *codec_type = AUDIO_FORMAT_PCM_16_BIT;
+        //For the time being Audio does not require any param to be passed for PCM so returning null
+        return NULL;
+    }
+    else if (codec_cfg[CODEC_OFFSET] == CODEC_TYPE_SBC)
     {
         memset(&sbc_codec,0,sizeof(audio_sbc_encoder_config));
         p_cfg++;//skip dev idx
@@ -588,7 +599,7 @@ int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int lengt
             ERROR("ack failed: error(%s)", strerror(errno));
             break;
         }
-        if (i == (CTRL_CHAN_RETRY_COUNT - 1)) {
+        if (i == (CTRL_CHAN_RETRY_COUNT + 1)) {
             ERROR("ack failed: max retry count");
             break;
         }
@@ -605,9 +616,11 @@ int a2dp_command(struct a2dp_stream_common *common, char cmd)
 {
     char ack;
 
-    INFO("A2DP COMMAND %s", dump_a2dp_ctrl_event(cmd));
+    INFO("A2DP COMMAND %s, fail count %d", dump_a2dp_ctrl_event(cmd),
+                                                open_ctrl_chnl_fail_count);
 
-    if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED) {
+    if ((common->ctrl_fd == AUDIO_SKT_DISCONNECTED)
+        && (open_ctrl_chnl_fail_count < 5)){
         INFO("recovering from previous error");
         a2dp_open_ctrl_path(common);
         if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED) {
@@ -615,6 +628,11 @@ int a2dp_command(struct a2dp_stream_common *common, char cmd)
             return -1;
         }
     }
+    else if (open_ctrl_chnl_fail_count >= 5)
+    {
+        WARN("control channel open alreday failed 5 times, bailing out");
+        return -1;
+    }
 
     /* send command */
     ssize_t sent;
@@ -635,7 +653,7 @@ int a2dp_command(struct a2dp_stream_common *common, char cmd)
 
     INFO("A2DP COMMAND %s DONE STATUS %d", dump_a2dp_ctrl_event(cmd), ack);
 
-    if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)
+    if (ack == A2DP_CTRL_ACK_INCALL_FAILURE || ack == A2DP_CTRL_ACK_DISCONNECT_IN_PROGRESS)
         return ack;
     if (ack != A2DP_CTRL_ACK_SUCCESS) {
         ERROR("A2DP COMMAND %s error %d", dump_a2dp_ctrl_event(cmd), ack);
@@ -688,7 +706,7 @@ int a2dp_read_codec_config(struct a2dp_stream_common *common,uint8_t idx)
     cmd[0] = A2DP_CTRL_GET_CODEC_CONFIG;
     cmd[1] = idx;
     INFO("%s",__func__);
-    memset(p_codec_cfg,0,20);
+    memset(p_codec_cfg,0,MAX_CODEC_CFG_SIZE);
     INFO("%s",__func__);
 
     if (send(common->ctrl_fd, cmd, 2,  MSG_NOSIGNAL) == -1)
@@ -707,7 +725,8 @@ int a2dp_read_codec_config(struct a2dp_stream_common *common,uint8_t idx)
         ERROR("%s: Failed to get ack",__func__);
         return -1;
     }
-    if (a2dp_ctrl_receive(common, &len, 1) < 0)
+    if ((a2dp_ctrl_receive(common, &len, 1) < 0) ||
+        (len <= 0) || (len > MAX_CODEC_CFG_SIZE))
         return -1;
     if (a2dp_ctrl_receive(common, p_codec_cfg, len) < 0)
         return -1;
@@ -750,17 +769,30 @@ void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
         if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)
         {
             /* success, now check if stack is ready */
-            if (check_a2dp_ready(common) == 0)
-                break;
-
-            ERROR("error : a2dp not ready, wait 250 ms and retry");
-            usleep(250000);
+            if (check_a2dp_open_ready(common) == 0)
+            {
+                open_ctrl_chnl_fail_count = 0;
+                WARN("a2dp_open_ctrl_path : Fail count reset to 0");
+                return;
+            }
+            ERROR("a2dp_open_ctrl_path : No valid a2dp connection, abort");
+            usleep(100000);
             skt_disconnect(common->ctrl_fd);
             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
         }
 
         /* ctrl channel not ready, wait a bit */
-        usleep(250000);
+        if (i < CTRL_CHAN_RETRY_COUNT - 1)
+        {
+            usleep(100000);
+        }
+    }
+    INFO("a2dp_open_ctrl_path : ctrl_fd: %d", common->ctrl_fd);
+    if (common->ctrl_fd <= 0)
+    {
+        open_ctrl_chnl_fail_count += 1;
+        WARN("a2dp_open_ctrl_path : Fail count raised to: %d",
+                                        open_ctrl_chnl_fail_count);
     }
 }
 
@@ -792,7 +824,7 @@ void a2dp_stream_common_init(struct a2dp_stream_common *common)
 int start_audio_datapath(struct a2dp_stream_common *common)
 {
     INFO("state %d", common->state);
-
+    int ret = 0;
     #ifdef BT_AUDIO_SYSTRACE_LOG
     char trace_buf[512];
     #endif
@@ -821,11 +853,19 @@ int start_audio_datapath(struct a2dp_stream_common *common)
     if (a2dp_status < 0)
     {
         ERROR("%s Audiopath start failed (status %d)", __func__, a2dp_status);
+        ret = -1;
         goto error;
     }
     else if (a2dp_status == A2DP_CTRL_ACK_INCALL_FAILURE)
     {
         ERROR("%s Audiopath start failed - in call, move to suspended", __func__);
+        ret = a2dp_status;
+        goto error;
+    }
+    else if (a2dp_status == A2DP_CTRL_ACK_DISCONNECT_IN_PROGRESS)
+    {
+        ERROR("%s Audiopath start failed - disconnection in progress", __func__);
+        ret = a2dp_status;
         goto error;
     }
     if (!bt_split_a2dp_enabled)
@@ -851,7 +891,10 @@ int start_audio_datapath(struct a2dp_stream_common *common)
     return 0;
 error:
     common->state = oldstate;
-    return -1;
+    if (bt_split_a2dp_enabled)
+        return ret;
+    else
+        return -1;
 }
 
 int stop_audio_datapath(struct a2dp_stream_common *common)
@@ -947,14 +990,24 @@ int audio_open_ctrl_path()
 
 int audio_start_stream()
 {
-    int i;
+    int i, status, j;
     INFO("%s: state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
 
+    pthread_mutex_lock(&audio_stream.lock);
     if (audio_stream.state == AUDIO_A2DP_STATE_SUSPENDED)
     {
         INFO("stream suspended");
+        pthread_mutex_unlock(&audio_stream.lock);
         return -1;
     }
+
+    if (audio_stream.state == AUDIO_A2DP_STATE_STARTED)
+    {
+        INFO("%s: stream alreday started", __func__);
+        pthread_mutex_unlock(&audio_stream.lock);
+        return 0;
+    }
+
     /* Sanity check if the ctrl_fd is valid. If audio_stream_close is not called
      * from audio hal previously when BT is turned off or device is disconnecte,
      * and tries to start stream again.
@@ -964,30 +1017,58 @@ int audio_start_stream()
         if (audio_stream.ctrl_fd != AUDIO_SKT_DISCONNECTED)
         {
             ERROR("BTIF is not ready to start stream");
+            pthread_mutex_unlock(&audio_stream.lock);
             return -1;
         }
         /* Try to start stream to recover from ctrl skt disconnect*/
     }
-    for (i = 0; i < STREAM_START_MAX_RETRY_COUNT; i++)
-    {
-        if (start_audio_datapath(&audio_stream) == 0)
+
+    for (j = 0; j <STREAM_START_MAX_RETRY_LOOPER; j++) {
+        for (i = 0; i < STREAM_START_MAX_RETRY_COUNT; i++)
         {
-            INFO("a2dp stream started successfully");
-            break;
+            status = start_audio_datapath(&audio_stream);
+            if (status == A2DP_CTRL_ACK_SUCCESS)
+            {
+                INFO("a2dp stream started successfully");
+                goto end;
+            }
+            else if (status == A2DP_CTRL_ACK_INCALL_FAILURE)
+            {
+                INFO("a2dp stream start failed: call in progress");
+                goto end;
+            }
+            else if (status == A2DP_CTRL_ACK_DISCONNECT_IN_PROGRESS)
+            {
+                INFO("a2dp stream start failed: disconnection in progress");
+                goto end;
+            }
+            if (audio_stream.ctrl_fd == AUDIO_SKT_DISCONNECTED)
+            {
+                INFO("control path is disconnected");
+                goto end;
+            }
+            INFO("%s: a2dp stream not started,wait 100mse & retry", __func__);
+            usleep(100000);
         }
-        if (audio_stream.ctrl_fd == AUDIO_SKT_DISCONNECTED)
-        {
-            INFO("control path is disconnected");
-            break;
+        INFO("%s: Check if valid connection is still up or not", __func__);
+
+        // For every 1 sec check if a2dp is still up, to avoid
+        // blocking the audio thread forever if a2dp connection is closed
+        // for some reason
+        if (check_a2dp_open_ready (&audio_stream) < 0) {
+            ERROR("%s: No valid a2dp connection\n", __func__);
+            pthread_mutex_unlock(&audio_stream.lock);
+            return -1;
         }
-        INFO("%s: a2dp stream not started,wait 100mse & retry", __func__);
-        usleep(100000);
     }
+end:
     if (audio_stream.state != AUDIO_A2DP_STATE_STARTED)
     {
-        ERROR("Failed to start a2dp stream");
+        ERROR("%s: Failed to start a2dp stream", __func__);
+        pthread_mutex_unlock(&audio_stream.lock);
         return -1;
     }
+    pthread_mutex_unlock(&audio_stream.lock);
     return 0;
 }
 
@@ -995,6 +1076,7 @@ int audio_stream_open()
 {
     INFO("%s",__func__);
     a2dp_stream_common_init(&audio_stream);
+    open_ctrl_chnl_fail_count = 0;
     a2dp_open_ctrl_path(&audio_stream);
     bt_split_a2dp_enabled = true;
     if (audio_stream.ctrl_fd != AUDIO_SKT_DISCONNECTED)
@@ -1002,7 +1084,7 @@ int audio_stream_open()
         INFO("control path open successful");
         /*Delay to ensure Headset is in proper state when START is initiated
         from DUT immediately after the connection due to ongoing music playback. */
-        usleep(250000);
+        usleep(1000000);
         a2dp_command(&audio_stream,A2DP_CTRL_CMD_OFFLOAD_SUPPORTED);
         return 0;
     }
@@ -1016,6 +1098,7 @@ int audio_stream_close()
 {
     INFO("%s",__func__);
 
+    pthread_mutex_lock(&audio_stream.lock);
     if (audio_stream.state == AUDIO_A2DP_STATE_STARTED ||
         audio_stream.state == AUDIO_A2DP_STATE_STOPPING)
     {
@@ -1025,72 +1108,132 @@ int audio_stream_close()
 
     skt_disconnect(audio_stream.ctrl_fd);
     audio_stream.ctrl_fd = AUDIO_SKT_DISCONNECTED;
+    pthread_mutex_unlock(&audio_stream.lock);
     return 0;
 }
 int audio_stop_stream()
 {
-    INFO("%s",__func__);
-    if (suspend_audio_datapath(&audio_stream, true) == 0)
+    INFO("%s state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
+    if (audio_stream.state != AUDIO_A2DP_STATE_SUSPENDED)
     {
-        INFO("audio stop stream successful");
-        return 0;
+        pthread_mutex_lock(&audio_stream.lock);
+        if (suspend_audio_datapath(&audio_stream, true) == 0)
+        {
+            INFO("audio stop stream successful");
+            pthread_mutex_unlock(&audio_stream.lock);
+            return 0;
+        }
+        audio_stream.state = AUDIO_A2DP_STATE_STOPPED;
+        pthread_mutex_unlock(&audio_stream.lock);
+        return -1;
     }
-    audio_stream.state = AUDIO_A2DP_STATE_STOPPED;
-    return -1;
+    return 0;
 }
 
 int audio_suspend_stream()
 {
-    INFO("%s",__func__);
-    if (suspend_audio_datapath(&audio_stream, false) == 0)
+    INFO("%s state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
+    if (audio_stream.state != AUDIO_A2DP_STATE_SUSPENDED)
     {
-        INFO("audio start stream successful");
-        return 0;
+        pthread_mutex_lock(&audio_stream.lock);
+        if (suspend_audio_datapath(&audio_stream, false) == 0)
+        {
+            INFO("audio suspend stream successful");
+            pthread_mutex_unlock(&audio_stream.lock);
+            return 0;
+        }
+        pthread_mutex_unlock(&audio_stream.lock);
+        return -1;
     }
-    return -1;
+    return 0;
 }
 
 void audio_handoff_triggered()
 {
     INFO("%s state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
+    pthread_mutex_lock(&audio_stream.lock);
     if (audio_stream.state != AUDIO_A2DP_STATE_STOPPED ||
         audio_stream.state != AUDIO_A2DP_STATE_STOPPING)
     {
         audio_stream.state = AUDIO_A2DP_STATE_STOPPED;
     }
+    pthread_mutex_unlock(&audio_stream.lock);
 }
 
 void clear_a2dpsuspend_flag()
 {
     INFO("%s: state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
+    pthread_mutex_lock(&audio_stream.lock);
     if (audio_stream.state == AUDIO_A2DP_STATE_SUSPENDED)
         audio_stream.state = AUDIO_A2DP_STATE_STOPPED;
+    pthread_mutex_unlock(&audio_stream.lock);
 }
 
 void * audio_get_codec_config(uint8_t *multicast_status, uint8_t *num_dev,
                               audio_format_t *codec_type)
 {
+    int i, status, j;
     INFO("%s: state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
 
+    pthread_mutex_lock(&audio_stream.lock);
     a2dp_get_multicast_status(&audio_stream, multicast_status,num_dev);
 
     DEBUG("got multicast status = %d dev = %d",*multicast_status,*num_dev);
-    if (a2dp_read_codec_config(&audio_stream, 0) == 0)
+
+    for (i = 0; i < STREAM_START_MAX_RETRY_COUNT; i++)
     {
-        return (a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type));
+        status = a2dp_read_codec_config(&audio_stream, 0);
+        if (status == A2DP_CTRL_ACK_SUCCESS)
+        {
+            pthread_mutex_unlock(&audio_stream.lock);
+            return (a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type));
+        }
+        INFO("%s: a2dp stream not configured,wait 100mse & retry", __func__);
+        usleep(100000);
     }
+    pthread_mutex_unlock(&audio_stream.lock);
     return NULL;
 }
 
 void* audio_get_next_codec_config(uint8_t idx, audio_format_t *codec_type)
 {
+    int i, status, j;
     INFO("%s",__func__);
-    if (a2dp_read_codec_config(&audio_stream,idx) == 0)
+    pthread_mutex_lock(&audio_stream.lock);
+    for (i = 0; i < STREAM_START_MAX_RETRY_COUNT; i++)
     {
-        return a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type);
+        status = a2dp_read_codec_config(&audio_stream, 0);
+        if (status == A2DP_CTRL_ACK_SUCCESS)
+        {
+            pthread_mutex_unlock(&audio_stream.lock);
+            return (a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type));
+        }
+        INFO("%s: a2dp stream not configured,wait 100mse & retry", __func__);
+        usleep(100000);
     }
+    pthread_mutex_unlock(&audio_stream.lock);
     return NULL;
 }
+
+int audio_check_a2dp_ready()
+{
+    INFO("audio_check_a2dp_ready: state %s", dump_a2dp_hal_state(audio_stream.state));
+    pthread_mutex_lock(&audio_stream.lock);
+    if (audio_stream.state == AUDIO_A2DP_STATE_SUSPENDED)
+    {
+        INFO("stream not ready to start");
+        pthread_mutex_unlock(&audio_stream.lock);
+        return 0;
+    }
+    if (a2dp_command(&audio_stream, A2DP_CTRL_CMD_CHECK_READY) != 0)
+    {
+        INFO("audio_check_a2dp_ready: FAIL");
+        pthread_mutex_unlock(&audio_stream.lock);
+        return 0;
+    }
+    pthread_mutex_unlock(&audio_stream.lock);
+    return 1;
+}
 //Entry point for dynamic lib
 const bt_host_ipc_interface_t BTHOST_IPC_INTERFACE = {
     sizeof(bt_host_ipc_interface_t),
@@ -1114,5 +1257,6 @@ const bt_host_ipc_interface_t BTHOST_IPC_INTERFACE = {
     audio_get_codec_config,
     audio_handoff_triggered,
     clear_a2dpsuspend_flag,
-    audio_get_next_codec_config
+    audio_get_next_codec_config,
+    audio_check_a2dp_ready
 };
diff --git a/audio_a2dp_hw/bthost_ipc.h b/audio_a2dp_hw/bthost_ipc.h
index da91522..d0a561a 100644
--- a/audio_a2dp_hw/bthost_ipc.h
+++ b/audio_a2dp_hw/bthost_ipc.h
@@ -54,6 +54,7 @@ codec specific definitions
 #define CODEC_OFFSET 3
 #define VENDOR_ID_OFFSET 4
 #define CODEC_ID_OFFSET (VENDOR_ID_OFFSET + 4)
+#define CODEC_TYPE_PCM 0x05
 
 #ifndef VENDOR_APTX
 #define VENDOR_APTX 0x4F
@@ -165,6 +166,6 @@ typedef struct {
     void (*audio_handoff_triggered)(void);
     void (*clear_a2dpsuspend_flag)(void);
     void*(*audio_get_next_codec_config)(uint8_t idx, audio_format_t *codec_type);
-
+    int (*audio_check_a2dp_ready)(void);
 } bt_host_ipc_interface_t;
 #endif
diff --git a/bta/Android.mk b/bta/Android.mk
index 71cd873..7512d64 100644
--- a/bta/Android.mk
+++ b/bta/Android.mk
@@ -98,6 +98,14 @@ LOCAL_C_INCLUDES+= . \
                    $(LOCAL_PATH)/../utils/include \
                    $(bluetooth_C_INCLUDES)
 
+ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
+LOCAL_C_INCLUDES+= . \
+                   vendor/qcom/opensource/bluetooth/system_bt_ext
+else
+LOCAL_C_INCLUDES+= . \
+                   device/qcom/msm8909w/opensource/bluetooth/system_bt_ext
+endif
+
 LOCAL_CFLAGS += $(bluetooth_CFLAGS) -DBUILDCFG
 LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
 LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
diff --git a/bta/ag/bta_ag_act.c b/bta/ag/bta_ag_act.c
index fb0de76..65cd63e 100644
--- a/bta/ag/bta_ag_act.c
+++ b/bta/ag/bta_ag_act.c
@@ -107,6 +107,12 @@ static void bta_ag_cback_open(tBTA_AG_SCB *p_scb, tBTA_AG_DATA *p_data, tBTA_AG_
         bdcpy(open.bd_addr, p_scb->peer_addr);
     }
 
+    // if failure, dump logs
+    if (status != BTA_AG_SUCCESS) {
+        APPL_TRACE_WARNING("%s: there is failure in SDP/RFCOMM connection", __func__);
+        GENERATE_VND_LOGS();
+    }
+
     (*bta_ag_cb.p_cback)(BTA_AG_OPEN_EVT, (tBTA_AG *) &open);
 }
 
@@ -528,6 +534,8 @@ void bta_ag_rfc_close(tBTA_AG_SCB *p_scb, tBTA_AG_DATA *p_data)
 void bta_ag_rfc_open(tBTA_AG_SCB *p_scb, tBTA_AG_DATA *p_data)
 {
     int ag_conn_timeout = p_bta_ag_cfg->conn_tout;
+    bt_bdaddr_t remote_bdaddr;
+    bdcpy(remote_bdaddr.address, p_scb->peer_addr);
     /* initialize AT feature variables */
     p_scb->clip_enabled = FALSE;
     p_scb->ccwa_enabled = FALSE;
@@ -551,7 +559,7 @@ void bta_ag_rfc_open(tBTA_AG_SCB *p_scb, tBTA_AG_DATA *p_data)
     bta_ag_cback_open(p_scb, NULL, BTA_AG_SUCCESS);
 
     if (interop_match_addr(INTEROP_INCREASE_AG_CONN_TIMEOUT,
-                            (const bt_bdaddr_t*)p_scb->peer_addr)) {
+                            (const bt_bdaddr_t*)&remote_bdaddr)) {
        /* use higher value for ag conn timeout */
        ag_conn_timeout = 20000;
     }
diff --git a/bta/ag/bta_ag_cmd.c b/bta/ag/bta_ag_cmd.c
index 9a87859..40a9c82 100644
--- a/bta/ag/bta_ag_cmd.c
+++ b/bta/ag/bta_ag_cmd.c
@@ -37,7 +37,8 @@
 #include "port_api.h"
 #include "utl.h"
 #include <cutils/properties.h>
-
+#include "device/include/interop.h"
+#include "btif/include/btif_storage.h"
 
 /*****************************************************************************
 **  Constants
@@ -177,7 +178,7 @@ enum
     BTA_AG_RES_FMT_STR         /* string argument */
 };
 
-/* enumeration of AT result codes, matches constant table */
+/* Local AT command result codes not defined in bta_ag_api.h */
 enum
 {
     BTA_AG_RES_OK,
@@ -207,7 +208,7 @@ enum
 #if defined(BTA_HSP_RESULT_REPLACE_COLON) && (BTA_HSP_RESULT_REPLACE_COLON == TRUE)
 #define COLON_IDX_4_VGSVGM    4
 #endif
-/* AT result code constant table  (Indexed by result code) */
+/* AT result code constant table */
 const tBTA_AG_RESULT bta_ag_result_tbl[] =
 {
     {"OK",      BTA_AG_RES_FMT_NONE},
@@ -234,6 +235,7 @@ const tBTA_AG_RESULT bta_ag_result_tbl[] =
     {"+BIND: ", BTA_AG_RES_FMT_STR},
 };
 
+
 const tBTA_AG_AT_CMD *bta_ag_at_tbl[BTA_AG_NUM_IDX] =
 {
     bta_ag_hsp_cmd,
@@ -350,10 +352,10 @@ const UINT8 bta_ag_callsetup_ind_tbl[] =
 static void bta_ag_send_result(tBTA_AG_SCB *p_scb, UINT8 code, char *p_arg,
                                INT16 int_arg)
 {
-    char    buf[BTA_AG_AT_MAX_LEN + 16];
-    char    *p = buf;
-    UINT16  len;
 
+    char buf[BTA_AG_AT_MAX_LEN + 16];
+    char *p = buf;
+    UINT16  len;
 #if defined(BTA_AG_RESULT_DEBUG) && (BTA_AG_RESULT_DEBUG == TRUE)
     memset(buf, NULL, sizeof(buf));
 #endif
@@ -364,7 +366,7 @@ static void bta_ag_send_result(tBTA_AG_SCB *p_scb, UINT8 code, char *p_arg,
     /* copy result code string */
     strlcpy(p, bta_ag_result_tbl[code].p_res, sizeof(buf) - 2);
 #if defined(BTA_HSP_RESULT_REPLACE_COLON) && (BTA_HSP_RESULT_REPLACE_COLON == TRUE)
-    if(p_scb->conn_service == BTA_AG_HSP)
+    if (p_scb->conn_service == BTA_AG_HSP)
     {
         /* If HSP then ":"symbol should be changed as "=" for HSP compatibility */
         switch(code)
@@ -972,7 +974,6 @@ void bta_ag_at_hsp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
                                 char *p_arg, INT16 int_arg)
 {
     tBTA_AG_VAL val;
-
     APPL_TRACE_DEBUG("AT cmd:%d arg_type:%d arg:%d arg:%s", cmd, arg_type,
                       int_arg, p_arg);
 
@@ -987,7 +988,6 @@ void bta_ag_at_hsp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
     /* call callback with event */
     (*bta_ag_cb.p_cback)(bta_ag_hsp_cb_evt[cmd], (tBTA_AG *) &val);
 }
-
 /*******************************************************************************
 **
 ** Function         bta_ag_at_hfp_cback
@@ -1233,11 +1233,23 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
             break;
 
         case BTA_AG_HF_CMD_BRSF:
-            /* store peer features */
+            /* store peer features. */
             p_scb->peer_features = (UINT16) int_arg;
             features = p_scb->features & BTA_AG_BSRF_FEAT_SPEC;
+            if (interop_match_addr(INTEROP_DISABLE_HF_INDICATOR,
+                                   (const bt_bdaddr_t*)p_scb->peer_addr))
+            {
+                if ((p_scb->peer_version < HFP_VERSION_1_7) &&
+                     (p_scb->peer_features & BTA_AG_PEER_FEAT_HFIND))
+                {
+                    APPL_TRACE_WARNING("hf indicator needs hfp 1.7 support,"
+                                       "thus remove remote device HF indicator bit");
+                    p_scb->peer_features = p_scb->peer_features &(~BTA_AG_PEER_FEAT_HFIND);
+                }
+            }
             /* if the devices does not support HFP 1.7, report DUT's HFP version as 1.6 */
-            if (p_scb->peer_version < HFP_VERSION_1_7)
+            if ((p_scb->peer_version < HFP_VERSION_1_7) &&
+                 (!(p_scb->peer_features & BTA_AG_PEER_FEAT_HFIND)))
             {
                 /* For PTS keep flags as is. */
                 if (property_get("bt.pts.certification", value, "false") &&
@@ -1257,7 +1269,31 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
                 {
                     features = features & ~(BTA_AG_FEAT_HFIND);
                 }
-             }
+            }
+
+            bt_property_t prop_name;
+            bt_bdname_t bdname;
+            BOOLEAN remote_name = FALSE;
+
+            BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_BDNAME,
+                    sizeof(bt_bdname_t), &bdname);
+            if (btif_storage_get_remote_device_property((bt_bdaddr_t*)p_scb->peer_addr,
+                    &prop_name) == BT_STATUS_SUCCESS)
+            {
+                remote_name = TRUE;
+            }
+
+            if (interop_match_addr(INTEROP_DISABLE_CODEC_NEGOTIATION,
+                    (const bt_bdaddr_t*)p_scb->peer_addr) ||
+                    (remote_name && interop_match_name(INTEROP_DISABLE_CODEC_NEGOTIATION,
+                    (const char *)bdname.name)))
+            {
+                APPL_TRACE_IMP("%s disable codec negotiation for phone, remote" \
+                                  "for blacklisted device", __func__);
+                features = features & ~(BTA_AG_FEAT_CODEC);
+                p_scb->peer_features = p_scb->peer_features & ~(BTA_AG_PEER_FEAT_CODEC);
+
+            }
             /* send BRSF, send OK */
             bta_ag_send_result(p_scb, BTA_AG_RES_BRSF, NULL,
                                (INT16) features);
@@ -1367,6 +1403,7 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
 
         case BTA_AG_HF_CMD_CNUM:
             break;
+
         case BTA_AG_HF_CMD_CLCC:
             if(!(p_scb->features & BTA_AG_FEAT_ECS))
             {
@@ -1561,7 +1598,6 @@ void bta_ag_at_err_cback(tBTA_AG_SCB *p_scb, BOOLEAN unknown, char *p_arg)
 void bta_ag_hsp_result(tBTA_AG_SCB *p_scb, tBTA_AG_API_RESULT *p_result)
 {
     UINT8 code = bta_ag_trans_result[p_result->result];
-
     APPL_TRACE_DEBUG("bta_ag_hsp_result : res = %d", p_result->result);
 
     switch(p_result->result)
@@ -1735,6 +1771,16 @@ void bta_ag_hfp_result(tBTA_AG_SCB *p_scb, tBTA_AG_API_RESULT *p_result)
             */
             bta_ag_send_call_inds(p_scb, p_result->result);
 
+            if (interop_match_addr(INTEROP_DELAY_SCO_FOR_MT_CALL,
+                (const bt_bdaddr_t*)p_scb->peer_addr))
+            {
+               /* Ensure that call active indicator is sent prior to SCO connection
+                  request by adding some delay. Some remotes are very strict in the
+                  order of call indicator and SCO connection request. */
+                APPL_TRACE_IMP("%s: sleeping 20msec before opening sco", __func__);
+                usleep(20*1000);
+            }
+
             if (!(p_scb->features & BTA_AG_FEAT_NOSCO))
             {
                 if (p_result->data.audio_handle == bta_ag_scb_to_idx(p_scb))
@@ -1943,8 +1989,8 @@ void bta_ag_hfp_result(tBTA_AG_SCB *p_scb, tBTA_AG_API_RESULT *p_result)
 
        default:
             break;
+        }
     }
-}
 
 
 /*******************************************************************************
diff --git a/bta/ag/bta_ag_int.h b/bta/ag/bta_ag_int.h
index 55cfff1..baadb99 100644
--- a/bta/ag/bta_ag_int.h
+++ b/bta/ag/bta_ag_int.h
@@ -28,6 +28,7 @@
 #include "bta_api.h"
 #include "bta_ag_api.h"
 #include "bta_ag_at.h"
+#include "osi/include/log.h"
 
 /* Send RING & CLIP in one AT cmd */
 #ifndef BTA_AG_MULTI_RESULT_INCLUDED
@@ -301,6 +302,7 @@ typedef struct
     tBTA_AG_SCO_MSBC_SETTINGS codec_msbc_settings; /* settings to be used for the impending eSCO */
 #endif
     BOOLEAN             slc_pend_open;  /* SLC is pending open */
+
 } tBTA_AG_SCB;
 
 /* type for sco data */
diff --git a/bta/ag/bta_ag_main.c b/bta/ag/bta_ag_main.c
index 508befe..182985c 100644
--- a/bta/ag/bta_ag_main.c
+++ b/bta/ag/bta_ag_main.c
@@ -838,6 +838,9 @@ void bta_ag_sm_execute(tBTA_AG_SCB *p_scb, UINT16 event, tBTA_AG_DATA *p_data)
         return;
     }
 
+    /* If SLC time out, dump the logs */
+    if (event == BTA_AG_SVC_TIMEOUT_EVT)
+        GENERATE_VND_LOGS();
     /* look up the state table for the current state */
     state_table = bta_ag_st_tbl[p_scb->state];
 
diff --git a/bta/ag/bta_ag_sco.c b/bta/ag/bta_ag_sco.c
index 5aafbc2..8bbbe24 100644
--- a/bta/ag/bta_ag_sco.c
+++ b/bta/ag/bta_ag_sco.c
@@ -33,6 +33,8 @@
 #include "btm_api.h"
 #include "bt_common.h"
 #include "utl.h"
+#include "device/include/interop.h"
+//#include "osi/include/log.h"
 
 #ifndef BTA_AG_SCO_DEBUG
 #define BTA_AG_SCO_DEBUG FALSE
@@ -40,10 +42,11 @@
 
 /* Codec negotiation timeout */
 #ifndef BTA_AG_CODEC_NEGOTIATION_TIMEOUT_MS
-#define BTA_AG_CODEC_NEGOTIATION_TIMEOUT_MS (3 * 1000)          /* 3 seconds */
+#define BTA_AG_CODEC_NEGOTIATION_TIMEOUT_MS (5 * 1000)          /* 5 seconds */
 #endif
 
 extern fixed_queue_t *btu_bta_alarm_queue;
+extern void bta_dm_pm_set_sniff_policy_toggle(BD_ADDR peer_addr, BOOLEAN bDisable);
 
 #if BTA_AG_SCO_DEBUG == TRUE
 static char *bta_ag_sco_evt_str(UINT8 event);
@@ -103,7 +106,7 @@ static const tBTM_ESCO_PARAMS bta_ag_esco_params[BTA_AG_NUM_CODECS] =
         BTM_64KBITS_RATE,                   /* RX Bandwidth (64 kbits/sec)              */
         0x000a,                             /* 10 ms (HS/HF can use EV3, 2-EV3, 3-EV3)  */
         BTM_VOICE_SETTING_CVSD,             /* Inp Linear, Air CVSD, 2s Comp, 16bit     */
-       (BTM_SCO_PKT_TYPES_MASK_HV1      +  /* Packet Types                             */
+       (BTM_SCO_PKT_TYPES_MASK_HV1      +   /* Packet Types                             */
         BTM_SCO_PKT_TYPES_MASK_HV2      +
         BTM_SCO_PKT_TYPES_MASK_HV3      +
         BTM_SCO_PKT_TYPES_MASK_EV3      +
@@ -304,6 +307,10 @@ static void bta_ag_sco_disc_cback(UINT16 sco_idx)
         p_buf->event = BTA_AG_SCO_CLOSE_EVT;
         p_buf->layer_specific = handle;
         bta_sys_sendmsg(p_buf);
+        if (interop_match_addr(INTEROP_DISABLE_SNIFF_POLICY_DURING_SCO,
+                        (const bt_bdaddr_t *)&bta_ag_cb.sco.p_curr_scb->peer_addr)) {
+            bta_dm_pm_set_sniff_policy_toggle(bta_ag_cb.sco.p_curr_scb->peer_addr, false);
+        }
     } else {
         /* no match found */
         APPL_TRACE_DEBUG("no scb for ag_sco_disc_cback");
@@ -692,6 +699,10 @@ static void bta_ag_codec_negotiation_timer_cback(void *data)
 {
     tBTA_AG_SCB *p_scb = (tBTA_AG_SCB *)data;
 
+    APPL_TRACE_IMP("codec negotiation timedout, aborting SCO/eSCO creation");
+
+    GENERATE_VND_LOGS();
+
     /* Announce that codec negotiation failed. */
     bta_ag_sco_codec_nego(p_scb, FALSE);
 
diff --git a/bta/ag/bta_ag_sdp.c b/bta/ag/bta_ag_sdp.c
index 1f8ca5c..b25dd9c 100644
--- a/bta/ag/bta_ag_sdp.c
+++ b/bta/ag/bta_ag_sdp.c
@@ -36,6 +36,7 @@
 #include "bt_common.h"
 #include "utl.h"
 #include "bt_utils.h"
+#include "device/include/interop_config.h"
 
 /* Number of protocol elements in protocol element list. */
 #define BTA_AG_NUM_PROTO_ELEMS      2
@@ -380,16 +381,12 @@ BOOLEAN bta_ag_sdp_find_attr(tBTA_AG_SCB *p_scb, tBTA_SERVICE_MASK service)
             /* Remote supports 1.7, store it in the file */
             if (p_scb->peer_version == HFP_VERSION_1_7)
             {
-                bool ret = FALSE;
-                /* Check if the device is already part of the list, if not store it */
-                ret = is_device_present(IOT_HFP_1_7_BLACKLIST, p_scb->peer_addr);
-
-                if (ret == FALSE)
-                {
-                   add_iot_device(IOT_DEV_CONF_FILE, IOT_HFP_1_7_BLACKLIST,
-                                  p_scb->peer_addr, METHOD_BD);
-                }
+                bt_bdaddr_t remote_bdaddr;
+                bdcpy(remote_bdaddr.address, p_scb->peer_addr);
+                interop_database_add_addr(INTEROP_HFP_1_7_BLACKLIST,
+                                (bt_bdaddr_t *)&remote_bdaddr, 3);
             }
+
         }
         else    /* HSP */
         {
diff --git a/bta/av/bta_av_aac.c b/bta/av/bta_av_aac.c
index 3ef0885..d358a6c 100644
--- a/bta/av/bta_av_aac.c
+++ b/bta/av/bta_av_aac.c
@@ -56,7 +56,6 @@ UINT8 bta_av_aac_cfg_in_cap(UINT8 *p_cfg, tA2D_AAC_CIE *p_cap)
         return status;
     }
 
-
     /* object type */
     if ((cfg_cie.object_type & p_cap->object_type) == 0)
     {
@@ -72,8 +71,8 @@ UINT8 bta_av_aac_cfg_in_cap(UINT8 *p_cfg, tA2D_AAC_CIE *p_cap)
     {
         status = A2D_NS_CHANNEL;
     }
-    /* block length */
-    else if ((cfg_cie.bit_rate & p_cap->bit_rate) == 0)
+    /* bitrate */
+    else if ((cfg_cie.bit_rate & p_cap->bit_rate || cfg_cie.bit_rate < p_cap->bit_rate ) == 0)
     {
         status = A2D_NS_BIT_RATE;
     }
diff --git a/bta/av/bta_av_aact.c b/bta/av/bta_av_aact.c
index aaf0d15..92188d5 100644
--- a/bta/av/bta_av_aact.c
+++ b/bta/av/bta_av_aact.c
@@ -70,6 +70,7 @@ extern BOOLEAN is_sniff_disabled;
 #define BTA_AV_RECONFIG_RETRY       6
 #endif
 
+static const size_t SBC_MIN_BITPOOL_OFFSET = 5;
 static const size_t SBC_MAX_BITPOOL_OFFSET = 6;
 
 #ifdef BTA_AV_SPLIT_A2DP_DEF_FREQ_48KHZ
@@ -445,11 +446,15 @@ static BOOLEAN bta_av_next_getcap(tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
             {
                 p_req = AVDT_GetCapReq;
             }
-            (*p_req)(p_scb->peer_addr,
+            if ((*p_req)(p_scb->peer_addr,
                            p_scb->sep_info[i].seid,
-                           p_scb->p_cap, bta_av_dt_cback[p_scb->hdi]);
-            sent_cmd = TRUE;
-            break;
+                           p_scb->p_cap, bta_av_dt_cback[p_scb->hdi]) == AVDT_SUCCESS)
+            {
+                sent_cmd = TRUE;
+                break;
+            }
+            else
+                APPL_TRACE_ERROR("bta_av_next_getcap command could not be sent because of resource constraint");
         }
     }
 
@@ -1189,6 +1194,7 @@ void bta_av_cleanup(tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
     /* if de-registering shut everything down */
     msg.hdr.layer_specific  = p_scb->hndl;
     p_scb->started  = FALSE;
+    p_scb->suspend_local_sent = FALSE;
     p_scb->cong = FALSE;
     p_scb->role = role;
     p_scb->cur_psc_mask = 0;
@@ -1462,22 +1468,13 @@ void bta_av_setconfig_rsp (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
             p_scb->avdt_version = AVDT_VERSION_SYNC;
 
 
-        if (p_scb->codec_type == BTA_AV_CODEC_SBC || num > 1)
-        {
-            /* if SBC is used by the SNK as INT, discover req is not sent in bta_av_config_ind.
-                       * call disc_res now */
-           /* this is called in A2DP SRC path only, In case of SINK we don't need it  */
-            if (local_sep == AVDT_TSEP_SRC)
-                p_scb->p_cos->disc_res(p_scb->hndl, num, num, 0, p_scb->peer_addr,
-                                                      UUID_SERVCLASS_AUDIO_SOURCE);
-        }
-        else
-        {
-            /* we do not know the peer device and it is using non-SBC codec
-             * we need to know all the SEPs on SNK */
-            bta_av_discover_req(p_scb, NULL);
-            return;
-        }
+        /* For any codec used by the SNK as INT, discover req is not sent in bta_av_config_ind.
+         * This is done since we saw an IOT issue with APTX codec. Thus, we now take same
+         * path for all codecs as for SBC. call disc_res now */
+        /* this is called in A2DP SRC path only, In case of SINK we don't need it  */
+        if (local_sep == AVDT_TSEP_SRC)
+            p_scb->p_cos->disc_res(p_scb->hndl, num, num, 0, p_scb->peer_addr,
+                                                  UUID_SERVCLASS_AUDIO_SOURCE);
 
         for (i = 1; i < num; i++)
         {
@@ -1527,7 +1524,7 @@ void bta_av_str_opened (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
     /* set the congestion flag, so AV would not send media packets by accident */
     p_scb->cong = TRUE;
     p_scb->offload_start_pending = FALSE;
-
+    p_scb->suspend_local_sent = FALSE;
 
     p_scb->stream_mtu = p_data->str_msg.msg.open_ind.peer_mtu - AVDT_MEDIA_HDR_SIZE;
     mtu = bta_av_chk_mtu(p_scb, p_scb->stream_mtu);
@@ -1611,11 +1608,15 @@ void bta_av_str_opened (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 ** Returns          bta_av_cb.codec_type
 **
 *******************************************************************************/
-UINT8 bta_av_get_codec_type()
+UINT8 bta_av_get_codec_type(tBTA_AV_HNDL hndl)
 {
+    APPL_TRACE_DEBUG("%s: hdl = %x", __func__, hndl);
+    tBTA_AV_SCB *p_scb = bta_av_hndl_to_scb(hndl);
+    bta_av_cb.codec_type = p_scb->codec_type;
     APPL_TRACE_DEBUG("%s [bta_av_cb.codec_type] %x", __func__, bta_av_cb.codec_type);
     return bta_av_cb.codec_type;
 }
+
 /*******************************************************************************
 **
 ** Function         bta_av_security_ind
@@ -1697,6 +1698,7 @@ void bta_av_do_close (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 
     /* close stream */
     p_scb->started = FALSE;
+    p_scb->suspend_local_sent = FALSE;
 
     /* drop the buffers queued in L2CAP */
     L2CA_FlushChannel (p_scb->l2c_cid, L2CAP_FLUSH_CHANS_ALL);
@@ -1729,9 +1731,10 @@ void bta_av_connect_req(tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
     {
         /* SNK initiated L2C connection while SRC was doing SDP.    */
         /* Wait until timeout to check if SNK starts signalling.    */
-        APPL_TRACE_EVENT("bta_av_connect_req: coll_mask = 0x%2X", p_scb->coll_mask);
+        APPL_TRACE_EVENT("%s: coll_mask = 0x%2X", __func__, p_scb->coll_mask);
         p_scb->coll_mask |= BTA_AV_COLL_API_CALLED;
-        APPL_TRACE_EVENT("bta_av_connect_req: updated coll_mask = 0x%2X", p_scb->coll_mask);
+        APPL_TRACE_EVENT("%s: updated coll_mask = 0x%2X", __func__,
+                         p_scb->coll_mask);
         return;
     }
 
@@ -2105,6 +2108,15 @@ void bta_av_getcap_results (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
             cfg.codec_info[SBC_MAX_BITPOOL_OFFSET] = SBC_MAX_BITPOOL;
         }
 
+        if ((uuid_int == UUID_SERVCLASS_AUDIO_SOURCE) &&
+            (cfg.codec_info[SBC_MIN_BITPOOL_OFFSET] > cfg.codec_info[SBC_MAX_BITPOOL_OFFSET]))
+        {
+            APPL_TRACE_WARNING("%s min bitpool value received for SBC is more than DUT supported Max bitpool"
+                    "Clamping the max bitpool configuration further from %d to %d.", __func__,
+                    cfg.codec_info[SBC_MAX_BITPOOL_OFFSET], cfg.codec_info[SBC_MIN_BITPOOL_OFFSET]);
+            cfg.codec_info[SBC_MAX_BITPOOL_OFFSET] = cfg.codec_info[SBC_MIN_BITPOOL_OFFSET];
+        }
+
         /* open the stream */
         AVDT_OpenReq(p_scb->seps[p_scb->sep_idx].av_handle, p_scb->peer_addr,
                      p_scb->sep_info[p_scb->sep_info_idx].seid, &cfg);
@@ -2161,8 +2173,11 @@ void bta_av_discover_req (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
     UNUSED(p_data);
 
     /* send avdtp discover request */
-
-    AVDT_DiscoverReq(p_scb->peer_addr, p_scb->sep_info, BTA_AV_NUM_SEPS, bta_av_dt_cback[p_scb->hdi]);
+    if (AVDT_DiscoverReq(p_scb->peer_addr, p_scb->sep_info, BTA_AV_NUM_SEPS, bta_av_dt_cback[p_scb->hdi]) != AVDT_SUCCESS)
+    {
+        APPL_TRACE_ERROR("bta_av_discover_req command could not be sent because of resource constraint");
+        bta_av_ssm_execute(p_scb, BTA_AV_STR_DISC_FAIL_EVT, p_data);
+    }
 }
 
 /*******************************************************************************
@@ -2300,16 +2315,18 @@ void bta_av_str_stopped (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 
     if (p_data && p_data->api_stop.suspend)
     {
-        APPL_TRACE_DEBUG("suspending: %d, sup:%d", start, p_scb->suspend_sup);
-        if ((start)  && (p_scb->suspend_sup))
+        APPL_TRACE_DEBUG("suspending: %d, sup:%d, suspend_local_sent = %d",
+                           start, p_scb->suspend_sup,p_scb->suspend_local_sent);
+        if ((start)  && (p_scb->suspend_sup) && (!p_scb->suspend_local_sent))
         {
+            p_scb->suspend_local_sent = TRUE;
             sus_evt = FALSE;
             p_scb->l2c_bufs = 0;
             AVDT_SuspendReq(&p_scb->avdt_handle, 1);
         }
 
         /* send SUSPEND_EVT event only if not in reconfiguring state and sus_evt is TRUE*/
-        if ((sus_evt)&&(p_scb->state != BTA_AV_RCFG_SST))
+        if ((sus_evt) && ((p_scb->suspend_local_sent) || (p_scb->state != BTA_AV_RCFG_SST)))
         {
             suspend_rsp.status = BTA_AV_SUCCESS;
             suspend_rsp.initiator = TRUE;
@@ -2846,12 +2863,12 @@ void bta_av_suspend_cfm (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
     tBTA_AV_SUSPEND suspend_rsp;
     UINT8           err_code = p_data->str_msg.msg.hdr.err_code;
     UINT8 policy = HCI_ENABLE_SNIFF_MODE;
-
+    p_scb->suspend_local_sent = FALSE;
     if (is_sniff_disabled == true)
         policy = 0;
 
-    APPL_TRACE_DEBUG ("bta_av_suspend_cfm:audio_open_cnt = %d, err_code = %d",
-        bta_av_cb.audio_open_cnt, err_code);
+    APPL_TRACE_DEBUG ("%s:audio_open_cnt = %d, err_code = %d, scb_started = %d",
+                      __func__,bta_av_cb.audio_open_cnt,err_code,p_scb->started);
 
     if (p_scb->started == FALSE)
     {
@@ -3070,7 +3087,7 @@ void bta_av_suspend_cont (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
 {
     UINT8       err_code = p_data->str_msg.msg.hdr.err_code;
     tBTA_AV_RECONFIG    evt;
-
+    p_scb->suspend_local_sent = FALSE;
     p_scb->started = FALSE;
     p_scb->cong    = FALSE;
     if (err_code)
@@ -3125,7 +3142,7 @@ void bta_av_rcfg_cfm (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
     */
     if (err_code)
     {
-        APPL_TRACE_ERROR("reconfig rejected, try close");
+        APPL_TRACE_ERROR("reconfig rejected, try close with error code = %d", err_code);
          /* Disable reconfiguration feature only with explicit rejection(not with timeout) */
         if (err_code != AVDT_ERR_TIMEOUT)
         {
@@ -3218,7 +3235,9 @@ void bta_av_chk_2nd_start (tBTA_AV_SCB *p_scb, tBTA_AV_DATA *p_data)
     BOOLEAN new_started = FALSE;
     UNUSED(p_data);
 
-    if ((p_scb->chnl == BTA_AV_CHNL_AUDIO) && (bta_av_cb.audio_open_cnt >= 2))
+    APPL_TRACE_DEBUG("%s\n", __func__);
+    if ((p_scb->chnl == BTA_AV_CHNL_AUDIO) && (bta_av_cb.audio_open_cnt >= 2) &&
+         bta_av_is_multicast_enabled())
     {
         /* more than one audio channel is connected */
         if (!(p_scb->role & BTA_AV_ROLE_SUSPEND_OPT))
diff --git a/bta/av/bta_av_act.c b/bta/av/bta_av_act.c
old mode 100644
new mode 100755
index d80128d..b3b2f21
--- a/bta/av/bta_av_act.c
+++ b/bta/av/bta_av_act.c
@@ -46,6 +46,7 @@
 #include "osi/include/osi.h"
 #include "osi/include/properties.h"
 #include "utl.h"
+#include "device/include/interop.h"
 
 #if ( defined BTA_AR_INCLUDED ) && (BTA_AR_INCLUDED == TRUE)
 #include "bta_ar_api.h"
@@ -65,6 +66,10 @@
 #define BTA_AV_ACCEPT_SIGNALLING_TIMEOUT_MS     (2 * 1000)      /* 2 seconds */
 #endif
 
+#ifndef AVRC_CONNECT_RETRY_DELAY_MS
+#define AVRC_CONNECT_RETRY_DELAY_MS 2000
+#endif
+
 extern fixed_queue_t *btu_bta_alarm_queue;
 
 static void bta_av_accept_signalling_timer_cback(void *data);
@@ -79,6 +84,8 @@ struct blacklist_entry
 #define AVRC_MIN_META_CMD_LEN 20
 #endif
 
+#define AVRC_L2CAP_MIN_CONN_FAILURE_CODE 2 /*same as L2CAP_CONN_NO_PSM*/
+
 /* state machine states */
 enum
 {
@@ -242,13 +249,24 @@ static void bta_av_avrc_sdp_cback(UINT16 status)
 static void bta_av_rc_ctrl_cback(UINT8 handle, UINT8 event, UINT16 result, BD_ADDR peer_addr)
 {
     UINT16 msg_event = 0;
-    UNUSED(result);
 
 #if (defined(BTA_AV_MIN_DEBUG_TRACES) && BTA_AV_MIN_DEBUG_TRACES == TRUE)
     APPL_TRACE_EVENT("rc_ctrl handle: %d event=0x%x", handle, event);
 #else
     BTIF_TRACE_IMP("bta_av_rc_ctrl_cback handle: %d event=0x%x", handle, event);
 #endif
+    if (((event == AVRC_OPEN_IND_EVT) || (event == AVRC_CLOSE_IND_EVT))
+        && (result >= AVRC_L2CAP_MIN_CONN_FAILURE_CODE))
+    {
+        APPL_TRACE_WARNING("AVRCP connection encountered error=%x", result);
+        tBTA_AV_RC_COLLISSION_DETECTED *p_msg =
+            (tBTA_AV_RC_COLLISSION_DETECTED *)osi_malloc(sizeof(tBTA_AV_RC_COLLISSION_DETECTED));
+        p_msg->hdr.event = BTA_AV_RC_COLLISSION_DETECTED_EVT;
+        p_msg->handle = handle;
+        if (peer_addr)
+            bdcpy(p_msg->peer_addr, peer_addr);
+        bta_sys_sendmsg(p_msg);
+    }
     if (event == AVRC_OPEN_IND_EVT)
     {
         /* save handle of opened connection
@@ -387,9 +405,9 @@ UINT8 bta_av_rc_create(tBTA_AV_CB *p_cb, UINT8 role, UINT8 shdl, UINT8 lidx)
         /* this LIDX is reserved for the AVRCP ACP connection */
         p_cb->rc_acp_handle = p_rcb->handle;
         p_cb->rc_acp_idx = (i + 1);
-        APPL_TRACE_DEBUG("rc_acp_handle:%d idx:%d", p_cb->rc_acp_handle, p_cb->rc_acp_idx);
+        APPL_TRACE_IMP("rc_acp_handle: %d idx: %d", p_cb->rc_acp_handle, p_cb->rc_acp_idx);
     }
-    APPL_TRACE_DEBUG("create %d, role: %d, shdl:%d, rc_handle:%d, lidx:%d, status:0x%x",
+    APPL_TRACE_IMP("bta_av_rc_create %d, role: %d, shdl:%d, rc_handle:%d, lidx:%d, status:0x%x",
         i, role, shdl, p_rcb->handle, lidx, p_rcb->status);
 
     return rc_handle;
@@ -711,7 +729,9 @@ void bta_av_rc_meta_rsp(tBTA_AV_CB *p_cb, tBTA_AV_DATA *p_data)
             (!p_data->api_meta_rsp.is_rsp && (p_cb->features & BTA_AV_FEAT_RCCT)) )
         {
             p_rcb = &p_cb->rcb[p_data->hdr.layer_specific];
-            if (p_rcb->handle != BTA_AV_RC_HANDLE_NONE) {
+            /* Fix for below Klockwork Issue
+             * Array 'avrc_cb.fcb' of size 5 may use index value(s) 0..254 */
+            if ((p_rcb->handle != BTA_AV_RC_HANDLE_NONE) && (p_rcb->handle < AVCT_NUM_CONN)) {
                 AVRC_MsgReq(p_rcb->handle, p_data->api_meta_rsp.label,
                             p_data->api_meta_rsp.rsp_code,
                             p_data->api_meta_rsp.p_pkt);
@@ -1793,6 +1813,8 @@ static void bta_av_accept_signalling_timer_cback(void *data)
 
             if (bta_av_is_scb_opening(p_scb))
             {
+                APPL_TRACE_DEBUG("%s: stream state opening: SDP started = %d",
+                                 __func__, p_scb->sdp_discovery_started);
                 if (p_scb->sdp_discovery_started)
                 {
                     /* We are still doing SDP. Run the timer again. */
@@ -1814,6 +1836,7 @@ static void bta_av_accept_signalling_timer_cback(void *data)
             {
                 /* Stay in incoming state if SNK does not start signalling */
 
+                APPL_TRACE_DEBUG("%s: stream state incoming", __func__);
                 /* API open was called right after SNK opened L2C connection. */
                 if (p_scb->coll_mask & BTA_AV_COLL_API_CALLED)
                 {
@@ -1929,6 +1952,22 @@ tBTA_AV_FEAT bta_av_check_peer_features (UINT16 service_uuid)
             /* get profile version (if failure, version parameter is not updated) */
             SDP_FindProfileVersionInRec(p_rec, UUID_SERVCLASS_AV_REMOTE_CONTROL,
                                                                 &peer_rc_version);
+
+            if (interop_match_addr(INTEROP_ADV_AVRCP_VER_1_3,
+                    (const bt_bdaddr_t*) p_rec->remote_bd_addr))
+            {
+                peer_rc_version = AVRC_REV_1_3;
+                APPL_TRACE_DEBUG("changing peer_rc_version as part of blacklisting to 0x%x",
+                        peer_rc_version);
+            }
+            else if (interop_match_addr(INTEROP_STORE_REMOTE_AVRCP_VERSION_1_4,
+                    (const bt_bdaddr_t*) p_rec->remote_bd_addr))
+            {
+                peer_rc_version = AVRC_REV_1_4;
+                APPL_TRACE_DEBUG("changing peer_rc_version as part of blacklisting to 0x%x",
+                        peer_rc_version);
+            }
+
             APPL_TRACE_DEBUG("peer_rc_version 0x%x", peer_rc_version);
 
             if (peer_rc_version >= AVRC_REV_1_3)
@@ -2113,6 +2152,15 @@ void bta_av_rc_disc_done(tBTA_AV_DATA *p_data)
     }
 
     APPL_TRACE_DEBUG("%s rc_handle %d", __FUNCTION__, rc_handle);
+    if (rc_handle == BTA_AV_RC_HANDLE_NONE)
+    {
+        if (AVRC_CheckIncomingConn(p_scb->peer_addr) == TRUE)
+        {
+            bta_sys_start_timer(p_scb->avrc_ct_timer, AVRC_CONNECT_RETRY_DELAY_MS,
+                                   BTA_AV_SDP_AVRC_DISC_EVT,p_scb->hndl);
+        }
+    }
+
 #if (BTA_AV_SINK_INCLUDED == TRUE)
     if (p_cb->sdp_a2d_snk_handle)
     {
@@ -2154,7 +2202,9 @@ void bta_av_rc_disc_done(tBTA_AV_DATA *p_data)
                 if (p_lcb)
                 {
                     rc_handle = bta_av_rc_create(p_cb, AVCT_INT, (UINT8)(p_scb->hdi + 1), p_lcb->lidx);
-                    if(rc_handle != BTA_AV_RC_HANDLE_NONE)
+                    /* Fix for below Klockwork Issue
+                     * Array 'rcb' of size 4 may use index value(s) 4..254 */
+                    if((rc_handle != BTA_AV_RC_HANDLE_NONE) && (rc_handle < BTA_AV_NUM_RCB))
                     {
                         p_cb->rcb[rc_handle].peer_features = peer_features;
                     }
@@ -2189,7 +2239,10 @@ void bta_av_rc_disc_done(tBTA_AV_DATA *p_data)
     }
     else
     {
-        p_cb->rcb[rc_handle].peer_features = peer_features;
+        /* Fix for below Klockwork Issue
+         * Array 'rcb' of size 4 may use index value(s) 4..254 */
+        if (rc_handle < BTA_AV_NUM_RCB)
+            p_cb->rcb[rc_handle].peer_features = peer_features;
         rc_feat.rc_handle =  rc_handle;
         rc_feat.peer_features = peer_features;
         if (p_scb == NULL)
@@ -2209,6 +2262,26 @@ void bta_av_rc_disc_done(tBTA_AV_DATA *p_data)
 
 /*******************************************************************************
 **
+** Function         bta_av_rc_collission_detected
+**
+** Description      Update App on collision detected case
+**
+**
+** Returns          void
+**
+*******************************************************************************/
+void bta_av_rc_collission_detected(tBTA_AV_DATA *p_data)
+{
+    tBTA_AV_CB   *p_cb = &bta_av_cb;
+    tBTA_AV_RC_COLL_DETECTED rc_coll;
+    tBTA_AV_RC_COLLISSION_DETECTED *p_msg = (tBTA_AV_RC_COLLISSION_DETECTED *)p_data;
+    rc_coll.rc_handle = p_msg->handle;
+    bdcpy(rc_coll.peer_addr, p_msg->peer_addr);
+    (*p_cb->p_cback)(BTA_AV_RC_COLL_DETECTED_EVT, (tBTA_AV *) &rc_coll);
+}
+
+/*******************************************************************************
+**
 ** Function         bta_av_rc_closed
 **
 ** Description      Set AVRCP state to closed.
@@ -2300,6 +2373,9 @@ void bta_av_rc_closed(tBTA_AV_DATA *p_data)
         bdcpy(rc_close.peer_addr, p_msg->peer_addr);
     }
     (*p_cb->p_cback)(BTA_AV_RC_CLOSE_EVT, (tBTA_AV *) &rc_close);
+    if (bta_av_cb.rc_acp_handle == BTA_AV_RC_HANDLE_NONE
+                    && bta_av_cb.features & BTA_AV_FEAT_RCTG)
+        bta_av_rc_create(&bta_av_cb, AVCT_ACP, 0, BTA_AV_NUM_LINKS + 1);
 }
 
 /*******************************************************************************
diff --git a/bta/av/bta_av_int.h b/bta/av/bta_av_int.h
index 7bb6e41..a751f14 100644
--- a/bta/av/bta_av_int.h
+++ b/bta/av/bta_av_int.h
@@ -114,7 +114,8 @@ enum
     BTA_AV_API_START_EVT,       /* the following 2 events must be in the same order as the *AP_*EVT */
     BTA_AV_API_STOP_EVT,
     BTA_AV_UPDATE_MAX_AV_CLIENTS_EVT,
-    BTA_AV_ENABLE_MULTICAST_EVT /* Event for enable and disable multicast */
+    BTA_AV_ENABLE_MULTICAST_EVT, /* Event for enable and disable multicast */
+    BTA_AV_RC_COLLISSION_DETECTED_EVT
 };
 
 /* events for AV control block state machine */
@@ -384,6 +385,14 @@ typedef struct
     UINT8               handle;
 } tBTA_AV_RC_CONN_CHG;
 
+/* data type for BTA_AV_AVRC_COLL_DETECTED_EVT */
+typedef struct
+{
+    BT_HDR              hdr;
+    BD_ADDR             peer_addr;
+    UINT8               handle;
+} tBTA_AV_RC_COLLISSION_DETECTED;
+
 /* data type for BTA_AV_CONN_CHG_EVT */
 typedef struct
 {
@@ -549,6 +558,7 @@ typedef struct
     UINT8               co_started;     /* non-zero, if stream started from call-out perspective */
     BOOLEAN             recfg_sup;      /* TRUE if the first attempt to reconfigure the stream was successfull, else False if command fails */
     BOOLEAN             suspend_sup;    /* TRUE if Suspend stream is supported, else FALSE if suspend command fails */
+    BOOLEAN             suspend_local_sent;    /* TRUE if outgoing Suspend is sent, else FALSE if confirmation is received */
     BOOLEAN             deregistring;   /* TRUE if deregistering */
     BOOLEAN             sco_suspend;    /* TRUE if SUSPEND is issued automatically for SCO */
     UINT8               coll_mask;      /* Mask to check incoming and outgoing collision */
@@ -704,6 +714,7 @@ extern void bta_av_rc_closed(tBTA_AV_DATA *p_data);
 extern void bta_av_rc_disc(UINT8 disc);
 extern void bta_av_conn_chg(tBTA_AV_DATA *p_data);
 extern void bta_av_dereg_comp(tBTA_AV_DATA *p_data);
+extern void bta_av_rc_collission_detected(tBTA_AV_DATA *p_data);
 
 /* sm action functions */
 extern void bta_av_disable (tBTA_AV_CB *p_cb, tBTA_AV_DATA *p_data);
diff --git a/bta/av/bta_av_main.c b/bta/av/bta_av_main.c
index c516612..50b116d 100644
--- a/bta/av/bta_av_main.c
+++ b/bta/av/bta_av_main.c
@@ -215,6 +215,7 @@ const tBTA_AV_NSM_ACT bta_av_nsm_act[] =
     bta_av_api_to_ssm,              /* BTA_AV_API_STOP_EVT */
     bta_av_api_update_max_av_clients,
     bta_av_api_enable_multicast,    /* BTA_AV_ENABLE_MULTICAST_EVT */
+    bta_av_rc_collission_detected, /* BTA_AV_RC_COLLISSION_DETECTED_EVT */
 };
 
 /*****************************************************************************
@@ -543,6 +544,7 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
     do
     {
         p_scb = bta_av_alloc_scb(registr.chnl);
+        cs.registration_id = p_scb->hdi;
         if(p_scb == NULL)
         {
             APPL_TRACE_ERROR("failed to alloc SCB");
@@ -763,10 +765,17 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
                              continue;
                         }
                     }
+                } else if (codec_type == AAC) {
+                    //Don't add AAC in Non split mode
+                    index++;
+                    continue;
                 }
 
-                if(AVDT_CreateStream(&p_scb->seps[index - startIndex].av_handle, &cs) ==
-                                                                            AVDT_SUCCESS)
+                /* Fix for below klockwork Issues
+                 * Array 'seps' of size 4 may use index value(s) 4 */
+                if (((index - startIndex) < BTA_AV_MAX_SEPS) &&
+                    (AVDT_CreateStream(&p_scb->seps[index - startIndex].av_handle, &cs) ==
+                                                                             AVDT_SUCCESS))
                 {
                    if ((profile_initialized == UUID_SERVCLASS_AUDIO_SOURCE) &&
                        ((index == BTIF_SV_AV_AA_APTX_INDEX) || (index == BTIF_SV_AV_AA_APTX_HD_INDEX)))
@@ -974,8 +983,7 @@ static void bta_av_api_to_ssm(tBTA_AV_DATA *p_data)
      * streams are not yet started. We need to take care of this
      * during suspend to ensure we suspend both streams.
      */
-    if ((is_multicast_enabled == TRUE) ||
-        ((event == BTA_AV_AP_STOP_EVT) && (bta_av_multiple_streams_started() == TRUE)))
+    if (is_multicast_enabled == TRUE)
     {
         /* Send START request to all Open Stream connections.*/
         for(xx=0; xx<BTA_AV_NUM_STRS; xx++)
diff --git a/bta/dm/bta_dm_act.c b/bta/dm/bta_dm_act.c
index e42429a..985e758 100644
--- a/bta/dm/bta_dm_act.c
+++ b/bta/dm/bta_dm_act.c
@@ -44,6 +44,7 @@
 #include "osi/include/osi.h"
 #include "sdp_api.h"
 #include "utl.h"
+#include "device/include/interop_config.h"
 
 #if (GAP_INCLUDED == TRUE)
 #include "gap_api.h"
@@ -105,6 +106,8 @@ extern tBTA_DM_CONTRL_STATE bta_dm_pm_obtain_controller_state(void);
 static void bta_dm_ctrl_features_rd_cmpl_cback(tBTM_STATUS result);
 #endif
 
+static void bta_dm_ext_adv_ctrl_features_rd_cmpl_cback(tBTM_STATUS result);
+
 #ifndef BTA_DM_BLE_ADV_CHNL_MAP
 #define BTA_DM_BLE_ADV_CHNL_MAP (BTM_BLE_ADV_CHNL_37|BTM_BLE_ADV_CHNL_38|BTM_BLE_ADV_CHNL_39)
 #endif
@@ -446,6 +449,9 @@ static void bta_dm_sys_hw_cback( tBTA_SYS_HW_EVT status )
         BTM_BleReadControllerFeatures (bta_dm_ctrl_features_rd_cmpl_cback);
 #endif
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        BTM_BleReadExtAdvControllerFeatures (bta_dm_ext_adv_ctrl_features_rd_cmpl_cback);
+#endif
         /* Earlier, we used to invoke BTM_ReadLocalAddr which was just copying the bd_addr
            from the control block and invoking the callback which was sending the DM_ENABLE_EVT.
            But then we have a few HCI commands being invoked above which were still in progress
@@ -507,8 +513,13 @@ void bta_dm_disable (tBTA_DM_MSG *p_data)
     /* Disable SOC Logging */
     if (soc_type == BT_SOC_SMD)
     {
-        UINT8       param[5] = {0x10,0x02,0x00,0x00,0x01};
-        BTM_VendorSpecificCommand(HCI_VS_HOST_LOG_OPCODE,5,param,NULL);
+        UINT8       param[5] = {0x10, 0x02, 0x00, 0x00, 0x01};
+        BTM_VendorSpecificCommand(HCI_VS_HOST_LOG_OPCODE, 5, param, NULL);
+    }
+    else if (soc_type == BT_SOC_CHEROKEE)
+    {
+        UINT8       param_cherokee[2] = {0x14, 0x00};
+        BTM_VendorSpecificCommand(HCI_VS_HOST_LOG_OPCODE, 2, param_cherokee, NULL);
     }
 
     if(BTM_GetNumAclLinks()==0)
@@ -581,7 +592,7 @@ static void bta_dm_disable_timer_cback(void *data)
         bta_dm_cb.disabling = FALSE;
 
         bta_sys_remove_uuid(UUID_SERVCLASS_PNP_INFORMATION);
-        bta_dm_cb.p_sec_cback(BTA_DM_DISABLE_EVT, NULL);
+        bta_dm_disable_conn_down_timer_cback(NULL);
     }
 }
 
@@ -775,9 +786,11 @@ void bta_dm_remove_device(tBTA_DM_MSG *p_data)
     bdcpy(other_address, p_dev->bd_addr);
 
     /* If ACL exists for the device in the remove_bond message*/
+    bt_bdaddr_t remote_bdaddr;
+    bdcpy(remote_bdaddr.address, p_dev->bd_addr);
     BOOLEAN continue_delete_dev = FALSE;
     UINT8 other_transport = BT_TRANSPORT_INVALID;
-    remove_iot_device(IOT_DEV_CONF_FILE, IOT_ROLE_CHANGE_BLACKLIST,p_dev->bd_addr, METHOD_BD);
+    interop_database_remove_addr(INTEROP_DYNAMIC_ROLE_SWITCH, (bt_bdaddr_t *)&remote_bdaddr);
 
     if (BTM_IsAclConnectionUp(p_dev->bd_addr, BT_TRANSPORT_LE) ||
         BTM_IsAclConnectionUp(p_dev->bd_addr, BT_TRANSPORT_BR_EDR))
@@ -827,9 +840,13 @@ void bta_dm_remove_device(tBTA_DM_MSG *p_data)
         /* Take the link down first, and mark the device for removal when disconnected */
         for(int i=0; i < bta_dm_cb.device_list.count; i++)
         {
-            if (!bdcmp(bta_dm_cb.device_list.peer_device[i].peer_bdaddr, other_address))
+            if ((!bdcmp(bta_dm_cb.device_list.peer_device[i].peer_bdaddr, other_address))&&
+               ((other_transport && (other_transport == bta_dm_cb.device_list.peer_device[i].transport)) ||
+               !other_transport))
             {
                 bta_dm_cb.device_list.peer_device[i].conn_state = BTA_DM_UNPAIRING;
+                APPL_TRACE_DEBUG("%s:transport = %d ,other_transport = %d", __func__,
+                                  bta_dm_cb.device_list.peer_device[i].transport, other_transport);
                 btm_remove_acl(other_address,bta_dm_cb.device_list.peer_device[i].transport);
                 break;
             }
@@ -2487,6 +2504,7 @@ static void bta_dm_inq_results_cb (tBTM_INQ_RESULTS *p_inq, UINT8 *p_eir)
     result.inq_res.device_type      = p_inq->device_type;
     result.inq_res.flag             = p_inq->flag;
 #endif
+    result.inq_res.adv_data_len     = p_inq->adv_data_len;
 
     /* application will parse EIR to find out remote device name */
     result.inq_res.p_eir = p_eir;
@@ -2947,8 +2965,10 @@ static UINT8 bta_dm_sp_cback (tBTM_SP_EVT event, tBTM_SP_EVT_DATA *p_data)
     /*case BTM_SP_KEY_REQ_EVT: */
     case BTM_SP_KEY_NOTIF_EVT:
 #endif
+
         if(BTM_SP_CFM_REQ_EVT == event)
         {
+          bta_dm_cb.num_val = sec_event.key_notif.passkey = p_data->cfm_req.num_val;
           /* Due to the switch case falling through below to BTM_SP_KEY_NOTIF_EVT,
              call remote name request using values from cfm_req */
           if(p_data->cfm_req.bd_name[0] == 0)
@@ -2977,9 +2997,10 @@ static UINT8 bta_dm_sp_cback (tBTM_SP_EVT event, tBTM_SP_EVT_DATA *p_data)
            }
         }
 
-        bta_dm_cb.num_val = sec_event.key_notif.passkey = p_data->key_notif.passkey;
         if (BTM_SP_KEY_NOTIF_EVT == event)
         {
+
+            bta_dm_cb.num_val = sec_event.key_notif.passkey = p_data->key_notif.passkey;
             /* If the device name is not known, save bdaddr and devclass
                and initiate a name request with values from key_notif */
             if(p_data->key_notif.bd_name[0] == 0)
@@ -3586,24 +3607,19 @@ static void bta_dm_reset_sec_dev_pending(BD_ADDR remote_bd_addr)
 *******************************************************************************/
 static void bta_dm_remove_sec_dev_entry(BD_ADDR remote_bd_addr)
 {
-    UINT16 index = 0;
     if ( BTM_IsAclConnectionUp(remote_bd_addr, BT_TRANSPORT_LE) ||
          BTM_IsAclConnectionUp(remote_bd_addr, BT_TRANSPORT_BR_EDR))
     {
-         APPL_TRACE_DEBUG("%s ACL is not down. Schedule for  Dev Removal when ACL closes",
-                            __FUNCTION__);
-        for (index = 0; index < bta_dm_cb.device_list.count; index ++)
+        APPL_TRACE_DEBUG("%s ACL is not down. Schedule for  Dev Removal when ACL closes",
+                            __func__);
+        BTM_SecClearSecurityFlags (remote_bd_addr);
+        for (int i = 0; i < bta_dm_cb.device_list.count; i++)
         {
-            if (!bdcmp( bta_dm_cb.device_list.peer_device[index].peer_bdaddr, remote_bd_addr))
+            if (!bdcmp( bta_dm_cb.device_list.peer_device[i].peer_bdaddr, remote_bd_addr))
+            {
+                bta_dm_cb.device_list.peer_device[i].remove_dev_pending = TRUE;
                 break;
-        }
-        if (index != bta_dm_cb.device_list.count)
-        {
-            bta_dm_cb.device_list.peer_device[index].remove_dev_pending = TRUE;
-        }
-        else
-        {
-            APPL_TRACE_ERROR(" %s Device does not exist in DB", __FUNCTION__);
+            }
         }
     }
     else
@@ -4349,7 +4365,6 @@ static void bta_dm_observe_results_cb (tBTM_INQ_RESULTS *p_inq, UINT8 *p_eir)
 ;
     tBTA_DM_SEARCH     result;
     tBTM_INQ_INFO      *p_inq_info;
-    APPL_TRACE_DEBUG("bta_dm_observe_results_cb")
 
     bdcpy(result.inq_res.bd_addr, p_inq->remote_bd_addr);
     result.inq_res.rssi = p_inq->rssi;
@@ -4357,6 +4372,7 @@ static void bta_dm_observe_results_cb (tBTM_INQ_RESULTS *p_inq, UINT8 *p_eir)
     result.inq_res.inq_result_type  = p_inq->inq_result_type;
     result.inq_res.device_type      = p_inq->device_type;
     result.inq_res.flag             = p_inq->flag;
+    result.inq_res.adv_data_len     = p_inq->adv_data_len;
 
     /* application will parse EIR to find out remote device name */
     result.inq_res.p_eir = p_eir;
@@ -4482,6 +4498,11 @@ static UINT8 bta_dm_ble_smp_cback (tBTM_LE_EVT event, BD_ADDR bda, tBTM_LE_EVT_D
             bta_dm_cb.p_sec_cback(BTA_DM_BLE_NC_REQ_EVT, &sec_event);
             break;
 
+        case BTM_LE_SC_OOB_REQ_EVT:
+            bdcpy(sec_event.ble_req.bd_addr, bda);
+            bta_dm_cb.p_sec_cback(BTA_DM_BLE_SC_OOB_REQ_EVT, &sec_event);
+            break;
+
         case BTM_LE_KEY_EVT:
             bdcpy(sec_event.ble_key.bd_addr, bda);
             sec_event.ble_key.key_type = p_data->key.key_type;
@@ -4509,6 +4530,7 @@ static UINT8 bta_dm_ble_smp_cback (tBTM_LE_EVT event, BD_ADDR bda, tBTM_LE_EVT_D
             else
             {
                 sec_event.auth_cmpl.success = TRUE;
+                sec_event.auth_cmpl.smp_over_br = p_data->complt.smp_over_br;
             }
 
             if (bta_dm_cb.p_sec_cback)
@@ -4717,8 +4739,11 @@ void bta_dm_ble_set_conn_params (tBTA_DM_MSG *p_data)
 void bta_dm_ble_set_scan_params(tBTA_DM_MSG *p_data)
 {
     BTM_BleSetScanParams(p_data->ble_set_scan_params.client_if,
+                         p_data->ble_set_scan_params.scan_phys,
                          p_data->ble_set_scan_params.scan_int,
                          p_data->ble_set_scan_params.scan_window,
+                         p_data->ble_set_scan_params.scan_int_coded,
+                         p_data->ble_set_scan_params.scan_window_coded,
                          p_data->ble_set_scan_params.scan_mode,
                          p_data->ble_set_scan_params.scan_param_setup_cback);
 }
@@ -4791,6 +4816,7 @@ void bta_dm_ble_observe (tBTA_DM_MSG *p_data)
         /*Save the  callback to be called when a scan results are available */
         bta_dm_search_cb.p_scan_cback = p_data->ble_observe.p_cback;
         if ((status = BTM_BleObserve(TRUE, p_data->ble_observe.duration,
+                            p_data->ble_observe.period,
                             bta_dm_observe_results_cb, bta_dm_observe_cmpl_cb))!= BTM_CMD_STARTED)
         {
             tBTA_DM_SEARCH  data;
@@ -4805,7 +4831,7 @@ void bta_dm_ble_observe (tBTA_DM_MSG *p_data)
     else
     {
         bta_dm_search_cb.p_scan_cback = NULL;
-        BTM_BleObserve(FALSE, 0, NULL,NULL );
+        BTM_BleObserve(FALSE, 0, p_data->ble_observe.period, NULL, NULL );
     }
 }
 /*******************************************************************************
@@ -4891,6 +4917,43 @@ void bta_dm_ble_set_data_length(tBTA_DM_MSG *p_data)
 
 /*******************************************************************************
 **
+** Function         bta_dm_ble_set_phy
+**
+** Description      This function sets the tx and rx phy for a connection
+**
+** Parameters
+**
+*******************************************************************************/
+void bta_dm_ble_set_phy(tBTA_DM_MSG *p_data)
+{
+    if (BTM_SetBlePhy(p_data->ble_set_phy.remote_bda, p_data->ble_set_phy.all_phy,
+                      p_data->ble_set_phy.tx_phy, p_data->ble_set_phy.rx_phy,
+                      p_data->ble_set_phy.phy_options) != BTM_SUCCESS)
+    {
+        APPL_TRACE_ERROR("%s failed", __func__);
+    }
+}
+
+/*******************************************************************************
+**
+** Function         bta_dm_ble_set_default_phy
+**
+** Description      This function sets the default tx and rx phy
+**
+** Parameters
+**
+*******************************************************************************/
+void bta_dm_ble_set_default_phy(tBTA_DM_MSG *p_data)
+{
+    if (BTM_SetDefaultBlePhy(p_data->ble_set_default_phy.all_phy,
+                      p_data->ble_set_default_phy.tx_phy, p_data->ble_set_default_phy.rx_phy) != BTM_SUCCESS)
+    {
+        APPL_TRACE_ERROR("%s failed", __func__);
+    }
+}
+
+/*******************************************************************************
+**
 ** Function         bta_dm_ble_broadcast
 **
 ** Description      Starts or stops LE broadcasts
@@ -4980,6 +5043,7 @@ void bta_dm_ble_multi_adv_data(tBTA_DM_MSG *p_data)
         btm_status = BTM_BleCfgAdvInstData(p_data->ble_multi_adv_data.inst_id,
                         p_data->ble_multi_adv_data.is_scan_rsp,
                         p_data->ble_multi_adv_data.data_mask,
+                        p_data->ble_multi_adv_data.frag_pref,
                         (tBTM_BLE_ADV_DATA*)&p_data->ble_multi_adv_data.data);
     }
 
@@ -5744,5 +5808,28 @@ static void bta_dm_ctrl_features_rd_cmpl_cback(tBTM_STATUS result)
 
 }
 #endif /* BLE_VND_INCLUDED */
+/*******************************************************************************
+**
+** Function         bta_dm_ext_adv_ctrl_features_rd_cmpl_cback
+**
+** Description      callback to handle controller feature read complete
+**
+** Parameters:
+**
+*******************************************************************************/
+static void bta_dm_ext_adv_ctrl_features_rd_cmpl_cback(tBTM_STATUS result)
+{
+    APPL_TRACE_DEBUG("%s  status = %d ", __FUNCTION__, result);
+    if (result == BTM_SUCCESS)
+    {
+        if(bta_dm_cb.p_sec_cback)
+            bta_dm_cb.p_sec_cback(BTA_DM_LE_ADV_EXT_FEATURES_READ, NULL);
+    }
+    else
+    {
+        APPL_TRACE_ERROR("%s Ctrl BLE ADV EXT feature read failed: status :%d",__FUNCTION__, result);
+    }
+
+}
 
 #endif  /* BLE_INCLUDED */
diff --git a/bta/dm/bta_dm_api.c b/bta/dm/bta_dm_api.c
index 6d6c0f2..42167ae 100644
--- a/bta/dm/bta_dm_api.c
+++ b/bta/dm/bta_dm_api.c
@@ -934,10 +934,10 @@ void BTA_DmSetBleConnScanParams(UINT32 scan_interval, UINT32 scan_window)
 ** Returns          void
 **
 *******************************************************************************/
-
 #if BLE_INCLUDED == TRUE
-void BTA_DmSetBleScanParams(tGATT_IF client_if, UINT32 scan_interval,
-                            UINT32 scan_window, tBLE_SCAN_MODE scan_mode,
+void BTA_DmSetBleScanParams(tGATT_IF client_if, UINT8 scan_phys, UINT32 scan_interval,
+                            UINT32 scan_window, UINT16 scan_interval_coded,
+                            UINT16 scan_window_coded, tBLE_SCAN_MODE scan_mode,
                             tBLE_SCAN_PARAM_SETUP_CBACK scan_param_setup_cback)
 {
     tBTA_DM_API_BLE_SCAN_PARAMS *p_msg =
@@ -945,11 +945,14 @@ void BTA_DmSetBleScanParams(tGATT_IF client_if, UINT32 scan_interval,
 
     p_msg->hdr.event = BTA_DM_API_BLE_SCAN_PARAM_EVT;
     p_msg->client_if = client_if;
+    p_msg->scan_phys = scan_phys;
     p_msg->scan_int = scan_interval;
     p_msg->scan_window = scan_window;
+    p_msg->scan_int_coded = scan_interval_coded;
+    p_msg->scan_window_coded = scan_window_coded;
+
     p_msg->scan_mode = scan_mode;
     p_msg->scan_param_setup_cback = scan_param_setup_cback;
-
     bta_sys_sendmsg(p_msg);
 }
 #endif  // BLE_INCLUDED == TRUE
@@ -1543,18 +1546,19 @@ void BTA_BleUpdateAdvInstParam (UINT8 inst_id, tBTA_BLE_ADV_PARAMS *p_params)
 **
 *******************************************************************************/
 void BTA_BleCfgAdvInstData (UINT8 inst_id, BOOLEAN is_scan_rsp,
-                            tBTA_BLE_AD_MASK data_mask,
+                            tBTA_BLE_AD_MASK data_mask, UINT8 frag_pref,
                             tBTA_BLE_ADV_DATA *p_data)
 {
-  tBTA_DM_API_BLE_MULTI_ADV_DATA *p_msg = osi_calloc(sizeof(*p_msg));
+    tBTA_DM_API_BLE_MULTI_ADV_DATA *p_msg = osi_calloc(sizeof(*p_msg));
 
-  p_msg->hdr.event = BTA_DM_API_BLE_MULTI_ADV_DATA_EVT;
-  p_msg->inst_id = inst_id;
-  p_msg->is_scan_rsp = is_scan_rsp;
-  p_msg->data_mask = data_mask;
-  memcpy(&p_msg->data, p_data, sizeof(p_msg->data));
+    p_msg->hdr.event     = BTA_DM_API_BLE_MULTI_ADV_DATA_EVT;
+    p_msg->inst_id      = inst_id;
+    p_msg->is_scan_rsp  = is_scan_rsp;
+    p_msg->data_mask     = data_mask;
+    memcpy(&p_msg->data, p_data, sizeof(p_msg->data));
+    p_msg->frag_pref     = frag_pref;
 
-  bta_sys_sendmsg(p_msg);
+    bta_sys_sendmsg(p_msg);
 }
 
 /*******************************************************************************
@@ -1880,6 +1884,59 @@ void BTA_DmBleSetDataLength(BD_ADDR remote_device, UINT16 tx_data_length)
     bta_sys_sendmsg(p_msg);
 }
 
+/*******************************************************************************
+**
+** Function         BTA_DmBleSetPhy
+**
+** Description      This function is to set Tx and Rx Phy for a connection
+**
+** Returns          void
+**
+*******************************************************************************/
+void BTA_DmBleSetPhy(BD_ADDR remote_device, UINT8 all_phy, UINT8 tx_phy,
+                     UINT8 rx_phy, UINT16 phy_options)
+{
+    tBTA_DM_API_BLE_SET_PHY *p_msg;
+
+    if ((p_msg = (tBTA_DM_API_BLE_SET_PHY *)osi_malloc(sizeof(tBTA_DM_API_BLE_SET_PHY)))
+                  != NULL)
+    {
+        bdcpy(p_msg->remote_bda, remote_device);
+        p_msg->all_phy = all_phy;
+        p_msg->tx_phy = tx_phy;
+        p_msg->rx_phy = rx_phy;
+        p_msg->phy_options = phy_options;
+        p_msg->hdr.event = BTA_DM_API_SET_BLE_PHY_EVT;
+
+        bta_sys_sendmsg(p_msg);
+    }
+}
+
+/*******************************************************************************
+**
+** Function         BTA_DmBleSetDefaultPhy
+**
+** Description      This function is to set default Tx and Rx Phy
+**
+** Returns          void
+**
+*******************************************************************************/
+void BTA_DmBleSetDefaultPhy(UINT8 all_phy, UINT8 tx_phy, UINT8 rx_phy)
+{
+    tBTA_DM_API_BLE_SET_DEFAULT_PHY *p_msg;
+
+    if ((p_msg = (tBTA_DM_API_BLE_SET_DEFAULT_PHY *)osi_malloc(sizeof(tBTA_DM_API_BLE_SET_DEFAULT_PHY)))
+                  != NULL)
+    {
+        p_msg->all_phy = all_phy;
+        p_msg->tx_phy = tx_phy;
+        p_msg->rx_phy = rx_phy;
+        p_msg->hdr.event = BTA_DM_API_SET_DEFAULT_BLE_PHY_EVT;
+
+        bta_sys_sendmsg(p_msg);
+    }
+}
+
 #endif
 
 /*******************************************************************************
@@ -1964,7 +2021,7 @@ void BTA_DmCloseACL(BD_ADDR bd_addr, BOOLEAN remove_dev, tBTA_TRANSPORT transpor
 ** Returns          void.
 **
 *******************************************************************************/
-extern void BTA_DmBleObserve(BOOLEAN start, UINT8 duration,
+extern void BTA_DmBleObserve(BOOLEAN start, UINT16 duration, UINT16 period,
                              tBTA_DM_SEARCH_CBACK *p_results_cb)
 {
     tBTA_DM_API_BLE_OBSERVE *p_msg =
@@ -1975,6 +2032,7 @@ extern void BTA_DmBleObserve(BOOLEAN start, UINT8 duration,
     p_msg->hdr.event = BTA_DM_API_BLE_OBSERVE_EVT;
     p_msg->start = start;
     p_msg->duration = duration;
+    p_msg->period = period;
     p_msg->p_cback = p_results_cb;
 
     bta_sys_sendmsg(p_msg);
diff --git a/bta/dm/bta_dm_cfg.c b/bta/dm/bta_dm_cfg.c
index d17717b..b5a6d41 100644
--- a/bta/dm/bta_dm_cfg.c
+++ b/bta/dm/bta_dm_cfg.c
@@ -529,7 +529,7 @@ tBTA_DM_SSR_SPEC bta_dm_ssr_spec[] =
 {
     /*max_lat, min_rmt_to, min_loc_to*/
     {0,      0, 0},     /* BTA_DM_PM_SSR0 - do not use SSR */
-    {0,      0, 1600},     /* BTA_DM_PM_SSR1 - HH, can NOT share entry with any other profile,
+    {0,      0, 2},     /* BTA_DM_PM_SSR1 - HH, can NOT share entry with any other profile,
                            seting default max latency and min remote timeout as 0,
                            and always read individual device preference from HH module */
     {1200,   2, 2},     /* BTA_DM_PM_SSR2 - others (as long as sniff is allowed)*/
diff --git a/bta/dm/bta_dm_int.h b/bta/dm/bta_dm_int.h
index 4c0f9dd..3e8a2422 100644
--- a/bta/dm/bta_dm_int.h
+++ b/bta/dm/bta_dm_int.h
@@ -98,6 +98,8 @@ enum
     BTA_DM_API_BLE_SET_SCAN_RSP_EVT,
     BTA_DM_API_BLE_BROADCAST_EVT,
     BTA_DM_API_SET_DATA_LENGTH_EVT,
+    BTA_DM_API_SET_BLE_PHY_EVT,
+    BTA_DM_API_SET_DEFAULT_BLE_PHY_EVT,
 
 #if BLE_ANDROID_CONTROLLER_SCAN_FILTER == TRUE
     BTA_DM_API_CFG_FILTER_COND_EVT,
@@ -480,8 +482,11 @@ typedef struct
 {
     BT_HDR hdr;
     tBTA_GATTC_IF client_if;
+    UINT8  scan_phys;
     UINT32 scan_int;
     UINT32 scan_window;
+    UINT16 scan_int_coded;
+    UINT16 scan_window_coded;
     tBLE_SCAN_MODE scan_mode;
     tBLE_SCAN_PARAM_SETUP_CBACK scan_param_setup_cback;
 }tBTA_DM_API_BLE_SCAN_PARAMS;
@@ -500,6 +505,7 @@ typedef struct
     BT_HDR                  hdr;
     BOOLEAN                 start;
     UINT16                  duration;
+    UINT16                  period;
     tBTA_DM_SEARCH_CBACK * p_cback;
 }tBTA_DM_API_BLE_OBSERVE;
 
@@ -510,6 +516,24 @@ typedef struct
     UINT16      tx_data_length;
 }tBTA_DM_API_BLE_SET_DATA_LENGTH;
 
+typedef struct
+{
+    BT_HDR      hdr;
+    BD_ADDR     remote_bda;
+    UINT8       all_phy;
+    UINT8       tx_phy;
+    UINT8       rx_phy;
+    UINT16      phy_options;
+}tBTA_DM_API_BLE_SET_PHY;
+
+typedef struct
+{
+    BT_HDR      hdr;
+    UINT8       all_phy;
+    UINT8       tx_phy;
+    UINT8       rx_phy;
+}tBTA_DM_API_BLE_SET_DEFAULT_PHY;
+
 /* set adv parameter for BLE advertising */
 typedef struct
 {
@@ -549,6 +573,7 @@ typedef struct
     BOOLEAN                 is_scan_rsp;
     tBTA_BLE_AD_MASK        data_mask;
     tBTA_BLE_ADV_DATA       data;
+    UINT8                   frag_pref;
 }tBTA_DM_API_BLE_MULTI_ADV_DATA;
 
 typedef struct
@@ -746,6 +771,8 @@ typedef union
 #endif
     tBTA_DM_API_UPDATE_CONN_PARAM       ble_update_conn_params;
     tBTA_DM_API_BLE_SET_DATA_LENGTH     ble_set_data_length;
+    tBTA_DM_API_BLE_SET_PHY             ble_set_phy;
+    tBTA_DM_API_BLE_SET_DEFAULT_PHY     ble_set_default_phy;
 
     tBTA_DM_API_BLE_MULTI_ADV_ENB       ble_multi_adv_enb;
     tBTA_DM_API_BLE_MULTI_ADV_PARAM     ble_multi_adv_param;
@@ -766,8 +793,12 @@ typedef union
     tBTA_DM_API_VENDOR_SPECIFIC_COMMAND vendor_command;
 } tBTA_DM_MSG;
 
-
+#ifndef MAX_ACL_CONNECTIONS
 #define BTA_DM_NUM_PEER_DEVICE 7
+#else
+#define BTA_DM_NUM_PEER_DEVICE  MAX_ACL_CONNECTIONS
+#endif
+
 
 #define BTA_DM_NOT_CONNECTED  0
 #define BTA_DM_CONNECTED      1
@@ -1142,6 +1173,8 @@ extern void bta_dm_ble_set_adv_config (tBTA_DM_MSG *p_data);
 extern void bta_dm_ble_set_scan_rsp (tBTA_DM_MSG *p_data);
 extern void bta_dm_ble_broadcast (tBTA_DM_MSG *p_data);
 extern void bta_dm_ble_set_data_length(tBTA_DM_MSG *p_data);
+extern void bta_dm_ble_set_phy(tBTA_DM_MSG *p_data);
+extern void bta_dm_ble_set_default_phy(tBTA_DM_MSG *p_data);
 
 #if BLE_ANDROID_CONTROLLER_SCAN_FILTER == TRUE
 extern void bta_dm_cfg_filter_cond (tBTA_DM_MSG *p_data);
diff --git a/bta/dm/bta_dm_main.c b/bta/dm/bta_dm_main.c
index 6197f03..4e51183 100644
--- a/bta/dm/bta_dm_main.c
+++ b/bta/dm/bta_dm_main.c
@@ -96,6 +96,8 @@ const tBTA_DM_ACTION bta_dm_action[] =
     bta_dm_ble_set_scan_rsp,       /* BTA_DM_API_BLE_SET_SCAN_RSPT */
     bta_dm_ble_broadcast,          /* BTA_DM_API_BLE_BROADCAST_EVT */
     bta_dm_ble_set_data_length,    /* BTA_DM_API_SET_DATA_LENGTH_EVT */
+    bta_dm_ble_set_phy,            /* BTA_DM_API_SET_BLE_PHY_EVT */
+    bta_dm_ble_set_default_phy,    /* BTA_DM_API_SET_BLE_DEFAULT_PHY_EVT */
 #if BLE_ANDROID_CONTROLLER_SCAN_FILTER == TRUE
     bta_dm_cfg_filter_cond,         /* BTA_DM_API_CFG_FILTER_COND_EVT */
     bta_dm_scan_filter_param_setup, /* BTA_DM_API_SCAN_FILTER_SETUP_EVT */
diff --git a/bta/dm/bta_dm_pm.c b/bta/dm/bta_dm_pm.c
index 64c0d11..0602022 100644
--- a/bta/dm/bta_dm_pm.c
+++ b/bta/dm/bta_dm_pm.c
@@ -47,6 +47,7 @@ static BOOLEAN bta_dm_pm_is_sco_active ();
 static int bta_dm_get_sco_index();
 static void bta_dm_pm_hid_check(BOOLEAN bScoActive);
 static void bta_dm_pm_set_sniff_policy(tBTA_DM_PEER_DEVICE *p_dev, BOOLEAN bDisable);
+void bta_dm_pm_set_sniff_policy_toggle(BD_ADDR peer_addr, BOOLEAN bDisable);
 static void bta_dm_pm_stop_timer_by_index(tBTA_PM_TIMER *p_timer,
                                           UINT8 timer_idx);
 
@@ -529,10 +530,12 @@ static void bta_dm_pm_cback(tBTA_SYS_CONN_STATUS status, UINT8 id, UINT8 app_id,
             tBTA_DM_PEER_DEVICE *p_rem_dev = NULL;
             if (BTM_ReadRemoteVersion(peer_addr, &lmp_version,
                 &manufacturer, &lmp_sub_version) == BTM_SUCCESS) {
+                bt_bdaddr_t remote_bdaddr;
+                bdcpy(remote_bdaddr.address, peer_addr);
                 p_rem_dev = bta_dm_find_peer_device(peer_addr);
                 /* Disable sniff policy on the HID link since SCO is Up on Slave Link */
                 if ((p_rem_dev) && (interop_match_addr(
-                    INTEROP_DISABLE_SNIFF_DURING_SCO, (const bt_bdaddr_t *)peer_addr) ||
+                    INTEROP_DISABLE_SNIFF_DURING_SCO, (const bt_bdaddr_t *)&remote_bdaddr) ||
                     interop_match_manufacturer(INTEROP_DISABLE_SNIFF_DURING_SCO, manufacturer)))
                 {
                     char buf[18];
@@ -917,10 +920,6 @@ static void bta_dm_pm_ssr(BD_ADDR peer_addr)
                     BTM_SetSsrParams (peer_addr, 0, 0, 0);
                     return;
                 }
-                else if (p_spec_cur->max_lat > BTA_HH_SSR_MAX_LATENCY_OPTIMAL)
-                {
-                    p_spec_cur->max_lat = BTA_HH_SSR_MAX_LATENCY_OPTIMAL;
-                }
                 else if (p_spec_cur->max_lat < BTA_HH_SSR_MAX_LATENCY_MIN_OPTIMAL)
                 {
                     p_spec_cur->max_lat = BTA_HH_SSR_MAX_LATENCY_MIN_OPTIMAL;
@@ -1289,14 +1288,16 @@ static void bta_dm_pm_hid_check(BOOLEAN bScoActive)
             UINT8 lmp_version = 0;
             tBTA_DM_PEER_DEVICE *p_rem_dev = NULL;
             UINT8 *p = BTM_ReadLocalFeatures();
+            bt_bdaddr_t remote_address;
             bdcpy(peer_bdaddr, bta_dm_conn_srvcs.conn_srvc[j].peer_bdaddr);
+            bdcpy(remote_address.address, bta_dm_conn_srvcs.conn_srvc[j].peer_bdaddr);
 
             if (BTM_ReadRemoteVersion(peer_bdaddr, &lmp_version,
                 &manufacturer, &lmp_sub_version) == BTM_SUCCESS) {
                 p_rem_dev = bta_dm_find_peer_device(peer_bdaddr);
                 /* Disable/Enable sniff policy on the HID link if SCO Up/Down*/
                 if ((p_rem_dev) && (interop_match_addr(
-                    INTEROP_DISABLE_SNIFF_DURING_SCO, (const bt_bdaddr_t *)peer_bdaddr) ||
+                    INTEROP_DISABLE_SNIFF_DURING_SCO, (const bt_bdaddr_t *)&remote_address) ||
                     interop_match_manufacturer(INTEROP_DISABLE_SNIFF_DURING_SCO, manufacturer)))
                 {
                     char buf[18];
@@ -1333,7 +1334,13 @@ static void bta_dm_pm_hid_check(BOOLEAN bScoActive)
     }
 
 }
-
+void bta_dm_pm_set_sniff_policy_toggle(BD_ADDR peer_addr, BOOLEAN bDisable)
+{
+    APPL_TRACE_DEBUG("%s: bDisable:%d", __func__, bDisable);
+    tBTA_DM_PEER_DEVICE *p_dev = NULL;
+    p_dev = bta_dm_find_peer_device(peer_addr);
+    bta_dm_pm_set_sniff_policy(p_dev, bDisable);
+}
 /*******************************************************************************
 **
 ** Function         bta_dm_pm_set_sniff_policy
diff --git a/bta/gatt/bta_gattc_act.c b/bta/gatt/bta_gattc_act.c
index e7eeb20..302f2bd 100644
--- a/bta/gatt/bta_gattc_act.c
+++ b/bta/gatt/bta_gattc_act.c
@@ -519,7 +519,7 @@ void bta_gattc_open(tBTA_GATTC_CLCB *p_clcb, tBTA_GATTC_DATA *p_data)
 
     /* open/hold a connection */
     if (!GATT_Connect(p_clcb->p_rcb->client_if, p_data->api_conn.remote_bda,
-                      TRUE, p_data->api_conn.transport))
+                      true, p_data->api_conn.transport, false))
     {
         APPL_TRACE_ERROR("Connection open failure");
 
@@ -559,7 +559,7 @@ void bta_gattc_init_bk_conn(tBTA_GATTC_API_OPEN *p_data, tBTA_GATTC_RCB *p_clreg
     if (bta_gattc_mark_bg_conn(p_data->client_if, p_data->remote_bda, TRUE, FALSE))
     {
         /* always call open to hold a connection */
-        if (!GATT_Connect(p_data->client_if, p_data->remote_bda, FALSE, p_data->transport))
+        if (!GATT_Connect(p_data->client_if, p_data->remote_bda, false, p_data->transport, false))
         {
             uint8_t *bda = (uint8_t *)p_data->remote_bda;
             status = BTA_GATT_ERROR;
@@ -692,7 +692,6 @@ void bta_gattc_cancel_open(tBTA_GATTC_CLCB *p_clcb, tBTA_GATTC_DATA *p_data)
 void bta_gattc_conn(tBTA_GATTC_CLCB *p_clcb, tBTA_GATTC_DATA *p_data)
 {
     tBTA_GATTC_IF   gatt_if;
-    BT_HDR  buf;
     APPL_TRACE_DEBUG("bta_gattc_conn server cache state=%d",p_clcb->p_srcb->state);
 
     if (p_data != NULL)
@@ -717,6 +716,7 @@ void bta_gattc_conn(tBTA_GATTC_CLCB *p_clcb, tBTA_GATTC_DATA *p_data)
             {
                 p_clcb->p_srcb->state = BTA_GATTC_SERV_LOAD;
                 if (bta_gattc_cache_load(p_clcb)) {
+                    p_clcb->p_srcb->state = BTA_GATTC_SERV_IDLE;
                     bta_gattc_reset_discover_st(p_clcb->p_srcb, BTA_GATT_OK);
                 } else {
                     p_clcb->p_srcb->state = BTA_GATTC_SERV_DISC;
@@ -725,17 +725,7 @@ void bta_gattc_conn(tBTA_GATTC_CLCB *p_clcb, tBTA_GATTC_DATA *p_data)
                 }
             }
             else /* cache is building */
-            {
-                if(p_clcb->p_srcb->state == BTA_GATTC_SERV_LOAD)
-                {
-                    bta_gattc_reset_discover_st(p_clcb->p_srcb, BTA_GATT_OK);
-                    buf.event = BTA_GATTC_API_CLOSE_EVT;
-                    buf.layer_specific = p_clcb->bta_conn_id;
-                    bta_gattc_close(p_clcb, (tBTA_GATTC_DATA *)&buf);
-                }
-                else
-                    p_clcb->state = BTA_GATTC_DISCOVER_ST;
-            }
+                p_clcb->state = BTA_GATTC_DISCOVER_ST;
         }
 
         else
@@ -836,6 +826,7 @@ void bta_gattc_close(tBTA_GATTC_CLCB *p_clcb, tBTA_GATTC_DATA *p_data)
     {
         bta_gattc_deregister_cmpl(p_clreg);
     }
+    bta_gattc_clear_notif_reg_on_disc(p_clreg, p_clcb->bda);
 }
 /*******************************************************************************
 **
diff --git a/bta/gatt/bta_gattc_cache.c b/bta/gatt/bta_gattc_cache.c
index 832b0ab..1a42e7d 100644
--- a/bta/gatt/bta_gattc_cache.c
+++ b/bta/gatt/bta_gattc_cache.c
@@ -326,7 +326,8 @@ static tBTA_GATT_STATUS bta_gattc_add_attr_to_cache(tBTA_GATTC_SERV *p_srvc_cb,
         descriptor->handle = handle;
         memcpy(&descriptor->uuid, p_uuid, sizeof(tBT_UUID));
 
-        if (service->characteristics == NULL) {
+        if (service->characteristics == NULL ||
+            list_is_empty(service->characteristics)) {
             APPL_TRACE_ERROR("%s: Illegal action to add descriptor before adding a characteristic!",
                              __func__);
             osi_free(descriptor);
diff --git a/bta/gatt/bta_gattc_int.h b/bta/gatt/bta_gattc_int.h
index d895864..88c39a9 100644
--- a/bta/gatt/bta_gattc_int.h
+++ b/bta/gatt/bta_gattc_int.h
@@ -79,7 +79,11 @@ typedef UINT16 tBTA_GATTC_INT_EVT;
 
 /* max known devices GATTC can support */
 #ifndef     BTA_GATTC_KNOWN_SR_MAX
+#ifndef MAX_ACL_CONNECTIONS
 #define     BTA_GATTC_KNOWN_SR_MAX    10
+#else
+#define     BTA_GATTC_KNOWN_SR_MAX    MAX_ACL_CONNECTIONS
+#endif
 #endif
 
 #define BTA_GATTC_CONN_MAX      GATT_MAX_PHY_CHANNEL
@@ -296,7 +300,11 @@ typedef struct
 } tBTA_GATTC_SERV;
 
 #ifndef BTA_GATTC_NOTIF_REG_MAX
+#ifndef MAX_ACL_CONNECTIONS
 #define BTA_GATTC_NOTIF_REG_MAX     15
+#else
+#define BTA_GATTC_NOTIF_REG_MAX     MAX_ACL_CONNECTIONS*3
+#endif
 #endif
 
 typedef struct
@@ -471,6 +479,7 @@ extern BOOLEAN bta_gattc_mark_bg_conn (tBTA_GATTC_IF client_if,  BD_ADDR_PTR rem
 extern BOOLEAN bta_gattc_check_bg_conn (tBTA_GATTC_IF client_if,  BD_ADDR remote_bda, UINT8 role);
 extern UINT8 bta_gattc_num_reg_app(void);
 extern void bta_gattc_clear_notif_registration(tBTA_GATTC_SERV *p_srcb, UINT16 conn_id, UINT16 start_handle, UINT16 end_handle);
+extern void bta_gattc_clear_notif_reg_on_disc(tBTA_GATTC_RCB *p_clreg, BD_ADDR bda);
 extern tBTA_GATTC_SERV * bta_gattc_find_srvr_cache(BD_ADDR bda);
 
 /* discovery functions */
diff --git a/bta/gatt/bta_gattc_utils.c b/bta/gatt/bta_gattc_utils.c
index bd0d466..f87ea49 100644
--- a/bta/gatt/bta_gattc_utils.c
+++ b/bta/gatt/bta_gattc_utils.c
@@ -302,6 +302,12 @@ void bta_gattc_clcb_dealloc(tBTA_GATTC_CLCB *p_clcb)
             p_srcb->connected = FALSE;
             p_srcb->state = BTA_GATTC_SERV_IDLE;
             p_srcb->mtu = 0;
+
+            /* clean up cache */
+            if (p_srcb->p_srvc_cache) {
+                list_free(p_srcb->p_srvc_cache);
+                p_srcb->p_srvc_cache = NULL;
+            }
         }
 
         osi_free_and_reset((void **)&p_clcb->p_q_cmd);
@@ -470,6 +476,31 @@ BOOLEAN bta_gattc_check_notif_registry(tBTA_GATTC_RCB  *p_clreg, tBTA_GATTC_SERV
     return FALSE;
 
 }
+
+/*******************************************************************************
+**
+** Function         bta_gattc_clear_notif_reg_on_disc
+**
+** Description      clear up the notification registration at disconnection.
+**
+** Returns          None.
+**
+*******************************************************************************/
+void bta_gattc_clear_notif_reg_on_disc(tBTA_GATTC_RCB *p_clreg, BD_ADDR bda) {
+    if (!p_clreg) {
+        APPL_TRACE_ERROR("%s, Invalid regiseration block", __func__);
+        return;
+    }
+
+    UINT8 i;
+    for (i = 0; i < BTA_GATTC_NOTIF_REG_MAX; i++) {
+        if (p_clreg->notif_reg[i].in_use &&
+                !bdcmp(p_clreg->notif_reg[i].remote_bda, bda)) {
+            memset(&p_clreg->notif_reg[i], 0, sizeof(tBTA_GATTC_NOTIF_REG));
+        }
+    }
+}
+
 /*******************************************************************************
 **
 ** Function         bta_gattc_clear_notif_registration
diff --git a/bta/gatt/bta_gatts_act.c b/bta/gatt/bta_gatts_act.c
index 4c35b0c..3f357bf 100644
--- a/bta/gatt/bta_gatts_act.c
+++ b/bta/gatt/bta_gatts_act.c
@@ -689,7 +689,7 @@ void bta_gatts_open (tBTA_GATTS_CB *p_cb, tBTA_GATTS_DATA * p_msg)
     {
         /* should always get the connection ID */
         if (GATT_Connect(p_rcb->gatt_if, p_msg->api_open.remote_bda,
-                        p_msg->api_open.is_direct, p_msg->api_open.transport))
+                        p_msg->api_open.is_direct, p_msg->api_open.transport, false))
         {
             status = BTA_GATT_OK;
 
diff --git a/bta/hf_client/bta_hf_client_act.c b/bta/hf_client/bta_hf_client_act.c
index 261a196..1126bc7 100644
--- a/bta/hf_client/bta_hf_client_act.c
+++ b/bta/hf_client/bta_hf_client_act.c
@@ -465,7 +465,7 @@ void bta_hf_client_disc_int_res(tBTA_HF_CLIENT_DATA *p_data)
     }
 
     /* free discovery db */
-    bta_hf_client_free_db(p_data);
+    bta_hf_client_free_db_int(p_data);
 
     /* send ourselves sdp ok/fail event */
     bta_hf_client_sm_execute(event, p_data);
@@ -483,6 +483,7 @@ void bta_hf_client_disc_int_res(tBTA_HF_CLIENT_DATA *p_data)
 *******************************************************************************/
 void bta_hf_client_disc_acp_res(tBTA_HF_CLIENT_DATA *p_data)
 {
+    APPL_TRACE_DEBUG ("%s: Status: %d", __func__, p_data->disc_result.status);
     /* if found service */
     if (p_data->disc_result.status == SDP_SUCCESS ||
         p_data->disc_result.status == SDP_DB_FULL)
@@ -492,7 +493,7 @@ void bta_hf_client_disc_acp_res(tBTA_HF_CLIENT_DATA *p_data)
     }
 
     /* free discovery db */
-    bta_hf_client_free_db(p_data);
+    bta_hf_client_free_db_acp(p_data);
 }
 
 /*******************************************************************************
diff --git a/bta/hf_client/bta_hf_client_at.c b/bta/hf_client/bta_hf_client_at.c
index 76575f7..745d147 100644
--- a/bta/hf_client/bta_hf_client_at.c
+++ b/bta/hf_client/bta_hf_client_at.c
@@ -148,6 +148,7 @@ static void bta_hf_client_at_resp_timer_cback(UNUSED_ATTR void *data)
     bta_hf_client_handle_ok();
   } else {
     APPL_TRACE_ERROR("HFPClient: AT response timeout, disconnecting");
+    GENERATE_VND_LOGS();
     bta_hf_client_sm_execute(BTA_HF_CLIENT_API_CLOSE_EVT, NULL);
   }
 }
diff --git a/bta/hf_client/bta_hf_client_int.h b/bta/hf_client/bta_hf_client_int.h
index d604fb1..521dc94 100644
--- a/bta/hf_client/bta_hf_client_int.h
+++ b/bta/hf_client/bta_hf_client_int.h
@@ -140,7 +140,8 @@ typedef struct
 {
     UINT16              serv_handle;    /* RFCOMM server handle */
     BD_ADDR             peer_addr;      /* peer bd address */
-    tSDP_DISCOVERY_DB   *p_disc_db;     /* pointer to discovery database */
+    tSDP_DISCOVERY_DB   *p_disc_db_int; /* pointer to discovery database for initiator */
+    tSDP_DISCOVERY_DB   *p_disc_db_acp; /* pointer to discovery database for acceptor*/
     UINT16              conn_handle;    /* RFCOMM handle of connected service */
     tBTA_SEC            serv_sec_mask;  /* server security mask */
     tBTA_SEC            cli_sec_mask;   /* client security mask */
@@ -216,7 +217,8 @@ extern void bta_hf_client_create_record(tBTA_HF_CLIENT_DATA *p_data);
 extern void bta_hf_client_del_record(tBTA_HF_CLIENT_DATA *p_data);
 extern BOOLEAN bta_hf_client_sdp_find_attr(void);
 extern void bta_hf_client_do_disc(void);
-extern void bta_hf_client_free_db(tBTA_HF_CLIENT_DATA *p_data);
+extern void bta_hf_client_free_db_int(tBTA_HF_CLIENT_DATA *p_data);
+extern void bta_hf_client_free_db_acp(tBTA_HF_CLIENT_DATA *p_data);
 
 /* RFCOMM functions */
 extern void bta_hf_client_setup_port(UINT16 handle);
diff --git a/bta/hf_client/bta_hf_client_main.c b/bta/hf_client/bta_hf_client_main.c
index 6573952..871ac91 100644
--- a/bta/hf_client/bta_hf_client_main.c
+++ b/bta/hf_client/bta_hf_client_main.c
@@ -67,7 +67,8 @@ enum
     BTA_HF_CLIENT_SCO_OPEN,
     BTA_HF_CLIENT_SCO_CLOSE,
     BTA_HF_CLIENT_SCO_SHUTDOWN,
-    BTA_HF_CLIENT_FREE_DB,
+    BTA_HF_CLIENT_FREE_DB_INT,
+    BTA_HF_CLIENT_FREE_DB_ACP,
     BTA_HF_CLIENT_OPEN_FAIL,
     BTA_HF_CLIENT_RFC_OPEN,
     BTA_HF_CLIENT_RFC_FAIL,
@@ -103,7 +104,8 @@ const tBTA_HF_CLIENT_ACTION bta_hf_client_action[] =
 /* BTA_HF_CLIENT_SCO_OPEN */      bta_hf_client_sco_open,
 /* BTA_HF_CLIENT_SCO_CLOSE */     bta_hf_client_sco_close,
 /* BTA_HF_CLIENT_SCO_SHUTDOWN */  bta_hf_client_sco_shutdown,
-/* BTA_HF_CLIENT_FREE_DB */       bta_hf_client_free_db,
+/* BTA_HF_CLIENT_FREE_DB_INT */   bta_hf_client_free_db_int,
+/* BTA_HF_CLIENT_FREE_DB_ACP */   bta_hf_client_free_db_acp,
 /* BTA_HF_CLIENT_OPEN_FAIL */     bta_hf_client_open_fail,
 /* BTA_HF_CLIENT_RFC_OPEN */      bta_hf_client_rfc_open,
 /* BTA_HF_CLIENT_RFC_FAIL */      bta_hf_client_rfc_fail,
@@ -136,7 +138,7 @@ const UINT8 bta_hf_client_st_init[][BTA_HF_CLIENT_NUM_COLS] =
 /* RFC_CLOSE_EVT */         {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
 /* RFC_SRV_CLOSE_EVT */     {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
 /* RFC_DATA_EVT */          {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
-/* DISC_ACP_RES_EVT */      {BTA_HF_CLIENT_FREE_DB,        BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
+/* DISC_ACP_RES_EVT */      {BTA_HF_CLIENT_FREE_DB_ACP,    BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
 /* DISC_INT_RES_EVT */      {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
 /* DISC_OK_EVT */           {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
 /* DISC_FAIL_EVT */         {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
@@ -205,8 +207,8 @@ const UINT8 bta_hf_client_st_closing[][BTA_HF_CLIENT_NUM_COLS] =
 /* RFC_CLOSE_EVT */         {BTA_HF_CLIENT_RFC_CLOSE,      BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
 /* RFC_SRV_CLOSE_EVT */     {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_CLOSING_ST},
 /* RFC_DATA_EVT */          {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_CLOSING_ST},
-/* DISC_ACP_RES_EVT */      {BTA_HF_CLIENT_FREE_DB,        BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_CLOSING_ST},
-/* DISC_INT_RES_EVT */      {BTA_HF_CLIENT_FREE_DB,        BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
+/* DISC_ACP_RES_EVT */      {BTA_HF_CLIENT_FREE_DB_ACP,    BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_CLOSING_ST},
+/* DISC_INT_RES_EVT */      {BTA_HF_CLIENT_FREE_DB_INT,    BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_INIT_ST},
 /* DISC_OK_EVT */           {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_CLOSING_ST},
 /* DISC_FAIL_EVT */         {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_CLOSING_ST},
 /* SCO_OPEN_EVT */          {BTA_HF_CLIENT_IGNORE,         BTA_HF_CLIENT_IGNORE,          BTA_HF_CLIENT_CLOSING_ST},
@@ -346,11 +348,22 @@ void bta_hf_client_collision_cback (tBTA_SYS_CONN_STATUS status, UINT8 id,
 
         bta_hf_client_cb.scb.state = BTA_HF_CLIENT_INIT_ST;
 
-        /* Cancel SDP if it had been started. */
-        if(bta_hf_client_cb.scb.p_disc_db)
+        APPL_TRACE_WARNING ("%s:bta_hf_client_cb.scb.role = %d", __func__,
+                                 bta_hf_client_cb.scb.role);
+        /* Cancel SDP if it had been started for initiator. */
+        if (bta_hf_client_cb.scb.p_disc_db_int)
         {
-            (void)SDP_CancelServiceSearch (bta_hf_client_cb.scb.p_disc_db);
-            bta_hf_client_free_db(NULL);
+            APPL_TRACE_WARNING ("%s:cancel SDP serach for the HFP client initiator:", __func__);
+            (void)SDP_CancelServiceSearch (bta_hf_client_cb.scb.p_disc_db_int);
+            bta_hf_client_free_db_int(NULL);
+        }
+
+        /* Cancel SDP if it had been started for acceptor. */
+        if (bta_hf_client_cb.scb.p_disc_db_acp)
+        {
+            APPL_TRACE_WARNING ("%s:cancel SDP serach for the HFP client acceptor:", __func__);
+            (void)SDP_CancelServiceSearch (bta_hf_client_cb.scb.p_disc_db_acp);
+            bta_hf_client_free_db_acp(NULL);
         }
 
         /* reopen registered server */
diff --git a/bta/hf_client/bta_hf_client_rfc.c b/bta/hf_client/bta_hf_client_rfc.c
index dc422ae..532b852 100644
--- a/bta/hf_client/bta_hf_client_rfc.c
+++ b/bta/hf_client/bta_hf_client_rfc.c
@@ -248,11 +248,21 @@ void bta_hf_client_rfc_do_close(tBTA_HF_CLIENT_DATA *p_data)
         p_buf->hdr.event = BTA_HF_CLIENT_RFC_CLOSE_EVT;
         bta_sys_sendmsg(p_buf);
 
-        /* Cancel SDP if it had been started. */
-        if(bta_hf_client_cb.scb.p_disc_db)
+        APPL_TRACE_DEBUG("%s: bta_hf_client_cb.scb.role = %d",__func__, bta_hf_client_cb.scb.role);
+        /* Cancel SDP if it had been started for initiator. */
+        if (bta_hf_client_cb.scb.p_disc_db_int)
         {
-            (void)SDP_CancelServiceSearch (bta_hf_client_cb.scb.p_disc_db);
-            bta_hf_client_free_db(NULL);
+            APPL_TRACE_DEBUG("%s: Cancel SDP service search for the HF client initiator", __func__);
+            (void)SDP_CancelServiceSearch (bta_hf_client_cb.scb.p_disc_db_int);
+            bta_hf_client_free_db_int(NULL);
+        }
+
+        /* Cancel SDP if it had been started for acceptor. */
+        if (bta_hf_client_cb.scb.p_disc_db_acp)
+        {
+            APPL_TRACE_DEBUG("%s: Cancel SDP service search for the HF client acceptor", __func__);
+            (void)SDP_CancelServiceSearch (bta_hf_client_cb.scb.p_disc_db_acp);
+            bta_hf_client_free_db_acp(NULL);
         }
     }
 }
diff --git a/bta/hf_client/bta_hf_client_sdp.c b/bta/hf_client/bta_hf_client_sdp.c
index 822fe97..952cf7d 100644
--- a/bta/hf_client/bta_hf_client_sdp.c
+++ b/bta/hf_client/bta_hf_client_sdp.c
@@ -222,19 +222,22 @@ BOOLEAN bta_hf_client_sdp_find_attr(void)
     BOOLEAN             result = FALSE;
 
     bta_hf_client_cb.scb.peer_version = HFP_VERSION_1_1;   /* Default version */
-
+    APPL_TRACE_DEBUG("%s: bta_hf_client_cb.scb.role = %d",__func__, bta_hf_client_cb.scb.role);
     /* loop through all records we found */
     while (TRUE)
     {
         /* get next record; if none found, we're done */
-        if ((p_rec = SDP_FindServiceInDb(bta_hf_client_cb.scb.p_disc_db, UUID_SERVCLASS_AG_HANDSFREE, p_rec)) == NULL)
-        {
-            break;
-        }
-
-        /* get scn from proto desc list if initiator */
         if (bta_hf_client_cb.scb.role == BTA_HF_CLIENT_INT)
         {
+            APPL_TRACE_DEBUG("%s: find SDP services for HFP client initiator", __func__);
+            if ((p_rec = SDP_FindServiceInDb(bta_hf_client_cb.scb.p_disc_db_int,
+                                             UUID_SERVCLASS_AG_HANDSFREE, p_rec)) == NULL)
+            {
+                APPL_TRACE_DEBUG("%s:initiator p_rec is null", __func__);
+                break;
+            }
+
+            /* get scn from proto desc list if initiator */
             if (SDP_FindProtocolListElemInRec(p_rec, UUID_PROTOCOL_RFCOMM, &pe))
             {
                 bta_hf_client_cb.scb.peer_scn = (UINT8) pe.params[0];
@@ -244,6 +247,17 @@ BOOLEAN bta_hf_client_sdp_find_attr(void)
                 continue;
             }
         }
+        /* get next record; if none found, we're done */
+        if (bta_hf_client_cb.scb.role == BTA_HF_CLIENT_ACP)
+        {
+            APPL_TRACE_DEBUG("%s: find SDP services for HFP client acceptor", __func__);
+            if ((p_rec = SDP_FindServiceInDb(bta_hf_client_cb.scb.p_disc_db_acp,
+                                             UUID_SERVCLASS_AG_HANDSFREE, p_rec)) == NULL)
+            {
+                 APPL_TRACE_DEBUG("%s:acceptor p_rec is null", __func__);
+                 break;
+            }
+        }
 
         /* get profile version (if failure, version parameter is not updated) */
         SDP_FindProfileVersionInRec(p_rec, UUID_SERVCLASS_HF_HANDSFREE, &bta_hf_client_cb.scb.peer_version);
@@ -304,8 +318,10 @@ void bta_hf_client_do_disc(void)
     UINT16          num_uuid = 1;
     UINT16          attr_list[4];
     UINT8           num_attr;
-    BOOLEAN         db_inited = FALSE;
+    BOOLEAN         db_inited_int = FALSE;
+    BOOLEAN         db_inited_acp = FALSE;
 
+    APPL_TRACE_DEBUG("%s: bta_hf_client_cb.scb.role=%d",__func__, bta_hf_client_cb.scb.role);
     /* initiator; get proto list and features */
     if (bta_hf_client_cb.scb.role == BTA_HF_CLIENT_INT)
     {
@@ -315,6 +331,32 @@ void bta_hf_client_do_disc(void)
         attr_list[3] = ATTR_ID_SUPPORTED_FEATURES;
         num_attr = 4;
         uuid_list[0].uu.uuid16 = UUID_SERVCLASS_AG_HANDSFREE;
+
+        /* allocate buffer for sdp database for initiator */
+        bta_hf_client_cb.scb.p_disc_db_int =
+                       (tSDP_DISCOVERY_DB *)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
+
+        /* set up service discovery database; attr happens to be attr_list len */
+        uuid_list[0].len = LEN_UUID_16;
+        uuid_list[1].len = LEN_UUID_16;
+        db_inited_int = SDP_InitDiscoveryDb(bta_hf_client_cb.scb.p_disc_db_int,
+                                    BT_DEFAULT_BUFFER_SIZE, num_uuid,
+                                    uuid_list, num_attr, attr_list);
+        APPL_TRACE_DEBUG("%s: db_inited_int=%d",__func__, db_inited_int);
+        if (db_inited_int)
+        {
+            /*Service discovery not initiated */
+            db_inited_int = SDP_ServiceSearchAttributeRequest(bta_hf_client_cb.scb.peer_addr,
+                                bta_hf_client_cb.scb.p_disc_db_int, bta_hf_client_sdp_cback);
+        }
+
+        if (!db_inited_int)
+        {
+            /*free discover db */
+            bta_hf_client_free_db_int(NULL);
+            /* sent failed event */
+            bta_hf_client_sm_execute(BTA_HF_CLIENT_DISC_FAIL_EVT, NULL);
+        }
     }
     /* acceptor; get features */
     else
@@ -324,47 +366,64 @@ void bta_hf_client_do_disc(void)
         attr_list[2] = ATTR_ID_SUPPORTED_FEATURES;
         num_attr = 3;
         uuid_list[0].uu.uuid16 = UUID_SERVCLASS_AG_HANDSFREE;
-    }
 
-    /* allocate buffer for sdp database */
-    bta_hf_client_cb.scb.p_disc_db = (tSDP_DISCOVERY_DB *)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
+        /* allocate buffer for sdp database for acceptor */
+        bta_hf_client_cb.scb.p_disc_db_acp = (tSDP_DISCOVERY_DB *)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
 
-    /* set up service discovery database; attr happens to be attr_list len */
-    uuid_list[0].len = LEN_UUID_16;
-    uuid_list[1].len = LEN_UUID_16;
-    db_inited = SDP_InitDiscoveryDb(bta_hf_client_cb.scb.p_disc_db,
+        /* set up service discovery database; attr happens to be attr_list len */
+        uuid_list[0].len = LEN_UUID_16;
+        uuid_list[1].len = LEN_UUID_16;
+        db_inited_acp = SDP_InitDiscoveryDb(bta_hf_client_cb.scb.p_disc_db_acp,
                                     BT_DEFAULT_BUFFER_SIZE, num_uuid,
                                     uuid_list, num_attr, attr_list);
+        APPL_TRACE_DEBUG("%s: db_inited_acp=%d",__func__, db_inited_acp);
+        if (db_inited_acp)
+        {
+            /*Service discovery not initiated */
+            db_inited_acp = SDP_ServiceSearchAttributeRequest(bta_hf_client_cb.scb.peer_addr,
+                                bta_hf_client_cb.scb.p_disc_db_acp, bta_hf_client_sdp_cback);
+        }
 
-    if (db_inited)
-    {
-        /*Service discovery not initiated */
-        db_inited = SDP_ServiceSearchAttributeRequest(bta_hf_client_cb.scb.peer_addr,
-                            bta_hf_client_cb.scb.p_disc_db, bta_hf_client_sdp_cback);
-    }
-
-    if (!db_inited)
-    {
-        /*free discover db */
-        bta_hf_client_free_db(NULL);
-        /* sent failed event */
-        bta_hf_client_sm_execute(BTA_HF_CLIENT_DISC_FAIL_EVT, NULL);
+        if (!db_inited_acp)
+        {
+            /*free discover db */
+            bta_hf_client_free_db_acp(NULL);
+            /* sent failed event */
+            bta_hf_client_sm_execute(BTA_HF_CLIENT_DISC_FAIL_EVT, NULL);
+        }
     }
+}
 
+/*******************************************************************************
+**
+** Function         bta_hf_client_free_db_int
+**
+** Description      Free discovery database of initiator.
+**
+**
+** Returns          void
+**
+*******************************************************************************/
+void bta_hf_client_free_db_int(tBTA_HF_CLIENT_DATA *p_data)
+{
+    UNUSED(p_data);
+    APPL_TRACE_DEBUG("%s:",__func__);
+    osi_free_and_reset((void **)&bta_hf_client_cb.scb.p_disc_db_int);
 }
 
 /*******************************************************************************
 **
-** Function         bta_hf_client_free_db
+** Function         bta_hf_client_free_db_acp
 **
-** Description      Free discovery database.
+** Description      Free discovery database of acceptor.
 **
 **
 ** Returns          void
 **
 *******************************************************************************/
-void bta_hf_client_free_db(tBTA_HF_CLIENT_DATA *p_data)
+void bta_hf_client_free_db_acp(tBTA_HF_CLIENT_DATA *p_data)
 {
     UNUSED(p_data);
-    osi_free_and_reset((void **)&bta_hf_client_cb.scb.p_disc_db);
+    APPL_TRACE_DEBUG("%s:",__func__);
+    osi_free_and_reset((void **)&bta_hf_client_cb.scb.p_disc_db_acp);
 }
diff --git a/bta/hh/bta_hh_act.c b/bta/hh/bta_hh_act.c
index 4dd3286..2237cf9 100644
--- a/bta/hh/bta_hh_act.c
+++ b/bta/hh/bta_hh_act.c
@@ -34,6 +34,7 @@
 #include "bta_hh_int.h"
 #include "bta_hh_co.h"
 #include "utl.h"
+#include "btm_ble_api.h"
 
 /*****************************************************************************
 **  Constants
@@ -495,6 +496,7 @@ void bta_hh_sdp_cmpl(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
             APPL_TRACE_DEBUG ("bta_hh_sdp_cmpl:SDP failed for  incoming conn :hndl %d",
                                 p_cb->incoming_hid_handle);
             HID_HostRemoveDev( p_cb->incoming_hid_handle);
+            GENERATE_VENDOR_LOGS();
         }
         conn_dat.status = status;
         (* bta_hh_cb.p_cback)(BTA_HH_OPEN_EVT, (tBTA_HH *)&conn_dat);
@@ -580,6 +582,8 @@ void bta_hh_open_cmpl_act(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
     conn.status = p_cb->status;
     conn.le_hid = p_cb->is_le_device;
     conn.scps_supported = p_cb->scps_supported;
+    if(p_cb->scps_supported)
+        BTA_HhUpdateLeScanParam(dev_handle,BTM_BLE_SCAN_SLOW_INT_1,BTM_BLE_SCAN_SLOW_WIN_1);
 
     if (!p_cb->is_le_device)
 #endif
@@ -602,6 +606,7 @@ void bta_hh_open_cmpl_act(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
             /* HID connection is up, while SET_PROTO fail */
             conn.status = BTA_HH_ERR_PROTO;
             (* bta_hh_cb.p_cback)(BTA_HH_OPEN_EVT, (tBTA_HH *)&conn);
+            GENERATE_VENDOR_LOGS();
         }
         else
         {
@@ -846,6 +851,7 @@ void bta_hh_open_failure(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
                                     BTA_HH_ERR_AUTH_FAILED : BTA_HH_ERR;
     bdcpy(conn_dat.bda, p_cb->addr);
     HID_HostCloseDev(p_cb->hid_handle);
+    GENERATE_VENDOR_LOGS();
 
 #if BTA_HH_DEBUG
     APPL_TRACE_DEBUG("bta_hh_open_failure: hid_handle = %d", p_cb->hid_handle);
@@ -920,6 +926,7 @@ void bta_hh_close_act (tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 
         /* Report OPEN fail event */
         (*bta_hh_cb.p_cback)(BTA_HH_OPEN_EVT, (tBTA_HH *)&conn_dat);
+        GENERATE_VENDOR_LOGS();
 
 #if BTA_HH_DEBUG
         bta_hh_trace_dev_db();
@@ -1190,7 +1197,7 @@ void bta_hh_write_dev_act(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
         }
         else if (p_data->api_sndcmd.param == BTA_HH_CTRL_SUSPEND)
         {
-			bta_sys_sco_close(BTA_ID_HH, p_cb->app_id, p_cb->addr);
+            bta_sys_sco_close(BTA_ID_HH, p_cb->app_id, p_cb->addr);
         }
         else if (p_data->api_sndcmd.param == BTA_HH_CTRL_EXIT_SUSPEND)
         {
diff --git a/bta/hh/bta_hh_le.c b/bta/hh/bta_hh_le.c
index eddc2d1..af7b74c 100644
--- a/bta/hh/bta_hh_le.c
+++ b/bta/hh/bta_hh_le.c
@@ -34,7 +34,6 @@
 #include "device/include/interop.h"
 #include "osi/include/log.h"
 #include "srvc_api.h"
-#include "stack/include/l2c_api.h"
 #include "utl.h"
 
 #ifndef BTA_HH_LE_RECONN
@@ -165,34 +164,27 @@ static void gatt_execute_next_op(UINT16 conn_id) {
     }
 
     if (op->type == GATT_READ_CHAR) {
-        const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(op->conn_id, op->handle);
-
         mark_as_executing(conn_id);
-        BTA_GATTC_ReadCharacteristic(op->conn_id, p_char->handle, BTA_GATT_AUTH_REQ_NONE);
+        BTA_GATTC_ReadCharacteristic(op->conn_id, op->handle, BTA_GATT_AUTH_REQ_NONE);
         list_remove(gatt_op_queue, op);
 
     } else if (op->type == GATT_READ_DESC) {
-        const tBTA_GATTC_DESCRIPTOR *p_desc = BTA_GATTC_GetDescriptor(op->conn_id, op->handle);
-
         mark_as_executing(conn_id);
-        BTA_GATTC_ReadCharDescr(op->conn_id, p_desc->handle, BTA_GATT_AUTH_REQ_NONE);
+        BTA_GATTC_ReadCharDescr(op->conn_id, op->handle, BTA_GATT_AUTH_REQ_NONE);
         list_remove(gatt_op_queue, op);
     } else if (op->type == GATT_WRITE_CHAR) {
-        const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(op->conn_id, op->handle);
         mark_as_executing(conn_id);
-        BTA_GATTC_WriteCharValue(op->conn_id, p_char->handle, op->write_type, op->len,
+        BTA_GATTC_WriteCharValue(op->conn_id, op->handle, op->write_type, op->len,
                                  op->p_value, BTA_GATT_AUTH_REQ_NONE);
 
         list_remove(gatt_op_queue, op);
     } else if (op->type == GATT_WRITE_DESC) {
-        const tBTA_GATTC_DESCRIPTOR *p_desc = BTA_GATTC_GetDescriptor(op->conn_id, op->handle);
-
         tBTA_GATT_UNFMT value;
         value.len = op->len;
         value.p_value = op->p_value;
 
         mark_as_executing(conn_id);
-        BTA_GATTC_WriteCharDescr(op->conn_id, p_desc->handle, BTA_GATTC_TYPE_WRITE,
+        BTA_GATTC_WriteCharDescr(op->conn_id, op->handle, BTA_GATTC_TYPE_WRITE,
                                  &value, BTA_GATT_AUTH_REQ_NONE);
         list_remove(gatt_op_queue, op);
     }
@@ -825,7 +817,7 @@ void bta_hh_le_register_input_notif(tBTA_HH_DEV_CB *p_dev_cb, UINT8 srvc_inst,
                 if (p_rpt->uuid == GATT_UUID_HID_REPORT &&
                     p_rpt->client_cfg_value == BTA_GATT_CLT_CONFIG_NOTIFICATION)
                 {
-                    APPL_TRACE_DEBUG("---> Deregister Report ID: %d", p_rpt->rpt_id);
+                    APPL_TRACE_DEBUG("%s ---> Deregister Report ID: %d", __func__, p_rpt->rpt_id);
                     BTA_GATTC_DeregisterForNotifications(bta_hh_cb.gatt_if, p_dev_cb->addr,
                                                          p_rpt->char_inst_id);
                 }
@@ -833,7 +825,7 @@ void bta_hh_le_register_input_notif(tBTA_HH_DEV_CB *p_dev_cb, UINT8 srvc_inst,
                 else if (p_rpt->uuid == GATT_UUID_HID_BT_KB_INPUT ||
                          p_rpt->uuid == GATT_UUID_HID_BT_MOUSE_INPUT)
                 {
-                    APPL_TRACE_DEBUG("<--- Register Boot Report ID: %d", p_rpt->rpt_id);
+                    APPL_TRACE_DEBUG("%s <--- Register Boot Report ID: %d", __func__, p_rpt->rpt_id);
                     BTA_GATTC_RegisterForNotifications(bta_hh_cb.gatt_if, p_dev_cb->addr,
                                                        p_rpt->char_inst_id);
                 }
@@ -845,14 +837,14 @@ void bta_hh_le_register_input_notif(tBTA_HH_DEV_CB *p_dev_cb, UINT8 srvc_inst,
                     p_rpt->client_cfg_value == BTA_GATT_CLT_CONFIG_NOTIFICATION)
                 {
 
-                    APPL_TRACE_DEBUG("---> Deregister Boot Report ID: %d", p_rpt->rpt_id);
+                    APPL_TRACE_DEBUG("%s ---> Deregister Boot Report ID: %d", __func__, p_rpt->rpt_id);
                     BTA_GATTC_DeregisterForNotifications(bta_hh_cb.gatt_if, p_dev_cb->addr,
                                                          p_rpt->char_inst_id);
                 }
                 else if (p_rpt->uuid == GATT_UUID_HID_REPORT &&
                          p_rpt->client_cfg_value == BTA_GATT_CLT_CONFIG_NOTIFICATION)
                 {
-                    APPL_TRACE_DEBUG("<--- Register Report ID: %d", p_rpt->rpt_id);
+                    APPL_TRACE_DEBUG("%s <--- Register Report ID: %d", __func__, p_rpt->rpt_id);
                     BTA_GATTC_RegisterForNotifications(bta_hh_cb.gatt_if, p_dev_cb->addr,
                                                        p_rpt->char_inst_id);
                 }
@@ -865,6 +857,42 @@ void bta_hh_le_register_input_notif(tBTA_HH_DEV_CB *p_dev_cb, UINT8 srvc_inst,
 
 /*******************************************************************************
 **
+** Function         bta_hh_le_deregister_input_notif
+**
+** Description      Deregister all notifications
+**
+*******************************************************************************/
+void bta_hh_le_deregister_input_notif(tBTA_HH_DEV_CB *p_dev_cb)
+{
+    tBTA_HH_LE_RPT  *p_rpt = &p_dev_cb->hid_srvc[0].report[0];
+    APPL_TRACE_DEBUG("%s ---> current service instance:%d", __func__, p_dev_cb->cur_srvc_index);
+
+    for (UINT8 i = 0; i < BTA_HH_LE_RPT_MAX; i++, p_rpt++)
+    {
+        if (p_rpt->rpt_type == BTA_HH_RPTT_INPUT)
+        {
+            if (p_rpt->uuid == GATT_UUID_HID_REPORT &&
+                p_rpt->client_cfg_value == BTA_GATT_CLT_CONFIG_NOTIFICATION)
+            {
+                APPL_TRACE_DEBUG("%s ---> Deregister Report ID: %d", __func__, p_rpt->rpt_id);
+                BTA_GATTC_DeregisterForNotifications(bta_hh_cb.gatt_if, p_dev_cb->addr,
+                                                    p_rpt->char_inst_id);
+            }
+            else if ((p_rpt->uuid == GATT_UUID_HID_BT_KB_INPUT ||
+                p_rpt->uuid == GATT_UUID_HID_BT_MOUSE_INPUT) &&
+                p_rpt->client_cfg_value == BTA_GATT_CLT_CONFIG_NOTIFICATION)
+            {
+                APPL_TRACE_DEBUG("%s ---> Deregister Boot Report ID: %d", __func__, p_rpt->rpt_id);
+                BTA_GATTC_DeregisterForNotifications(bta_hh_cb.gatt_if, p_dev_cb->addr,
+                                                    p_rpt->char_inst_id);
+            }
+        }
+    }
+}
+
+
+/*******************************************************************************
+**
 ** Function         bta_hh_le_open_cmpl
 **
 ** Description      HID over GATT connection sucessfully opened
@@ -956,6 +984,7 @@ BOOLEAN bta_hh_le_write_rpt_clt_cfg(tBTA_HH_DEV_CB *p_cb, UINT8 srvc_inst_id)
         p_cb->disc_active &= ~BTA_HH_LE_DISC_HIDS;
 
         bta_hh_le_open_cmpl(p_cb);
+        p_cb->cur_srvc_index = 0;
     }
     return FALSE;
 }
@@ -1629,20 +1658,6 @@ void bta_hh_le_srvc_search_cmpl(tBTA_GATTC_SEARCH_CMPL *p_data)
                if (p_dev_cb->scan_refresh_char_handle &&  p_dev_cb->scan_int_char_handle)
                    break;
             }
-        } else if (service->uuid.uu.uuid16 == UUID_SERVCLASS_GAP_SERVER) {
-            //TODO(jpawlowski): this should be done by GAP profile, remove when GAP is fixed.
-            for (list_node_t *cn = list_begin(service->characteristics);
-                 cn != list_end(service->characteristics); cn = list_next(cn)) {
-                tBTA_GATTC_CHARACTERISTIC *p_char = list_node(cn);
-                if (p_char->uuid.len == LEN_UUID_16 &&
-                    p_char->uuid.uu.uuid16 == GATT_UUID_GAP_PREF_CONN_PARAM) {
-
-                    /* read the char value */
-                    gatt_queue_read_op(GATT_READ_CHAR, p_dev_cb->conn_id, p_char->handle);
-
-                    break;
-                }
-            }
         }
     }
 
@@ -1719,6 +1734,12 @@ void bta_hh_le_proc_get_rpt_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_GATTC_READ *p_da
     const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(p_dev_cb->conn_id,
                                                                           p_data->handle);
 
+    if (p_char == NULL) {
+        APPL_TRACE_ERROR("%s: report cmpl for Unknown Characteristic,handle: 0x%04x",
+            __func__, p_data->handle);
+        return;
+    }
+
     memset(&hs_data, 0, sizeof(hs_data));
     hs_data.status  = BTA_HH_ERR;
     hs_data.handle  = p_dev_cb->hid_handle;
@@ -1805,44 +1826,20 @@ void bta_hh_w4_le_read_char_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 {
     tBTA_GATTC_READ     * p_data = (tBTA_GATTC_READ *)p_buf;
     UINT8               *pp ;
-    BD_NAME             bdname;
 
     const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(p_dev_cb->conn_id,
                                                                           p_data->handle);
+    if (p_char == NULL) {
+        APPL_TRACE_ERROR("%s: p_char is NULL %d", __func__, p_data->handle);
+        return;
+    }
+
     UINT16 char_uuid = p_char->uuid.uu.uuid16;
 
     if (char_uuid == GATT_UUID_BATTERY_LEVEL)
     {
         bta_hh_read_battery_level_cmpl(p_data->status, p_dev_cb, p_data);
     }
-    else if (char_uuid == GATT_UUID_GAP_PREF_CONN_PARAM)
-    {
-        //TODO(jpawlowski): this should be done by GAP profile, remove when GAP is fixed.
-        UINT8 *pp = p_data->p_value->p_value;
-        UINT16 min, max, latency, tout;
-        STREAM_TO_UINT16 (min, pp);
-        STREAM_TO_UINT16 (max, pp);
-        STREAM_TO_UINT16 (latency, pp);
-        STREAM_TO_UINT16 (tout, pp);
-
-        // Make sure both min, and max are bigger than 11.25ms, lower values can introduce
-        // audio issues if A2DP is also active.
-        if (min < BTM_BLE_CONN_INT_MIN_LIMIT)
-            min = BTM_BLE_CONN_INT_MIN_LIMIT;
-        if (max < BTM_BLE_CONN_INT_MIN_LIMIT)
-            max = BTM_BLE_CONN_INT_MIN_LIMIT;
-
-        if (tout < BTM_BLE_CONN_TIMEOUT_MIN_DEF)
-            tout = BTM_BLE_CONN_TIMEOUT_MIN_DEF;
-
-        BTM_BleSetPrefConnParams (p_dev_cb->addr, min, max, latency, tout);
-
-        if (!BTM_GetRemoteDeviceName(p_dev_cb->addr, bdname) || !*bdname ||
-        (!interop_match_name(INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS, (const char*) bdname)))
-        {
-            L2CA_UpdateBleConnParams(p_dev_cb->addr, min, max, latency, tout);
-        }
-    }
     else
     {
         if (p_data->status == BTA_GATT_OK && p_data->p_value)
@@ -1898,6 +1895,11 @@ void bta_hh_le_read_char_cmpl (tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 
     const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(p_dev_cb->conn_id,
                                                                           p_data->handle);
+    if (p_char == NULL) {
+        APPL_TRACE_ERROR("%s: p_char is NULL %d", __func__, p_data->handle);
+        return;
+    }
+
     UINT16 char_uuid = p_char->uuid.uu.uuid16;
 
     switch (char_uuid)
@@ -1938,6 +1940,10 @@ void bta_hh_le_read_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
     UINT8   *pp;
 
     const tBTA_GATTC_DESCRIPTOR *p_desc = BTA_GATTC_GetDescriptor(p_data->conn_id, p_data->handle);
+    if (p_desc == NULL) {
+        APPL_TRACE_ERROR("%s: p_descr is NULL %d", __func__, p_data->handle);
+        return;
+    }
 
     /* if a report client configuration */
     if (p_desc->uuid.uu.uuid16 == GATT_UUID_CHAR_CLIENT_CONFIG)
@@ -1974,7 +1980,6 @@ void bta_hh_w4_le_read_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
         return;
 
     const tBTA_GATTC_DESCRIPTOR *p_desc = BTA_GATTC_GetDescriptor(p_data->conn_id, p_data->handle);
-
     if (p_desc == NULL) {
         APPL_TRACE_ERROR("%s: p_descr is NULL %d", __func__, p_data->handle);
         return;
@@ -2034,6 +2039,11 @@ void bta_hh_w4_le_write_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 
     const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(p_dev_cb->conn_id,
                                                                           p_data->handle);
+    if (p_char == NULL) {
+        APPL_TRACE_ERROR("%s: write cmpl for Unknown Characteristic,handle: 0x%04x",
+            __func__, p_data->handle);
+        return;
+    }
 
     if (p_char->uuid.uu.uuid16 == GATT_UUID_HID_PROTO_MODE)
     {
@@ -2065,6 +2075,12 @@ void bta_hh_le_write_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
     const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(p_dev_cb->conn_id,
                                                                           p_data->handle);
 
+    if (p_char == NULL) {
+        APPL_TRACE_ERROR("%s: write cmpl for Unknown Characteristic,handle: 0x%04x",
+            __func__, p_data->handle);
+        return;
+    }
+
 #if BTA_HH_DEBUG
     APPL_TRACE_DEBUG("bta_hh_le_write_cmpl w4_evt: %d", p_dev_cb->w4_evt);
 #endif
@@ -2185,13 +2201,25 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
 
     if (p_dev_cb == NULL)
     {
-        APPL_TRACE_ERROR("notification received from Unknown device");
+        APPL_TRACE_ERROR("%s: notification received from Unknown device, conn_id: 0x%04x",
+            __func__, p_data->conn_id);
         return;
     }
 
     const tBTA_GATTC_CHARACTERISTIC *p_char = BTA_GATTC_GetCharacteristic(p_dev_cb->conn_id,
                                                                           p_data->handle);
+    if (p_char == NULL)
+    {
+        APPL_TRACE_ERROR("%s: notification received for Unknown Characteristic, conn_id: 0x%04x, handle: 0x%04x",
+            __func__, p_dev_cb->conn_id, p_data->handle);
+        return;
+    }
 
+    if (p_char == NULL) {
+        APPL_TRACE_ERROR("%s: notification received for Unknown Characteristic,handle: 0x%04x",
+            __func__, p_data->handle);
+        return;
+    }
     app_id= p_dev_cb->app_id;
 
     if (p_char->uuid.uu.uuid16 == GATT_UUID_SCAN_REFRESH) {
@@ -2206,7 +2234,8 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
                                         p_char->handle);
     if (p_rpt == NULL)
     {
-        APPL_TRACE_ERROR("notification received for Unknown Report");
+        APPL_TRACE_ERROR("%s: notification received for Unknown Report, uuid: 0x%04x, handle: 0x%04x",
+            __func__, p_char->uuid.uu.uuid16, p_char->handle);
         return;
     }
 
@@ -2291,6 +2320,8 @@ void bta_hh_gatt_close(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 {
     tBTA_HH_CBDATA          disc_dat = {BTA_HH_OK, 0};
 
+    /* deregister all notification */
+    bta_hh_le_deregister_input_notif(p_cb);
     /* finaliza device driver */
     bta_hh_co_close(p_cb->hid_handle, p_cb->app_id);
     /* update total conn number */
diff --git a/bta/hh/bta_hh_utils.c b/bta/hh/bta_hh_utils.c
index 8bfed31..695ddad 100644
--- a/bta/hh/bta_hh_utils.c
+++ b/bta/hh/bta_hh_utils.c
@@ -22,6 +22,8 @@
 
 
 #include "bta_hh_int.h"
+#include "device/include/interop.h"
+#include "device/include/interop_config.h"
 
 /* if SSR max latency is not defined by remote device, set the default value
    as half of the link supervision timeout */
@@ -49,20 +51,6 @@ static const UINT8 bta_hh_mod_key_mask[BTA_HH_MOD_MAX_KEY] =
     BTA_HH_KB_GUI_MASK
 };
 
-/* hid_blacklist_addr_prefix_for_ssr & hid_ssr_max_lat_list_for_iot are used
-   to fix IOP issues of sniff subrate feature */
-static const UINT8 hid_blacklist_addr_prefix_for_ssr[][3] = {
-    {0x00, 0x1B, 0xDC} // ISSC
-    ,{0xdc, 0x2c, 0x26} // BORND
-    ,{0x54, 0x46, 0x6B} // JW MT002
-};
-
-static const UINT16 hid_ssr_max_lat_list_for_iot[] = {
-    0x0012 // ISSC
-    ,BTA_HH_SSR_MAX_LATENCY_ZERO // BORND
-    ,BTA_HH_SSR_DISABLE_SSR // JW MT002
-};
-
 
 /*******************************************************************************
 **      Function       blacklist_adjust_sniff_subrate
@@ -75,17 +63,12 @@ static const UINT16 hid_ssr_max_lat_list_for_iot[] = {
 static void blacklist_adjust_sniff_subrate(BD_ADDR peer_dev, UINT16 *ssr_max_lat)
 {
     UINT16 old_ssr_max_lat = *ssr_max_lat;
-    const int blacklist_size =
-            sizeof(hid_blacklist_addr_prefix_for_ssr)/sizeof(hid_blacklist_addr_prefix_for_ssr[0]);
-    for (int i = 0; i < blacklist_size; i++) {
-        if (hid_blacklist_addr_prefix_for_ssr[i][0] == peer_dev[0] &&
-            hid_blacklist_addr_prefix_for_ssr[i][1] == peer_dev[1] &&
-            hid_blacklist_addr_prefix_for_ssr[i][2] == peer_dev[2]) {
-            *ssr_max_lat = hid_ssr_max_lat_list_for_iot[i];
-            APPL_TRACE_WARNING("%s: Device in blacklist for ssr, max latency changed "
-                "from %d to %d", __func__, old_ssr_max_lat, *ssr_max_lat);
-            return;
-        }
+    bt_bdaddr_t remote_bdaddr;
+    bdcpy(remote_bdaddr.address, peer_dev);
+    if (interop_match_addr_get_max_lat(INTEROP_UPDATE_HID_SSR_MAX_LAT, &remote_bdaddr,
+        ssr_max_lat)) {
+        APPL_TRACE_WARNING("%s: Device in blacklist for ssr, max latency changed "
+            "from %d to %d", __func__, old_ssr_max_lat, *ssr_max_lat);
     }
 }
 
@@ -227,7 +210,8 @@ void bta_hh_add_device_to_list(tBTA_HH_DEV_CB *p_cb, UINT8 handle,
                                UINT8 app_id)
 {
 #if BTA_HH_DEBUG
-    APPL_TRACE_DEBUG("subclass = 0x%2x", sub_class);
+    APPL_TRACE_DEBUG("subclass = 0x%2x, maxlat = 0x%2x, minto = 0x%2x",
+                     sub_class, ssr_max_latency, ssr_min_tout);
 #endif
 
     p_cb->hid_handle = handle;
@@ -282,7 +266,7 @@ BOOLEAN bta_hh_tod_spt(tBTA_HH_DEV_CB *p_cb,UINT8 sub_class)
         }
     }
 #if BTA_HH_DEBUG
-            APPL_TRACE_EVENT("bta_hh_tod_spt sub_class:0x%x NOT supported", sub_class);
+    APPL_TRACE_ERROR("bta_hh_tod_spt sub_class:0x%x NOT supported", sub_class);
 #endif
     return FALSE;
 }
@@ -465,11 +449,15 @@ tBTA_HH_STATUS bta_hh_read_ssr_param(BD_ADDR bd_addr, UINT16 *p_max_ssr_lat, UIN
 
                 BTM_GetLinkSuperTout(p_cb->kdev[i].addr, &ssr_max_latency) ;
                 ssr_max_latency = BTA_HH_GET_DEF_SSR_MAX_LAT(ssr_max_latency);
+                APPL_TRACE_DEBUG("ssr_max_latency: 0x%2x", ssr_max_latency);
 
                 /* per 1.1 spec, if the newly calculated max latency is greater than
                 BTA_HH_SSR_MAX_LATENCY_DEF which is 500ms, use BTA_HH_SSR_MAX_LATENCY_DEF */
-                if (ssr_max_latency > BTA_HH_SSR_MAX_LATENCY_DEF)
+                if (ssr_max_latency > BTA_HH_SSR_MAX_LATENCY_DEF) {
                     ssr_max_latency = BTA_HH_SSR_MAX_LATENCY_DEF;
+                    APPL_TRACE_DEBUG("Updating ssr_max_latency to: 0x%2x",
+                        BTA_HH_SSR_MAX_LATENCY_DEF);
+                }
 
                 * p_max_ssr_lat  = ssr_max_latency;
             }
@@ -481,6 +469,8 @@ tBTA_HH_STATUS bta_hh_read_ssr_param(BD_ADDR bd_addr, UINT16 *p_max_ssr_lat, UIN
             else
                 * p_min_ssr_tout = p_cb->kdev[i].dscp_info.ssr_min_tout;
 
+            APPL_TRACE_DEBUG("max_lat: 0x%2x, min to: 0x%2x", * p_max_ssr_lat,
+                                * p_min_ssr_tout);
             status           = BTA_HH_OK;
 
             break;
@@ -507,7 +497,12 @@ void bta_hh_cleanup_disable(tBTA_HH_STATUS status)
     for (xx = 0; xx < BTA_HH_MAX_DEVICE; xx ++) {
         osi_free_and_reset((void **)&bta_hh_cb.kdev[xx].dscp_info.descriptor.dsc_list);
     }
-    osi_free_and_reset((void **)&bta_hh_cb.p_disc_db);
+
+    if (bta_hh_cb.p_disc_db) {
+        /* Cancel SDP if it had been started. */
+        (void)SDP_CancelServiceSearch (bta_hh_cb.p_disc_db);
+        osi_free_and_reset((void **)&bta_hh_cb.p_disc_db);
+    }
 
     (* bta_hh_cb.p_cback)(BTA_HH_DISABLE_EVT, (tBTA_HH *)&status);
     /* all connections are down, no waiting for diconnect */
diff --git a/bta/hl/bta_hl_sdp.c b/bta/hl/bta_hl_sdp.c
index 0d7f7be..826adcd 100644
--- a/bta/hl/bta_hl_sdp.c
+++ b/bta/hl/bta_hl_sdp.c
@@ -179,7 +179,7 @@ tBTA_HL_STATUS bta_hl_sdp_update (UINT8 app_id)
     UINT8                           data_exchange_spec = BTA_HL_SDP_IEEE_11073_20601;
     UINT8                           mcap_sup_proc = BTA_HL_MCAP_SUP_PROC_MASK;
     UINT16                          profile_uuid = UUID_SERVCLASS_HDP_PROFILE;
-    UINT16                          version = BTA_HL_VERSION_01_00;
+    UINT16                          version = BTA_HL_VERSION;
     UINT8                           num_services=1;
     tBTA_HL_APP_CB                  *p_cb = BTA_HL_GET_APP_CB_PTR(0);
     BOOLEAN                         result = TRUE;
@@ -382,7 +382,7 @@ tBTA_HL_STATUS bta_hl_sdp_register (UINT8 app_idx)
     UINT8                           data_exchange_spec = BTA_HL_SDP_IEEE_11073_20601;
     UINT8                           mcap_sup_proc = BTA_HL_MCAP_SUP_PROC_MASK;
     UINT16                          profile_uuid = UUID_SERVCLASS_HDP_PROFILE;
-    UINT16                          version = BTA_HL_VERSION_01_00;
+    UINT16                          version = BTA_HL_VERSION;
     UINT8                           num_services=1;
     tBTA_HL_APP_CB                  *p_cb = BTA_HL_GET_APP_CB_PTR(app_idx);
     BOOLEAN                         result = TRUE;
diff --git a/bta/include/bta_ag_api.h b/bta/include/bta_ag_api.h
index c45a8a3..64a6e0b 100644
--- a/bta/include/bta_ag_api.h
+++ b/bta/include/bta_ag_api.h
@@ -45,6 +45,7 @@
 #define BTA_AG_FEAT_HFIND   0x00000400   /* HF indicators */
 #define BTA_AG_FEAT_S4      0x00000800   /* ESCO S4 link setting */
 #define BTA_AG_FEAT_VOIP    0x00001000   /* VoIP call */
+
 /* Proprietary features: using 31 ~ 16 bits */
 #define BTA_AG_FEAT_BTRH    0x00010000   /* CCAP incoming call hold */
 #define BTA_AG_FEAT_UNAT    0x00020000   /* Pass unknown AT commands to application */
@@ -75,6 +76,7 @@ typedef UINT8 tBTA_AG_STATUS;
  * SCO_NO_CHANGE is used for changing sco behavior
  * They donot interfere with each other
  */
+
 #define BTA_AG_HANDLE_SCO_NO_CHANGE 0xFFFF
 
 /* AG result codes used with BTA_AgResult */
@@ -389,6 +391,7 @@ typedef void (tBTA_AG_CBACK)(tBTA_AG_EVT event, tBTA_AG *p_data);
 #define BTA_AG_BEARER_RES2          6   /* Reserved     */
 #define BTA_AG_BEARER_RES3          7   /* Reserved     */
 
+
 /* AG configuration structure */
 typedef struct
 {
diff --git a/bta/include/bta_api.h b/bta/include/bta_api.h
index a138ace..0984f2c 100644
--- a/bta/include/bta_api.h
+++ b/bta/include/bta_api.h
@@ -392,12 +392,22 @@ typedef UINT8 tBTA_BLE_ADV_TX_POWER;
 /* advertising instance parameters */
 typedef struct
 {
-    UINT16                  adv_int_min;            /* minimum adv interval */
-    UINT16                  adv_int_max;            /* maximum adv interval */
-    tBTA_BLE_ADV_EVT        adv_type;               /* adv event type */
+    UINT32                  adv_int_min;            /* minimum adv interval */
+    UINT32                  adv_int_max;            /* maximum adv interval */
+    UINT16                  adv_type;               /* adv event type */
     tBTA_BLE_ADV_CHNL_MAP   channel_map;            /* adv channel map */
     tBTA_BLE_AFP            adv_filter_policy;      /* advertising filter policy */
     tBTA_BLE_ADV_TX_POWER   tx_power;               /* adv tx power */
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    UINT8                   pri_phy;
+    UINT8                   sec_adv_max_skip;       /* max adv events skipped before AUX_ADV_IND is sent */
+    UINT8                   sec_adv_phy;            /* PHY for secondary channel */
+    UINT8                   adv_sid;
+    UINT8                   scan_req_notf_enb;      /* send scan req notifications from controller */
+    UINT16                  duration;               /* duration of adv */
+    UINT8                   max_ext_adv_evts;
+    UINT8                   frag_pref;
+#endif
 }tBTA_BLE_ADV_PARAMS;
 
 /* These are the fields returned in each device adv packet.  It
@@ -593,7 +603,9 @@ typedef UINT8 tBTA_SIG_STRENGTH_MASK;
 #define BTA_DM_HW_ERROR_EVT             26      /* BT Chip H/W error */
 #define BTA_DM_LE_FEATURES_READ         27      /* Cotroller specific LE features are read */
 #define BTA_DM_ENER_INFO_READ           28      /* Energy info read */
-typedef UINT8 tBTA_DM_SEC_EVT;
+#define BTA_DM_LE_ADV_EXT_FEATURES_READ 29
+#define BTA_DM_BLE_SC_OOB_REQ_EVT       30      /* SMP SC OOB request event */
+typedef uint8_t tBTA_DM_SEC_EVT;
 
 /* Structure associated with BTA_DM_ENABLE_EVT */
 typedef struct
@@ -614,8 +626,11 @@ typedef struct
 /* BLE related definition */
 
 #define BTA_DM_AUTH_FAIL_BASE                   (HCI_ERR_MAX_ERR + 10)
-#define BTA_DM_AUTH_CONVERT_SMP_CODE(x)        (BTA_DM_AUTH_FAIL_BASE + (x))
-#define BTA_DM_AUTH_SMP_PASSKEY_FAIL             BTA_DM_AUTH_CONVERT_SMP_CODE (SMP_PASSKEY_ENTRY_FAIL)
+
+/* Converts SMP error codes defined in smp_api.h to SMP auth fail reasons below. */
+#define BTA_DM_AUTH_CONVERT_SMP_CODE(x)         (BTA_DM_AUTH_FAIL_BASE + (x))
+
+#define BTA_DM_AUTH_SMP_PASSKEY_FAIL            (BTA_DM_AUTH_FAIL_BASE + SMP_PASSKEY_ENTRY_FAIL)
 #define BTA_DM_AUTH_SMP_OOB_FAIL                (BTA_DM_AUTH_FAIL_BASE + SMP_OOB_FAIL)
 #define BTA_DM_AUTH_SMP_PAIR_AUTH_FAIL          (BTA_DM_AUTH_FAIL_BASE + SMP_PAIR_AUTH_FAIL)
 #define BTA_DM_AUTH_SMP_CONFIRM_VALUE_FAIL      (BTA_DM_AUTH_FAIL_BASE + SMP_CONFIRM_VALUE_ERR)
@@ -632,6 +647,7 @@ typedef struct
 #define BTA_DM_AUTH_SMP_BUSY                    (BTA_DM_AUTH_FAIL_BASE + SMP_BUSY)
 #define BTA_DM_AUTH_SMP_ENC_FAIL                (BTA_DM_AUTH_FAIL_BASE + SMP_ENC_FAIL)
 #define BTA_DM_AUTH_SMP_RSP_TIMEOUT             (BTA_DM_AUTH_FAIL_BASE + SMP_RSP_TIMEOUT)
+#define BTA_DM_AUTH_SMP_CONN_TOUT               (BTA_DM_AUTH_FAIL_BASE + SMP_CONN_TOUT)
 
 /* connection parameter boundary value and dummy value */
 #define BTA_DM_BLE_SCAN_INT_MIN          BTM_BLE_SCAN_INT_MIN
@@ -721,6 +737,7 @@ typedef struct
     UINT8           fail_reason;        /* The HCI reason/error code for when success=FALSE */
     tBLE_ADDR_TYPE  addr_type;          /* Peer device address type */
     tBT_DEVICE_TYPE dev_type;
+    BOOLEAN         smp_over_br;        /* SMP pairing done over BR/EDR link CID 7 */
 } tBTA_DM_AUTH_CMPL;
 
 
@@ -900,6 +917,10 @@ typedef void (tBTA_DM_SEC_CBACK)(tBTA_DM_SEC_EVT event, tBTA_DM_SEC *p_data);
 #define BTA_BLE_MULTI_ADV_DISABLE_EVT       2
 #define BTA_BLE_MULTI_ADV_PARAM_EVT         3
 #define BTA_BLE_MULTI_ADV_DATA_EVT          4
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+#define BTA_BLE_EXTENDED_ADV_ENB_EVT        5
+#define BTA_BLE_EXTENDED_ADV_PARAM_EVT      6
+#endif
 
 typedef UINT8 tBTA_BLE_MULTI_ADV_EVT;
 
@@ -996,6 +1017,7 @@ typedef struct
     BOOLEAN         is_limited;             /* TRUE, if the limited inquiry bit is set in the CoD */
     INT8            rssi;                   /* The rssi value */
     UINT8           *p_eir;                 /* received EIR */
+    UINT16          adv_data_len;
 #if (BLE_INCLUDED == TRUE)
     UINT8               inq_result_type;
     UINT8               ble_addr_type;
@@ -1227,8 +1249,8 @@ typedef UINT8 tBTA_DM_PM_ACTION;
 #endif
 
 #ifndef BTA_DM_PM_SNIFF2_MAX
-#define BTA_DM_PM_SNIFF2_MAX     180
-#define BTA_DM_PM_SNIFF2_MIN     150
+#define BTA_DM_PM_SNIFF2_MAX     54
+#define BTA_DM_PM_SNIFF2_MIN     30
 #define BTA_DM_PM_SNIFF2_ATTEMPT 4
 #define BTA_DM_PM_SNIFF2_TIMEOUT 1
 #endif
@@ -1880,8 +1902,9 @@ extern void BTA_DmSetBleConnScanParams(UINT32 scan_interval,
 ** Returns          void
 **
 *******************************************************************************/
-extern void BTA_DmSetBleScanParams(tGATT_IF client_if, UINT32 scan_interval,
-                                   UINT32 scan_window, tBLE_SCAN_MODE scan_mode,
+extern void BTA_DmSetBleScanParams(tGATT_IF client_if, UINT8 scan_phys, UINT32 scan_interval,
+                                   UINT32 scan_window, UINT16 scan_interval_coded,
+                                   UINT16 scan_window_coded, tBLE_SCAN_MODE scan_mode,
                                    tBLE_SCAN_PARAM_SETUP_CBACK scan_param_setup_status_cback);
 
 /*******************************************************************************
@@ -2003,7 +2026,7 @@ extern void BTA_DmSetEncryption(BD_ADDR bd_addr, tBTA_TRANSPORT transport,
 ** Returns          void
 **
 *******************************************************************************/
-extern void BTA_DmBleObserve(BOOLEAN start, UINT8 duration,
+extern void BTA_DmBleObserve(BOOLEAN start, UINT16 duration, UINT16 period,
                              tBTA_DM_SEARCH_CBACK *p_results_cb);
 
 
@@ -2126,7 +2149,7 @@ extern void BTA_BleUpdateAdvInstParam (UINT8 inst_id,
 **
 *******************************************************************************/
 extern void BTA_BleCfgAdvInstData (UINT8 inst_id, BOOLEAN is_scan_rsp,
-                                tBTA_BLE_AD_MASK data_mask, tBTA_BLE_ADV_DATA *p_data);
+                                tBTA_BLE_AD_MASK data_mask, UINT8 frag_pref, tBTA_BLE_ADV_DATA *p_data);
 
 /*******************************************************************************
 **
@@ -2172,6 +2195,30 @@ extern void BTA_DmBleSetDataLength(BD_ADDR remote_device, UINT16 tx_data_length)
 
 /*******************************************************************************
 **
+** Function         BTA_DmBleSetPhy
+**
+** Description      This function is to set Tx and Rx Phy for a connection
+**
+** Returns          void
+**
+*******************************************************************************/
+extern void BTA_DmBleSetPhy(BD_ADDR remote_device, UINT8 all_phy,
+                            UINT8 tx_phy, UINT8 rx_phy, UINT16 phy_options);
+
+/*******************************************************************************
+**
+** Function         BTA_DmBleSetDefaultPhy
+**
+** Description      This function is to set default Tx and Rx Phy
+**
+** Returns          void
+**
+*******************************************************************************/
+extern void BTA_DmBleSetDefaultPhy(UINT8 all_phy,
+                            UINT8 tx_phy, UINT8 rx_phy);
+
+/*******************************************************************************
+**
 ** Function         BTA_DmBleSetStorageParams
 **
 ** Description      This function is called to set the storage parameters
diff --git a/bta/include/bta_av_api.h b/bta/include/bta_av_api.h
index c79173e..7dd1e6f 100644
--- a/bta/include/bta_av_api.h
+++ b/bta/include/bta_av_api.h
@@ -269,8 +269,10 @@ typedef UINT8 tBTA_AV_ERR;
 #define BTA_AV_OFFLOAD_START_RSP_EVT 22 /* a2dp offload start response */
 #define BTA_AV_BROWSE_MSG_EVT   23      /* Browse MSG EVT */
 #define BTA_AV_ROLE_CHANGED_EVT     24
+#define BTA_AV_RC_COLL_DETECTED_EVT     25       /* RC channel collosion detected */
+
 /* Max BTA event */
-#define BTA_AV_MAX_EVT          25
+#define BTA_AV_MAX_EVT          26
 
 typedef UINT8 tBTA_AV_EVT;
 
@@ -379,6 +381,13 @@ typedef struct
     BD_ADDR         peer_addr;
 } tBTA_AV_RC_CLOSE;
 
+/* data associated with BTA_AV_RC_COLL_DETECTED */
+typedef struct
+{
+    UINT8           rc_handle;
+    BD_ADDR         peer_addr;
+} tBTA_AV_RC_COLL_DETECTED;
+
 /* data associated with BTA_AV_RC_FEAT_EVT */
 typedef struct
 {
@@ -477,6 +486,7 @@ typedef union
     tBTA_AV_PROTECT_RSP protect_rsp;
     tBTA_AV_RC_OPEN     rc_open;
     tBTA_AV_RC_CLOSE    rc_close;
+    tBTA_AV_RC_COLL_DETECTED rc_col_detected;
     tBTA_AV_REMOTE_CMD  remote_cmd;
     tBTA_AV_REMOTE_RSP  remote_rsp;
     tBTA_AV_VENDOR      vendor_cmd;
@@ -899,10 +909,10 @@ void BTA_AvOffloadStartRsp(tBTA_AV_HNDL hndl, tBTA_AV_STATUS status);
 **
 ** Description      Returns the codec_type from the most recently used scb
 **
-** Returns          A2D_NON_A2DP_MEDIA_CT or BTIF_AV_CODEC_SBC
+** Returns          Codec type corresponding to AV handle
 **
 *******************************************************************************/
-UINT8 bta_av_get_codec_type();
+UINT8 bta_av_get_codec_type(tBTA_AV_HNDL hndl);
 
 #ifdef __cplusplus
 }
diff --git a/bta/include/bta_gatt_api.h b/bta/include/bta_gatt_api.h
index 4c9f76c..b55dfc7 100644
--- a/bta/include/bta_gatt_api.h
+++ b/bta/include/bta_gatt_api.h
@@ -146,6 +146,10 @@ typedef UINT8 tBTA_GATT_STATUS;
 #define BTA_GATTC_SCAN_FLT_PARAM_EVT 32 /* Param filter event */
 #define BTA_GATTC_SCAN_FLT_STATUS_EVT 33 /* Filter status event */
 #define BTA_GATTC_ADV_VSC_EVT         34 /* ADV VSC event */
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+#define BTA_GATTC_EXTENDED_ADV_ENB_EVT  35  /* Extended Enable ADV event */
+#define BTA_GATTC_EXTENDED_ADV_UPD_EVT  36  /* Extended Update parameter event */
+#endif
 
 typedef UINT8 tBTA_GATTC_EVT;
 
diff --git a/bta/include/bta_hl_api.h b/bta/include/bta_hl_api.h
index b8e2c9a..62388be 100644
--- a/bta/include/bta_hl_api.h
+++ b/bta/include/bta_hl_api.h
@@ -89,7 +89,7 @@
 #define BTA_HL_NUM_PROTO_ELEMS          2
 #endif
 
-#define BTA_HL_VERSION_01_00            0x0100
+#define BTA_HL_VERSION                  0x0101
 #define BTA_HL_NUM_ADD_PROTO_LISTS      1
 #define BTA_HL_NUM_ADD_PROTO_ELEMS      2
 #define BTA_HL_MDEP_SEQ_SIZE            20
diff --git a/bta/include/bta_jv_api.h b/bta/include/bta_jv_api.h
index 06f4b42..9042f28 100644
--- a/bta/include/bta_jv_api.h
+++ b/bta/include/bta_jv_api.h
@@ -272,6 +272,7 @@ typedef struct
     tBTA_JV_STATUS  status;     /* Whether the operation succeeded or failed. */
     UINT32          handle;     /* The connection handle */
     BD_ADDR         rem_bda;    /* The peer address */
+    UINT16          mtu;        /* peer mtu */
 } tBTA_JV_RFCOMM_OPEN;
 /* data associated with BTA_JV_RFCOMM_SRV_OPEN_EVT */
 typedef struct
@@ -280,6 +281,7 @@ typedef struct
     UINT32          handle;             /* The connection handle */
     UINT32          new_listen_handle;  /* The new listen handle */
     BD_ADDR         rem_bda;            /* The peer address */
+    UINT16          mtu;                /* peer mtu */
 } tBTA_JV_RFCOMM_SRV_OPEN;
 
 
diff --git a/bta/jv/bta_jv_act.c b/bta/jv/bta_jv_act.c
index a1e7ad4..68dd4f9 100644
--- a/bta/jv/bta_jv_act.c
+++ b/bta/jv/bta_jv_act.c
@@ -414,12 +414,15 @@ tBTA_JV_STATUS bta_jv_free_l2c_cb(tBTA_JV_L2C_CB *p_cb)
 *******************************************************************************/
 static void bta_jv_clear_pm_cb(tBTA_JV_PM_CB *p_pm_cb, BOOLEAN close_conn)
 {
+    /* Ensure that timer is stopped */
+    alarm_cancel(p_pm_cb->idle_timer);
+
     /* needs to be called if registered with bta pm, otherwise we may run out of dm pm slots! */
     if (close_conn)
         bta_sys_conn_close(BTA_ID_JV, p_pm_cb->app_id, p_pm_cb->peer_bd_addr);
+    else
+        bta_jv_pm_state_change(p_pm_cb, BTA_JV_CONN_IDLE);
 
-    /* Ensure that timer is stopped */
-    alarm_cancel(p_pm_cb->idle_timer);
     p_pm_cb->state = BTA_JV_PM_FREE_ST;
     p_pm_cb->app_id = BTA_JV_PM_ALL;
     p_pm_cb->handle = BTA_JV_PM_HANDLE_CLEAR;
@@ -460,10 +463,6 @@ static tBTA_JV_STATUS bta_jv_free_set_pm_profile_cb(UINT32 jv_handle)
                     "app_id: 0x%x",__func__, jv_handle, i, bta_jv_cb.pm_cb[i].app_id);
             APPL_TRACE_API("%s, bd_counter = %d, "
                     "appid_counter = %d", __func__, bd_counter, appid_counter);
-            if (bd_counter > 1)
-            {
-                bta_jv_pm_conn_idle(&bta_jv_cb.pm_cb[i]);
-            }
 
             if (bd_counter <= 1 || (appid_counter <= 1))
             {
@@ -1033,6 +1032,10 @@ static void bta_jv_l2cap_client_cback(UINT16 gap_handle, UINT16 event)
         bta_jv_pm_conn_idle(p_cb->p_pm_cb);
         break;
 
+    case GAP_EVT_TX_DONE:
+        bta_jv_pm_conn_idle(p_cb->p_pm_cb);
+        break;
+
     case GAP_EVT_CONN_CONGESTED:
     case GAP_EVT_CONN_UNCONGESTED:
         p_cb->cong = (event == GAP_EVT_CONN_CONGESTED) ? TRUE : FALSE;
@@ -1204,6 +1207,10 @@ static void bta_jv_l2cap_server_cback(UINT16 gap_handle, UINT16 event)
         bta_jv_pm_conn_idle(p_cb->p_pm_cb);
         break;
 
+    case GAP_EVT_TX_DONE:
+        bta_jv_pm_conn_idle(p_cb->p_pm_cb);
+        break;
+
     case GAP_EVT_CONN_CONGESTED:
     case GAP_EVT_CONN_UNCONGESTED:
         p_cb->cong = (event == GAP_EVT_CONN_CONGESTED) ? TRUE : FALSE;
@@ -1507,6 +1514,7 @@ static void bta_jv_port_mgmt_cl_cback(UINT32 code, UINT16 port_handle)
         evt_data.rfc_open.handle = p_cb->handle;
         evt_data.rfc_open.status = BTA_JV_SUCCESS;
         bdcpy(evt_data.rfc_open.rem_bda, rem_bda);
+        evt_data.rfc_open.mtu = PORT_GetRemoteMtu(port_handle);
         p_pcb->state = BTA_JV_ST_CL_OPEN;
         p_cb->p_cback(BTA_JV_RFCOMM_OPEN_EVT, &evt_data, p_pcb->user_data);
     }
@@ -1746,6 +1754,7 @@ static void bta_jv_port_mgmt_sr_cback(UINT32 code, UINT16 port_handle)
         evt_data.rfc_srv_open.handle = p_pcb->handle;
         evt_data.rfc_srv_open.status = BTA_JV_SUCCESS;
         bdcpy(evt_data.rfc_srv_open.rem_bda, rem_bda);
+        evt_data.rfc_srv_open.mtu = PORT_GetRemoteMtu(port_handle);
         tBTA_JV_PCB *p_pcb_new_listen  = bta_jv_add_rfc_port(p_cb, p_pcb);
         if (p_pcb_new_listen)
         {
diff --git a/btif/Android.mk b/btif/Android.mk
index 7f82854..cea6e80 100644
--- a/btif/Android.mk
+++ b/btif/Android.mk
@@ -23,7 +23,8 @@ LOCAL_PATH := $(call my-dir)
 
 # HAL layer
 btifCommonSrc := \
-  src/bluetooth.c
+  src/bluetooth.c \
+  ../EventLogTags.logtags
 
 # BTIF implementation
 btifCommonSrc += \
@@ -35,6 +36,7 @@ btifCommonSrc += \
   src/btif_debug.c \
   src/btif_debug_btsnoop.c \
   src/btif_debug_conn.c \
+  src/btif_debug_l2c.c \
   src/btif_dm.c \
   src/btif_gatt.c \
   src/btif_gatt_client.c \
@@ -120,10 +122,12 @@ btifCommonIncludes := \
 
 ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
 btifCommonIncludes += \
-   vendor/qcom/opensource/bluetooth/hal/include
+   vendor/qcom/opensource/bluetooth/hal/include \
+   vendor/qcom/opensource/bluetooth/system_bt_ext
 else
 btifCommonIncludes += \
-   device/qcom/msm8909w/opensource/bluetooth/hal/include
+   device/qcom/msm8909w/opensource/bluetooth/hal/include \
+   device/qcom/msm8909w/opensource/bluetooth/system_bt_ext
 endif
 
 # libbtif static library for target
@@ -150,7 +154,7 @@ include $(CLEAR_VARS)
 LOCAL_C_INCLUDES := $(btifCommonIncludes)
 LOCAL_SRC_FILES := $(btifTestSrc)
 LOCAL_SHARED_LIBRARIES += liblog libhardware libhardware_legacy libcutils
-LOCAL_STATIC_LIBRARIES += libbtcore libbtif libosi
+LOCAL_STATIC_LIBRARIES += libbtcore libbtif libosi libbtdevice
 LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE := net_test_btif
 
diff --git a/btif/co/bta_av_co.c b/btif/co/bta_av_co.c
index cdf4690..e6f480f 100644
--- a/btif/co/bta_av_co.c
+++ b/btif/co/bta_av_co.c
@@ -27,7 +27,7 @@
  *  BTIF.
  *
  ******************************************************************************/
-
+#include <cutils/properties.h>
 #include "string.h"
 #include "a2d_api.h"
 #include "a2d_sbc.h"
@@ -43,6 +43,7 @@
 #include "btif_av_co.h"
 #include "btif_util.h"
 #include "osi/include/mutex.h"
+#include "device/include/interop.h"
 
 #include "bt_utils.h"
 #include "a2d_aptx.h"
@@ -203,14 +204,14 @@ const tA2D_APTX_HD_CIE btif_av_aptx_hd_default_config =
 #if defined(AAC_ENCODER_INCLUDED) && (AAC_ENCODER_INCLUDED == TRUE)
 const tA2D_AAC_CIE bta_av_co_aac_caps =
 {
-    (A2D_AAC_IE_OBJ_TYPE_MPEG_2_AAC_LC|A2D_AAC_IE_OBJ_TYPE_MPEG_4_AAC_LC), /* obj type */
+    (A2D_AAC_IE_OBJ_TYPE_MPEG_2_AAC_LC), /* obj type */
 #ifndef BTA_AV_SPLIT_A2DP_DEF_FREQ_48KHZ
     (A2D_AAC_IE_SAMP_FREQ_44100),
 #else
-    (A2D_AAC_IE_SAMP_FREQ_44100 | A2D_AAC_IE_SAMP_FREQ_48000),
+    (A2D_AAC_IE_SAMP_FREQ_48000),
 #endif
     (A2D_AAC_IE_CHANNELS_1 | A2D_AAC_IE_CHANNELS_2 ), /* channels  */
-    A2D_AAC_IE_BIT_RATE, /* BIT RATE */
+    BTIF_AAC_DEFAULT_BIT_RATE,      /* bit rate */
     A2D_AAC_IE_VBR_NOT_SUPP  /* variable bit rate */
 };
 
@@ -301,7 +302,7 @@ static BOOLEAN bta_av_co_audio_codec_build_config(const UINT8 *p_codec_caps, UIN
 static void bta_av_co_audio_peer_reset_config(tBTA_AV_CO_PEER *p_peer);
 static BOOLEAN bta_av_co_cp_is_scmst(const UINT8 *p_protectinfo);
 static BOOLEAN bta_av_co_audio_sink_has_scmst(const tBTA_AV_CO_SINK *p_sink);
-static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_snk_index);
+static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_snk_index, UINT8 *p_codec_type);
 static BOOLEAN bta_av_co_audio_media_supports_config(UINT8 codec_type, const UINT8 *p_codec_cfg);
 static BOOLEAN bta_av_co_audio_sink_supports_config(UINT8 codec_type, const UINT8 *p_codec_cfg);
 static BOOLEAN bta_av_co_audio_peer_src_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_src_index);
@@ -849,7 +850,7 @@ UINT8 bta_av_co_audio_getconfig(tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type,
         mutex_global_lock();
 
         /* Find a sink that matches the codec config */
-        if (bta_av_co_audio_peer_supports_codec(p_peer, &index))
+        if (bta_av_co_audio_peer_supports_codec(p_peer, &index, NULL))
         {
             /* stop fetching caps once we retrieved a supported codec */
             if (p_peer->acp)
@@ -1011,7 +1012,7 @@ void bta_av_co_audio_setconfig(tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type,
             switch (codec_type)
             {
             case BTIF_AV_CODEC_SBC:
-                if ((codec_type != BTA_AV_CODEC_SBC) || memcmp(p_codec_info, bta_av_co_cb.codec_cfg->info, 5))
+                if ((codec_type != BTA_AV_CODEC_SBC) || memcmp(p_codec_info, bta_av_co_cb.codec_cfg_sbc.info, 5))
                 {
                     recfg_needed = TRUE;
                 }
@@ -1050,10 +1051,12 @@ void bta_av_co_audio_setconfig(tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type,
                 APPL_TRACE_DEBUG("%s codecId = %d", __func__, codecId);
                 APPL_TRACE_DEBUG("%s vendorId = %x", __func__, vendorId);
 
-                if ((codec_type != A2D_NON_A2DP_MEDIA_CT) ||
-                    (codecId != A2D_APTX_CODEC_ID_BLUETOOTH) ||
-                    (vendorId != A2D_APTX_VENDOR_ID) ||
-                    memcmp(p_codec_info, bta_av_co_cb.codec_cfg_aptx.info, 5))
+                if ( (codec_type != A2D_NON_A2DP_MEDIA_CT) ||
+                    ( (codecId != A2D_APTX_CODEC_ID_BLUETOOTH) &&
+                    (codecId != A2D_APTX_HD_CODEC_ID_BLUETOOTH) )
+                    || ((vendorId != A2D_APTX_VENDOR_ID) && (vendorId != A2D_APTX_HD_VENDOR_ID)) ||
+                    (memcmp(p_codec_info, bta_av_co_cb.codec_cfg_aptx.info, 5) &&
+                     memcmp(p_codec_info, bta_av_co_cb.codec_cfg_aptx_hd.info, 5)) )
                 {
                     APPL_TRACE_DEBUG("%s recfg_needed", __func__);
                     recfg_needed = TRUE;
@@ -1080,6 +1083,23 @@ void bta_av_co_audio_setconfig(tBTA_AV_HNDL hndl, tBTA_AV_CODEC codec_type,
 #if defined(AAC_ENCODER_INCLUDED) && (AAC_ENCODER_INCLUDED == TRUE)
             case BTA_AV_CODEC_M24:
             {
+                tA2D_AAC_CIE p_aac_cie;
+                A2D_ParsAacInfo(&p_aac_cie, p_codec_info, FALSE);
+                APPL_TRACE_ERROR("%s p_aac_cie->bitrate = %x",__func__, p_aac_cie.bit_rate);
+                if ((codec_type != BTA_AV_CODEC_M24) ||
+                        memcmp(p_codec_info, bta_av_co_cb.codec_cfg_aac.info, 5))
+                {
+                    recfg_needed = TRUE;
+                }
+                else if (p_aac_cie.bit_rate == 0 || p_aac_cie.bit_rate < BTIF_AAC_MIN_BITRATE)
+                {
+                    recfg_needed = TRUE;
+                }
+                else if ((num_protect == 1) && (!bta_av_co_cb.cp.active))
+                {
+                    recfg_needed = TRUE;
+                }
+
                 APPL_TRACE_DEBUG("%s AAC", __func__);
                 bta_av_co_cb.codec_cfg_aac_setconfig.id = BTIF_AV_CODEC_M24;
                 memcpy(bta_av_co_cb.codec_cfg_aac_setconfig.info, p_codec_info, AVDT_CODEC_SIZE);
@@ -1357,6 +1377,8 @@ void bta_av_co_audio_delay(tBTA_AV_HNDL hndl, UINT16 delay)
 static BOOLEAN bta_av_co_audio_codec_build_config(const UINT8 *p_codec_caps, UINT8 *p_codec_cfg)
 {
     FUNC_TRACE();
+    tA2D_AAC_CIE peer_aac_cfg;
+    tA2D_AAC_CIE aac_cfg_selected;
 
     memset(p_codec_cfg, 0, AVDT_CODEC_SIZE);
 
@@ -1380,6 +1402,19 @@ static BOOLEAN bta_av_co_audio_codec_build_config(const UINT8 *p_codec_caps, UIN
     case BTIF_AV_CODEC_M24:
         /*  only copy the relevant portions for this codec to avoid issues when
             comparing codec configs covering larger codec sets than SBC (7 bytes) */
+        A2D_ParsAacInfo (&peer_aac_cfg ,(UINT8*)p_codec_caps, FALSE);
+        A2D_ParsAacInfo (&aac_cfg_selected ,bta_av_co_cb.codec_cfg->info, FALSE);
+
+        if (peer_aac_cfg.bit_rate != 0 && peer_aac_cfg.bit_rate >= BTIF_AAC_MIN_BITRATE)
+        {
+            aac_cfg_selected.bit_rate =
+                            BTA_AV_CO_MIN(peer_aac_cfg.bit_rate,
+                                          aac_cfg_selected.bit_rate);
+            //update with new value
+            A2D_BldAacInfo (AVDT_MEDIA_AUDIO, &aac_cfg_selected, bta_av_co_cb.codec_cfg->info);
+        }
+        APPL_TRACE_EVENT("%s AAC bitrate selected %d", __func__,
+                                      aac_cfg_selected.bit_rate);
         memcpy(p_codec_cfg, bta_av_co_cb.codec_cfg->info, A2D_AAC_INFO_LEN+1);
         APPL_TRACE_DEBUG("%s AAC", __func__);
         break;
@@ -1684,6 +1719,26 @@ static BOOLEAN bta_av_co_audio_sink_supports_cp(const tBTA_AV_CO_SINK *p_sink)
     }
 }
 
+BOOLEAN bta_av_co_audio_is_aac_enabled(bt_bdaddr_t *remote_bdaddr)
+{
+    int retval;
+    BOOLEAN res = FALSE;
+    char is_whitelist_by_default[255] = "false";
+    retval = property_get("persist.bt.a2dp.aac_whitelist", is_whitelist_by_default, "false");
+    BTIF_TRACE_DEBUG("%s: property_get: bt.a2dp.aac_whitelist: %s, retval: %d",
+                                    __func__, is_whitelist_by_default, retval);
+
+    if (!strncmp(is_whitelist_by_default, "true", 4)) {
+        if (interop_match_addr(INTEROP_ENABLE_AAC_CODEC, remote_bdaddr))
+            res = TRUE;
+    } else if (!interop_match_addr(INTEROP_DISABLE_AAC_CODEC, remote_bdaddr)) {
+            res = TRUE;
+    }
+
+    return res;
+}
+
+
 /*******************************************************************************
  **
  ** Function         bta_av_co_audio_peer_supports_codec
@@ -1693,15 +1748,24 @@ static BOOLEAN bta_av_co_audio_sink_supports_cp(const tBTA_AV_CO_SINK *p_sink)
  ** Returns          TRUE if the connection supports this codec, FALSE otherwise
  **
  *******************************************************************************/
-static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_snk_index)
+static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT8 *p_snk_index, UINT8 *p_codec_type)
 {
     int index;
     UINT8 codec_type;
+    bt_bdaddr_t remote_bdaddr;
+    bdcpy(remote_bdaddr.address, p_peer->addr);
+
     FUNC_TRACE();
 
-    /* Configure the codec type to look for */
     codec_type = bta_av_co_cb.codec_cfg->id;
 
+    /* Configure the codec type to look for */
+    if (p_codec_type != NULL)
+    {
+        APPL_TRACE_DEBUG("%s Incoming codec_type = %d", __func__, *p_codec_type);
+        APPL_TRACE_DEBUG("%s SEP codec_type = %d", __func__, codec_type);
+    }
+
 /* Check for aptX HD before aptX Classic as
  * this is order of priority, if supported return true.
  * multicast is not supported for aptX
@@ -1716,7 +1780,8 @@ static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT
         if ((bt_split_a2dp_enabled && btif_av_is_codec_offload_supported(APTXHD)) || isA2dAptXHdEnabled) {
             for (index = 0; index < p_peer->num_sup_snks; index++)
             {
-                if (p_peer->snks[index].codec_type == A2D_NON_A2DP_MEDIA_CT)
+                if (((p_codec_type != NULL) && (p_peer->snks[index].codec_type == *p_codec_type)) ||
+                    ((p_codec_type == NULL) && (p_peer->snks[index].codec_type == A2D_NON_A2DP_MEDIA_CT)))
                 {
                     aptx_capabilities = &(p_peer->snks[index].codec_caps[0]);
                     codecId = ((tA2D_APTX_HD_CIE*)aptx_capabilities)->codecId;
@@ -1750,52 +1815,56 @@ static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT
                 }
             }
         }
-
-        for (index = 0; index < p_peer->num_sup_snks; index++)
-        {
-            if (p_peer->snks[index].codec_type == A2D_NON_A2DP_MEDIA_CT)
-            {
-                aptx_capabilities = &(p_peer->snks[index].codec_caps[0]);
-                codecId = ((tA2D_APTX_CIE*)aptx_capabilities)->codecId;
-                vendorId = ((tA2D_APTX_CIE*)aptx_capabilities)->vendorId;
-                int i = 0;
-                for ( i = 0 ; i < AVDT_CODEC_SIZE; i++) {
-                    APPL_TRACE_DEBUG("%s codec_caps[%d]: %x", __func__, i, p_peer->snks[index].codec_caps[i]);
-                }
-                APPL_TRACE_DEBUG("%s codecId = %d", __func__, codecId);
-                APPL_TRACE_DEBUG("%s vendorId = %x", __func__, vendorId);
-                APPL_TRACE_DEBUG("%s p_peer->snks[index].codec_type = %x", __func__, p_peer->snks[index].codec_type );
-
-                if (codecId ==  A2D_APTX_CODEC_ID_BLUETOOTH && vendorId == A2D_APTX_VENDOR_ID)
-                {
-                    if (p_snk_index)
-                        *p_snk_index = index;
-                    APPL_TRACE_DEBUG("%s aptX", __func__);
-
-                    if (bta_av_co_audio_codec_match(p_peer->snks[index].codec_caps, A2D_NON_A2DP_MEDIA_CT))
-                    {
+        if ((bt_split_a2dp_enabled && btif_av_is_codec_offload_supported(APTX)) || isA2dAptXEnabled) {
+            for (index = 0; index < p_peer->num_sup_snks; index++)
+            {   
+                 if (((p_codec_type != NULL) && (p_peer->snks[index].codec_type == *p_codec_type)) ||
+                     ((p_codec_type == NULL) && (p_peer->snks[index].codec_type == A2D_NON_A2DP_MEDIA_CT)))
+                 {
+                     aptx_capabilities = &(p_peer->snks[index].codec_caps[0]);
+                     codecId = ((tA2D_APTX_CIE*)aptx_capabilities)->codecId;
+                     vendorId = ((tA2D_APTX_CIE*)aptx_capabilities)->vendorId;
+                     int i = 0;
+                     for ( i = 0 ; i < AVDT_CODEC_SIZE; i++) {
+                          APPL_TRACE_DEBUG("%s codec_caps[%d]: %x", __func__, i, p_peer->snks[index].codec_caps[i]);
+                     }
+                     APPL_TRACE_DEBUG("%s codecId = %d", __func__, codecId);
+                     APPL_TRACE_DEBUG("%s vendorId = %x", __func__, vendorId);
+                     APPL_TRACE_DEBUG("%s p_peer->snks[index].codec_type = %x", __func__, p_peer->snks[index].codec_type );
+
+                     if (codecId ==  A2D_APTX_CODEC_ID_BLUETOOTH && vendorId == A2D_APTX_VENDOR_ID)
+                     {
+                         if (p_snk_index)
+                             *p_snk_index = index;
+                         APPL_TRACE_DEBUG("%s aptX", __func__);
+
+                         if (bta_av_co_audio_codec_match(p_peer->snks[index].codec_caps, A2D_NON_A2DP_MEDIA_CT))
+                         {
 #if defined(BTA_AV_CO_CP_SCMS_T) && (BTA_AV_CO_CP_SCMS_T == TRUE)
-                        if (bta_av_co_audio_sink_has_scmst(&p_peer->snks[index]))
+                             if (bta_av_co_audio_sink_has_scmst(&p_peer->snks[index]))
 #endif
-                        {
-                            bta_av_co_cb.current_codec_id = bta_av_co_cb.codec_cfg_aptx.id;
-                            bta_av_co_cb.codec_cfg = &bta_av_co_cb.codec_cfg_aptx;
-                            return TRUE;
-                        }
-                    }
-                }
+                             {
+                                  bta_av_co_cb.current_codec_id = bta_av_co_cb.codec_cfg_aptx.id;
+                                  bta_av_co_cb.codec_cfg = &bta_av_co_cb.codec_cfg_aptx;
+                                  return TRUE;
+                             }
+                         }
+                     }
+                 }
             }
         }
     } else
-        APPL_TRACE_DEBUG("%s aptX is disabled", __func__);
+            APPL_TRACE_DEBUG("%s aptX is disabled", __func__);
 
 #if defined(AAC_ENCODER_INCLUDED) && (AAC_ENCODER_INCLUDED == TRUE)
-    if (bt_split_a2dp_enabled && btif_av_is_codec_offload_supported(AAC)) {
+    if (bt_split_a2dp_enabled && btif_av_is_codec_offload_supported(AAC) &&
+          bta_av_co_audio_is_aac_enabled(&remote_bdaddr)) {
         for (index = 0; index < p_peer->num_sup_snks; index++)
         {
             APPL_TRACE_DEBUG("%s AAC: index: %d, codec_type: %d", __func__, index, p_peer->snks[index].codec_type);
 
-               if (p_peer->snks[index].codec_type == bta_av_co_cb.codec_cfg_aac.id)
+               if (((p_codec_type != NULL) && (p_peer->snks[index].codec_type == *p_codec_type)) ||
+                   ((p_codec_type == NULL) && (p_peer->snks[index].codec_type == bta_av_co_cb.codec_cfg_aac.id)))
                {
                    switch (p_peer->snks[index].codec_type)
                    {
@@ -1825,14 +1894,15 @@ static BOOLEAN bta_av_co_audio_peer_supports_codec(tBTA_AV_CO_PEER *p_peer, UINT
               }
         }
     } else
-        APPL_TRACE_DEBUG("%s aptX is disabled", __func__);
+        APPL_TRACE_DEBUG("%s AAC is disabled", __func__);
 #endif
 
 
     for (index = 0; index < p_peer->num_sup_snks; index++)
     {
-        if (p_peer->snks[index].codec_type == codec_type ||
-            p_peer->snks[index].codec_type == bta_av_co_cb.codec_cfg_sbc.id)
+        if (((p_codec_type != NULL) && (p_peer->snks[index].codec_type == *p_codec_type)) ||
+            ((p_codec_type == NULL) && (p_peer->snks[index].codec_type == codec_type ||
+            p_peer->snks[index].codec_type == bta_av_co_cb.codec_cfg_sbc.id)))
         {
             switch (p_peer->snks[index].codec_type)
             {
@@ -2042,8 +2112,22 @@ BOOLEAN bta_av_co_audio_codec_supported(tBTIF_STATUS *p_status)
         p_peer = &bta_av_co_cb.peers[index];
         if (p_peer->opened)
         {
-            if (bta_av_co_audio_peer_supports_codec(p_peer, &snk_index))
+            if (bta_av_co_audio_peer_supports_codec(p_peer, &snk_index, NULL))
             {
+                APPL_TRACE_DEBUG("%s current_codec_id: %x", __func__, bta_av_co_cb.current_codec_id);
+                p_scb_codec_type = bta_av_get_codec_type(BTA_AV_CO_AUDIO_INDX_TO_HNDL(index));
+                APPL_TRACE_DEBUG("%s p_scb_codec_type: %x", __func__, p_scb_codec_type);
+                APPL_TRACE_DEBUG("%s current_sink_index: %x", __func__, snk_index);
+                if (bta_av_co_cb.current_codec_id != p_scb_codec_type)
+                {
+                    APPL_TRACE_WARNING("%s Mismatch found in selected codec and configured codec type", __func__);
+                    if (!bta_av_co_audio_peer_supports_codec(p_peer, &snk_index, &p_scb_codec_type))
+                    {
+                        APPL_TRACE_ERROR("bta_av_co_audio_codec_supported index %d doesn't support codec", index);
+                        return FALSE;
+                    }
+                    APPL_TRACE_WARNING("%s current_sink_index changed to: %x", __func__, snk_index);
+                }
                 p_sink = &p_peer->snks[snk_index];
 
                 /* Check that this sink is compatible with the CP */
@@ -2073,7 +2157,7 @@ BOOLEAN bta_av_co_audio_codec_supported(tBTIF_STATUS *p_status)
 #endif
                     APPL_TRACE_DEBUG("%s current_codec_id: %x", __func__, bta_av_co_cb.current_codec_id);
                     APPL_TRACE_DEBUG("%s p_scb_codec_type: %x", __func__, p_scb_codec_type);
-                    p_scb_codec_type = bta_av_get_codec_type();
+                    p_scb_codec_type = bta_av_get_codec_type(BTA_AV_CO_AUDIO_INDX_TO_HNDL(index));
                     APPL_TRACE_DEBUG("%s p_scb_codec_type: %x", __func__, p_scb_codec_type);
                     /* Check if this is a new configuration (new sink or new config) */
                     if ((p_sink != p_peer->p_snk) ||
@@ -2317,7 +2401,7 @@ UINT8 bta_av_select_codec(UINT8 hdl)
            line 2001.*/
         if (p_peer != NULL)
         {
-            bta_av_co_audio_peer_supports_codec(p_peer,&index);
+            bta_av_co_audio_peer_supports_codec(p_peer,&index, NULL);
         }
         return bta_av_co_cb.codec_cfg->id;
     }
@@ -2421,8 +2505,13 @@ BOOLEAN bta_av_co_audio_get_codec_config(UINT8 *p_config, UINT16 *p_minmtu, UINT
                     sbc_config->max_bitpool =
                         BTA_AV_CO_MIN(p_sink->codec_caps[BTA_AV_CO_SBC_MAX_BITPOOL_OFF],
                                       sbc_config->max_bitpool);
-                    APPL_TRACE_EVENT("%s sink bitpool min %d, max %d", __func__,
-                                      sbc_config->min_bitpool, sbc_config->max_bitpool);
+                    APPL_TRACE_EVENT("%s actual sink bitpool min %d, max %d", __func__,
+                                  sbc_config->min_bitpool, sbc_config->max_bitpool);
+                    if(sbc_config->min_bitpool > sbc_config->max_bitpool) {
+                        sbc_config->max_bitpool = sbc_config->min_bitpool;
+                        APPL_TRACE_EVENT("%s changed sink bitpool min %d, max %d", __func__,
+                                          sbc_config->min_bitpool, sbc_config->max_bitpool);
+                    }
                     break;
                 }
             }
@@ -2483,8 +2572,13 @@ BOOLEAN bta_av_co_audio_get_sbc_config(tA2D_SBC_CIE *p_sbc_config, UINT16 *p_min
                             p_sbc_config->max_bitpool =
                                BTA_AV_CO_MIN(p_sink->codec_caps[BTA_AV_CO_SBC_MAX_BITPOOL_OFF],
                                              p_sbc_config->max_bitpool);
-                            APPL_TRACE_EVENT("bta_av_co_audio_get_sbc_config : sink bitpool min %d, max %d",
-                                 p_sbc_config->min_bitpool, p_sbc_config->max_bitpool);
+                            APPL_TRACE_EVENT("%s: actual sink bitpool min %d, max %d", __func__,
+                                  p_sbc_config->min_bitpool, p_sbc_config->max_bitpool);
+                            if(p_sbc_config->min_bitpool > p_sbc_config->max_bitpool) {
+                                p_sbc_config->max_bitpool = p_sbc_config->min_bitpool;
+                                APPL_TRACE_EVENT("%s: updated sink bitpool min %d, max %d", __func__,
+                                                  p_sbc_config->min_bitpool, p_sbc_config->max_bitpool);
+                            }
                             break;
                         }
                     }
diff --git a/btif/co/bta_dm_co.c b/btif/co/bta_dm_co.c
index 9d6fc80..5c3b0a3 100644
--- a/btif/co/bta_dm_co.c
+++ b/btif/co/bta_dm_co.c
@@ -24,6 +24,9 @@
 #include "bta_dm_ci.h"
 #include "bt_utils.h"
 #include "btif_dm.h"
+#if (defined WEAR_LE_IO_CAP_OVERRIDE && WEAR_LE_IO_CAP_OVERRIDE == TRUE)
+#include "btif_storage.h"
+#endif
 #if (defined BLE_INCLUDED && BLE_INCLUDED == TRUE)
 #include "bte_appl.h"
 
@@ -408,7 +411,24 @@ void bta_dm_co_ble_io_req(BD_ADDR bd_addr,  tBTA_IO_CAP *p_io_cap,
                           tBTA_LE_KEY_TYPE  *p_resp_key )
 {
     UNUSED(bd_addr);
-    /* Retrieve the properties from file system if possible */
+
+
+#if (defined WEAR_LE_IO_CAP_OVERRIDE && WEAR_LE_IO_CAP_OVERRIDE == TRUE)
+    /*
+     * Note: This is a Wear-specific feature for iOS pairing.
+     *
+     * Set WearLeIoCap config to force local IO capability to be BTM_IO_CAP_NONE
+     * (No input, no output) for the first bond creation, that indirectly
+     * triggers Just Works pairing.
+     */
+    if (btif_storage_get_num_bonded_devices() == 0)
+        bte_appl_cfg.ble_io_cap = BTM_IO_CAP_NONE;
+#endif
+
+    /* For certification testing purpose, LE IO capability can also be specified with
+     * "PTS_SmpOptions" in the BT stack configuration file (i.e. bt_stack.conf).
+     * Note that if "PTS_SmpOptions" is set, it could override IO capability set above.
+     */
     tBTE_APPL_CFG nv_config;
     if(btif_dm_get_smp_config(&nv_config))
         bte_appl_cfg = nv_config;
diff --git a/btif/co/bta_hh_co.c b/btif/co/bta_hh_co.c
index cc8797e..344f4ac 100644
--- a/btif/co/bta_hh_co.c
+++ b/btif/co/bta_hh_co.c
@@ -652,8 +652,9 @@ void bta_hh_co_send_hid_info(btif_hh_device_t *p_dev, char *dev_name, UINT16 ven
                                                                     vendor_id, product_id,
                                                                     version, ctry_code);
 
-    if (interop_match_hid_multitouch(INTEROP_REMOVE_HID_DIG_DESCRIPTOR, vendor_id, product_id,
-        dev_name))
+    if (interop_match_vendor_product_ids(INTEROP_REMOVE_HID_DIG_DESCRIPTOR,
+        vendor_id, product_id) ||
+        interop_match_name(INTEROP_REMOVE_HID_DIG_DESCRIPTOR, dev_name))
         remove_digitizer_descriptor(&p_dscp, (UINT16 *)&dscp_len);
 
     //Create and send hid descriptor to kernel
diff --git a/btif/include/btif_av.h b/btif/include/btif_av.h
index 814f178..8e2de02 100644
--- a/btif/include/btif_av.h
+++ b/btif/include/btif_av.h
@@ -50,8 +50,10 @@ typedef enum {
     BTIF_AV_SINK_FOCUS_REQ_EVT,
     BTIF_AV_CLEANUP_REQ_EVT,
     BTIF_AV_UPDATE_ENCODER_REQ_EVT,
+    BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT,
+    BTIF_AV_RESET_REMOTE_STARTED_FLAG_EVT,
+    BTIF_AV_RESET_REMOTE_STARTED_FLAG_UPDATE_AUDIO_STATE_EVT,
     BTIF_AV_INIT_REQ_EVT,
-	
 } btif_av_sm_event_t;
 
 
@@ -231,6 +233,17 @@ BOOLEAN btif_av_any_br_peer(void);
 *******************************************************************************/
 BOOLEAN btif_av_peer_supports_3mbps(void);
 
+/*******************************************************************************
+**
+** Function         btif_av_check_flag_remote_suspend
+**
+** Description      Check whether remote suspend flag is set or not
+**
+** Returns          TRUE if remote suspen flag set
+**
+*******************************************************************************/
+BOOLEAN btif_av_check_flag_remote_suspend(int index);
+
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
 /******************************************************************************
 **
@@ -252,9 +265,20 @@ UINT16 btif_av_get_streaming_channel_id(void);
 ********************************************************************************/
 void btif_av_get_peer_addr(bt_bdaddr_t *peer_bda);
 
+/*******************************************************************************
+**
+** Function         btif_av_get_current_playing_dev_idx
+**
+** Description      Returns the current playing device index.
+**
+** Returns          index.
+**
+*******************************************************************************/
+int btif_av_get_current_playing_dev_idx();
 #else
 #define btif_av_get_streaming_channel_id() (0)
 #define btif_av_get_peer_addr(peer_bda) (0)
+#define btif_av_get_current_playing_dev_idx() (0)
 #endif
 
 /*******************************************************************************
diff --git a/btif/include/btif_av_co.h b/btif/include/btif_av_co.h
index 836bd56..a60749a 100644
--- a/btif/include/btif_av_co.h
+++ b/btif/include/btif_av_co.h
@@ -227,4 +227,16 @@ BOOLEAN bta_av_co_get_remote_bitpool_pref(UINT8 *min, UINT8 *max);
  *******************************************************************************/
 UINT8 bta_av_select_codec(tBTA_AV_HNDL hdl);
 
+/*******************************************************************************
+ **
+ ** Function         bta_av_co_audio_is_aac_enabled
+ **
+ ** Description      Compares the given BD address family against the interop databse
+ **                  and return if AAC can be selected as a codec for streaming or not
+ **
+ ** Returns          TRUE if AAC is allowed , FALSE otherwise
+ **
+ *******************************************************************************/
+BOOLEAN bta_av_co_audio_is_aac_enabled(bt_bdaddr_t *remote_bdaddr);
+
 #endif
diff --git a/btif/include/btif_common.h b/btif/include/btif_common.h
index 6748017..83ab28e 100644
--- a/btif/include/btif_common.h
+++ b/btif/include/btif_common.h
@@ -125,7 +125,9 @@ enum
     BTIF_DM_CB_HID_REMOTE_NAME,   /* Remote name callback for HID device */
     BTIF_DM_CB_BOND_STATE_BONDING,
     BTIF_DM_CB_LE_TX_TEST,    /* BLE Tx Test command complete callback */
+    BTIF_DM_CB_LE_ENH_TX_TEST,    /* BLE Enh Tx Test command complete callback */
     BTIF_DM_CB_LE_RX_TEST,    /* BLE Rx Test command complete callback */
+    BTIF_DM_CB_LE_ENH_RX_TEST,    /* BLE Enh Rx Test command complete callback */
     BTIF_DM_CB_LE_TEST_END,   /* BLE Test mode end callback */
 
     BTIF_HFP_CB_START  = BTIF_SIG_CB_START(BTIF_HFP),
@@ -138,6 +140,19 @@ enum
     BTIF_HF_CLIENT_CB_AUDIO_CONNECTING, /* AUDIO connect has been sent to BTA successfully */
 };
 
+/*
+ * Logger preference, based on which the Bluetooth logging is
+ * enabled.
+ */
+#ifdef BLUEDROID_DEBUG
+typedef enum {
+    CONFIG_PREFERENCE_FALSE = 0,
+    CONFIG_PREFERENCE_TRUE,
+    DEV_OPT_PREFERENCE,
+    NO_PREFERENCE,
+} logging_preference_t;
+#endif
+
 /* Macro definitions for BD ADDR persistence */
 
 /**
diff --git a/btif/include/btif_debug_l2c.h b/btif/include/btif_debug_l2c.h
new file mode 100644
index 0000000..b77c49b
--- /dev/null
+++ b/btif/include/btif_debug_l2c.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Google Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include <stdint.h>
+
+#include <hardware/bluetooth.h>
+
+// Captures a BLE connection parameter update request (Section 4.20 of
+// Bluetooth Core V4.2 specification):
+//
+// |min_interval| and |max_interval| define the minimum and maximum values for
+// the connection event interval (in units of 1.25ms and should be in the
+// [6, 3200] range).
+// |slave_latency_param| is the slave latency parameter for the connection in
+// number of connection events (unitless and should be less than 500).
+// |timeout_multiplier| is the connection timeout parameter (in units of 10ms
+// and should be in the [10, 3200] range).
+void btif_debug_ble_connection_update_request(bt_bdaddr_t bda,
+    uint16_t min_interval, uint16_t max_interval, uint16_t slave_latency_param,
+    uint16_t timeout_multiplier);
+
+// Captures a BLE connection parameter update response ((Section 4.21 of
+// Bluetooth Core V4.2 specification):
+//
+// |interval| defines the minimum and maximum values for the
+// connection event interval (in units of 1.25ms and should be in the
+// [6, 3200] range).
+// |slave_latency_param| is the slave latency parameter for the connection in
+// number of connection events (unitless and should be less than 500).
+// |timeout_multiplier| is the connection timeout parameter (in units of 10ms
+// and should be in the [10, 3200] range).
+void btif_debug_ble_connection_update_response(bt_bdaddr_t bda, uint8_t status,
+    uint16_t interval, uint16_t slave_latency_param,
+    uint16_t timeout_multiplier);
+
+// Dumps captured L2C information.
+void btif_debug_l2c_dump(int fd);
diff --git a/btif/include/btif_gatt_multi_adv_util.h b/btif/include/btif_gatt_multi_adv_util.h
index ac8351c..b009875 100644
--- a/btif/include/btif_gatt_multi_adv_util.h
+++ b/btif/include/btif_gatt_multi_adv_util.h
@@ -47,6 +47,7 @@ typedef struct
     uint8_t* p_service_data;
     uint16_t service_uuid_len;
     uint8_t* p_service_uuid;
+    uint8_t frag_preference;
 } btif_adv_data_t;
 
 
@@ -58,7 +59,8 @@ typedef struct
     tBTA_BLE_ADV_PARAMS param;
     alarm_t *multi_adv_timer;
     int timeout_s;
-} btgatt_multi_adv_inst_cb;
+    UINT8 frag_preference;
+}btgatt_multi_adv_inst_cb;
 
 typedef struct
 {
diff --git a/btif/include/btif_gatt_util.h b/btif/include/btif_gatt_util.h
index 715e0c5..1dff7cf 100644
--- a/btif/include/btif_gatt_util.h
+++ b/btif/include/btif_gatt_util.h
@@ -26,7 +26,7 @@
 
 void btif_to_bta_uuid(tBT_UUID *p_dest, bt_uuid_t *p_src);
 void btif_to_bta_response(tBTA_GATTS_RSP *p_dest, btgatt_response_t* p_src);
-void btif_to_bta_uuid_mask(tBTA_DM_BLE_PF_COND_MASK *p_mask, bt_uuid_t *p_src);
+void btif_to_bta_uuid_mask(tBTA_DM_BLE_PF_COND_MASK *p_mask, bt_uuid_t *p_src, bt_uuid_t *svc_uuid);
 
 void bta_to_btif_uuid(bt_uuid_t *p_dest, tBT_UUID *p_src);
 
diff --git a/btif/include/btif_hh.h b/btif/include/btif_hh.h
index aa9793e..b58be36 100644
--- a/btif/include/btif_hh.h
+++ b/btif/include/btif_hh.h
@@ -31,7 +31,12 @@
 **  Constants & Macros
 ********************************************************************************/
 
+#ifndef MAX_ACL_CONNECTIONS
 #define BTIF_HH_MAX_HID         8
+#else
+#define BTIF_HH_MAX_HID         MAX_ACL_CONNECTIONS
+#endif
+
 #define BTIF_HH_MAX_ADDED_DEV   32
 
 #define BTIF_HH_MAX_KEYSTATES            3
diff --git a/btif/include/btif_media.h b/btif/include/btif_media.h
index bac746f..3046f60 100644
--- a/btif/include/btif_media.h
+++ b/btif/include/btif_media.h
@@ -38,7 +38,6 @@
 #include "bta_api.h"
 #include "bt_common.h"
 #include "btif_av_api.h"
-#include "audio_a2dp_hw.h"
 #include "a2d_aac.h"
 
 /*******************************************************************************
@@ -301,22 +300,27 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
 void btif_media_on_stop_vendor_command();
 void btif_media_send_reset_vendor_state();
+BOOLEAN btif_media_send_vendor_start();
+void btif_media_start_vendor_command();
 #else
 #define btif_media_on_stop_vendor_command() (0)
 #define btif_media_send_reset_vendor_state() (0)
+#define btif_media_send_vendor_start() (0)
+#define btif_media_start_vendor_command() (0)
 #endif
+void btif_a2dp_on_remote_started();
 void btif_a2dp_ack_fail(void);
 void btif_a2dp_on_stop_req(void);
 void btif_a2dp_on_stopped(tBTA_AV_SUSPEND *p_av);
 void btif_a2dp_on_suspend(void);
 void btif_a2dp_on_suspended(tBTA_AV_SUSPEND *p_av);
+UINT8 btif_a2dp_get_pending_hal_command();
 void btif_a2dp_set_tx_flush(BOOLEAN enable);
 void btif_a2dp_set_rx_flush(BOOLEAN enable);
 void btif_media_check_iop_exceptions(UINT8 *peer_bda);
 void btif_reset_decoder(UINT8 *p_av);
 void btif_a2dp_on_offload_started(tBTA_AV_STATUS status);
 
-
 int btif_a2dp_get_track_frequency(UINT8 frequency);
 int btif_a2dp_get_track_channel_count(UINT8 channeltype);
 void btif_a2dp_set_peer_sep(UINT8 sep);
diff --git a/btif/include/btif_storage.h b/btif/include/btif_storage.h
index 2da8bd1..a0d04c0 100644
--- a/btif/include/btif_storage.h
+++ b/btif/include/btif_storage.h
@@ -286,6 +286,16 @@ bt_status_t btif_storage_remove_hid_info(bt_bdaddr_t *remote_bd_addr);
 *******************************************************************************/
 BOOLEAN btif_storage_is_restricted_device(const bt_bdaddr_t *remote_bd_addr);
 
+/*******************************************************************************
+**
+** Function         btif_storage_get_num_bonded_devices
+**
+** Description      BTIF storage API - Gets the number of bonded devices
+**
+** Returns          the number of bonded devices
+**
+*******************************************************************************/
+int btif_storage_get_num_bonded_devices(void);
 #if (BLE_INCLUDED == TRUE)
 bt_status_t btif_storage_add_ble_bonding_key( bt_bdaddr_t *remote_bd_addr,
                                               char *key,
diff --git a/btif/src/bluetooth.c b/btif/src/bluetooth.c
index ae9850d..a264f32 100644
--- a/btif/src/bluetooth.c
+++ b/btif/src/bluetooth.c
@@ -31,6 +31,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <cutils/properties.h>
 #include <hardware/bluetooth.h>
 #include <hardware/bt_av.h>
 #include <hardware/bt_gatt.h>
@@ -44,6 +45,9 @@
 #include <hardware/bt_sdp.h>
 #include <hardware/bt_sock.h>
 #include <hardware/vendor.h>
+#ifdef WIPOWER_SUPPORTED
+#include <hardware/wipower.h>
+#endif
 
 #include "bt_utils.h"
 #include "btif_api.h"
@@ -64,9 +68,11 @@
 #include "btif_storage.h"
 #include "btif/include/btif_debug_btsnoop.h"
 #include "btif/include/btif_debug_conn.h"
+#include "btif/include/btif_debug_l2c.h"
 #include "btif/include/btif_media.h"
 #include "l2cdefs.h"
 #include "l2c_api.h"
+#include "stack_config.h"
 
 #if TEST_APP_INTERFACE == TRUE
 #include <bt_testapp.h>
@@ -113,6 +119,9 @@ extern btgatt_interface_t *btif_gatt_get_interface();
 /* avrc target */
 extern btrc_interface_t *btif_rc_get_interface();
 /* avrc controller */
+#ifdef WIPOWER_SUPPORTED
+extern wipower_interface_t *get_wipower_interface();
+#endif
 extern btrc_interface_t *btif_rc_ctrl_get_interface();
 /*SDP search client*/
 extern btsdp_interface_t *btif_sdp_get_interface();
@@ -129,6 +138,13 @@ extern const btsmp_interface_t *btif_smp_get_interface(void);
 extern const btgap_interface_t *btif_gap_get_interface(void);
 #endif
 
+extern void set_logging_pref(uint16_t pref_val);
+#ifdef BLUEDROID_DEBUG
+extern void enable_bt_logger_debug(bool);
+#else
+extern void enable_bt_logger(bool);
+#endif
+
 /************************************************************************************
 **  Functions
 ************************************************************************************/
@@ -187,6 +203,9 @@ static int disable(void) {
 
 static void cleanup(void) {
   stack_manager_get_interface()->clean_up_stack();
+
+  if(bt_logger_enabled)
+    property_set("bluetooth.startbtlogger", "false");
 }
 
 bool is_restricted_mode() {
@@ -363,20 +382,15 @@ static int read_energy_info()
 static void dump(int fd, const char **arguments)
 {
     if (arguments != NULL && arguments[0] != NULL) {
-      if (strncmp(arguments[0], "--proto-text", 12) == 0) {
-        btif_update_a2dp_metrics();
-        metrics_print(fd, true);
-        return;
-      }
       if (strncmp(arguments[0], "--proto-bin", 11) == 0) {
-        btif_update_a2dp_metrics();
-        metrics_write(fd, true);
+        metrics_write_base64(fd, true);
         return;
       }
     }
     btif_debug_conn_dump(fd);
     btif_debug_bond_event_dump(fd);
     btif_debug_a2dp_dump(fd);
+    btif_debug_l2c_dump(fd);
     btif_debug_config_dump(fd);
     wakelock_debug_dump(fd);
     alarm_debug_dump(fd);
@@ -434,6 +448,11 @@ static const void* get_profile_interface (const char *profile_id)
     if (is_profile(profile_id, BT_PROFILE_AV_RC_ID))
         return btif_rc_get_interface();
 
+#ifdef WIPOWER_SUPPORTED
+    if (is_profile(profile_id, BT_PROFILE_WIPOWER_VENDOR_ID))
+        return get_wipower_interface();
+#endif
+
     if (is_profile(profile_id, BT_PROFILE_AV_RC_CTRL_ID))
         return btif_rc_ctrl_get_interface();
 
@@ -500,7 +519,7 @@ int hci_cmd_send(uint16_t opcode, uint8_t* buf, uint8_t len)
     ALOGI("hci_cmd_send");
 
     /* sanity check */
-    if (interface_ready() == FALSE)
+    if (interface_ready() == FALSE || stack_manager_get_interface()->get_stack_is_running() == FALSE)
         return BT_STATUS_NOT_READY;
 
     return btif_hci_cmd_send(opcode, buf, len);
@@ -527,6 +546,12 @@ int config_hci_snoop_log(uint8_t enable)
     if (!interface_ready())
         return BT_STATUS_NOT_READY;
 
+#ifdef BLUEDROID_DEBUG
+    enable_bt_logger_debug(enable);
+#else
+    enable_bt_logger(enable);
+#endif
+
     btsnoop_get_interface()->set_api_wants_to_log(enable);
     controller_get_static_interface()->enable_soc_logging(enable);
 
diff --git a/btif/src/btif_av.c b/btif/src/btif_av.c
old mode 100644
new mode 100755
index c4c49a5..e426ea3
--- a/btif/src/btif_av.c
+++ b/btif/src/btif_av.c
@@ -38,6 +38,9 @@
 #include "bt_common.h"
 #include "osi/include/allocator.h"
 #include <cutils/properties.h>
+#include "device/include/interop.h"
+#include "btif_storage.h"
+#include "audio_a2dp_hw.h"
 
 /*****************************************************************************
 **  Constants & Macros
@@ -46,6 +49,7 @@
 #define BTIF_AVK_SERVICE_NAME "Advanced Audio Sink"
 
 #define BTIF_TIMEOUT_AV_OPEN_ON_RC_MS  (2 * 1000)
+#define BTIF_TIMEOUT_AV_COLL_DETECTED_MS (2 * 1000)
 
 /* Number of BTIF-AV control blocks */
 /* Now supports Two AV connections. */
@@ -70,6 +74,7 @@ typedef enum {
 #define BTIF_AV_FLAG_REMOTE_SUSPEND        0x2
 #define BTIF_AV_FLAG_PENDING_START         0x4
 #define BTIF_AV_FLAG_PENDING_STOP          0x8
+#define BTIF_AV_FLAG_PENDING_DISCONNECT   0x10
 /* Host role defenitions */
 #define HOST_ROLE_MASTER                   0x00
 #define HOST_ROLE_SLAVE                    0x01
@@ -94,6 +99,8 @@ typedef struct
     int service;
     BOOLEAN is_slave;
     BOOLEAN is_device_playing;
+    BOOLEAN is_remote_start_received;
+    BOOLEAN is_suspend_for_remote_start;
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
     UINT16 channel_id;
 #endif
@@ -133,6 +140,9 @@ typedef enum {
 static btav_callbacks_t *bt_av_src_callbacks = NULL;
 static btav_callbacks_t *bt_av_sink_callbacks = NULL;
 static alarm_t *av_open_on_rc_timer = NULL;
+static alarm_t *av_coll_detected_timer = NULL;
+static bt_bdaddr_t retry_bda;
+static int conn_retry_count = 1;
 static btif_av_cb_t btif_av_cb[BTIF_AV_NUM_CB];
 static btif_sm_event_t idle_rc_event;
 static tBTA_AV idle_rc_data;
@@ -141,6 +151,7 @@ static BOOLEAN enable_multicast = FALSE;
 static BOOLEAN is_multicast_supported = FALSE;
 static BOOLEAN multicast_disabled = FALSE;
 BOOLEAN bt_split_a2dp_enabled = FALSE;
+BOOLEAN reconfig_a2dp = FALSE;
 btif_av_a2dp_offloaded_codec_cap_t btif_av_codec_offload;
 /* both interface and media task needs to be ready to alloc incoming request */
 #define CHECK_BTAV_INIT() if (((bt_av_src_callbacks == NULL) &&(bt_av_sink_callbacks == NULL)) \
@@ -176,7 +187,7 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *data,i
 static BOOLEAN btif_av_state_closing_handler(btif_sm_event_t event, void *data,int index);
 
 static BOOLEAN btif_av_get_valid_idx(int idx);
-static UINT8 btif_av_idx_by_bdaddr( BD_ADDR bd_addr);
+UINT8 btif_av_idx_by_bdaddr( BD_ADDR bd_addr);
 int btif_get_latest_playing_device_idx();
 static int btif_get_latest_device_idx_to_start();
 static int btif_av_get_valid_idx_for_rc_events(BD_ADDR bd_addr, int rc_handle);
@@ -184,6 +195,9 @@ static int btif_get_conn_state_of_device(BD_ADDR address);
 static bt_status_t connect_int(bt_bdaddr_t *bd_addr, uint16_t uuid);
 static void btif_av_update_current_playing_device(int index);
 static void btif_av_check_rc_connection_priority(void *p_data);
+static int btif_get_is_remote_started_idx();
+static void btif_av_reset_remote_started_flag();
+
 #ifdef AVK_BACKPORT
 void btif_av_request_audio_focus( BOOLEAN enable);
 #endif
@@ -211,7 +225,8 @@ extern void btif_rc_clear_priority(BD_ADDR address);
 extern void btif_rc_send_pause_command();
 extern UINT16 btif_dm_get_br_edr_links();
 extern UINT16 btif_dm_get_le_links();
-extern UINT16 btif_hf_is_call_idle();
+extern UINT16 btif_hf_is_call_vr_idle();
+extern void btif_media_on_cancel_remote_start_alarm();
 
 extern fixed_queue_t *btu_general_alarm_queue;
 
@@ -231,12 +246,16 @@ tBTA_AV_HNDL btif_av_get_av_hdl_from_idx(UINT8 idx);
 int btif_av_get_other_connected_idx(int current_index);
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
 BOOLEAN btif_av_is_codec_offload_supported(int codec);
-int btif_av_get_current_playing_dev_idx();
 BOOLEAN btif_av_is_under_handoff();
+void btif_av_reset_reconfig_flag();
+BOOLEAN btif_av_is_device_disconnecting();
+BOOLEAN btif_av_is_suspend_stop_pending_ack();
 #else
 #define btif_av_is_codec_offload_supported(codec) (0)
-#define btif_av_get_current_playing_dev_idx() (0)
 #define btif_av_is_under_handoff() (0)
+#define btif_av_reset_reconfig_flag() (0)
+#define btif_av_is_device_disconnecting() (0)
+#define btif_av_is_suspend_stop_pending_ack() (0)
 #endif
 
 const char *dump_av_sm_state_name(btif_av_state_t state)
@@ -284,6 +303,7 @@ const char *dump_av_sm_event_name(btif_av_sm_event_t event)
         CASE_RETURN_STR(BTIF_AV_START_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_STOP_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_SUSPEND_STREAM_REQ_EVT)
+        CASE_RETURN_STR(BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_SINK_CONFIG_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_OFFLOAD_START_REQ_EVT)
 #ifdef USE_AUDIO_TRACK
@@ -413,6 +433,90 @@ static void btif_report_audio_state(btav_audio_state_t state, bt_bdaddr_t *bd_ad
     }
 }
 
+static void btif_av_collission_timer_timeout(UNUSED_ATTR void *data)
+{
+    bt_bdaddr_t *target_bda = &retry_bda;
+    btif_sm_state_t av_state;
+    BD_ADDR av_address;
+
+    bdcpy(av_address, target_bda->address);
+    av_state = btif_get_conn_state_of_device(av_address);
+    BTIF_TRACE_IMP("btif_av_collission_timer_timeout: AV state: %d", av_state);
+    BTIF_TRACE_IMP("TARGET BD ADDRESS %x:%x:%x:%x:%x:%x", av_address[0],
+        av_address[1], av_address[2], av_address[3], av_address[4], av_address[5]);
+
+    if (av_state == BTIF_AV_STATE_IDLE && conn_retry_count <= 1)
+    {
+        if (bt_av_src_callbacks != NULL)
+        {
+            BTIF_TRACE_IMP("%s Starting A2dp connection", __FUNCTION__);
+            conn_retry_count++;
+            btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE, target_bda, connect_int);
+        }
+        else
+        {
+            BTIF_TRACE_IMP("%s Aborting A2dp connection retry", __FUNCTION__);
+        }
+    }
+    else if (btif_rc_get_connected_peer_handle(av_address) == BTIF_RC_HANDLE_NONE
+            && conn_retry_count <= 1)
+    {
+        tBTA_AV_HNDL handle;
+        UINT8 idx = btif_av_idx_by_bdaddr(av_address);
+        if (idx == btif_max_av_clients)
+        {
+            BTIF_TRACE_ERROR("%s: Invalid handle",__func__);
+            handle = (tBTA_AV_HNDL)INVALID_INDEX;
+        }
+        else
+        {
+            handle = btif_av_cb[idx].bta_handle;
+        }
+        BTIF_TRACE_IMP("%s Starting Avrcp connection for handle: %d", __FUNCTION__, handle);
+        if ((handle != (tBTA_AV_HNDL)INVALID_INDEX) && (bt_av_src_callbacks != NULL))
+        {
+            BTA_AvOpenRc(handle);
+            conn_retry_count++;
+        }
+        else
+        {
+            BTIF_TRACE_IMP("%s Aborting Avrcp connection retry", __FUNCTION__);
+        }
+    }
+    else
+    {
+        if (conn_retry_count > 1)
+        {
+            conn_retry_count = 1;
+            BTIF_TRACE_IMP("%s Connection Retry count exceeded", __FUNCTION__);
+            return;
+        }
+        BTIF_TRACE_IMP("%s A2dp already connected", __FUNCTION__);
+        BTIF_TRACE_IMP("%s Avrcp already connected on handle: %d", __FUNCTION__,
+            btif_rc_get_connected_peer_handle(av_address));
+    }
+}
+
+
+void btif_av_check_and_start_collission_timer(int index)
+{
+    memcpy(&retry_bda, &btif_av_cb[index].peer_bda, sizeof(bt_bdaddr_t));
+
+    BTIF_TRACE_IMP("btif_av_check_and_start_collission_timer, index: %d ", index);
+
+    if (alarm_is_scheduled(av_coll_detected_timer))
+    {
+        alarm_cancel(av_coll_detected_timer);
+        BTIF_TRACE_IMP("btif_av_check_and_start_collission_timer:Deleting previously queued timer");
+    }
+    alarm_set_on_queue(av_coll_detected_timer,
+              BTIF_TIMEOUT_AV_COLL_DETECTED_MS,
+              btif_av_collission_timer_timeout,
+              NULL,
+              btu_general_alarm_queue);
+}
+
+
 /*****************************************************************************
 **
 ** Function     btif_av_state_idle_handler
@@ -441,6 +545,8 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
             btif_av_cb[index].edr = 0;
             btif_av_cb[index].current_playing = FALSE;
             btif_av_cb[index].is_slave = FALSE;
+            btif_av_cb[index].is_remote_start_received = FALSE;
+            btif_av_cb[index].is_suspend_for_remote_start = FALSE;
             btif_av_cb[index].is_device_playing = FALSE;
             for (int i = 0; i < btif_max_av_clients; i++)
             {
@@ -476,6 +582,7 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
                  bt_split_a2dp_enabled)
             {
                 BTIF_TRACE_EVENT("reset Vendor flag A2DP state is IDLE");
+                reconfig_a2dp = FALSE;
                 btif_media_send_reset_vendor_state();
             }
             break;
@@ -519,7 +626,7 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
             memcpy(&btif_av_cb[index].peer_bda, ((btif_av_connect_req_t*)p_data)->target_bda,
                                                                         sizeof(bt_bdaddr_t));
             BTA_AvOpen(btif_av_cb[index].peer_bda.address, btif_av_cb[index].bta_handle,
-                        TRUE, BTA_SEC_NONE, ((btif_av_connect_req_t*)p_data)->uuid);
+                        TRUE, BTA_SEC_AUTHENTICATE, ((btif_av_connect_req_t*)p_data)->uuid);
             btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_OPENING);
             break;
 
@@ -581,7 +688,7 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
                 if(event == BTA_AV_PENDING_EVT)
                 {
                     BTA_AvOpen(btif_av_cb[index].peer_bda.address, btif_av_cb[index].bta_handle,
-                       TRUE, BTA_SEC_NONE, UUID_SERVCLASS_AUDIO_SINK);
+                       TRUE, BTA_SEC_AUTHENTICATE, UUID_SERVCLASS_AUDIO_SINK);
                 }
                 else if(event == BTA_AV_RC_OPEN_EVT)
                 {
@@ -617,7 +724,9 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
                  btif_av_cb[index].peer_sep = p_bta_data->open.sep;
                  btif_a2dp_set_peer_sep(p_bta_data->open.sep);
 
-                 if (p_bta_data->open.edr & BTA_AV_EDR_3MBPS)
+                 if ((p_bta_data->open.edr & BTA_AV_EDR_3MBPS) &&
+                     (!(interop_match_addr(INTEROP_2MBPS_LINK_ONLY,
+                        (const bt_bdaddr_t *)&btif_av_cb[index].peer_bda.address))))
                  {
                      BTIF_TRACE_DEBUG("remote supports 3 mbps");
                      btif_av_cb[index].edr_3mbps = TRUE;
@@ -686,6 +795,10 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
             btif_a2dp_on_offload_started(BTA_AV_FAIL);
             break;
 
+        case BTA_AV_RC_COLL_DETECTED_EVT:
+            BTIF_TRACE_WARNING("BTA_AV_RC_COLL_DETECTED_EVT: Not Starting conn retry timer");
+            break;
+
         default:
             BTIF_TRACE_WARNING("%s : unhandled event:%s", __FUNCTION__,
                                 dump_av_sm_event_name(event));
@@ -756,7 +869,9 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
                  }
                  btif_av_cb[index].peer_sep = p_bta_data->open.sep;
                  btif_a2dp_set_peer_sep(p_bta_data->open.sep);
-                 if (p_bta_data->open.edr & BTA_AV_EDR_3MBPS)
+                 if ((p_bta_data->open.edr & BTA_AV_EDR_3MBPS) &&
+                     (!(interop_match_addr(INTEROP_2MBPS_LINK_ONLY,
+                        (const bt_bdaddr_t *)&btif_av_cb[index].peer_bda.address))))
                  {
                      BTIF_TRACE_DEBUG("remote supports 3 mbps");
                      btif_av_cb[index].edr_3mbps = TRUE;
@@ -778,16 +893,31 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
                 if ((btif_rc_get_connected_peer(peer_addr))
                     &&(!bdcmp(btif_av_cb[index].peer_bda.address, peer_addr)))
                 {
-                    /* Disconnect AVRCP connection, if A2DP
-                     * conneciton failed, for any reason
+                    /* Do not disconnect AVRCP connection if A2DP
+                     * connection failed due to SDP failure since remote
+                     * may not support A2DP. In such case we will keep
+                     * AVRCP only connection.
                      */
-                    BTIF_TRACE_WARNING(" Disconnecting AVRCP ");
-                    BTA_AvCloseRc(btif_rc_get_connected_peer_handle(peer_addr));
+                    if (p_bta_data->open.status != BTA_AV_FAIL_SDP)
+                    {
+                        BTIF_TRACE_WARNING("Disconnecting AVRCP ");
+                        BTA_AvCloseRc(btif_rc_get_connected_peer_handle(peer_addr));
+                    }
+                    else
+                    {
+                        BTIF_TRACE_WARNING("Keep AVRCP only connection");
+                    }
                 }
                 state = BTAV_CONNECTION_STATE_DISCONNECTED;
                 av_state  = BTIF_AV_STATE_IDLE;
             }
 
+            if (p_bta_data->open.status != BTA_AV_SUCCESS &&
+                    p_bta_data->open.status != BTA_AV_FAIL_SDP)
+            {
+                btif_av_check_and_start_collission_timer(index);
+            }
+
             /* inform the application of the event */
             btif_report_connection_state(state, &(btif_av_cb[index].peer_bda));
             /* change state to open/idle based on the status */
@@ -899,7 +1029,9 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
             /* inform the application that we are disconnected */
             btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED,
                     &(btif_av_cb[index].peer_bda));
+            btif_queue_advance();
             btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_IDLE);
+            btif_av_check_and_start_collission_timer(index);
             break;
 
         case BTIF_AV_DISCONNECT_REQ_EVT:
@@ -914,6 +1046,10 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
              btif_rc_handler(event, p_data);;
             break;
 
+        case BTA_AV_RC_COLL_DETECTED_EVT:
+            BTIF_TRACE_WARNING("BTA_AV_RC_COLL_DETECTED_EVT: Not Starting conn retry timer");
+            break;
+
         CHECK_RC_EVENT(event, p_data);
 
         default:
@@ -1026,6 +1162,10 @@ static BOOLEAN btif_av_state_closing_handler(btif_sm_event_t event, void *p_data
             btif_rc_handler(event, (tBTA_AV*)p_data);
             break;
 
+        case BTA_AV_RC_COLL_DETECTED_EVT:
+            BTIF_TRACE_WARNING("BTA_AV_RC_COLL_DETECTED_EVT: Not Starting conn retry timer");
+            break;
+
         case BTIF_AV_OFFLOAD_START_REQ_EVT:
             btif_a2dp_on_offload_started(BTA_AV_FAIL);
             BTIF_TRACE_ERROR("BTIF_AV_OFFLOAD_START_REQ_EVT: Stream not Started Closing");
@@ -1039,6 +1179,19 @@ static BOOLEAN btif_av_state_closing_handler(btif_sm_event_t event, void *p_data
    return TRUE;
 }
 
+/******************************************************************************
+**
+** Function        btif_av_is_offload_supported
+**
+** Description     Returns split mode status
+**
+** Returns         TRUE if split mode is enabled, FALSE otherwise
+********************************************************************************/
+BOOLEAN btif_av_is_offload_supported()
+{
+    return bt_split_a2dp_enabled;
+}
+
 /*****************************************************************************
 **
 ** Function     btif_av_state_opened_handler
@@ -1059,13 +1212,14 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
     if ((event == BTA_AV_REMOTE_CMD_EVT) &&
          (p_av->remote_cmd.rc_id == BTA_AV_RC_PLAY) )
     {
-        for (int i = 0; i < btif_max_av_clients; i++)
+        if (btif_av_check_flag_remote_suspend(index))
         {
-            if (btif_av_cb[i].flags & BTIF_AV_FLAG_REMOTE_SUSPEND)
+            BTIF_TRACE_EVENT("%s: Resetting remote suspend flag on RC PLAY",
+                __FUNCTION__);
+            btif_av_clear_remote_suspend_flag();
+            if (btif_av_is_offload_supported())
             {
-                BTIF_TRACE_EVENT("%s: Resetting remote suspend flag on RC PLAY",
-                        __FUNCTION__);
-                btif_av_cb[i].flags &= ~BTIF_AV_FLAG_REMOTE_SUSPEND;
+                btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
             }
         }
     }
@@ -1078,7 +1232,6 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
             break;
 
         case BTIF_SM_EXIT_EVT:
-            btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
             break;
 
         case BTIF_AV_START_STREAM_REQ_EVT:
@@ -1157,9 +1310,13 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
                 return TRUE;
 
             /* if remote tries to start a2dp when call is in progress, suspend it right away */
-            if ((!(btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START)) && (!btif_hf_is_call_idle())) {
+            if ((!(btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START)) && (!btif_hf_is_call_vr_idle())) {
                 BTIF_TRACE_EVENT("%s: trigger suspend as call is in progress!!", __FUNCTION__);
-                btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+                btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
+                btif_av_cb[index].is_remote_start_received = TRUE;
+                btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_STARTED);
+                btif_dispatch_sm_event(BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+                break;
             }
 
             /* if remote tries to start a2dp when DUT is a2dp source
@@ -1203,29 +1360,21 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
                             BTIF_TRACE_DEBUG("%s: clear remote suspend flag on remote start",
                                 __FUNCTION__);
                             btif_av_cb[index].flags &= ~BTIF_AV_FLAG_REMOTE_SUSPEND;
+                            if (btif_av_is_offload_supported())
+                            {
+                               btif_media_start_vendor_command();
+                            }
                         }
                         else
                         {
-                            BTIF_TRACE_DEBUG("%s: trigger suspend as remote initiated!!",
-                                __FUNCTION__);
-                            btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+                            BTIF_TRACE_DEBUG("%s: honor remote started for BL device",__FUNCTION__);
+                            btif_a2dp_on_remote_started();
+                            btif_av_cb[index].is_remote_start_received = TRUE;
                         }
                     }
                 }
             }
 
-            /*  In case peer is A2DP SRC we do not want to ack commands on UIPC*/
-            if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
-            {
-                if (btif_a2dp_on_started(&p_av->start,
-                    ((btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) != 0),
-                      btif_av_cb[index].bta_handle))
-                {
-                    /* only clear pending flag after acknowledgement */
-                    btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
-                }
-            }
-
             /* remain in open state if status failed */
             /* Multicast-soft Handoff:
              * START failed, cleanup Handoff flag.
@@ -1234,6 +1383,18 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
             {
                 int i;
 
+                /* In case peer is A2DP SRC we do not want to ack commands on UIPC */
+                if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
+                {
+                    if (btif_a2dp_on_started(&p_av->start,
+                        ((btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) != 0),
+                        btif_av_cb[index].bta_handle))
+                    {
+                        /* only clear pending flag after acknowledgement */
+                        btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
+                    }
+                }
+                /* Clear dual handoff flag */
                 for (i = 0; i < btif_max_av_clients; i++)
                 {
                     btif_av_cb[i].dual_handoff = FALSE;
@@ -1248,12 +1409,6 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
             }
 #endif
 
-            /* change state to started, send acknowledgement if start is pending */
-            if (btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) {
-                if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
-                    btif_a2dp_on_started(NULL, TRUE, btif_av_cb[index].bta_handle);
-                /* pending start flag will be cleared when exit current state */
-            }
             btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_STARTED);
 
         } break;
@@ -1288,14 +1443,16 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
                  btif_a2dp_on_stopped(NULL);
              }
 
+            btif_av_cb[index].flags |= BTIF_AV_FLAG_PENDING_DISCONNECT;
             /* inform the application that we are disconnected */
             btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED,
                                         &(btif_av_cb[index].peer_bda));
+            btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_DISCONNECT;
 
             /* change state to idle, send acknowledgement if start is pending */
             if (btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) {
                 btif_a2dp_ack_fail();
-                /* pending start flag will be cleared when exit current state */
+                btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
             }
 
             btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_IDLE);
@@ -1338,6 +1495,12 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
         case BTA_AV_RC_OPEN_EVT:
             btif_av_check_rc_connection_priority(p_data);
             break;
+
+        case BTA_AV_RC_COLL_DETECTED_EVT:
+            BTIF_TRACE_ERROR("BTA_AV_RC_COLL_DETECTED_EVT: Start conn retry timer");
+            btif_av_check_and_start_collission_timer(index);
+            break;
+
         CHECK_RC_EVENT(event, p_data);
 
         default:
@@ -1364,6 +1527,7 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
     tBTA_AV *p_av = (tBTA_AV*)p_data;
     btif_sm_state_t state = BTIF_AV_STATE_IDLE;
     int i;
+    BOOLEAN hal_suspend_pending = FALSE;
 
     BTIF_TRACE_IMP("%s event:%s flags %x  index =%d", __FUNCTION__,
                      dump_av_sm_event_name(event), btif_av_cb[index].flags, index);
@@ -1371,10 +1535,49 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
     switch (event)
     {
         case BTIF_SM_ENTER_EVT:
+            /*Ack from entry point of started handler instead of open state to avoid race condition*/
+            if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
+            {
+                if (!((!enable_multicast)&&((btif_av_cb[index].is_remote_start_received)
+                && ((btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) == 0))))
+                {
+                    BTIF_TRACE_IMP("%s update media task on DUT initiated start for index =%d",
+                        __FUNCTION__, index);
+                    if (btif_a2dp_on_started(&p_av->start,
+                        ((btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) != 0),
+                          btif_av_cb[index].bta_handle))
+                    {
+                        /* only clear pending flag after acknowledgement */
+                        btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
+                    }
+                }
+                else
+                {
+                    BTIF_TRACE_IMP("%s Do not update media task on remote start for index =%d",
+                        __FUNCTION__, index);
+                }
+            }
+
+            /* Already changed state to started, send acknowledgement if start is pending */
+            if (btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) {
+                if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
+                    btif_a2dp_on_started(NULL, TRUE, btif_av_cb[index].bta_handle);
+                btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
+            }
+
             /* we are again in started state, clear any remote suspend flags */
             btif_av_cb[index].flags &= ~BTIF_AV_FLAG_REMOTE_SUSPEND;
 
-            btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
+            if ((!enable_multicast)&&((btif_av_cb[index].is_remote_start_received)
+            && (btif_av_is_playing_on_other_idx(index))))
+            {
+                BTIF_TRACE_IMP("%s Do not update audio state change to app for index =%d",
+                    __FUNCTION__, index);
+            }
+            else
+            {
+                btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
+            }
             btif_av_cb[index].is_device_playing = TRUE;
 
             /* increase the a2dp consumer task priority temporarily when start
@@ -1396,6 +1599,7 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             }
             //This is latest device to play now
             btif_av_cb[index].current_playing = TRUE;
+            //reconfig_a2dp = FALSE;
             break;
 
         case BTIF_SM_EXIT_EVT:
@@ -1407,7 +1611,20 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
         case BTIF_AV_START_STREAM_REQ_EVT:
             /* we were remotely started, just ack back the local request */
             if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
+            {
                 btif_a2dp_on_started(NULL, TRUE, btif_av_cb[index].bta_handle);
+                btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
+                btif_av_cb[index].is_device_playing = TRUE;
+                for (i = 0; i < btif_max_av_clients; i++)
+                {
+                    //Other device is not current playing
+                    if (i != index)
+                        btif_av_cb[i].current_playing = FALSE;
+                }
+                //This is latest device to play now
+                btif_av_cb[index].current_playing = TRUE;
+                btif_av_reset_reconfig_flag();
+            }
             break;
 
         case BTIF_AV_UPDATE_ENCODER_REQ_EVT:
@@ -1425,14 +1642,21 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
              * be sent to only one stream as internally BTA takes care of
              * suspending both streams.
              */
-            for(i = 0; i < btif_max_av_clients; i++)
+            if (enable_multicast)
             {
-                state = btif_sm_get_state(btif_av_cb[i].sm_handle);
-                if (state == BTIF_AV_STATE_STARTED)
+                for(i = 0; i < btif_max_av_clients; i++)
                 {
-                    btif_av_cb[i].flags |= BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING;
+                    state = btif_sm_get_state(btif_av_cb[i].sm_handle);
+                    if (state == BTIF_AV_STATE_STARTED)
+                    {
+                        btif_av_cb[i].flags |= BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING;
+                    }
                 }
             }
+            else
+            {
+                btif_av_cb[index].flags |= BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING;
+            }
 
             /* if we were remotely suspended but suspend locally, local suspend
                always overrides */
@@ -1484,6 +1708,7 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
                  * Array 'btif_av_cb' of size 2 may use index value(s) -1 */
                 if (idx != INVALID_INDEX)
                 {
+                    reconfig_a2dp = TRUE;
                     HAL_CBACK(bt_av_src_callbacks, reconfig_a2dp_trigger_cb, 1,
                                                     &(btif_av_cb[idx].peer_bda));
                 }
@@ -1491,7 +1716,6 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             break;
 
         case BTA_AV_SUSPEND_EVT:
-
             BTIF_TRACE_EVENT("BTA_AV_SUSPEND_EVT status %d, init %d",
                  p_av->suspend.status, p_av->suspend.initiator);
             //Check if this suspend is due to DUAL_Handoff
@@ -1534,8 +1758,14 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
              * Keep the suspend failure handling untouched and handle
              * only success case to check and avoid calling onsuspended.
              */
+            if (btif_a2dp_get_pending_hal_command() == A2DP_CTRL_CMD_SUSPEND ||
+                btif_a2dp_get_pending_hal_command() == A2DP_CTRL_CMD_STOP)
+            {
+                BTIF_TRACE_DEBUG("HAL suspend/stop pending ack the suspend");
+                hal_suspend_pending = TRUE;
+            }
             if ((p_av->suspend.status != BTA_AV_SUCCESS) ||
-                !btif_av_is_playing_on_other_idx(index))
+                hal_suspend_pending || !btif_av_is_playing_on_other_idx(index))
             {
                 btif_a2dp_on_suspended(&p_av->suspend);
             }
@@ -1557,14 +1787,18 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
                 return FALSE;
             }
 
-            if (p_av->suspend.initiator != TRUE)
+            if ((!enable_multicast)&& btif_av_cb[index].is_suspend_for_remote_start
+            && (btif_av_is_playing_on_other_idx(index)))
             {
-                btif_report_audio_state(BTAV_AUDIO_STATE_REMOTE_SUSPEND, &(btif_av_cb[index].peer_bda));
+                BTIF_TRACE_IMP("%s Do not update audio state change to app for index =%d",
+                    __FUNCTION__, index);
             }
             else
             {
                 btif_report_audio_state(BTAV_AUDIO_STATE_REMOTE_SUSPEND, &(btif_av_cb[index].peer_bda));
             }
+            btif_av_cb[index].is_suspend_for_remote_start = FALSE;
+
             btif_av_cb[index].is_device_playing = FALSE;
             btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_OPENED);
 
@@ -1581,7 +1815,9 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
                 if (enable_multicast == FALSE)
                 {
                     APPL_TRACE_WARNING("other Idx is connected, move to SUSPENDED");
-                    btif_rc_send_pause_command();
+                    if (!bt_split_a2dp_enabled) {
+                        btif_rc_send_pause_command();
+                    }
                     btif_a2dp_on_stopped(&p_av->suspend);
                 }
             }
@@ -1592,12 +1828,39 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             }
             btif_av_cb[index].is_device_playing = FALSE;
 
-
-            btif_report_audio_state(BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb[index].peer_bda));
+            if ((!enable_multicast)&& btif_av_cb[index].is_suspend_for_remote_start
+            && (btif_av_is_playing_on_other_idx(index)))
+            {
+                BTIF_TRACE_IMP("%s Do not update audio state change to app for index =%d",
+                    __FUNCTION__, index);
+            }
+            else
+            {
+                btif_report_audio_state(BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb[index].peer_bda));
+            }
+            btif_av_cb[index].is_suspend_for_remote_start = FALSE;
             /* if stop was successful, change state to open */
             if (p_av->suspend.status == BTA_AV_SUCCESS)
                 btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_OPENED);
 
+            if (bt_split_a2dp_enabled &&
+                btif_av_is_connected_on_other_idx(index))
+            {
+               /*Fake handoff state to switch streaming to other coddeced
+                  device */
+                btif_av_cb[index].dual_handoff = TRUE;
+                BTIF_TRACE_DEBUG("%s: Notify framework to reconfig",__func__);
+                int idx = btif_av_get_other_connected_idx(index);
+                /* Fix for below Klockwork Issue
+                 * Array 'btif_av_cb' of size 2 may use index value(s) -1 */
+                if (idx != INVALID_INDEX)
+                {
+                    reconfig_a2dp = TRUE;
+                    HAL_CBACK(bt_av_src_callbacks, reconfig_a2dp_trigger_cb, 1,
+                                                    &(btif_av_cb[idx].peer_bda));
+                }
+            }
+
             break;
 
         case BTA_AV_CLOSE_EVT:
@@ -1627,6 +1890,11 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             btif_a2dp_on_offload_started(p_av->status);
             break;
 
+        case BTA_AV_RC_COLL_DETECTED_EVT:
+            BTIF_TRACE_ERROR("BTA_AV_RC_COLL_DETECTED_EVT: Start conn retry timer");
+            btif_av_check_and_start_collission_timer(index);
+            break;
+
         CHECK_RC_EVENT(event, p_data);
 
         default:
@@ -1638,7 +1906,6 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
     return TRUE;
 }
 
-
 void btif_av_event_deep_copy(UINT16 event, char *p_dest, char *p_src)
 {
     tBTA_AV *av_src = (tBTA_AV *)p_src;
@@ -1803,12 +2070,48 @@ static void btif_av_handle_event(UINT16 event, char* p_param)
         case BTIF_AV_STOP_STREAM_REQ_EVT:
         case BTIF_AV_SUSPEND_STREAM_REQ_EVT:
             /*Should be handled by current STARTED*/
+            index = btif_get_latest_playing_device_idx();
+            if ((index < btif_max_av_clients) && (index == btif_get_is_remote_started_idx()))
+            {
+                BTIF_TRACE_IMP("%s: Postpone handling suspend/stop req @ index = %d",
+                    __FUNCTION__, index);
+                return;
+            }
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
             if (bt_split_a2dp_enabled)
                 btif_media_on_stop_vendor_command();
 #endif
-            index = btif_get_latest_playing_device_idx();
             break;
+        case BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT:
+            index = btif_get_is_remote_started_idx();
+            if (index >= btif_max_av_clients)
+            {
+                BTIF_TRACE_ERROR("%s: Invalid index for connection", __FUNCTION__);
+                return;
+            }
+            BTIF_TRACE_IMP("%s: Remote Started set @ index = %d", __FUNCTION__, index);
+            btif_av_cb[index].is_remote_start_received = FALSE;
+            btif_av_cb[index].is_suspend_for_remote_start = TRUE;
+#ifdef BTA_AV_SPLIT_A2DP_ENABLED
+            if ((bt_split_a2dp_enabled) && (!btif_av_is_playing_on_other_idx(index)))
+            {
+                BTIF_TRACE_IMP("%s: Other index is not playing", __FUNCTION__);
+                btif_media_on_stop_vendor_command();
+            }
+#endif
+            event = BTIF_AV_SUSPEND_STREAM_REQ_EVT;
+            break;
+        case BTIF_AV_RESET_REMOTE_STARTED_FLAG_UPDATE_AUDIO_STATE_EVT:
+            index = btif_get_is_remote_started_idx();
+            if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
+            {
+                BTIF_TRACE_IMP("%s: on remote start clean up update audio started state for index %d",
+                    __FUNCTION__, index);
+                btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
+            }
+        case BTIF_AV_RESET_REMOTE_STARTED_FLAG_EVT:
+            btif_av_reset_remote_started_flag();
+            return;
         /*Events from the stack, BTA*/
         case BTA_AV_ENABLE_EVT:
             index = 0;
@@ -1877,6 +2180,9 @@ static void btif_av_handle_event(UINT16 event, char* p_param)
                 btif_rc_handler(event, p_bta_data);
             }
             break;
+        case BTA_AV_RC_COLL_DETECTED_EVT:
+            index = btif_av_idx_by_bdaddr(p_bta_data->rc_col_detected.peer_addr);
+            break;
         /* Let the RC handler decide on these passthrough cmds
          * Use rc_handle to get the active AV device and use that mapping.
          */
@@ -1901,6 +2207,17 @@ static void btif_av_handle_event(UINT16 event, char* p_param)
 
 }
 
+void btif_av_reset_remote_started_flag()
+{
+    int i;
+    BTIF_TRACE_DEBUG("btif_av_reset_remote_started_flag");
+    for (i = 0; i < btif_max_av_clients; i++)
+    {
+        if (btif_av_cb[i].is_remote_start_received)
+            btif_av_cb[i].is_remote_start_received = FALSE;
+    }
+}
+
 /*******************************************************************************
 **
 ** Function         btif_av_get_valid_idx
@@ -1929,7 +2246,7 @@ static BOOLEAN btif_av_get_valid_idx(int idx)
 **
 *******************************************************************************/
 
-static UINT8 btif_av_idx_by_bdaddr(BD_ADDR bd_addr)
+UINT8 btif_av_idx_by_bdaddr(BD_ADDR bd_addr)
 {
     int i;
     for (i = 0; i < btif_max_av_clients; i++)
@@ -1946,7 +2263,8 @@ BOOLEAN btif_av_is_current_device(BD_ADDR address)
     UINT8 index;
 
     index = btif_av_idx_by_bdaddr(address);
-    if((index < btif_max_av_clients) && btif_av_cb[index].current_playing)
+    if ((index < btif_max_av_clients) && (btif_av_cb[index].current_playing)
+        && (!btif_av_cb[index].is_remote_start_received))
     {
         return TRUE;
     }
@@ -2026,6 +2344,31 @@ int btif_get_latest_playing_device_idx()
         state = btif_sm_get_state(btif_av_cb[i].sm_handle);
         if (state == BTIF_AV_STATE_STARTED)
         {
+            BTIF_TRACE_IMP("Latest playing device index %d", i);
+            break;
+        }
+    }
+    return i;
+}
+
+/*******************************************************************************
+**
+** Function         btif_get_is_remote_started_idx
+**
+** Description      Get the index of AV where remote Start is received
+**
+** Returns          int
+**
+*******************************************************************************/
+
+int btif_get_is_remote_started_idx()
+{
+    int i;
+    for (i = 0; i < btif_max_av_clients; i++)
+    {
+        if (btif_av_cb[i].is_remote_start_received == TRUE)
+        {
+            BTIF_TRACE_IMP("remote started set for device index %d", i);
             break;
         }
     }
@@ -2230,9 +2573,25 @@ static void a2dp_offload_codec_cap_parser(const char *value)
 {
     char *tok = NULL;
     char *tmp_token = NULL;
+    int size = 0;
+    char *tmp_copy_buf = NULL;
+    if (value == NULL)
+    {
+        BTIF_TRACE_ERROR("%s: Offload String is NULL",__func__);
+        return;
+    }
+    size = strlen(value) + 1;
+    tmp_copy_buf = (char *) osi_malloc (size);
+    if (tmp_copy_buf == NULL)
+    {
+        BTIF_TRACE_ERROR("%s: Memorey allocation failed",__func__);
+        return;
+    }
+    memset(tmp_copy_buf, 0, size);
+    memcpy(tmp_copy_buf, value, size - 1);
     /* Fix for below Klockwork Issue
      * 'strtok' has been deprecated; replace it with a safe function. */
-    tok = strtok_r((char*)value, "-", &tmp_token);
+    tok = strtok_r((char*)tmp_copy_buf, "-", &tmp_token);
     while (tok != NULL)
     {
         if (strcmp(tok,"sbc") == 0)
@@ -2257,6 +2616,7 @@ static void a2dp_offload_codec_cap_parser(const char *value)
         }
         tok = strtok_r(NULL, "-", &tmp_token);
     };
+    osi_free_and_reset((void **) &tmp_copy_buf);
 }
 
 /******************************************************************************
@@ -2291,6 +2651,8 @@ bt_status_t btif_av_init(int service_id)
     {
         alarm_free(av_open_on_rc_timer);
         av_open_on_rc_timer = alarm_new("btif_av.av_open_on_rc_timer");
+        alarm_free(av_coll_detected_timer);
+        av_coll_detected_timer = alarm_new("btif_av.av_coll_detected_timer");
         BTIF_TRACE_DEBUG("%s", __FUNCTION__);
         if(!btif_a2dp_is_media_task_stopped())
             return BT_STATUS_FAIL;
@@ -2483,6 +2845,17 @@ void btif_av_trigger_dual_handoff(BOOLEAN handoff, BD_ADDR address)
         if (bt_split_a2dp_enabled)
             btif_media_on_stop_vendor_command();
         /*Initiate SUSPEND for this device*/
+
+        next_idx = btif_av_get_other_connected_idx(index);
+        if (next_idx != INVALID_INDEX && next_idx != btif_max_av_clients)
+        {
+            if (btif_av_cb[next_idx].is_remote_start_received)
+            {
+                btif_media_on_cancel_remote_start_alarm();
+                BTIF_TRACE_DEBUG("Reset remote start alarm on index = %d", next_idx);
+                btif_av_cb[next_idx].is_remote_start_received = FALSE;
+            }
+        }
         BTIF_TRACE_DEBUG("Initiate SUSPEND for this device on index = %d", index);
         btif_sm_dispatch(btif_av_cb[index].sm_handle, BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL);
     }
@@ -2492,12 +2865,12 @@ void btif_av_trigger_dual_handoff(BOOLEAN handoff, BD_ADDR address)
     }
     if (bt_split_a2dp_enabled)
     {
-        btif_media_send_reset_vendor_state();
         next_idx = btif_av_get_other_connected_idx(index);
         /* Fix for below Klockwork Issue
         Array 'btif_av_cb' of size 2 may use index value(s) -1 */
         if (next_idx != INVALID_INDEX && next_idx != btif_max_av_clients)
         {
+            reconfig_a2dp = TRUE;
             HAL_CBACK(bt_av_src_callbacks, reconfig_a2dp_trigger_cb, 1,
                                     &(btif_av_cb[next_idx].peer_bda));
         }
@@ -2572,6 +2945,8 @@ static bt_status_t connect_int(bt_bdaddr_t *bd_addr, uint16_t uuid)
 
         BTIF_TRACE_ERROR("%s: All indexes are full", __FUNCTION__);
 
+        btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED, bd_addr);
+
         /* Multicast: Check if AV slot is available for connection
          * If not available, AV got connected to different devices.
          * Disconnect this RC connection without AV connection.
@@ -2691,7 +3066,7 @@ static void allow_connection(int is_valid, bt_bdaddr_t *bd_addr)
                 }
                 BTIF_TRACE_DEBUG("The connection is allowed for the device at index = %d", index);
                 BTA_AvOpen(btif_av_cb[index].peer_bda.address, btif_av_cb[index].bta_handle,
-                       TRUE, BTA_SEC_NONE, UUID_SERVCLASS_AUDIO_SOURCE);
+                       TRUE, BTA_SEC_AUTHENTICATE, UUID_SERVCLASS_AUDIO_SOURCE);
             }
             else
             {
@@ -2817,6 +3192,7 @@ BOOLEAN btif_av_stream_ready(void)
          * Check the pending SUSPEND flag and return failure
          * if suspend is in progress.
          */
+        BTIF_TRACE_DEBUG("btif_av_stream_ready flags: %d", btif_av_cb[i].flags);
         if (btif_av_cb[i].dual_handoff ||
             (btif_av_cb[i].flags & BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING))
         {
@@ -2824,7 +3200,7 @@ BOOLEAN btif_av_stream_ready(void)
             break;
         }
         else if (btif_av_cb[i].flags &
-            (BTIF_AV_FLAG_REMOTE_SUSPEND|BTIF_AV_FLAG_PENDING_STOP))
+            (BTIF_AV_FLAG_REMOTE_SUSPEND|BTIF_AV_FLAG_PENDING_STOP|BTIF_AV_FLAG_PENDING_DISCONNECT))
         {
             status = FALSE;
             break;
@@ -2879,6 +3255,39 @@ BOOLEAN btif_av_stream_started_ready(void)
 
 /*******************************************************************************
 **
+** Function         btif_av_stream_started_ready
+**
+** Description      Checks whether AV ready for media start in streaming state
+**
+** Returns          None
+**
+*******************************************************************************/
+
+BOOLEAN btif_av_is_suspend_stop_pending_ack(void)
+{
+    int i;
+    BOOLEAN status = FALSE;
+
+    for (i = 0; i < btif_max_av_clients; i++)
+    {
+        btif_av_cb[i].state = btif_sm_get_state(btif_av_cb[i].sm_handle);
+        BTIF_TRACE_DEBUG("btif_av_stream_ready flags: %d, state: %d",
+                                btif_av_cb[i].flags, btif_av_cb[i].state);
+        if ((btif_av_cb[i].flags &
+            (BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING |
+            BTIF_AV_FLAG_PENDING_STOP)) &&
+            (btif_av_cb[i].state == BTIF_AV_STATE_STARTED))
+        {
+            status = TRUE;
+            break;
+        }
+    }
+    BTIF_TRACE_DEBUG("btif_av_is_stream_suspend_pending_ack: %d", status);
+    return status;
+}
+
+/*******************************************************************************
+**
 ** Function         btif_dispatch_sm_event
 **
 ** Description      Send event to AV statemachine
@@ -3322,6 +3731,7 @@ void btif_av_move_idle(bt_bdaddr_t bd_addr)
         BTA_AvClose(btif_av_cb[index].bta_handle);
         btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_IDLE);
         btif_queue_advance();
+        btif_av_check_and_start_collission_timer(index);
     }
 }
 /******************************************************************************
@@ -3512,17 +3922,19 @@ BOOLEAN btif_av_is_multicast_supported()
     return is_multicast_supported;
 }
 
-/******************************************************************************
-**
-** Function        btif_av_is_offload_supported
-**
-** Description     Returns split mode status
-**
-** Returns         TRUE if split mode is enabled, FALSE otherwise
-********************************************************************************/
-BOOLEAN btif_av_is_offload_supported()
+BOOLEAN btif_av_check_flag_remote_suspend(int index)
 {
-    return bt_split_a2dp_enabled;
+    BTIF_TRACE_ERROR("%s: index = %d",__FUNCTION__,index);
+    if (btif_av_cb[index].flags & BTIF_AV_FLAG_REMOTE_SUSPEND)
+    {
+        BTIF_TRACE_DEBUG("remote suspend flag set on index = %d",index);
+        return TRUE;
+    }
+    else
+    {
+        BTIF_TRACE_DEBUG("remote suspend flag not set on index = %d",index);
+        return FALSE;
+    }
 }
 
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
@@ -3566,7 +3978,7 @@ UINT16 btif_av_get_streaming_channel_id(void)
 **
 ** Function         btif_av_get_peer_addr
 **
-** Description     Returns peer device address
+** Description     Returns peer device address.
 **
 ** Returns          peer address
 ********************************************************************************/
@@ -3578,12 +3990,16 @@ void btif_av_get_peer_addr(bt_bdaddr_t *peer_bda)
     for (i = 0; i < btif_max_av_clients; i++)
     {
         state = btif_sm_get_state(btif_av_cb[i].sm_handle);
-        if (state == BTIF_AV_STATE_STARTED)
+        if ((state == BTIF_AV_STATE_OPENED) ||
+            (state == BTIF_AV_STATE_STARTED))
         {
-            BTIF_TRACE_DEBUG("btif_av_get_peer_addr: %u",
-                    btif_av_cb[i].peer_bda);
+            BTIF_TRACE_DEBUG("btif_av_get_peer_addr: %u state: %d ",
+                    btif_av_cb[i].peer_bda, state);
+            memset(peer_bda, 0, sizeof(bt_bdaddr_t));
             memcpy(peer_bda, &btif_av_cb[i].peer_bda,
                                     sizeof(bt_bdaddr_t));
+            if (state == BTIF_AV_STATE_STARTED)
+                break;
         }
     }
 }
@@ -3641,6 +4057,9 @@ tBTA_AV_HNDL btif_av_get_av_hdl_from_idx(UINT8 idx)
 BOOLEAN btif_av_is_codec_offload_supported(int codec)
 {
     BOOLEAN ret = FALSE;
+    int retval;
+    char value[255] = "false";
+
     BTIF_TRACE_DEBUG("btif_av_is_codec_offload_supported = %s",dump_av_codec_name(codec));
     switch(codec)
     {
@@ -3652,6 +4071,11 @@ BOOLEAN btif_av_is_codec_offload_supported(int codec)
             break;
         case AAC:
             ret = btif_av_codec_offload.aac_offload;
+            retval = property_get("persist.bt.a2dp.aac_disable", value, "false");
+            BTIF_TRACE_DEBUG("%s: property_get: bt.a2dp.aac_disable: %s, retval: %d", __func__, value, retval);
+            if (strncmp(value, "true", 5) == 0) {
+                ret = FALSE;
+            }
             break;
         case APTXHD:
             ret = btif_av_codec_offload.aptxhd_offload;
@@ -3688,10 +4112,46 @@ BOOLEAN btif_av_is_under_handoff()
              * initiated locally then return false, otherwise wait till the suspend cfm
              * is received from the remote.
              */
+            BTIF_TRACE_DEBUG("AV is under handoff");
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+BOOLEAN btif_av_is_device_disconnecting()
+{
+    int i;
+    btif_sm_state_t state = BTIF_AV_STATE_IDLE;
+    BTIF_TRACE_DEBUG("btif_av_is_device_disconnecting");
+    for (i = 0; i < btif_max_av_clients; i++)
+    {
+        state = btif_sm_get_state(btif_av_cb[i].sm_handle);
+        BTIF_TRACE_DEBUG("%s: state = %d",__func__,state);
+        if ((btif_av_cb[i].dual_handoff &&
+            state == BTIF_AV_STATE_CLOSING))
+        {
+            BTIF_TRACE_DEBUG("Device disconnecting");
             return TRUE;
         }
     }
     return FALSE;
 }
+
+void btif_av_reset_reconfig_flag()
+{
+    int i;
+    BTIF_TRACE_DEBUG("%s",__func__);
+    reconfig_a2dp = FALSE;
+    for (i = 0; i < btif_max_av_clients; i++)
+    {
+        if (btif_av_cb[i].dual_handoff)
+        {
+            BTIF_TRACE_DEBUG("%s resetting dual handoff flag for index %d",
+                __func__, i);
+            btif_av_cb[i].dual_handoff = FALSE;
+        }
+    }
+}
 #endif
 
diff --git a/btif/src/btif_avrcp_audio_track.cpp b/btif/src/btif_avrcp_audio_track.cpp
index cd9cf9a..89d2a5f 100644
--- a/btif/src/btif_avrcp_audio_track.cpp
+++ b/btif/src/btif_avrcp_audio_track.cpp
@@ -15,6 +15,8 @@
  */
 
 //#define LOG_NDEBUG 0
+#define LOG_TAG "bt_btif_avrcp_audio_track"
+
 #include "btif_avrcp_audio_track.h"
 
 #include <media/AudioTrack.h>
diff --git a/btif/src/btif_config.c b/btif/src/btif_config.c
index 2e7e19f..b2b4b68 100644
--- a/btif/src/btif_config.c
+++ b/btif/src/btif_config.c
@@ -52,6 +52,8 @@
 #include <cutils/properties.h>
 #endif  /* !defined(OS_GENERIC) */
 
+#define BT_CONFIG_SOURCE_TAG_NUM 1010001
+
 #define INFO_SECTION "Info"
 #define FILE_TIMESTAMP "TimeCreated"
 #define FILE_SOURCE "FileSource"
@@ -201,6 +203,8 @@ static future_t *init(void) {
     goto error;
   }
 
+  LOG_EVENT_INT(BT_CONFIG_SOURCE_TAG_NUM, btif_config_source);
+
   pthread_mutex_unlock(&lock);
   return future_new_immediate(FUTURE_SUCCESS);
 
diff --git a/btif/src/btif_config_transcode.cpp b/btif/src/btif_config_transcode.cpp
index e9d859e..e8bd1a2 100644
--- a/btif/src/btif_config_transcode.cpp
+++ b/btif/src/btif_config_transcode.cpp
@@ -31,19 +31,19 @@ extern "C" config_t *btif_config_transcode(const char *xml_filename) {
   XMLDocument document;
   int error = document.LoadFile(xml_filename);
   if (error != XML_SUCCESS) {
-    LOG_ERROR("%s unable to load XML file '%s': %d", __func__, xml_filename, error);
+    LOG_ERROR(LOG_TAG, "%s unable to load XML file '%s': %d", __func__, xml_filename, error);
     return NULL;
   }
 
   XMLElement *rootElement = document.RootElement();
   if (!rootElement) {
-    LOG_ERROR("%s unable to find root element; assuming corrupted config file.", __func__);
+    LOG_ERROR(LOG_TAG, "%s unable to find root element; assuming corrupted config file.", __func__);
     return NULL;
   }
 
   config_t *config = config_new_empty();
   if (!config) {
-    LOG_ERROR("%s unable to allocate config object.", __func__);
+    LOG_ERROR(LOG_TAG, "%s unable to allocate config object.", __func__);
     return NULL;
   }
 
diff --git a/btif/src/btif_core.c b/btif/src/btif_core.c
index 1f6b35b..ef73e89 100644
--- a/btif/src/btif_core.c
+++ b/btif/src/btif_core.c
@@ -177,17 +177,20 @@ void bte_main_config_hci_logging(BOOLEAN enable, BOOLEAN bt_disabled);
 
 static void btif_context_switched(void *p_msg)
 {
-
-    BTIF_TRACE_VERBOSE("btif_context_switched");
-
     tBTIF_CONTEXT_SWITCH_CBACK *p = (tBTIF_CONTEXT_SWITCH_CBACK *) p_msg;
 
     /* each callback knows how to parse the data */
     if (p->p_cb)
+    {
+        BTIF_TRACE_VERBOSE("btif_context_switched for event: %u", p->event);
         p->p_cb(p->event, p->p_param);
+    }
+    else
+    {
+        BTIF_TRACE_ERROR("btif_context_switched with null callback");
+    }
 }
 
-
 /*******************************************************************************
 **
 ** Function         btif_transfer_context
diff --git a/btif/src/btif_debug_l2c.c b/btif/src/btif_debug_l2c.c
new file mode 100644
index 0000000..5a04135
--- /dev/null
+++ b/btif/src/btif_debug_l2c.c
@@ -0,0 +1,159 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Google Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <time.h>
+
+#include "btcore/include/bdaddr.h"
+#include "btif/include/btif_debug.h"
+#include "btif/include/btif_debug_l2c.h"
+
+#define NUM_UPDATE_REQUESTS 5
+#define NUM_UPDATE_RESPONSES 5
+
+#define INTERVAL_1_25_MS_MULTIPLIER 1.25f
+#define TIMEOUT_10_MS_MULTIPLIER 10
+
+typedef enum {
+  BTIF_DEBUG_CONNECTION_UPDATE_REQUEST,
+  BTIF_DEBUG_CONNECTION_UPDATE_RESPONSE,
+} btif_debug_ble_conn_update_t;
+
+/* Shared Connection update record for both request and response. */
+typedef struct ble_conn_update_t {
+  uint64_t timestamp_ms;
+  bt_bdaddr_t bda;
+  btif_debug_ble_conn_update_t type;
+  uint8_t status;         /* Not populated for request. */
+  uint16_t min_interval;  /* Not populated for response. */
+  uint16_t max_interval;
+  uint16_t latency;
+  uint16_t timeout;
+} ble_conn_update_t;
+
+static int update_request_index;
+static int update_response_index;
+static ble_conn_update_t last_ble_conn_update_requests[NUM_UPDATE_REQUESTS];
+static ble_conn_update_t last_ble_conn_update_responses[NUM_UPDATE_RESPONSES];
+
+static int dump_connection_update(int fd, const ble_conn_update_t *update) {
+  if (!update || update->timestamp_ms == 0) {
+    return -1;
+  }
+
+  /* Format timestamp */
+  const uint64_t msecs = update->timestamp_ms / 1000;
+  const time_t secs = msecs / 1000;
+  struct tm *ptm = localtime(&secs);
+  char time_buf[20] = {0};
+  strftime(time_buf, sizeof(time_buf), "%m-%d %H:%M:%S", ptm);
+  snprintf(time_buf, sizeof(time_buf), "%s.%03u", time_buf,
+      (uint16_t)(msecs % 1000));
+
+  /* Format address */
+  char addr_buf[18] = {0};
+  bdaddr_to_string(&update->bda, addr_buf, sizeof(addr_buf));
+
+  if (update->type == BTIF_DEBUG_CONNECTION_UPDATE_REQUEST) {
+    dprintf(fd,
+        "  %s %s min interval=%d (%.2fms) max interval=%d (%.2fms) "
+        "latency parameter=%d timeout multiplier=%d (%dms)\n",
+        time_buf, addr_buf, update->min_interval,
+        (float)update->min_interval * INTERVAL_1_25_MS_MULTIPLIER,
+        update->max_interval,
+        (float)update->max_interval * INTERVAL_1_25_MS_MULTIPLIER,
+        update->latency, update->timeout,
+        update->timeout * TIMEOUT_10_MS_MULTIPLIER);
+  } else {
+    dprintf(fd,
+        "  %s %s status=%d interval=%d (%.2fms) latency parameter=%d "
+        "timeout multiplier=%d (%dms)\n", time_buf,
+        addr_buf, update->status, update->max_interval,
+        (float)update->max_interval * INTERVAL_1_25_MS_MULTIPLIER,
+        update->latency, update->timeout,
+        update->timeout * TIMEOUT_10_MS_MULTIPLIER);
+  }
+
+  return 0;
+}
+
+static void record_connection_update(bt_bdaddr_t bda, uint8_t status,
+    uint16_t min_interval, uint16_t max_interval, uint16_t latency,
+    uint16_t timeout, btif_debug_ble_conn_update_t type,
+    ble_conn_update_t* update) {
+
+  memcpy(&update->bda, &bda, sizeof(bt_bdaddr_t));
+  update->type = type;
+  update->timestamp_ms = btif_debug_ts();
+  update->min_interval = min_interval;
+  update->max_interval = max_interval;
+  update->latency = latency;
+  update->timeout = timeout;
+  update->status = 0;
+}
+
+void btif_debug_ble_connection_update_request(bt_bdaddr_t bda,
+    uint16_t min_interval, uint16_t max_interval, uint16_t slave_latency_param,
+    uint16_t timeout_multiplier) {
+  ble_conn_update_t *request =
+      &last_ble_conn_update_requests[update_request_index];
+
+  record_connection_update(bda, 0, min_interval, max_interval, slave_latency_param,
+      timeout_multiplier, BTIF_DEBUG_CONNECTION_UPDATE_REQUEST, request);
+
+  update_request_index = (update_request_index == NUM_UPDATE_REQUESTS - 1) ?
+      0 : update_request_index + 1;
+}
+
+void btif_debug_ble_connection_update_response(bt_bdaddr_t bda, uint8_t status,
+    uint16_t interval, uint16_t slave_latency_param,
+    uint16_t timeout_multiplier) {
+  ble_conn_update_t *response =
+      &last_ble_conn_update_responses[update_response_index];
+
+  record_connection_update(bda, status, 0, interval, slave_latency_param,
+      timeout_multiplier, BTIF_DEBUG_CONNECTION_UPDATE_RESPONSE, response);
+
+  update_response_index = (update_response_index == NUM_UPDATE_RESPONSES - 1) ?
+      0 : update_response_index + 1;
+}
+
+void btif_debug_l2c_dump(int fd) {
+  dprintf(fd, "\nLE Connection Parameter Updates:\n");
+
+  int i;
+  dprintf(fd, "  Last %d Request(s):\n", NUM_UPDATE_REQUESTS);
+  for (i = 0; i < NUM_UPDATE_REQUESTS; ++i) {
+    if (dump_connection_update(fd, &last_ble_conn_update_requests[i]) < 0 &&
+        i == 0) {
+      dprintf(fd, "  None\n");
+      break;
+    }
+  }
+
+  dprintf(fd, "\n  Last %d Response(s):\n", NUM_UPDATE_RESPONSES);
+  for (i = 0; i < NUM_UPDATE_RESPONSES; ++i) {
+    if (dump_connection_update(fd, &last_ble_conn_update_responses[i]) < 0 &&
+        i == 0) {
+      dprintf(fd, "  None\n");
+      break;
+    }
+  }
+}
diff --git a/btif/src/btif_dm.c b/btif/src/btif_dm.c
index 5879011..75cccde 100644
--- a/btif/src/btif_dm.c
+++ b/btif/src/btif_dm.c
@@ -230,6 +230,7 @@ static void btif_dm_ble_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl);
 static void btif_dm_ble_passkey_req_evt(tBTA_DM_PIN_REQ *p_pin_req);
 static void btif_dm_ble_key_nc_req_evt(tBTA_DM_SP_KEY_NOTIF *p_notif_req) ;
 static void btif_dm_ble_oob_req_evt(tBTA_DM_SP_RMT_OOB *req_oob_type);
+static void btif_dm_ble_sc_oob_req_evt(tBTA_DM_SP_RMT_OOB *req_oob_type);
 #endif
 
 static void bte_scan_filt_param_cfg_evt(UINT8 action_type,
@@ -370,7 +371,7 @@ static BOOLEAN check_eir_is_remote_name_short(tBTA_DM_SEARCH *p_search_data)
     if (p_search_data->inq_res.p_eir)
     {
         p_eir_remote_name = BTM_CheckEirData(p_search_data->inq_res.p_eir,
-                         BTM_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len);
+                BTM_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len, p_search_data->inq_res.adv_data_len);
 
         if (p_eir_remote_name)
         {
@@ -400,11 +401,11 @@ static BOOLEAN check_eir_remote_name(tBTA_DM_SEARCH *p_search_data,
     if (p_search_data->inq_res.p_eir)
     {
         p_eir_remote_name = BTM_CheckEirData(p_search_data->inq_res.p_eir,
-                BTM_EIR_COMPLETE_LOCAL_NAME_TYPE, &remote_name_len);
+                BTM_EIR_COMPLETE_LOCAL_NAME_TYPE, &remote_name_len, p_search_data->inq_res.adv_data_len);
         if (!p_eir_remote_name)
         {
             p_eir_remote_name = BTM_CheckEirData(p_search_data->inq_res.p_eir,
-                    BTM_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len);
+                    BTM_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len, p_search_data->inq_res.adv_data_len);
         }
 
         if (p_eir_remote_name)
@@ -645,15 +646,19 @@ static void bond_state_changed(bt_status_t status, bt_bdaddr_t *bd_addr, bt_bond
                       state, pairing_cb.state, pairing_cb.sdp_attempts);
 
     HAL_CBACK(bt_hal_cbacks, bond_state_changed_cb, status, bd_addr, state);
-
     if (state == BT_BOND_STATE_BONDING)
     {
         pairing_cb.state = state;
         bdcpy(pairing_cb.bd_addr, bd_addr->address);
-    } else {
+    } else if ((state == BT_BOND_STATE_NONE)&&
+        ((bdcmp(bd_addr->address, pairing_cb.bd_addr) == 0) ||
+        (bdcmp(bd_addr->address, pairing_cb.static_bdaddr.address) == 0)))
+    {
+        memset(&pairing_cb, 0, sizeof(pairing_cb));
+    }else{
         if ((!pairing_cb.sdp_attempts)&&
             ((bdcmp(bd_addr->address, pairing_cb.bd_addr) == 0) ||
-             (bdcmp(bd_addr->address, pairing_cb.static_bdaddr.address) == 0)))
+            (bdcmp(bd_addr->address, pairing_cb.static_bdaddr.address) == 0)))
             memset(&pairing_cb, 0, sizeof(pairing_cb));
         else
             BTIF_TRACE_DEBUG("%s: BR-EDR service discovery active", __func__);
@@ -814,7 +819,15 @@ static void btif_dm_cb_create_bond(bt_bdaddr_t *bd_addr, tBTA_TRANSPORT transpor
         }
         if (btif_storage_get_remote_addr_type(bd_addr, &addr_type) != BT_STATUS_SUCCESS)
         {
-            btif_storage_set_remote_addr_type(bd_addr, BLE_ADDR_PUBLIC);
+
+            // Try to read address type. OOB pairing might have set it earlier, but
+            // didn't store it, it defaults to BLE_ADDR_PUBLIC
+            uint8_t tmp_dev_type;
+            uint8_t tmp_addr_type;
+            BTM_ReadDevInfo(bd_addr->address, &tmp_dev_type, &tmp_addr_type);
+            addr_type = tmp_addr_type;
+
+            btif_storage_set_remote_addr_type(bd_addr, addr_type);
         }
     }
     if((btif_config_get_int((char const *)&bdstr,"DevType", &device_type) &&
@@ -944,7 +957,7 @@ static void search_devices_copy_cb(UINT16 event, char *p_dest, char *p_src)
             if (p_src_data->inq_res.p_eir)
             {
                 p_dest_data->inq_res.p_eir = (UINT8 *)(p_dest + sizeof(tBTA_DM_SEARCH));
-                memcpy(p_dest_data->inq_res.p_eir, p_src_data->inq_res.p_eir, HCI_EXT_INQ_RESPONSE_LEN);
+                memcpy(p_dest_data->inq_res.p_eir, p_src_data->inq_res.p_eir, p_src_data->inq_res.adv_data_len);
             }
         }
         break;
@@ -1051,14 +1064,14 @@ static void btif_dm_pin_req_evt(tBTA_DM_PIN_REQ *p_pin_req)
             return;
         }
         if (check_cod(&bd_addr, COD_AV_HEADSETS) ||
-            check_cod(&bd_addr, COD_AV_HANDSFREE) ||
             check_cod(&bd_addr, COD_AV_HEADPHONES) ||
+            check_cod(&bd_addr, COD_AV_HANDSFREE) ||
             check_cod(&bd_addr, COD_AV_PORTABLE_AUDIO) ||
             check_cod(&bd_addr, COD_AV_HIFI_AUDIO) ||
             check_cod(&bd_addr, COD_HID_POINTING))
         {
             /*  Check if this device can be auto paired  */
-            if (!interop_match_addr(INTEROP_DISABLE_AUTO_PAIRING, &bd_addr) &&
+            if (!interop_match_addr(INTEROP_DISABLE_AUTO_PAIRING, (bt_bdaddr_t *)&bd_addr) &&
                 !interop_match_name(INTEROP_DISABLE_AUTO_PAIRING, (const char *)bd_name.name) &&
                 (pairing_cb.autopair_attempts == 0))
             {
@@ -1076,7 +1089,7 @@ static void btif_dm_pin_req_evt(tBTA_DM_PIN_REQ *p_pin_req)
         else if (check_cod(&bd_addr, COD_HID_KEYBOARD) ||
                  check_cod(&bd_addr, COD_HID_COMBO))
         {
-            if ((interop_match_addr(INTEROP_KEYBOARD_REQUIRES_FIXED_PIN, &bd_addr) == TRUE) &&
+            if ((interop_match_addr(INTEROP_KEYBOARD_REQUIRES_FIXED_PIN, (bt_bdaddr_t *)&bd_addr) == TRUE) &&
                 (pairing_cb.autopair_attempts == 0))
             {
                 BTIF_TRACE_DEBUG("%s() Attempting auto pair", __FUNCTION__);
@@ -1168,6 +1181,19 @@ static void btif_dm_ssp_cfm_req_evt(tBTA_DM_SP_CFM_REQ *p_ssp_cfm_req)
             BTIF_TRACE_EVENT("%s: User consent needed for incoming pairing request. loc_io_caps: %d, rmt_io_caps: %d",
                 __FUNCTION__, p_ssp_cfm_req->loc_io_caps, p_ssp_cfm_req->rmt_io_caps);
         }
+        /* Errata:4348
+         * Pairing confirmation for JustWorks needed if:
+         * 1. Outgoing (non-temporary) pairing is detected AND
+         * 2. local IO capabilities are DisplayYesNo AND
+         * 3. remote IO capbiltiies are NoInputNoOutput
+         */
+        else if (!is_incoming && pairing_cb.bond_type != BOND_TYPE_TEMPORARY &&
+                (p_ssp_cfm_req->loc_io_caps == HCI_IO_CAP_DISPLAY_YESNO) &&
+                (p_ssp_cfm_req->rmt_io_caps == HCI_IO_CAP_NO_IO))
+        {
+            BTIF_TRACE_EVENT("%s: Show pairing pop up for outgoing pairing when loc_io_caps: %d, rmt_io_caps: %d",
+                __FUNCTION__, p_ssp_cfm_req->loc_io_caps, p_ssp_cfm_req->rmt_io_caps);
+        }
         else
         {
             BTIF_TRACE_EVENT("%s: Auto-accept JustWorks pairing", __FUNCTION__);
@@ -1275,6 +1301,23 @@ static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
     // Skip SDP for certain  HID Devices
     if (p_auth_cmpl->success)
     {
+        // We could have received a new link key without going through the pairing flow.
+        // If so, we don't want to perform SDP or any other operations on the authenticated
+        // device. Also, make sure that the link key is not derived from secure LTK, because
+        // we will need to perform SDP in case of link key derivation to allow bond state change
+        // notification for the BR/EDR transport so that the subsequent BR/EDR connections
+        // to the remote can use the derived link key.
+        if ((bdcmp(p_auth_cmpl->bd_addr, pairing_cb.bd_addr) != 0) &&
+              (!pairing_cb.ble.is_penc_key_rcvd)) {
+            char address[32];
+            bt_bdaddr_t bt_bdaddr;
+
+            memcpy(bt_bdaddr.address, p_auth_cmpl->bd_addr,
+                  sizeof(bt_bdaddr.address));
+            bdaddr_to_string(&bt_bdaddr, address, sizeof(address));
+            LOG_INFO(LOG_TAG, "%s skipping SDP since we did not initiate pairing to %s.", __func__, address);
+            return;
+        }
 #if BLE_INCLUDED == TRUE
         btif_storage_set_remote_addr_type(&bd_addr, p_auth_cmpl->addr_type);
 #endif
@@ -1309,8 +1352,6 @@ static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
             status = BT_STATUS_SUCCESS;
             state = BT_BOND_STATE_BONDED;
 
-            /* Trigger SDP on the device */
-            pairing_cb.sdp_attempts = 1;
 
 #if BLE_INCLUDED == TRUE
             BOOLEAN is_crosskey = FALSE;
@@ -1345,8 +1386,9 @@ static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
         switch(p_auth_cmpl->fail_reason)
         {
             case HCI_ERR_PAGE_TIMEOUT:
-                if (interop_match_addr(INTEROP_AUTO_RETRY_PAIRING, &bd_addr)
-                    && pairing_cb.timeout_retries)
+                if ((pairing_cb.timeout_retries == NUM_TIMEOUT_RETRIES) ||
+                   (interop_match_addr(INTEROP_AUTO_RETRY_PAIRING, (bt_bdaddr_t *)&bd_addr)
+                    && pairing_cb.timeout_retries))
                 {
                     BTIF_TRACE_WARNING("%s() - Pairing timeout; retrying (%d) ...", __FUNCTION__, pairing_cb.timeout_retries);
                     --pairing_cb.timeout_retries;
@@ -1367,9 +1409,12 @@ static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
                 status =  BT_STATUS_AUTH_FAILURE;
                 break;
 
+            /* Dont fail the bonding for key missing error as stack retry security */
+            case HCI_ERR_KEY_MISSING:
+                btif_storage_remove_bonded_device(&bd_addr);
+                return;
             /* map the auth failure codes, so we can retry pairing if necessary */
             case HCI_ERR_AUTH_FAILURE:
-            case HCI_ERR_KEY_MISSING:
                 btif_storage_remove_bonded_device(&bd_addr);
             case HCI_ERR_HOST_REJECT_SECURITY:
             case HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE:
@@ -1378,6 +1423,7 @@ static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
             case HCI_ERR_INSUFFCIENT_SECURITY:
             case HCI_ERR_PEER_USER:
             case HCI_ERR_UNSPECIFIED:
+            case HCI_ERR_REPEATED_ATTEMPTS:
                 BTIF_TRACE_DEBUG(" %s() Authentication fail reason %d",
                     __FUNCTION__, p_auth_cmpl->fail_reason);
                 if (pairing_cb.autopair_attempts  == 1)
@@ -1397,6 +1443,13 @@ static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
             default:
                 status =  BT_STATUS_FAIL;
         }
+        if(p_auth_cmpl->fail_reason == HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE
+                || p_auth_cmpl->fail_reason == HCI_ERR_UNIT_KEY_USED
+                || p_auth_cmpl->fail_reason == HCI_ERR_INSUFFCIENT_SECURITY
+                || p_auth_cmpl->fail_reason == HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED
+                || p_auth_cmpl->fail_reason == HCI_ERR_HOST_REJECT_SECURITY
+                || p_auth_cmpl->fail_reason == HCI_ERR_UNSPECIFIED)
+            GENERATE_VND_LOGS();
         /* Special Handling for HID Devices */
         if (check_cod(&bd_addr, COD_HID_POINTING)) {
             /* Remove Device as bonded in nvram as authentication failed */
@@ -1673,16 +1726,18 @@ static void btif_dm_search_services_evt(UINT16 event, char *p_param)
                  (bdcmp(p_data->disc_res.bd_addr, pairing_cb.static_bdaddr.address) == 0)) &&
                   pairing_cb.sdp_attempts > 0)
             {
-                 BTIF_TRACE_DEBUG("%s Remote Service SDP done. Call bond_state_changed_cb BONDED",
-                                   __FUNCTION__);
-                 pairing_cb.sdp_attempts  = 0;
-
-                 // If bonding occured due to cross-key pairing, send bonding callback
-                 // for static address now
-                 if (bdcmp(p_data->disc_res.bd_addr, pairing_cb.static_bdaddr.address) == 0)
+                BTIF_TRACE_DEBUG("%s Remote Service SDP done. Call bond_state_changed_cb BONDED",
+                                __FUNCTION__);
+                if(p_data->disc_res.result != BTA_SUCCESS)
+                    GENERATE_VND_LOGS();
+                pairing_cb.sdp_attempts  = 0;
+
+                // If bonding occured due to cross-key pairing, send bonding callback
+                // for static address now
+                if (bdcmp(p_data->disc_res.bd_addr, pairing_cb.static_bdaddr.address) == 0)
                     bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);
 
-                 bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDED);
+                bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDED);
             }
 
             if (p_data->disc_res.num_uuids != 0)
@@ -1718,6 +1773,10 @@ static void btif_dm_search_services_evt(UINT16 event, char *p_param)
             /* fixme */
         break;
 
+        case BTA_DM_SEARCH_CANCEL_CMPL_EVT:
+            /* no-op */
+        break;
+
 #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
         case BTA_DM_DISC_BLE_RES_EVT:
              BTIF_TRACE_DEBUG("%s:, services 0x%x)", __FUNCTION__,
@@ -1853,7 +1912,7 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
     uint32_t i;
     bt_bdaddr_t bd_addr;
 
-    BTIF_TRACE_EVENT("btif_dm_upstreams_cback  ev: %s", dump_dm_event(event));
+    BTIF_TRACE_EVENT("%s: ev: %s", __func__, dump_dm_event(event));
 
     switch (event)
     {
@@ -1938,6 +1997,7 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
                 bdcpy(bd_addr.address, pairing_cb.bd_addr);
                 btm_set_bond_type_dev(pairing_cb.bd_addr, BOND_TYPE_UNKNOWN);
                 bond_state_changed(p_data->bond_cancel_cmpl.result, &bd_addr, BT_BOND_STATE_NONE);
+                btif_dm_remove_bond(&bd_addr);
             }
             break;
 
@@ -2136,6 +2196,10 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
             BTIF_TRACE_DEBUG("BTA_DM_BLE_OOB_REQ_EVT. ");
             btif_dm_ble_oob_req_evt(&p_data->rmt_oob);
             break;
+        case BTA_DM_BLE_SC_OOB_REQ_EVT:
+            BTIF_TRACE_DEBUG("BTA_DM_BLE_SC_OOB_REQ_EVT. ");
+            btif_dm_ble_sc_oob_req_evt(&p_data->rmt_oob);
+            break;
         case BTA_DM_BLE_LOCAL_IR_EVT:
             BTIF_TRACE_DEBUG("BTA_DM_BLE_LOCAL_IR_EVT. ");
             ble_local_key_cb.is_id_keys_rcvd = TRUE;
@@ -2283,7 +2347,9 @@ static void btif_dm_generic_evt(UINT16 event, char* p_param)
             }
             break;
         case BTIF_DM_CB_LE_TX_TEST:
+        case BTIF_DM_CB_LE_ENH_TX_TEST:
         case BTIF_DM_CB_LE_RX_TEST:
+        case BTIF_DM_CB_LE_ENH_RX_TEST:
             {
                 uint8_t status;
                 STREAM_TO_UINT8(status, p_param);
@@ -2351,7 +2417,7 @@ static void bte_search_devices_evt(tBTA_DM_SEARCH_EVT event, tBTA_DM_SEARCH *p_d
         case BTA_DM_INQ_RES_EVT:
         {
             if (p_data && p_data->inq_res.p_eir)
-                param_len += HCI_EXT_INQ_RESPONSE_LEN;
+                param_len += p_data->inq_res.adv_data_len;
         }
         break;
 
@@ -2604,6 +2670,19 @@ bt_status_t btif_dm_create_bond_out_of_band(const bt_bdaddr_t *bd_addr, int tran
     bdcpy(oob_cb.bdaddr, bd_addr->address);
     memcpy(&oob_cb.oob_data, oob_data, sizeof(bt_out_of_band_data_t));
 
+    uint8_t empty[] = {0, 0, 0, 0, 0, 0, 0};
+    // If LE Bluetooth Device Address is provided, use provided address type
+    // value.
+    if (memcmp(oob_data->le_bt_dev_addr, empty, 7) != 0) {
+        /* byte no 7 is address type in LE Bluetooth Address OOB data */
+        uint8_t address_type = oob_data->le_bt_dev_addr[6];
+        if (address_type == BLE_ADDR_PUBLIC || address_type == BLE_ADDR_RANDOM) {
+            // bd_addr->address is already reversed, so use it instead of
+            // oob_data->le_bt_dev_addr
+            BTM_SecAddBleDevice(bd_addr->address, NULL, BT_DEVICE_TYPE_BLE, address_type);
+        }
+    }
+
     bdstr_t bdstr;
     BTIF_TRACE_EVENT("%s: bd_addr=%s, transport=%d", __FUNCTION__, bdaddr_to_string(bd_addr, bdstr, sizeof(bdstr)), transport);
     return btif_dm_create_bond(bd_addr, transport);
@@ -2918,10 +2997,15 @@ bt_status_t btif_dm_get_adapter_property(bt_property_t *prop)
 *******************************************************************************/
 bt_status_t btif_dm_get_remote_services(bt_bdaddr_t *remote_addr)
 {
-    bdstr_t bdstr;
+    bdstr_t bdstr = {'\0'};
 
     BTIF_TRACE_EVENT("%s: remote_addr=%s", __FUNCTION__, bdaddr_to_string(remote_addr, bdstr, sizeof(bdstr)));
 
+    if (bdaddr_is_empty(remote_addr))
+    {
+        BTIF_TRACE_WARNING("%s: remote_addr =%s not valid.", __FUNCTION__, bdaddr_to_string(remote_addr, bdstr, sizeof(bdstr)));
+        return BT_STATUS_FAIL;
+    }
     BTA_DmDiscover(remote_addr->address, BTA_ALL_SERVICE_MASK,
                    bte_dm_search_services_evt, TRUE);
 
@@ -3076,29 +3160,36 @@ void btif_dm_set_oob_for_le_io_req(BD_ADDR bd_addr, tBTA_OOB_DATA  *p_has_oob_da
                                    tBTA_LE_AUTH_REQ *p_auth_req)
 {
 
-    /* We currently support only Security Manager TK as OOB data for LE transport.
-       If it's not present mark no OOB data.
-     */
-    if (!is_empty_128bit(oob_cb.oob_data.sm_tk))
-    {
+    if (!is_empty_128bit(oob_cb.oob_data.le_sc_c) &&
+        !is_empty_128bit(oob_cb.oob_data.le_sc_r)) {
+        /* We have LE SC OOB data */
+
+        /* make sure OOB data is for this particular device */
+        if (memcmp(bd_addr, oob_cb.bdaddr, BD_ADDR_LEN) == 0) {
+            *p_auth_req = ((*p_auth_req) | BTM_LE_AUTH_REQ_SC_ONLY);
+            *p_has_oob_data = true;
+        } else {
+            *p_has_oob_data = false;
+            BTIF_TRACE_WARNING("%s: remote address didn't match OOB data address",
+                               __func__);
+        }
+    } else if (!is_empty_128bit(oob_cb.oob_data.sm_tk)) {
+        /* We have security manager TK */
+
         /* make sure OOB data is for this particular device */
         if (memcmp(bd_addr, oob_cb.bdaddr, BD_ADDR_LEN) == 0) {
             // When using OOB with TK, SC Secure Connections bit must be disabled.
             tBTA_LE_AUTH_REQ mask = ~BTM_LE_AUTH_REQ_SC_ONLY;
             *p_auth_req = ((*p_auth_req) & mask);
 
-            *p_has_oob_data = TRUE;
-        }
-        else
-        {
-            *p_has_oob_data = FALSE;
+            *p_has_oob_data = true;
+        } else {
+            *p_has_oob_data = false;
             BTIF_TRACE_WARNING("%s: remote address didn't match OOB data address",
                                __func__);
         }
-    }
-    else
-    {
-        *p_has_oob_data = FALSE;
+    } else {
+        *p_has_oob_data = false;
     }
     BTIF_TRACE_DEBUG("%s *p_has_oob_data=%d", __func__, *p_has_oob_data);
 }
@@ -3343,7 +3434,10 @@ static void btif_dm_ble_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
         } else {
             btif_dm_save_ble_bonding_keys();
             BTA_GATTC_Refresh(bd_addr.address);
-            btif_dm_get_remote_services_by_transport(&bd_addr, BTA_GATT_TRANSPORT_LE);
+            if(!p_auth_cmpl->smp_over_br)
+               btif_dm_get_remote_services_by_transport(&bd_addr, BTA_GATT_TRANSPORT_LE);
+            else
+               btif_dm_get_remote_services(&bd_addr);
         }
     }
     else
@@ -3353,6 +3447,8 @@ static void btif_dm_ble_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
         {
             case BTA_DM_AUTH_SMP_PAIR_AUTH_FAIL:
             case BTA_DM_AUTH_SMP_CONFIRM_VALUE_FAIL:
+            case BTA_DM_AUTH_SMP_UNKNOWN_ERR:
+            case BTA_DM_AUTH_SMP_CONN_TOUT:
                 btif_dm_remove_ble_bonding_keys();
                 status = BT_STATUS_AUTH_FAILURE;
                 break;
@@ -3594,10 +3690,9 @@ static void btif_dm_ble_oob_req_evt(tBTA_DM_SP_RMT_OOB *req_oob_type)
 
     bt_bdaddr_t bd_addr;
     bdcpy(bd_addr.address, req_oob_type->bd_addr);
-
-    /* We currently support only Security Manager TK as OOB data. We already
-     * checked if it's present in btif_dm_set_oob_for_le_io_req, but check here
-     * again. If it's not present do nothing, pairing will timeout.
+    /* We already checked if OOB data is present in
+     * btif_dm_set_oob_for_le_io_req, but check here again. If it's not present
+     * do nothing, pairing will timeout.
      */
     if (is_empty_128bit(oob_cb.oob_data.sm_tk)) {
         return;
@@ -3621,6 +3716,44 @@ static void btif_dm_ble_oob_req_evt(tBTA_DM_SP_RMT_OOB *req_oob_type)
     BTM_BleOobDataReply(req_oob_type->bd_addr, 0, 16, oob_cb.oob_data.sm_tk);
 }
 
+
+static void btif_dm_ble_sc_oob_req_evt(tBTA_DM_SP_RMT_OOB *req_oob_type)
+{
+    BTIF_TRACE_DEBUG("%s", __func__);
+
+    bt_bdaddr_t bd_addr;
+    bdcpy(bd_addr.address, req_oob_type->bd_addr);
+
+    /* We already checked if OOB data is present in
+     * btif_dm_set_oob_for_le_io_req, but check here again. If it's not present
+     * do nothing, pairing will timeout.
+     */
+    if (is_empty_128bit(oob_cb.oob_data.le_sc_c) &&
+        is_empty_128bit(oob_cb.oob_data.le_sc_r)) {
+        BTIF_TRACE_WARNING("%s: LE SC OOB data is empty", __func__);
+        return;
+    }
+
+    /* make sure OOB data is for this particular device */
+    if (memcmp(req_oob_type->bd_addr, oob_cb.bdaddr, BD_ADDR_LEN) != 0) {
+        BTIF_TRACE_WARNING("%s: remote address didn't match OOB data address", __func__);
+        return;
+    }
+
+    /* Remote name update */
+    btif_update_remote_properties(req_oob_type->bd_addr , req_oob_type->bd_name,
+                                          NULL, BT_DEVICE_TYPE_BLE);
+
+    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);
+    pairing_cb.is_ssp = false;
+    pairing_cb.is_le_only = true; //TODO: we can derive classic pairing from this one
+    pairing_cb.is_le_nc = false;
+
+    BTM_BleSecureConnectionOobDataReply(req_oob_type->bd_addr,
+                                        oob_cb.oob_data.le_sc_c,
+                                        oob_cb.oob_data.le_sc_r);
+}
+
 void btif_dm_update_ble_remote_properties( BD_ADDR bd_addr, BD_NAME bd_name,
                                            tBT_DEVICE_TYPE dev_type)
 {
@@ -3633,12 +3766,24 @@ static void btif_dm_ble_tx_test_cback(void *p)
                           (char *)p, 1, NULL);
 }
 
+static void btif_dm_ble_enh_tx_test_cback(void *p)
+{
+    btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_LE_ENH_TX_TEST,
+                          (char *)p, 1, NULL);
+}
+
 static void btif_dm_ble_rx_test_cback(void *p)
 {
     btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_LE_RX_TEST,
                           (char *)p, 1, NULL);
 }
 
+static void btif_dm_ble_enh_rx_test_cback(void *p)
+{
+    btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_LE_ENH_RX_TEST,
+                          (char *)p, 1, NULL);
+}
+
 static void btif_dm_ble_test_end_cback(void *p)
 {
     btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_LE_TEST_END,
@@ -3660,10 +3805,18 @@ bt_status_t btif_le_test_mode(uint16_t opcode, uint8_t *buf, uint8_t len)
              if (len != 3) return BT_STATUS_PARM_INVALID;
              BTM_BleTransmitterTest(buf[0],buf[1],buf[2], btif_dm_ble_tx_test_cback);
              break;
+         case HCI_BLE_ENH_TRANSMITTER_TEST:
+             if (len != 4) return BT_STATUS_PARM_INVALID;
+             BTM_BleEnhTransmitterTest(buf[0],buf[1],buf[2],buf[3], btif_dm_ble_enh_tx_test_cback);
+             break;
          case HCI_BLE_RECEIVER_TEST:
              if (len != 1) return BT_STATUS_PARM_INVALID;
              BTM_BleReceiverTest(buf[0], btif_dm_ble_rx_test_cback);
              break;
+         case HCI_BLE_ENH_RECEIVER_TEST:
+             if (len != 3) return BT_STATUS_PARM_INVALID;
+             BTM_BleEnhReceiverTest(buf[0],buf[1],buf[2], btif_dm_ble_enh_rx_test_cback);
+             break;
          case HCI_BLE_TEST_END:
              BTM_BleTestEnd((tBTM_CMPL_CB*) btif_dm_ble_test_end_cback);
              break;
@@ -3766,7 +3919,7 @@ static void btif_stats_add_bond_event(const bt_bdaddr_t *bd_addr,
     uint32_t cod = get_cod(bd_addr);
     uint64_t ts = event->timestamp.tv_sec * 1000 +
                   event->timestamp.tv_nsec / 1000000;
-    metrics_pair_event(0, ts, cod, device_type);
+    metrics_log_pair_event(0, ts, cod, device_type);
 
     pthread_mutex_unlock(&bond_event_lock);
 }
diff --git a/btif/src/btif_gatt_client.c b/btif/src/btif_gatt_client.c
index 9e27082..bac5772 100644
--- a/btif/src/btif_gatt_client.c
+++ b/btif/src/btif_gatt_client.c
@@ -117,6 +117,10 @@ typedef enum {
 #define ENABLE_BATCH_SCAN 1
 #define DISABLE_BATCH_SCAN 0
 
+#define SCAN_PHY_LE_1M    1
+#define SCAN_PHY_LE_CODED 4
+#define SCAN_PHY_LE_1M_CODED 5
+
 /*******************************************************************************
 **  Local type definitions
 ********************************************************************************/
@@ -199,9 +203,17 @@ typedef struct
     uint8_t     start;
     uint8_t     has_mask;
     int8_t      rssi;
+    uint8_t     scan_phys;
+    uint16_t    scan_interval_coded;
+    uint16_t    scan_window_coded;
+
+    uint16_t    duration;
+    uint16_t    period;
+
     uint8_t     flag;
     tBT_DEVICE_TYPE device_type;
     btgatt_transport_t transport;
+    UINT16      adv_data_len;
 } __attribute__((packed)) btif_gattc_cb_t;
 
 typedef struct
@@ -422,12 +434,12 @@ static void btif_gattc_update_properties ( btif_gattc_cb_t *p_btif_cb )
     bt_bdname_t bdname;
 
     p_eir_remote_name = BTM_CheckEirData(p_btif_cb->value,
-                                         BTM_EIR_COMPLETE_LOCAL_NAME_TYPE, &remote_name_len);
+                                         BTM_EIR_COMPLETE_LOCAL_NAME_TYPE, &remote_name_len, p_btif_cb->adv_data_len);
 
     if (p_eir_remote_name == NULL)
     {
         p_eir_remote_name = BTM_CheckEirData(p_btif_cb->value,
-                                BT_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len);
+                                BT_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len, p_btif_cb->adv_data_len);
     }
 
     if (p_eir_remote_name)
@@ -497,6 +509,12 @@ static void btif_gattc_upstreams_evt(uint16_t event, char* p_param)
             break;
         }
 
+        case BTA_GATTC_SEARCH_RES_EVT:
+        {
+            /* Do nothing */
+            break;
+        }
+
         case BTA_GATTC_READ_DESCR_EVT:
         {
             btgatt_read_params_t data;
@@ -580,12 +598,12 @@ static void btif_gattc_upstreams_evt(uint16_t event, char* p_param)
             bt_property_t properties;
 
             p_eir_remote_name = BTM_CheckEirData(p_btif_cb->value,
-                                         BTM_EIR_COMPLETE_LOCAL_NAME_TYPE, &remote_name_len);
+                                                     BTM_EIR_COMPLETE_LOCAL_NAME_TYPE, &remote_name_len, p_btif_cb->adv_data_len);
 
             if (p_eir_remote_name == NULL)
             {
                 p_eir_remote_name = BTM_CheckEirData(p_btif_cb->value,
-                                BT_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len);
+                                BT_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len, p_btif_cb->adv_data_len);
             }
 
             if ((p_btif_cb->addr_type != BLE_ADDR_RANDOM) || (p_eir_remote_name))
@@ -661,6 +679,31 @@ static void btif_gattc_upstreams_evt(uint16_t event, char* p_param)
             break;
         }
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        case BTA_GATTC_EXTENDED_ADV_ENB_EVT:
+        {
+            btif_gattc_cb_t *p_btif_cb = (btif_gattc_cb_t*) p_param;
+            if (0xFF != p_btif_cb->inst_id)
+                btif_multi_adv_add_instid_map(p_btif_cb->client_if, p_btif_cb->inst_id, false);
+            HAL_CBACK(bt_gatt_callbacks, client->multi_adv_enable_cb
+                    , p_btif_cb->client_if
+                    , p_btif_cb->status
+                );
+            break;
+        }
+
+        case BTA_GATTC_EXTENDED_ADV_UPD_EVT:
+        {
+            btif_gattc_cb_t *p_btif_cb = (btif_gattc_cb_t*) p_param;
+            HAL_CBACK(bt_gatt_callbacks, client->multi_adv_update_cb
+                , p_btif_cb->client_if
+                , p_btif_cb->status
+            );
+            break;
+        }
+
+#endif
+
         case BTA_GATTC_MULT_ADV_DATA_EVT:
          {
             btif_gattc_cb_t *p_btif_cb = (btif_gattc_cb_t*) p_param;
@@ -858,6 +901,16 @@ static void bta_gattc_multi_adv_cback(tBTA_BLE_MULTI_ADV_EVT event, UINT8 inst_i
             upevt = BTA_GATTC_MULT_ADV_DATA_EVT;
             break;
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        case BTA_BLE_EXTENDED_ADV_ENB_EVT:
+            upevt = BTA_GATTC_EXTENDED_ADV_ENB_EVT;
+            break;
+
+        case BTA_BLE_EXTENDED_ADV_PARAM_EVT:
+            upevt = BTA_GATTC_EXTENDED_ADV_UPD_EVT;
+            break;
+#endif
+
         default:
             return;
     }
@@ -985,11 +1038,14 @@ static void bta_scan_results_cb (tBTA_DM_SEARCH_EVT event, tBTA_DM_SEARCH *p_dat
             btif_cb.rssi = p_data->inq_res.rssi;
             btif_cb.addr_type = p_data->inq_res.ble_addr_type;
             btif_cb.flag = p_data->inq_res.flag;
+            btif_cb.adv_data_len = p_data->inq_res.adv_data_len;
+
+            memset(&btif_cb.value[0], 0, BTGATT_MAX_ATTR_LEN);
             if (p_data->inq_res.p_eir)
             {
-                memcpy(btif_cb.value, p_data->inq_res.p_eir, 62);
+                memcpy(btif_cb.value, p_data->inq_res.p_eir, p_data->inq_res.adv_data_len);
                 if (BTM_CheckEirData(p_data->inq_res.p_eir, BTM_EIR_COMPLETE_LOCAL_NAME_TYPE,
-                                      &len))
+                                                      &len, p_data->inq_res.adv_data_len))
                 {
                     p_data->inq_res.remt_name_not_required  = TRUE;
                 }
@@ -1025,6 +1081,9 @@ static void bta_track_adv_event_cb(tBTA_DM_BLE_TRACK_ADV_DATA *p_track_adv_data)
 
 static void btm_read_rssi_cb (tBTM_RSSI_RESULTS *p_result)
 {
+    if (!p_result)
+      return;
+
     btif_gattc_cb_t btif_cb;
 
     bdcpy(btif_cb.bd_addr.address, p_result->rem_bda);
@@ -1108,6 +1167,10 @@ static void btgattc_handle_event(uint16_t event, char* p_param)
     tBT_UUID                   uuid;
     tBTA_GATT_UNFMT            descr_val;
 
+    if (!btif_is_enabled()) {
+       LOG_ERROR(LOG_TAG,"%s: bluetooth adapter not enabled",__FUNCTION__);
+       return;
+    }
     btif_gattc_cb_t* p_cb = (btif_gattc_cb_t*) p_param;
     if (!p_cb) return;
 
@@ -1129,11 +1192,11 @@ static void btgattc_handle_event(uint16_t event, char* p_param)
 
         case BTIF_GATTC_SCAN_START:
             btif_gattc_init_dev_cb();
-            BTA_DmBleObserve(TRUE, 0, bta_scan_results_cb);
+            BTA_DmBleObserve(TRUE, 0, 0, bta_scan_results_cb);
             break;
 
         case BTIF_GATTC_SCAN_STOP:
-            BTA_DmBleObserve(FALSE, 0, 0);
+            BTA_DmBleObserve(FALSE, 0, 0, 0);
             break;
 
         case BTIF_GATTC_OPEN:
@@ -1334,7 +1397,7 @@ static void btgattc_handle_event(uint16_t event, char* p_param)
                     cond.srvc_uuid.p_uuid_mask = NULL;
                     if (p_adv_filt_cb->has_mask)
                     {
-                        btif_to_bta_uuid_mask(&uuid_mask, &p_adv_filt_cb->uuid_mask);
+                        btif_to_bta_uuid_mask(&uuid_mask, &p_adv_filt_cb->uuid_mask, &p_adv_filt_cb->uuid);
                         cond.srvc_uuid.p_uuid_mask = &uuid_mask;
                     }
                     BTA_DmBleCfgFilterCondition(p_adv_filt_cb->action,
@@ -1509,10 +1572,12 @@ static void btgattc_handle_event(uint16_t event, char* p_param)
             {
                 btgatt_multi_adv_common_data *p_multi_adv_data_cb =
                     btif_obtain_multi_adv_data_cb();
+                p_multi_adv_data_cb->inst_cb[cbindex].frag_preference = p_adv_data->frag_preference;
                 BTA_BleCfgAdvInstData(
                     (UINT8)inst_id,
                     p_adv_data->set_scan_rsp,
                     p_multi_adv_data_cb->inst_cb[cbindex].mask,
+                    p_multi_adv_data_cb->inst_cb[cbindex].frag_preference,
                     &p_multi_adv_data_cb->inst_cb[cbindex].data);
             }
             else
@@ -1558,7 +1623,8 @@ static void btgattc_handle_event(uint16_t event, char* p_param)
 
         case BTIF_GATTC_SET_SCAN_PARAMS:
         {
-            BTA_DmSetBleScanParams(p_cb->client_if, p_cb->scan_interval, p_cb->scan_window,
+            BTA_DmSetBleScanParams(p_cb->client_if, p_cb->scan_phys, p_cb->scan_interval, p_cb->scan_window,
+                                   p_cb->scan_interval_coded, p_cb->scan_window_coded,
                                    BTM_BLE_SCAN_MODE_ACTI, bta_scan_param_setup_cb);
             break;
         }
@@ -1630,6 +1696,12 @@ static bt_status_t btif_gattc_scan( bool start )
 {
     CHECK_BTGATT_INIT();
     btif_gattc_cb_t btif_cb;
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    btif_cb.duration = 0;
+    btif_cb.period = 0;
+#endif
+
     return btif_transfer_context(btgattc_handle_event, start ? BTIF_GATTC_SCAN_START : BTIF_GATTC_SCAN_STOP,
                                  (char*) &btif_cb, sizeof(btif_gattc_cb_t), NULL);
 }
@@ -1982,9 +2054,23 @@ static bt_status_t btif_gattc_set_scan_parameters(int client_if, int scan_interv
 {
     CHECK_BTGATT_INIT();
     btif_gattc_cb_t btif_cb;
+
+    memset(&btif_cb, 0, sizeof(btif_gattc_cb_t));
+
     btif_cb.client_if = client_if;
     btif_cb.scan_interval = scan_interval;
     btif_cb.scan_window = scan_window;
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    btif_cb.scan_phys = 0x01;/*LE 1M*/
+    btif_cb.scan_interval_coded = 0;
+    btif_cb.scan_window_coded = 0;
+
+    BTIF_TRACE_DEBUG("btif_gattc_set_scan_parameters ::scan_phys=%d scan_interval=%d scan_window= %d "
+                    "scan_interval_coded= %d scan_window_coded=%d",btif_cb.scan_phys,btif_cb.scan_interval,
+                    btif_cb.scan_window, btif_cb.scan_interval_coded, btif_cb.scan_window_coded);
+#endif
+
     return btif_transfer_context(btgattc_handle_event, BTIF_GATTC_SET_SCAN_PARAMS,
                                  (char*) &btif_cb, sizeof(btif_gattc_cb_t), NULL);
 }
@@ -2014,6 +2100,9 @@ static bt_status_t btif_gattc_multi_adv_enable(int client_if, int min_interval,
     adv_cb.param.channel_map = chnl_map;
     adv_cb.param.adv_filter_policy = 0;
     adv_cb.param.tx_power = tx_power;
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    adv_cb.param.duration = timeout_s;
+#endif
     adv_cb.timeout_s = timeout_s;
     return btif_transfer_context(btgattc_handle_event, BTIF_GATTC_ADV_INSTANCE_ENABLE,
                              (char*) &adv_cb, sizeof(btgatt_multi_adv_inst_cb), NULL);
@@ -2033,6 +2122,9 @@ static bt_status_t btif_gattc_multi_adv_update(int client_if, int min_interval,
     adv_cb.param.channel_map = chnl_map;
     adv_cb.param.adv_filter_policy = 0;
     adv_cb.param.tx_power = tx_power;
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    adv_cb.param.duration = timeout_s;
+#endif
     adv_cb.timeout_s = timeout_s;
     return btif_transfer_context(btgattc_handle_event, BTIF_GATTC_ADV_INSTANCE_UPDATE,
                          (char*) &adv_cb, sizeof(btgatt_multi_adv_inst_cb), NULL);
@@ -2056,6 +2148,10 @@ static bt_status_t btif_gattc_multi_adv_setdata(int client_if, bool set_scan_rsp
         min_interval, max_interval, appearance, manufacturer_len, manufacturer_data,
         service_data_len, service_data, service_uuid_len, service_uuid, &multi_adv_data_inst);
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    multi_adv_data_inst.frag_preference = 0;
+#endif
+
     bt_status_t status = btif_transfer_context(
         btgattc_handle_event, BTIF_GATTC_ADV_INSTANCE_SET_DATA,
         (char *)&multi_adv_data_inst, sizeof(multi_adv_data_inst),
diff --git a/btif/src/btif_gatt_multi_adv_util.c b/btif/src/btif_gatt_multi_adv_util.c
index ddca7d2..8430475 100644
--- a/btif/src/btif_gatt_multi_adv_util.c
+++ b/btif/src/btif_gatt_multi_adv_util.c
@@ -43,6 +43,7 @@
 #include "btif_common.h"
 #include "btif_gatt_multi_adv_util.h"
 #include "btif_gatt_util.h"
+#include "device/include/controller.h"
 
 extern fixed_queue_t *btu_general_alarm_queue;
 
@@ -54,6 +55,11 @@ static btgatt_multi_adv_common_data *p_multi_adv_com_data_cb = NULL;
 
 btgatt_multi_adv_common_data *btif_obtain_multi_adv_data_cb()
 {
+    if (!controller_get_interface()->get_is_ready())
+    {
+        BTIF_TRACE_ERROR("btif_obtain_multi_adv_data_cb controller not ready!");
+        return NULL;
+    }
     int max_adv_inst = BTM_BleMaxMultiAdvInstanceCount();
     if (0 == max_adv_inst)
         max_adv_inst = 1;
diff --git a/btif/src/btif_gatt_qual.c b/btif/src/btif_gatt_qual.c
index bdd9d89..f973d67 100644
--- a/btif/src/btif_gatt_qual.c
+++ b/btif/src/btif_gatt_qual.c
@@ -74,7 +74,7 @@ void Gatt_StartIf(tGATT_IF gatt_if)
 BOOLEAN Gatt_Connect (tGATT_IF gatt_if, BD_ADDR bd_addr, BOOLEAN is_direct,tBT_TRANSPORT transport)
 {
     BOOLEAN     Ret = 0;
-    Ret = GATT_Connect(gatt_if, bd_addr, is_direct,BT_TRANSPORT_LE);
+    Ret = GATT_Connect(gatt_if, bd_addr, is_direct,BT_TRANSPORT_LE, false);
     printf("%s::Ret=%d,gatt_if=%d, is_direct=%d \n", __FUNCTION__, Ret, gatt_if, is_direct);
     return Ret;
 }
diff --git a/btif/src/btif_gatt_server.c b/btif/src/btif_gatt_server.c
index 41d194f..039db8d 100644
--- a/btif/src/btif_gatt_server.c
+++ b/btif/src/btif_gatt_server.c
@@ -359,6 +359,11 @@ static void btapp_gatts_cback(tBTA_GATTS_EVT event, tBTA_GATTS *p_data)
 
 static void btgatts_handle_event(uint16_t event, char* p_param)
 {
+    if (!btif_is_enabled()) {
+       LOG_ERROR(LOG_TAG,"%s: bluetooth adapter not enabled",__FUNCTION__);
+       return;
+    }
+
     btif_gatts_cb_t* p_cb = (btif_gatts_cb_t*)p_param;
     if (!p_cb) return;
 
@@ -431,13 +436,15 @@ static void btgatts_handle_event(uint16_t event, char* p_param)
         }
 
         case BTIF_GATTS_CLOSE:
-            // Cancel pending foreground/background connections
-            BTA_GATTS_CancelOpen(p_cb->server_if, p_cb->bd_addr.address, TRUE);
-            BTA_GATTS_CancelOpen(p_cb->server_if, p_cb->bd_addr.address, FALSE);
 
             // Close active connection
             if (p_cb->conn_id != 0)
                 BTA_GATTS_Close(p_cb->conn_id);
+            else
+                BTA_GATTS_CancelOpen(p_cb->server_if, p_cb->bd_addr.address, TRUE);
+
+            // Cancel pending background connections
+            BTA_GATTS_CancelOpen(p_cb->server_if, p_cb->bd_addr.address, FALSE);
             break;
 
         case BTIF_GATTS_CREATE_SERVICE:
diff --git a/btif/src/btif_gatt_test.c b/btif/src/btif_gatt_test.c
index 349674e..ab1c1d2 100644
--- a/btif/src/btif_gatt_test.c
+++ b/btif/src/btif_gatt_test.c
@@ -240,7 +240,7 @@ bt_status_t btif_gattc_test_command_impl(uint16_t command, btgatt_test_params_t*
             if (params->u1 == BT_DEVICE_TYPE_BLE)
                 BTM_SecAddBleDevice(params->bda1->address, NULL, BT_DEVICE_TYPE_BLE, params->u2);
 
-            if ( !GATT_Connect(test_cb.gatt_if, params->bda1->address, TRUE, BT_TRANSPORT_LE) )
+            if ( !GATT_Connect(test_cb.gatt_if, params->bda1->address, true, BT_TRANSPORT_LE, false) )
             {
                 LOG_ERROR(LOG_TAG, "%s: GATT_Connect failed!", __FUNCTION__);
             }
diff --git a/btif/src/btif_gatt_util.c b/btif/src/btif_gatt_util.c
index c93d866..17661ea 100644
--- a/btif/src/btif_gatt_util.c
+++ b/btif/src/btif_gatt_util.c
@@ -118,20 +118,21 @@ void btif_to_bta_response(tBTA_GATTS_RSP *p_dest, btgatt_response_t* p_src)
     memcpy(p_dest->attr_value.value, p_src->attr_value.value, GATT_MAX_ATTR_LEN);
 }
 
-void btif_to_bta_uuid_mask(tBTA_DM_BLE_PF_COND_MASK *p_mask, bt_uuid_t *p_src)
+void btif_to_bta_uuid_mask(tBTA_DM_BLE_PF_COND_MASK *p_mask, bt_uuid_t *uuid_mask, bt_uuid_t *svc_uuid)
 {
-    char *p_byte = (char*)p_src;
+    char *p_byte = (char*)uuid_mask;
+    int uuid_len = uuidType(svc_uuid->uu);
     int i = 0;
 
-    switch (uuidType(p_src->uu))
+    switch (uuid_len)
     {
         case LEN_UUID_16:
-            p_mask->uuid16_mask = (p_src->uu[13] << 8) + p_src->uu[12];
+            p_mask->uuid16_mask = (uuid_mask->uu[13] << 8) + uuid_mask->uu[12];
             break;
 
         case LEN_UUID_32:
-            p_mask->uuid32_mask = (p_src->uu[13] <<  8) + p_src->uu[12];
-            p_mask->uuid32_mask += (p_src->uu[15] << 24) + (p_src->uu[14] << 16);
+            p_mask->uuid32_mask = (uuid_mask->uu[13] <<  8) + uuid_mask->uu[12];
+            p_mask->uuid32_mask += (uuid_mask->uu[15] << 24) + (uuid_mask->uu[14] << 16);
             break;
 
         case LEN_UUID_128:
diff --git a/btif/src/btif_hf.c b/btif/src/btif_hf.c
index bd731ce..fffafa6 100644
--- a/btif/src/btif_hf.c
+++ b/btif/src/btif_hf.c
@@ -155,6 +155,7 @@ typedef struct _btif_hf_cb
     struct timespec         call_end_timestamp;
     struct timespec         connected_timestamp;
     bthf_call_state_t       call_setup_state;
+    bthf_audio_state_t      audio_state;
 } btif_hf_cb_t;
 
 static btif_hf_cb_t btif_hf_cb[BTIF_HF_NUM_CB];
@@ -444,6 +445,40 @@ static bt_status_t btif_hf_check_if_slc_connected()
     }
 }
 
+/*******************************************************************************
+**
+** Function         btif_hf_check_if_sco_connected
+**
+** Description      Returns BT_STATUS_SUCCESS if SCO is up for any HF
+**
+** Returns          bt_status_t
+**
+*******************************************************************************/
+static bt_status_t btif_hf_check_if_sco_connected()
+{
+    if (bt_hf_callbacks == NULL)
+    {
+        BTIF_TRACE_WARNING("BTHF: %s: BTHF not initialized. ", __FUNCTION__);
+        return BT_STATUS_NOT_READY;
+    }
+    else
+    {
+        int i;
+        for (i = 0; i < btif_max_hf_clients; i++)
+        {
+            if ((btif_hf_cb[i].audio_state == BTHF_AUDIO_STATE_CONNECTED) ||
+                (btif_hf_cb[i].audio_state == BTHF_AUDIO_STATE_CONNECTING))
+            {
+                BTIF_TRACE_EVENT("BTHF: %s: sco connected/connecting for idx = %d",
+                                         __FUNCTION__, i);
+                return BT_STATUS_SUCCESS;
+            }
+        }
+        BTIF_TRACE_WARNING("BTHF: %s: No SCO connection up", __FUNCTION__);
+        return BT_STATUS_NOT_READY;
+    }
+}
+
 /*****************************************************************************
 **   Section name (Group of functions)
 *****************************************************************************/
@@ -467,11 +502,23 @@ static void btif_hf_upstreams_evt(UINT16 event, char* p_param)
 {
     tBTA_AG *p_data = (tBTA_AG *)p_param;
     bdstr_t bdstr;
-    int idx = p_data->hdr.handle - 1;
+    int idx;
     BOOLEAN ignore_rfc_fail = false;
 
     BTIF_TRACE_IMP("%s: event=%s", __FUNCTION__, dump_hf_event(event));
 
+    // for BTA_AG_ENABLE_EVT/BTA_AG_DISABLE_EVT, p_data is NULL
+    if (event == BTA_AG_ENABLE_EVT || event == BTA_AG_DISABLE_EVT)
+        return;
+
+    // p_data is NULL for any other event, return
+    if (p_data == NULL)
+    {
+        BTIF_TRACE_ERROR("%s: data is NULL", __FUNCTION__);
+        return;
+    }
+
+    idx = p_data->hdr.handle - 1;
     if ((idx < 0) || (idx >= BTIF_HF_NUM_CB))
     {
         BTIF_TRACE_ERROR("%s: Invalid index %d", __FUNCTION__, idx);
@@ -480,10 +527,6 @@ static void btif_hf_upstreams_evt(UINT16 event, char* p_param)
 
     switch (event)
     {
-        case BTA_AG_ENABLE_EVT:
-        case BTA_AG_DISABLE_EVT:
-            break;
-
         case BTA_AG_REGISTER_EVT:
             btif_hf_cb[idx].handle = p_data->reg.hdr.handle;
             BTIF_TRACE_DEBUG("%s: BTA_AG_REGISTER_EVT,"
@@ -539,6 +582,9 @@ static void btif_hf_upstreams_evt(UINT16 event, char* p_param)
         case BTA_AG_CLOSE_EVT:
             btif_hf_cb[idx].connected_timestamp.tv_sec = 0;
             btif_hf_cb[idx].state = BTHF_CONNECTION_STATE_DISCONNECTED;
+
+            BTIF_TRACE_IMP("%s: Moving the audio_state to DISCONNECTED", __FUNCTION__);
+            btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_DISCONNECTED;
             BTIF_TRACE_DEBUG("%s: BTA_AG_CLOSE_EVT,"
                  "idx = %d, btif_hf_cb.handle = %d", __FUNCTION__, idx,
                           btif_hf_cb[idx].handle);
@@ -569,11 +615,15 @@ static void btif_hf_upstreams_evt(UINT16 event, char* p_param)
 
         case BTA_AG_AUDIO_OPEN_EVT:
             hf_idx = idx;
+            BTIF_TRACE_IMP("%s: Moving the audio_state to CONNECTED", __FUNCTION__);
+            btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_CONNECTED;
             HAL_CBACK(bt_hf_callbacks, audio_state_cb, BTHF_AUDIO_STATE_CONNECTED,
                                                         &btif_hf_cb[idx].connected_bda);
             break;
 
         case BTA_AG_AUDIO_CLOSE_EVT:
+            BTIF_TRACE_IMP("%s: Moving the audio_state to DISCONNECTED", __FUNCTION__);
+            btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_DISCONNECTED;
             HAL_CBACK(bt_hf_callbacks, audio_state_cb, BTHF_AUDIO_STATE_DISCONNECTED,
                                                            &btif_hf_cb[idx].connected_bda);
             break;
@@ -737,6 +787,7 @@ static void btif_hf_upstreams_evt(UINT16 event, char* p_param)
         case BTA_AG_AT_BIEV_EVT:
             HAL_CBACK(bt_hf_callbacks, biev_cmd_cb, p_data->val.str,
                                                &btif_hf_cb[idx].connected_bda);
+
             break;
         default:
             BTIF_TRACE_WARNING("%s: Unhandled event: %d", __FUNCTION__, event);
@@ -803,6 +854,8 @@ static void btif_in_hf_generic_evt(UINT16 event, char *p_param)
     switch (event) {
         case BTIF_HFP_CB_AUDIO_CONNECTING:
         {
+            BTIF_TRACE_IMP("%s: Moving the audio_state to CONNECTING", __FUNCTION__);
+            btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_CONNECTING;
             HAL_CBACK(bt_hf_callbacks, audio_state_cb, BTHF_AUDIO_STATE_CONNECTING,
                       &btif_hf_cb[idx].connected_bda);
         } break;
@@ -1366,6 +1419,8 @@ static bt_status_t phone_state_change(int num_active, int num_held, bthf_call_st
     BOOLEAN activeCallUpdated = FALSE;
     int idx, i;
 
+    memset(&ag_res, 0, sizeof(ag_res));
+
     /* hf_idx is index of connected HS that sent ATA/BLDN,
             otherwise index of latest connected HS */
     if (hf_idx != BTIF_HF_INVALID_IDX)
@@ -1426,6 +1481,9 @@ static bt_status_t phone_state_change(int num_active, int num_held, bthf_call_st
 
         memset(&ag_res, 0, sizeof(tBTA_AG_RES_DATA));
         ag_res.audio_handle = btif_hf_cb[idx].handle;
+
+        BTIF_TRACE_IMP("%s: Moving the audio_state to CONNECTING", __FUNCTION__);
+        btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_CONNECTING;
         /* Addition call setup with the Active call
         ** CIND response should have been updated.
         ** just open SCO conenction.
@@ -1457,6 +1515,10 @@ static bt_status_t phone_state_change(int num_active, int num_held, bthf_call_st
                         {
                             res = BTA_AG_IN_CALL_CONN_RES;
                             ag_res.audio_handle = btif_hf_cb[idx].handle;
+
+                            BTIF_TRACE_IMP("%s: Moving the audio_state to CONNECTING",
+                                              __FUNCTION__);
+                            btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_CONNECTING;
                         }
                         else if (num_held > btif_hf_cb[idx].num_held)
                             res = BTA_AG_IN_CALL_HELD_RES;
@@ -1502,6 +1564,9 @@ static bt_status_t phone_state_change(int num_active, int num_held, bthf_call_st
                 if (!(num_active + num_held))
                 {
                     ag_res.audio_handle = btif_hf_cb[idx].handle;
+
+                    BTIF_TRACE_IMP("%s: Moving the audio_state to CONNECTING", __FUNCTION__);
+                    btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_CONNECTING;
                 }
                 else
                 {
@@ -1515,6 +1580,9 @@ static bt_status_t phone_state_change(int num_active, int num_held, bthf_call_st
                         !(num_active + num_held))
                 {
                     ag_res.audio_handle = btif_hf_cb[idx].handle;
+
+                    BTIF_TRACE_IMP("%s: Moving the audio_state to CONNECTING", __FUNCTION__);
+                    btif_hf_cb[idx].audio_state = BTHF_AUDIO_STATE_CONNECTING;
                 }
                 else
                 {
@@ -1589,14 +1657,14 @@ update_call_states:
 
 /*******************************************************************************
 **
-** Function         btif_hf_is_call_idle
+** Function         btif_hf_is_call_vr_idle
 **
 ** Description      returns true if no call is in progress
 **
 ** Returns          bt_status_t
 **
 *******************************************************************************/
-BOOLEAN btif_hf_is_call_idle()
+BOOLEAN btif_hf_is_call_vr_idle()
 {
     int i, j = 1;
 
@@ -1614,9 +1682,9 @@ BOOLEAN btif_hf_is_call_idle()
                 ((btif_hf_cb[i].num_held + btif_hf_cb[i].num_active) == 0));
     }
 
-    if (j)
+    if (j && (btif_hf_check_if_sco_connected() != BT_STATUS_SUCCESS))
     {
-        BTIF_TRACE_EVENT("%s: call state idle ", __FUNCTION__);
+        BTIF_TRACE_EVENT("%s: call state idle and no sco connected.", __FUNCTION__);
         return TRUE;
     }
     else
diff --git a/btif/src/btif_l2cap.c b/btif/src/btif_l2cap.c
index 13a23c8..c44fe57 100644
--- a/btif/src/btif_l2cap.c
+++ b/btif/src/btif_l2cap.c
@@ -38,6 +38,7 @@
 #include "bt_utils.h"
 #include "l2cdefs.h"
 #include "l2c_api.h"
+#include <l2c_int.h>
 #if TEST_APP_INTERFACE == TRUE
 #include <bt_testapp.h>
 
@@ -79,6 +80,14 @@ static BOOLEAN L2cap_GetPeerFeatures (BD_ADDR bd_addr, UINT32 *p_ext_feat, UINT8
 static BOOLEAN L2cap_GetBDAddrbyHandle (UINT16 handle, BD_ADDR bd_addr);
 static UINT8 L2cap_GetChnlFcrMode (UINT16 lcid);
 static UINT16 L2cap_SendFixedChnlData (UINT16 fixed_cid, BD_ADDR rem_bda, BT_HDR *p_buf);
+static bt_status_t L2cap_LE_Register (UINT16 le_psm, BOOLEAN ConnType, UINT16 SecLevel, UINT8 enc_key_size);
+static bt_status_t L2cap_LE_DeRegister (UINT16 psm);
+static UINT16 L2cap_LE_Connect(UINT16 le_psm , BD_ADDR address, tL2CAP_LE_CFG_INFO *p_cfg);
+static BOOLEAN L2cap_LE_ConnectRsp (BD_ADDR p_bd_addr, UINT8 id, UINT16 lcid, UINT16 result,
+                             UINT16 status, tL2CAP_LE_CFG_INFO *p_cfg);
+//static BOOLEAN L2cap_LE_ConnectRsp (BD_ADDR p_bd_addr, UINT8 id, UINT16 lcid, tL2CAP_LE_CFG_INFO *p_cfg);
+static BOOLEAN L2cap_LE_FlowControl (UINT16 lcid, UINT16 credits);
+static void L2cap_LE_freebuf(BT_HDR *p_buf);
 
 static const btl2cap_interface_t btl2capInterface = {
     sizeof(btl2cap_interface_t),
@@ -117,6 +126,12 @@ static const btl2cap_interface_t btl2capInterface = {
     L2cap_GetChnlFcrMode,
     L2cap_SendFixedChnlData,
     NULL, // cleanup,
+    L2cap_LE_Register,
+    L2cap_LE_DeRegister,
+    L2cap_LE_Connect,
+    L2cap_LE_ConnectRsp,
+    L2cap_LE_FlowControl,
+    L2cap_LE_freebuf,
 };
 
 const btl2cap_interface_t *btif_l2cap_get_interface(void)
@@ -175,6 +190,97 @@ static bt_status_t L2cap_Register (UINT16 psm, BOOLEAN ConnType, UINT16 SecLevel
    return BT_STATUS_SUCCESS;
 }
 
+/*******************************************************************************
+**
+** Function L2cap_LE_Register
+**
+** Description This function is called during the task startup
+** to register interface functions with L2CAP.
+**
+*******************************************************************************/
+static bt_status_t L2cap_LE_Register (UINT16 le_psm, BOOLEAN ConnType, UINT16 SecLevel,
+                                          UINT8 enc_key_size)
+{
+
+    BTIF_TRACE_DEBUG("LE-L2CAP: %s le_psm=%d, SecLevel=%d ", __FUNCTION__, le_psm, SecLevel);
+#if 0
+    if (!BTM_SetSecurityLevel (ConnType, "l2c_le_test", BTM_SEC_SERVICE_ATT,
+            SecLevel, le_psm))
+    {
+        BTIF_TRACE_ERROR("LE-L2CAP: BTM_SetSecurityLevel failed");
+        return BT_STATUS_FAIL;
+    }
+    if (!BTM_SetBleEncKeySize ("l2c_le_test", enc_key_size, le_psm))
+    {
+        BTIF_TRACE_ERROR("LE-L2CAP: BTM_SetBleEncKeySize failed");
+        return BT_STATUS_FAIL;
+    }
+#endif
+
+    g_Psm = L2CA_REGISTER_COC (le_psm, pl2test_l2c_appl,
+                                       AMP_AUTOSWITCH_ALLOWED|AMP_USE_AMP_IF_POSSIBLE);
+
+    if(0 == g_Psm) {
+        BTIF_TRACE_ERROR("LE-L2CAP: L2cap_LE_Register failed");
+        return BT_STATUS_FAIL;
+    }
+
+    if (!BTM_SetSecurityLevel (ConnType, "l2c_le_test", BTM_SEC_SERVICE_ATT,
+            SecLevel, le_psm, 0, 0))
+    {
+        BTIF_TRACE_ERROR("LE-L2CAP: BTM_SetSecurityLevel failed");
+        return BT_STATUS_FAIL;
+    }
+    return BT_STATUS_SUCCESS;
+}
+
+static UINT16 L2cap_LE_Connect (UINT16 le_psm , BD_ADDR address, tL2CAP_LE_CFG_INFO *p_cfg)
+{
+    BTIF_TRACE_DEBUG("LE-L2CAP: %s:: %0x %0x %0x %0x %0x %0x", __FUNCTION__,
+    address[0], address[1], address[2],address[3],address[4],address[5]);
+
+    if (0 == (g_lcid = L2CA_CONNECT_COC_REQ (le_psm, address, p_cfg))) {
+        BTIF_TRACE_ERROR("LE-L2CAP: L2CA_LE_CreditBasedConn_Req failed for le_psm ");
+    }
+    return g_lcid;
+}
+
+static BOOLEAN L2cap_LE_ConnectRsp (BD_ADDR p_bd_addr, UINT8 id, UINT16 lcid, UINT16 result,
+                             UINT16 status, tL2CAP_LE_CFG_INFO *p_cfg)
+{
+     p_cfg->credits = L2CAP_LE_DEFAULT_CREDIT;
+     p_cfg->mtu = L2CAP_LE_DEFAULT_MTU;
+     p_cfg->mps = L2CAP_LE_DEFAULT_MPS;
+
+    L2CA_CONNECT_COC_RSP (p_bd_addr, id, lcid, L2CAP_CONN_OK, L2CAP_CONN_OK, p_cfg);
+#if 0
+    if (!L2CA_LE_CreditBasedConn_Rsp (p_bd_addr, id, lcid, conn_info)) {
+        BTIF_TRACE_ERROR("LE-L2CAP: L2CA_LE_CreditBasedConn_Rsp failed");
+        return BT_STATUS_FAIL;
+    }
+#endif
+    return BT_STATUS_SUCCESS;
+}
+
+static BOOLEAN L2cap_LE_FlowControl (UINT16 lcid, UINT16 credits)
+{
+    if (!L2CA_LE_SetFlowControlCredits (lcid, credits)) {
+        BTIF_TRACE_ERROR("LE-L2CAP: L2CA_LE_SetFlowControlCredits failed");
+        return BT_STATUS_FAIL;
+    }
+    return BT_STATUS_SUCCESS;
+}
+static void L2cap_LE_freebuf (BT_HDR *p_buf)
+{
+     osi_free(p_buf);
+}
+
+static bt_status_t L2cap_LE_DeRegister (UINT16 psm)
+{
+    L2CA_DeregisterLECoc(psm);
+    return BT_STATUS_SUCCESS;
+}
+
 static bt_status_t L2cap_DeRegister (UINT16 psm)
 {
     L2CA_Deregister(psm);
diff --git a/btif/src/btif_media_task.c b/btif/src/btif_media_task.c
index 9defe4d..a512a7b 100644
--- a/btif/src/btif_media_task.c
+++ b/btif/src/btif_media_task.c
@@ -177,7 +177,7 @@ enum {
 #define BTIF_MEDIA_TIME_TICK                     (20 * BTIF_MEDIA_NUM_TICK)
 #define A2DP_DATA_READ_POLL_MS    (BTIF_MEDIA_TIME_TICK / 2)
 #define BTIF_SINK_MEDIA_TIME_TICK_MS             (20 * BTIF_MEDIA_NUM_TICK)
-
+#define BTIF_REMOTE_START_TOUT 3000
 
 /* buffer pool */
 #define BTIF_MEDIA_AA_BUF_SIZE  BT_DEFAULT_BUFFER_SIZE
@@ -221,6 +221,8 @@ enum {
 #endif
 #endif
 
+#define BTIF_A2DP_MAX_BITPOOL_MQ 35
+
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
 /* A2DP header will contain a CP header of size 1 */
 #define A2DP_HDR_SIZE               2
@@ -305,6 +307,7 @@ typedef struct {
 
 typedef struct {
     uint64_t session_start_us;
+    uint64_t session_end_us;
 
     scheduling_stats_t tx_queue_enqueue_stats;
     scheduling_stats_t tx_queue_dequeue_stats;
@@ -322,6 +325,7 @@ typedef struct {
     uint64_t tx_queue_last_flushed_us;
 
     size_t tx_queue_total_dropped_messages;
+    size_t tx_queue_max_dropped_messages;
     size_t tx_queue_dropouts;
     uint64_t tx_queue_last_dropouts_us;
 
@@ -399,6 +403,7 @@ typedef struct
 #endif
     alarm_t *media_alarm;
     alarm_t *decode_alarm;
+    alarm_t *remote_start_alarm;
     btif_media_stats_t stats;
 //#ifdef BTA_AV_SPLIT_A2DP_ENABLED
     UINT8 max_bitpool;
@@ -407,8 +412,10 @@ typedef struct
     BOOLEAN tx_started;
     BOOLEAN tx_stop_initiated;
     BOOLEAN tx_start_initiated;
+    BOOLEAN tx_enc_update_initiated;
 //#endif
 
+    btif_media_stats_t accumulated_stats;
 #endif
 } tBTIF_MEDIA_CB;
 
@@ -454,7 +461,6 @@ static void btif_media_task_handle_inc_media(tBT_SBC_HDR*p_msg);
 #endif
 
 BOOLEAN bta_av_co_audio_get_codec_config(UINT8 *p_config, UINT16 *p_minmtu, UINT8 type);
-static thread_t *aptx_thread = NULL;
 
 #if (BTA_AV_INCLUDED == TRUE)
 static void btif_media_send_aa_frame(uint64_t timestamp_us);
@@ -476,7 +482,7 @@ BOOLEAN btif_media_task_clear_track(void);
 
 static void btif_media_task_aa_handle_timer(UNUSED_ATTR void *context);
 static void btif_media_task_avk_handle_timer(UNUSED_ATTR void *context);
-extern BOOLEAN btif_hf_is_call_idle();
+extern BOOLEAN btif_hf_is_call_vr_idle();
 extern int btif_get_latest_playing_device_idx();
 extern tBTA_AV_HNDL btif_av_get_playing_device_hdl();
 extern int btif_get_num_playing_devices();
@@ -485,41 +491,43 @@ extern BOOLEAN btif_av_get_multicast_state();
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
 extern tBTA_AV_HNDL btif_av_get_av_hdl_from_idx(UINT8 idx);
 extern BOOLEAN btif_av_is_under_handoff();
+extern BOOLEAN btif_av_is_device_disconnecting();
+extern void btif_av_reset_reconfig_flag();
 void btif_media_send_reset_vendor_state();
 void btif_media_on_start_vendor_command();
-void btif_media_start_vendor_command();
 void btif_media_on_stop_vendor_command();
 BOOLEAN btif_media_send_vendor_pref_bit_rate();
 BOOLEAN btif_media_send_vendor_write_sbc_cfg();
 BOOLEAN btif_media_send_vendor_media_chn_cfg();
 BOOLEAN btif_media_send_vendor_stop();
-BOOLEAN btif_media_send_vendor_start();
 void disconnect_a2dp_on_vendor_start_failure();
 BOOLEAN btif_media_send_vendor_selected_codec();
 BOOLEAN btif_media_send_vendor_transport_cfg();
 BOOLEAN btif_media_send_vendor_scmst_hdr();
+BOOLEAN btif_av_is_suspend_stop_pending_ack();
 #else
 #define btif_av_get_av_hdl_from_idx(idx) (0)
 #define btif_av_is_under_handoff() (0)
+#define btif_av_is_device_disconnecting() (0)
+#define btif_av_reset_reconfig_flag() (0)
 #define btif_media_send_reset_vendor_state() (0)
 #define btif_media_on_start_vendor_command() (0)
-#define btif_media_start_vendor_command()    (0)
 #define btif_media_on_stop_vendor_command()  (0)
 #define btif_media_send_vendor_pref_bit_rate() (0)
 #define btif_media_send_vendor_write_sbc_cfg() (0)
 #define btif_media_send_vendor_media_chn_cfg() (0)
 #define btif_media_send_vendor_stop()        (0)
-#define btif_media_send_vendor_start()       (0)
 #define disconnect_a2dp_on_vendor_start_failure() (0)
 #define btif_media_send_vendor_selected_codec() (0)
 #define btif_media_send_vendor_transport_cfg()  (0)
 #define btif_media_send_vendor_scmst_hdr()      (0)
-
+#define btif_av_is_suspend_stop_pending_ack() (0)
 #endif
-
+void btif_a2dp_remote_start_timer();
 
 static tBTIF_MEDIA_CB btif_media_cb;
 static int media_task_running = MEDIA_TASK_STATE_OFF;
+static BOOLEAN enc_update_in_progress = FALSE;
 
 static fixed_queue_t *btif_media_cmd_msg_queue;
 static thread_t *worker_thread;
@@ -529,9 +537,72 @@ BOOLEAN bta_av_co_audio_get_codec_config(UINT8 *p_config, UINT16 *p_minmtu, UINT
 extern BOOLEAN bt_split_a2dp_enabled;
 extern int btif_max_av_clients;
 static uint8_t multicast_query = FALSE;
+extern BOOLEAN reconfig_a2dp;
 /*****************************************************************************
  **  Misc helper functions
  *****************************************************************************/
+void btif_a2dp_source_accumulate_scheduling_stats(scheduling_stats_t* src,
+                                                  scheduling_stats_t* dst) {
+    dst->total_updates += src->total_updates;
+    dst->last_update_us = src->last_update_us;
+    dst->overdue_scheduling_count += src->overdue_scheduling_count;
+    dst->total_overdue_scheduling_delta_us += src->total_overdue_scheduling_delta_us;
+    if (src->max_overdue_scheduling_delta_us > dst->max_overdue_scheduling_delta_us) {
+        dst->max_overdue_scheduling_delta_us = src->max_overdue_scheduling_delta_us;
+    }
+    dst->premature_scheduling_count += src->premature_scheduling_count;
+    dst->total_premature_scheduling_delta_us += src->total_premature_scheduling_delta_us;
+    if (src->max_premature_scheduling_delta_us > dst->max_premature_scheduling_delta_us) {
+        dst->max_premature_scheduling_delta_us = src->max_premature_scheduling_delta_us;
+    }
+    dst->exact_scheduling_count += src->exact_scheduling_count;
+    dst->total_scheduling_time_us += src->total_scheduling_time_us;
+}
+
+void btif_a2dp_source_accumulate_stats(btif_media_stats_t* src,
+                                       btif_media_stats_t* dst) {
+    dst->tx_queue_total_frames += src->tx_queue_total_frames;
+    if (src->tx_queue_max_frames_per_packet > dst->tx_queue_max_frames_per_packet) {
+        dst->tx_queue_max_frames_per_packet = src->tx_queue_max_frames_per_packet;
+    }
+    dst->tx_queue_total_queueing_time_us += src->tx_queue_total_queueing_time_us;
+    if (src->tx_queue_max_queueing_time_us > dst->tx_queue_max_queueing_time_us) {
+        dst->tx_queue_max_queueing_time_us = src->tx_queue_max_queueing_time_us;
+    }
+    dst->tx_queue_total_readbuf_calls += src->tx_queue_total_readbuf_calls;
+    dst->tx_queue_last_readbuf_us = src->tx_queue_last_readbuf_us;
+    dst->tx_queue_total_flushed_messages += src->tx_queue_total_flushed_messages;
+    dst->tx_queue_last_flushed_us = src->tx_queue_last_flushed_us;
+    dst->tx_queue_total_dropped_messages += src->tx_queue_total_dropped_messages;
+    if (src->tx_queue_max_dropped_messages > dst->tx_queue_max_dropped_messages) {
+        dst->tx_queue_max_dropped_messages = src->tx_queue_max_dropped_messages;
+    }
+    dst->tx_queue_dropouts += src->tx_queue_dropouts;
+    dst->tx_queue_last_dropouts_us = src->tx_queue_last_dropouts_us;
+    dst->media_read_total_underflow_bytes +=
+      src->media_read_total_underflow_bytes;
+    dst->media_read_total_underflow_count +=
+      src->media_read_total_underflow_count;
+    dst->media_read_last_underflow_us = src->media_read_last_underflow_us;
+    dst->media_read_total_underrun_bytes += src->media_read_total_underrun_bytes;
+    dst->media_read_total_underflow_count += src->media_read_total_underrun_count;
+    dst->media_read_last_underrun_us = src->media_read_last_underrun_us;
+    dst->media_read_total_expected_frames += src->media_read_total_expected_frames;
+    if (src->media_read_max_expected_frames > dst->media_read_max_expected_frames) {
+        dst->media_read_max_expected_frames = src->media_read_max_expected_frames;
+    }
+    dst->media_read_expected_count += src->media_read_expected_count;
+    dst->media_read_total_limited_frames += src->media_read_total_limited_frames;
+    if (src->media_read_max_limited_frames > dst->media_read_max_limited_frames) {
+        dst->media_read_max_limited_frames = src->media_read_max_limited_frames;
+    }
+    dst->media_read_limited_count += src->media_read_limited_count;
+    btif_a2dp_source_accumulate_scheduling_stats(&src->tx_queue_enqueue_stats,
+                                               &dst->tx_queue_enqueue_stats);
+    btif_a2dp_source_accumulate_scheduling_stats(&src->tx_queue_dequeue_stats,
+                                               &dst->tx_queue_dequeue_stats);
+    memset(src, 0, sizeof(btif_media_stats_t));
+}
 
 static void update_scheduling_stats(scheduling_stats_t *stats,
                                     uint64_t now_us, uint64_t expected_delta)
@@ -627,6 +698,29 @@ UNUSED_ATTR static const char *dump_media_event(UINT16 event)
     }
 }
 
+static void btm_read_rssi_cb(void *data)
+{
+    if (data == NULL)
+    {
+        LOG_ERROR(LOG_TAG, "%s RSSI request timed out", __func__);
+        return;
+    }
+
+    tBTM_RSSI_RESULTS *result = (tBTM_RSSI_RESULTS*)data;
+    if (result->status != BTM_SUCCESS)
+    {
+        LOG_ERROR(LOG_TAG, "%s unable to read remote RSSI (status %d)",
+            __func__, result->status);
+        return;
+    }
+
+    char temp_buffer[20] = {0};
+    LOG_WARN(LOG_TAG, "%s device: %s, rssi: %d", __func__,
+        bdaddr_to_string((bt_bdaddr_t *)result->rem_bda, temp_buffer,
+            sizeof(temp_buffer)),
+        result->rssi);
+}
+
 /*****************************************************************************
  **  A2DP CTRL PATH
  *****************************************************************************/
@@ -710,14 +804,31 @@ static void btif_recv_ctrl_data(void)
     {
         case A2DP_CTRL_CMD_CHECK_READY:
 
-            if (media_task_running == MEDIA_TASK_STATE_SHUTTING_DOWN)
+            if (!bt_split_a2dp_enabled && media_task_running == MEDIA_TASK_STATE_SHUTTING_DOWN)
             {
                 APPL_TRACE_WARNING("%s: A2DP command %s while media task shutting down",
                                    __func__, dump_a2dp_ctrl_event(cmd));
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
                 return;
             }
-
+            if (bt_split_a2dp_enabled && !btif_hf_is_call_vr_idle())
+            {
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_INCALL_FAILURE);
+                return;
+            }
+            /*There can be instances where because of remote start received early, reconfig
+            flag may get reset, for such case check for tx_started flag set as well,
+            this would help returning proper status to MM*/
+            if (bt_split_a2dp_enabled)
+                APPL_TRACE_IMP("%s: A2DP command %s, reconfig: %d, tx_started: %d",
+                   __func__, dump_a2dp_ctrl_event(cmd), reconfig_a2dp,
+                   btif_media_cb.tx_started);
+            if (bt_split_a2dp_enabled && (btif_av_is_under_handoff() || reconfig_a2dp
+                || btif_media_cb.tx_started))
+            {
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+                return;
+            }
             /* check whether av is ready to setup a2dp datapath */
             if ((btif_av_stream_ready() == TRUE) || (btif_av_stream_started_ready() == TRUE))
             {
@@ -743,11 +854,15 @@ static void btif_recv_ctrl_data(void)
             /* Don't sent START request to stack while we are in call.
                Some headsets like the Sony MW600, don't allow AVDTP START
                in call and respond BAD_STATE. */
-            if (!btif_hf_is_call_idle())
+            if (!btif_hf_is_call_vr_idle())
             {
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_INCALL_FAILURE);
                 break;
             }
+            APPL_TRACE_DEBUG("%s:A2DP command %s AV stream_started_ready %d",
+                             __func__, dump_a2dp_ctrl_event(cmd),btif_av_stream_started_ready());
+            APPL_TRACE_DEBUG("%s:A2DP command %s AV stream_ready %d",
+                             __func__, dump_a2dp_ctrl_event(cmd),btif_av_stream_ready());
 
             if (alarm_is_scheduled(btif_media_cb.media_alarm))
             {
@@ -757,6 +872,14 @@ static void btif_recv_ctrl_data(void)
                 break;
             }
 
+            if (alarm_is_scheduled(btif_media_cb.remote_start_alarm))
+            {
+                APPL_TRACE_WARNING("%s: remote a2dp started, cancle remote start timer",
+                                   __func__);
+                alarm_free(btif_media_cb.remote_start_alarm);
+                btif_media_cb.remote_start_alarm = NULL;
+                btif_dispatch_sm_event(BTIF_AV_RESET_REMOTE_STARTED_FLAG_UPDATE_AUDIO_STATE_EVT, NULL, 0);
+            }
             /* In Dual A2dp, first check for started state of stream
             * as we dont want to START again as while doing Handoff
             * the stack state will be started, so it is not needed
@@ -773,10 +896,20 @@ static void btif_recv_ctrl_data(void)
                 else
                 {
                     //UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);//Test Remove later
-                    APPL_TRACE_DEBUG("Av stream alreday started");
+                    APPL_TRACE_DEBUG("Av stream already started");
                     if (btif_media_cb.peer_sep == AVDT_TSEP_SNK)
                         btif_a2dp_encoder_update();
+                    if (btif_media_cb.tx_start_initiated == TRUE) {
+                        APPL_TRACE_DEBUG("VSC exchange alreday started on Handoff Start, wait");
+                        break;
+                    }
+                    else if (btif_media_cb.tx_started == FALSE) {
+                        APPL_TRACE_DEBUG("Start VSC exchange on MM Start when state is remote started");
+                        btif_media_on_start_vendor_command();
+                        break;
+                    }
                 }
+                btif_av_reset_reconfig_flag();
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             }
             else if (btif_av_stream_ready() == TRUE)
@@ -828,23 +961,26 @@ static void btif_recv_ctrl_data(void)
 
         case A2DP_CTRL_CMD_SUSPEND:
             /* local suspend */
-            if (btif_av_stream_started_ready())
+            APPL_TRACE_DEBUG("%s:A2DP command %s AV stream_started_ready %d",
+                             __func__, dump_a2dp_ctrl_event(cmd),btif_av_stream_started_ready());
+            if (bt_split_a2dp_enabled && reconfig_a2dp)
             {
-                APPL_TRACE_DEBUG("Suspend stream request to Av");
-                btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+                APPL_TRACE_DEBUG("Suspend called due to reconfig");
+                APPL_TRACE_DEBUG("VS exchange started: ACK suspend, cmd_start will block");
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             }
-            else if (bt_split_a2dp_enabled && btif_av_is_under_handoff())
+            else if (btif_av_stream_started_ready())
             {
-                /* Do nothing when handoff is in progress. On suspend cfm, a2dp cmd will
-                   be acknowledged. ACKing might lead to wrong codec config will be updated
-                   to hal during multi-codec connection */
-                APPL_TRACE_DEBUG("AV is under handoff");
+                APPL_TRACE_DEBUG("Suspend stream request to Av");
+                btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
             }
             else
             {
                 /* if we are not in started state, just ack back ok and let
                    audioflinger close the channel. This can happen if we are
                    remotely suspended, clear REMOTE SUSPEND Flag */
+                APPL_TRACE_DEBUG("%s:A2DP command %s AV stream_started_ready clear flag",
+                             __func__, dump_a2dp_ctrl_event(cmd));
                 btif_av_clear_remote_suspend_flag();
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             }
@@ -866,13 +1002,14 @@ static void btif_recv_ctrl_data(void)
         case A2DP_CTRL_GET_CODEC_CONFIG:
         {
             UINT16 min_mtu;
-            uint8_t param[20],idx,bta_hdl,codec_id = 0;
+            uint8_t param[MAX_CODEC_CFG_SIZE],idx,bta_hdl,codec_id = 0;
             uint32_t bitrate = 0;
             uint8_t i = 0;
             UIPC_Read(UIPC_CH_ID_AV_CTRL, NULL, &idx, 1);
-            memset(param,0,20);
+            memset(param,0,MAX_CODEC_CFG_SIZE);
 
-            if (btif_av_stream_started_ready() == FALSE)
+            if ((btif_av_stream_started_ready() == FALSE) ||
+                (enc_update_in_progress == TRUE))
             {
                 BTIF_TRACE_ERROR("A2DP_CTRL_GET_CODEC_CONFIG: stream not started");
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
@@ -906,7 +1043,17 @@ static void btif_recv_ctrl_data(void)
 
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             BTIF_TRACE_DEBUG("codec_id = %x",codec_id);
-            if (codec_id == BTIF_AV_CODEC_SBC)
+
+            if (get_soc_type() == BT_SOC_SMD)
+            {
+                //For Pronto PLs Audio pumps raw PCM data for others its encoded data to SOC
+                param[1] = 4; //RAW PCM
+                param[2] = AVDT_MEDIA_AUDIO;
+                param[3] = BTIF_AV_CODEC_PCM;
+                param[4] = btif_media_cb.media_feeding.cfg.pcm.sampling_freq;
+                param[5] = btif_media_cb.media_feeding.cfg.pcm.num_channel;
+            }
+            else if (codec_id == BTIF_AV_CODEC_SBC)
             {
                 tA2D_SBC_CIE codec_cfg;
                 bta_av_co_audio_get_sbc_config(&codec_cfg, &min_mtu);
@@ -935,24 +1082,49 @@ static void btif_recv_ctrl_data(void)
                 {
                     tA2D_APTX_CIE* codecInfo = 0;
                     codecInfo = (tA2D_APTX_CIE*) &ptr[BTA_AV_CFG_START_IDX];
-                    if (codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID 
+                    if (codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID
                         && codecInfo->codecId == A2D_APTX_CODEC_ID_BLUETOOTH)
                     {
                         tA2D_APTX_CIE aptx_config;
                         memset(&aptx_config,0,sizeof(tA2D_APTX_CIE));
                         aptx_config.vendorId = codecInfo->vendorId;
                         aptx_config.codecId = codecInfo->codecId;
-                        aptx_config.sampleRate = codecInfo->sampleRate;
-                        aptx_config.channelMode = codecInfo->channelMode;
+                        //SampleRate & Chmode are bitmasked
+                        aptx_config.sampleRate = (codecInfo->sampleRate & 0xF0);
+                        aptx_config.channelMode = (codecInfo->sampleRate & 0x0F);
                         BTIF_TRACE_DEBUG("vendor id = %x",aptx_config.vendorId);
                         BTIF_TRACE_DEBUG("codec id = %x",aptx_config.codecId);
                         BTIF_TRACE_DEBUG("sample rate  = %x",aptx_config.sampleRate);
                         BTIF_TRACE_DEBUG("ch mode  = %x",aptx_config.channelMode);
                         A2D_BldAptxInfo(AVDT_MEDIA_AUDIO,&aptx_config,&param[1]);
-                    }
+
+                        /* For aptxClassic BR = (Sampl_Rate * PCM_DEPTH * CHNL)/Compression_Ratio */
+                        bitrate = ((btif_media_cb.media_feeding.cfg.pcm.sampling_freq * 16 * 2)/4);
+                    } else {
+                        tA2D_APTX_HD_CIE* cI = 0;
+                        cI = (tA2D_APTX_HD_CIE*) &ptr[BTA_AV_CFG_START_IDX];
+                        if (cI && cI->vendorId == A2D_APTX_HD_VENDOR_ID
+                        && cI->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH)
+                        {
+                            tA2D_APTX_HD_CIE aptxhd_config;
+                            memset(&aptxhd_config,0,sizeof(tA2D_APTX_HD_CIE));
+                            aptxhd_config.vendorId = codecInfo->vendorId;
+                            aptxhd_config.codecId = codecInfo->codecId;
+                            //SampleRate & Chmode are bitmasked
+                            aptxhd_config.sampleRate = (codecInfo->sampleRate & 0xF0);
+                            aptxhd_config.channelMode = (codecInfo->sampleRate & 0x0F);
+                            BTIF_TRACE_DEBUG("vendor id = %x",aptxhd_config.vendorId);
+                            BTIF_TRACE_DEBUG("codec id = %x",aptxhd_config.codecId);
+                            BTIF_TRACE_DEBUG("sample rate  = %x",aptxhd_config.sampleRate);
+                            BTIF_TRACE_DEBUG("ch mode  = %x",aptxhd_config.channelMode);
+                            A2D_BldAptx_hdInfo(AVDT_MEDIA_AUDIO,&aptxhd_config,&param[1]);
+
+                            /* For aptxHD BR = (Sampl_Rate * PCM_DEPTH * CHNL)/Compression_Ratio,
+                               derived from classic */
+                            bitrate = ((btif_media_cb.media_feeding.cfg.pcm.sampling_freq * 16 * 2)/4);
+                       }
+                   }
                 }
-                /* For aptxClassic BR = (Sampl_Rate * PCM_DEPTH * CHNL)/Compression_Ratio */
-                bitrate = ((btif_media_cb.media_feeding.cfg.pcm.sampling_freq * 16 * 2)/4);
             }
             param[0] = btif_get_latest_playing_device_idx();
             i = param[1] + 2; //LOSC
@@ -995,7 +1167,7 @@ static void btif_recv_ctrl_data(void)
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             break;
         case A2DP_CTRL_GET_CONNECTION_STATUS:
-            if (btif_av_is_connected())
+            if (btif_av_is_connected() && media_task_running != MEDIA_TASK_STATE_SHUTTING_DOWN)
             {
                 BTIF_TRACE_DEBUG("got valid connection");
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
@@ -1087,11 +1259,14 @@ static BOOLEAN btif_media_task_is_aptx_configured()
         UINT8* ptr = bta_av_co_get_current_codecInfo();
         if (ptr) {
             tA2D_APTX_CIE* codecInfo = (tA2D_APTX_CIE*) &ptr[BTA_AV_CFG_START_IDX];
+            /* Fix for below Klockwork Issue.
+             * Pointer 'codecInfo' checked for NULL at line 1089 may be dereferenced at line 1092.*/
             if ((codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID && codecInfo->codecId == A2D_APTX_CODEC_ID_BLUETOOTH)
-                || (codecInfo && codecInfo->vendorId == A2D_APTX_HD_VENDOR_ID && codecInfo->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH))
+                || (codecInfo && codecInfo->vendorId == A2D_APTX_HD_VENDOR_ID && codecInfo->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH)) {
                 APPL_TRACE_DEBUG("%s codecId %d", __func__, codecInfo->codecId);
                 APPL_TRACE_DEBUG("%s vendorId %x", __func__, codecInfo->vendorId);
                 result = TRUE;
+            }
         }
     }
     return result;
@@ -1259,9 +1434,11 @@ static void btif_a2dp_encoder_update(void)
     tA2D_APTX_CIE* codecInfo = 0;
 
     APPL_TRACE_DEBUG("btif_a2dp_encoder_update");
+    btif_media_cb.tx_enc_update_initiated = TRUE;
 
     UINT8 codectype = 0;
     codectype = bta_av_co_get_current_codec();
+    enc_update_in_progress = TRUE;
     if (codectype == A2D_NON_A2DP_MEDIA_CT)
     {
         UINT8* ptr = bta_av_co_get_current_codecInfo();
@@ -1418,17 +1595,18 @@ void btif_a2dp_stop_media_task(void)
     media_task_running = MEDIA_TASK_STATE_SHUTTING_DOWN;
 
     // remove aptX thread
-    if (A2d_aptx_thread)
-    {
-        A2D_aptx_sched_stop();
-        thread_free(A2d_aptx_thread);
-        A2d_aptx_thread = NULL;
-    }
+    A2D_stop_aptX();
 
     // Stop timer
     alarm_free(btif_media_cb.media_alarm);
     btif_media_cb.media_alarm = NULL;
 
+    if (btif_media_cb.remote_start_alarm != NULL)
+    {
+        alarm_free(btif_media_cb.remote_start_alarm);
+        btif_media_cb.remote_start_alarm = NULL;
+        btif_dispatch_sm_event(BTIF_AV_RESET_REMOTE_STARTED_FLAG_EVT, NULL, 0);
+    }
     // Exit thread
     fixed_queue_free(btif_media_cmd_msg_queue, NULL);
     thread_post(worker_thread, btif_media_thread_cleanup, NULL);
@@ -1664,7 +1842,8 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
         else
         {
             /* ack back a local start request */
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+            if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
         }
         return TRUE;
     }
@@ -1684,7 +1863,10 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
                         }
                     }
                     else
-                        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+                    {
+                        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
+                            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+                    }
                     ack = TRUE;
                 }
             }
@@ -1696,8 +1878,8 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
                 {
                     if (btif_media_cb.peer_sep == AVDT_TSEP_SNK)
                     {
-                        APPL_TRACE_IMP("Initiate VSC exchange on remote start");
-                        btif_media_on_start_vendor_command();
+                        APPL_TRACE_IMP("Do not Initiate VSC exchange on remote start");
+                        //btif_media_on_start_vendor_command();
                     }
                 }
                 else
@@ -1711,13 +1893,13 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
     {
         APPL_TRACE_WARNING("%s: A2DP start request failed: status = %d",
                          __func__, p_av->status);
-        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
         ack = TRUE;
     }
     return ack;
 }
 
-
 /*****************************************************************************
 **
 ** Function        btif_a2dp_ack_fail
@@ -1768,7 +1950,9 @@ void btif_a2dp_on_stopped(tBTA_AV_SUSPEND *p_av)
             if (p_av->initiator) {
                 APPL_TRACE_WARNING("%s: A2DP stop request failed: status = %d",
                                    __func__, p_av->status);
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+                if ((btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP) ||
+                    (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND))
+                    a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
             }
             return;
         }
@@ -1816,7 +2000,9 @@ void btif_a2dp_on_suspended(tBTA_AV_SUSPEND *p_av)
         if (p_av->initiator == TRUE) {
             APPL_TRACE_WARNING("%s: A2DP suspend request failed: status = %d",
                                __func__, p_av->status);
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+            if ((btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP) ||
+                    (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND))
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
         }
     }
 
@@ -1829,9 +2015,83 @@ void btif_a2dp_on_suspended(tBTA_AV_SUSPEND *p_av)
     btif_media_task_stop_aa_req();
 }
 
+UINT8 btif_a2dp_get_pending_hal_command()
+{
+    return btif_media_cb.a2dp_cmd_pending;
+}
 
 /*****************************************************************************
 **
+** Function        btif_media_remote_start_alarm_cb
+**
+** Description     Remote start honor timer, if media is not started then
+**                 suspend AV
+** Returns
+**
+*******************************************************************************/
+static void btif_media_remote_start_alarm_cb(UNUSED_ATTR void *context) {
+  thread_post(worker_thread, btif_a2dp_remote_start_timer, NULL);
+}
+
+/*****************************************************************************
+**
+** Function        btif_a2dp_remote_start_timer
+**
+** Description     Suspend stream if media is not started for remote stream
+**                 start is honored
+** Returns
+**
+*******************************************************************************/
+void btif_a2dp_remote_start_timer()
+{
+    alarm_free(btif_media_cb.remote_start_alarm);
+    btif_media_cb.remote_start_alarm = NULL;
+    APPL_TRACE_DEBUG("Suspend stream request to Av");
+    btif_dispatch_sm_event(BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+}
+
+void btif_a2dp_cancel_remote_start_timer()
+{
+    if (alarm_is_scheduled(btif_media_cb.remote_start_alarm))
+    {
+        APPL_TRACE_DEBUG("Cancel remote start timer");
+        alarm_free(btif_media_cb.remote_start_alarm);
+        btif_media_cb.remote_start_alarm = NULL;
+    }
+}
+
+void btif_media_on_cancel_remote_start_alarm() {
+  thread_post(worker_thread, btif_a2dp_cancel_remote_start_timer, NULL);
+}
+
+/*****************************************************************************
+**
+** Function        btif_a2dp_on_remote_started
+**
+** Description
+**
+** Returns
+**
+*******************************************************************************/
+void btif_a2dp_on_remote_started()
+{
+    btif_media_cb.remote_start_alarm = alarm_new("btif.remote_start_task");
+
+    if (!btif_media_cb.remote_start_alarm)
+    {
+        APPL_TRACE_WARNING("%s:unable to allocate media alarm",__func__);
+        return;
+    }
+    alarm_set(btif_media_cb.remote_start_alarm, BTIF_REMOTE_START_TOUT,
+              btif_media_remote_start_alarm_cb, NULL);
+}
+
+BOOLEAN btif_is_remote_start_timer_scheduled()
+{
+    return (alarm_is_scheduled(btif_media_cb.remote_start_alarm))? TRUE:FALSE;
+}
+/*****************************************************************************
+**
 ** Function        btif_a2dp_on_offload_started
 **
 ** Description
@@ -1976,6 +2236,9 @@ static void btif_media_task_aa_handle_timer(UNUSED_ATTR void *context)
     if (alarm_is_scheduled(btif_media_cb.media_alarm))
     {
         btif_media_send_aa_frame(timestamp_us);
+        update_scheduling_stats(&btif_media_cb.stats.tx_queue_enqueue_stats,
+                                timestamp_us,
+                                BTIF_SINK_MEDIA_TIME_TICK_MS * 1000);
     }
     else
     {
@@ -2003,7 +2266,6 @@ static void btif_media_thread_init(UNUSED_ATTR void *context) {
 
   APPL_TRACE_IMP(" btif_media_thread_init");
   memset(&btif_media_cb, 0, sizeof(btif_media_cb));
-  btif_media_cb.stats.session_start_us = time_now_us();
 
   UIPC_Init(NULL);
 
@@ -2015,12 +2277,16 @@ static void btif_media_thread_init(UNUSED_ATTR void *context) {
 
   raise_priority_a2dp(TASK_HIGH_MEDIA);
   media_task_running = MEDIA_TASK_STATE_ON;
+  enc_update_in_progress = FALSE;
   APPL_TRACE_DEBUG(" btif_media_thread_init complete");
+  metrics_log_bluetooth_session_start(CONNECTION_TECHNOLOGY_TYPE_BREDR, 0);
 }
 
 static void btif_media_thread_cleanup(UNUSED_ATTR void *context) {
   APPL_TRACE_IMP(" btif_media_thread_cleanup");
 
+  APPL_TRACE_IMP(" before close the UIPC channnel, ack the pending cmd");
+  a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
   /* this calls blocks until uipc is fully closed */
   UIPC_Close(UIPC_CH_ID_ALL);
 
@@ -2033,7 +2299,9 @@ static void btif_media_thread_cleanup(UNUSED_ATTR void *context) {
 
   /* Clear media task flag */
   media_task_running = MEDIA_TASK_STATE_OFF;
+  enc_update_in_progress = FALSE;
   APPL_TRACE_DEBUG(" btif_media_thread_cleanup complete");
+  metrics_log_bluetooth_session_end(DISCONNECT_REASON_UNKNOWN, 0);
 }
 
 /*******************************************************************************
@@ -2130,20 +2398,29 @@ static void btif_media_thread_handle_cmd(fixed_queue_t *queue, UNUSED_ATTR void
         btif_media_cb.tx_stop_initiated = FALSE;
         btif_media_cb.vs_configs_exchanged = FALSE;
         btif_media_cb.tx_start_initiated = FALSE;
+        btif_media_cb.tx_enc_update_initiated = FALSE;
         break;
     case BTIF_MEDIA_START_VS_CMD:
-        if (!btif_media_cb.tx_started && !btif_media_cb.tx_start_initiated)
+        if (!btif_hf_is_call_vr_idle())
+        {
+            APPL_TRACE_IMP("ignore VS start request as Call is not idle");
+        }
+        else if (!btif_media_cb.tx_started
+             && (!btif_media_cb.tx_start_initiated || btif_media_cb.tx_enc_update_initiated))
         {
             btif_a2dp_encoder_update();
             btif_media_start_vendor_command();
         }
         else
+        {
             APPL_TRACE_IMP("ignore VS start request");
+        }
         break;
     case BTIF_MEDIA_STOP_VS_CMD:
         if (btif_media_cb.tx_started && !btif_media_cb.tx_stop_initiated)
             btif_media_send_vendor_stop();
-        else if(btif_media_cb.tx_start_initiated && !btif_media_cb.tx_started)
+        else if((btif_media_cb.tx_start_initiated || btif_media_cb.tx_enc_update_initiated)
+                && !btif_media_cb.tx_started)
         {
             APPL_TRACE_IMP("Suspend Req when VSC exchange in progress,reset VSC");
             btif_media_send_reset_vendor_state();
@@ -2152,50 +2429,96 @@ static void btif_media_thread_handle_cmd(fixed_queue_t *queue, UNUSED_ATTR void
             APPL_TRACE_IMP("ignore VS stop request");
         break;
     case BTIF_MEDIA_VS_A2DP_START_SUCCESS:
+        if (get_soc_type() == BT_SOC_SMD)
+        {
+            btif_media_cb.vs_configs_exchanged = false;
+        }
         btif_media_cb.tx_start_initiated = FALSE;
         btif_media_cb.tx_started = TRUE;
-        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
+        {
+            btif_av_reset_reconfig_flag();
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+        }
+        else
+        {
+            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
+                                    btif_media_cb.a2dp_cmd_pending);
+        }
         break;
     case BTIF_MEDIA_VS_A2DP_START_FAILURE:
+        if (get_soc_type() == BT_SOC_SMD)
+        {
+            btif_media_cb.vs_configs_exchanged = false;
+        }
         btif_media_cb.tx_start_initiated = FALSE;
-        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
+        {
+            btif_av_reset_reconfig_flag();
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+        }
+        else
+        {
+            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
+                                    btif_media_cb.a2dp_cmd_pending);
+        }
         disconnect_a2dp_on_vendor_start_failure();
         break;
     case BTIF_MEDIA_VS_A2DP_STOP_SUCCESS:
         btif_media_cb.tx_started = FALSE;
         btif_media_cb.tx_stop_initiated = FALSE;
-        /*Reset vendor state after stop success
-          to handle stream started for touch tone
-          to connect to second other device
-        */
-        btif_media_send_reset_vendor_state();
         if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND ||
             btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP)
         {
+            /*Reset vendor state after stop success
+              to handle stream started for touch tone
+              to connect to second other device
+            */
+            btif_media_send_reset_vendor_state();
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
         }
         else
         {
-            APPL_TRACE_ERROR("wrong cmd pending");
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
+                                    btif_media_cb.a2dp_cmd_pending);
         }
         break;
     case BTIF_MEDIA_VS_A2DP_STOP_FAILURE:
         btif_media_cb.tx_stop_initiated = FALSE;
-        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND ||
+            btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP)
+        {
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+        }
+        else
+        {
+            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
+                                    btif_media_cb.a2dp_cmd_pending);
+        }
         break;
     case BTIF_MEDIA_VS_A2DP_MEDIA_CHNL_CFG_SUCCESS:
         //btif_media_send_vendor_pref_bit_rate();
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
         btif_media_send_vendor_scmst_hdr();
 #else
-        if (!btif_media_cb.vs_configs_exchanged &&
-              btif_media_cb.tx_start_initiated)
-            btif_media_cb.vs_configs_exchanged = TRUE;
+        if (get_soc_type() == BT_SOC_SMD)
+        {
+            if (!btif_media_cb.vs_configs_exchanged &&
+                  btif_media_cb.tx_start_initiated)
+                btif_media_cb.vs_configs_exchanged = TRUE;
+            else
+            {
+                APPL_TRACE_ERROR("Dont send start,stream suspended")
+                break;
+            }
+        }
         else
         {
-            APPL_TRACE_ERROR("Dont send start,stream suspended")
-            break;
+            if (!btif_media_cb.tx_start_initiated)
+            {
+                APPL_TRACE_ERROR("Dont send start,stream suspended")
+                break;
+            }
         }
         btif_media_send_vendor_start();
 #endif
@@ -2213,20 +2536,34 @@ static void btif_media_thread_handle_cmd(fixed_queue_t *queue, UNUSED_ATTR void
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
         btif_media_send_vendor_scmst_hdr();
 #else
-        if (!btif_media_cb.vs_configs_exchanged)
+        if ((get_soc_type() == BT_SOC_SMD) &&
+                    (!btif_media_cb.vs_configs_exchanged))
+        {
             btif_media_cb.vs_configs_exchanged = TRUE;
+        }
         btif_media_send_vendor_start();
 #endif
         break;
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
     case BTIF_MEDIA_VS_A2DP_SET_SCMST_HDR_SUCCESS:
-        if (!btif_media_cb.vs_configs_exchanged &&
-              btif_media_cb.tx_start_initiated)
-            btif_media_cb.vs_configs_exchanged = TRUE;
+        if (get_soc_type() == BT_SOC_SMD)
+        {
+            if (!btif_media_cb.vs_configs_exchanged &&
+                  btif_media_cb.tx_start_initiated)
+                btif_media_cb.vs_configs_exchanged = TRUE;
+            else
+            {
+                APPL_TRACE_ERROR("Dont send start,stream suspended")
+                break;
+            }
+        }
         else
         {
-            APPL_TRACE_ERROR("Dont send start,stream suspended")
-            break;
+            if (!btif_media_cb.tx_start_initiated)
+            {
+                APPL_TRACE_ERROR("Dont send start,stream suspended")
+                break;
+            }
         }
         btif_media_send_vendor_start();
         break;
@@ -2386,6 +2723,14 @@ BOOLEAN btif_media_task_start_aa_req(void)
 
     if (btif_media_cmd_msg_queue != NULL)
         fixed_queue_enqueue(btif_media_cmd_msg_queue, p_buf);
+    memset(&btif_media_cb.stats, 0, sizeof(btif_media_stats_t));
+    // Assign session_start_us to 1 when time_now_us() is 0 to indicate
+    // btif_media_task_start_aa_req() has been called
+    btif_media_cb.stats.session_start_us = time_now_us();
+    if (btif_media_cb.stats.session_start_us == 0) {
+        btif_media_cb.stats.session_start_us = 1;
+    }
+    btif_media_cb.stats.session_end_us = 0;
     return TRUE;
 }
 
@@ -2414,8 +2759,14 @@ BOOLEAN btif_media_task_stop_aa_req(void)
      * the "cleanup() -> btif_a2dp_stop_media_task()" processing during
      * the shutdown of the Bluetooth stack.
      */
-    if (btif_media_cmd_msg_queue != NULL)
+    if (btif_media_cmd_msg_queue != NULL) {
         fixed_queue_enqueue(btif_media_cmd_msg_queue, p_buf);
+    }
+
+    btif_media_cb.stats.session_end_us = time_now_us();
+    btif_update_a2dp_metrics();
+    btif_a2dp_source_accumulate_stats(&btif_media_cb.stats,
+        &btif_media_cb.accumulated_stats);
 
     return TRUE;
 }
@@ -2641,12 +2992,14 @@ static void btif_media_task_enc_update(BT_HDR *p_msg)
             btif_media_cb.TxAaMtuSize = ((BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_OFFSET - sizeof(BT_HDR)) < pUpdateAudio->MinMtuSize) ?
                                                   (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_OFFSET - sizeof(BT_HDR)) : pUpdateAudio->MinMtuSize;
             APPL_TRACE_DEBUG("%s : aptX btif_media_cb.TxAaMtuSize %d", __func__, btif_media_cb.TxAaMtuSize);
+            enc_update_in_progress = FALSE;
             return;
         } else if ((pUpdateAudio->BluetoothVendorID == A2D_APTX_HD_VENDOR_ID)
             && (pUpdateAudio->BluetoothCodecID == A2D_APTX_HD_CODEC_ID_BLUETOOTH)) {
             APPL_TRACE_DEBUG("%s aptX HD", __func__);
             btif_media_cb.TxAaMtuSize = ((BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_HD_OFFSET - sizeof(BT_HDR)) < pUpdateAudio->MinMtuSize) ?
                                                   (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_HD_OFFSET - sizeof(BT_HDR)) : pUpdateAudio->MinMtuSize;
+            enc_update_in_progress = FALSE;
             return;
         } else {
             /* do nothing, fall through to SBC */
@@ -2659,6 +3012,7 @@ static void btif_media_task_enc_update(BT_HDR *p_msg)
                                       BTIF_MEDIA_AA_AAC_OFFSET - sizeof(BT_HDR))
                 < pUpdateAudio->MinMtuSize) ? (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_AAC_OFFSET
                 - sizeof(BT_HDR)) : pUpdateAudio->MinMtuSize;
+       enc_update_in_progress = FALSE;
        return;
     }
 #endif
@@ -2804,6 +3158,7 @@ static void btif_media_task_enc_update(BT_HDR *p_msg)
         }
         btif_media_cb.tx_sbc_frames = calculate_max_frames_per_packet();
     }
+    enc_update_in_progress = FALSE;
 }
 
 /*******************************************************************************
@@ -3470,35 +3825,32 @@ static void btif_media_task_aa_start_tx(void)
     if (!bt_split_a2dp_enabled)
     {
         if (isA2dAptXEnabled && btif_media_task_is_aptx_configured()) {
+
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
-          BOOLEAN use_SCMS_T = true;
+        BOOLEAN use_SCMS_T = true;
 #else
-          BOOLEAN use_SCMS_T = false;
+        BOOLEAN use_SCMS_T = false;
 #endif
-          A2D_AptXCodecType aptX_codec_type = btif_media_task_get_aptX_codec_type();
-          BOOLEAN is_24bit_audio = true;
-
-          BOOLEAN test = false;
-          BOOLEAN trace = false;
-
-          A2d_aptx_thread_fn = A2D_aptx_sched_start(btif_media_cb.aptxEncoderParams.encoder,
-                   aptX_codec_type,
-                   use_SCMS_T,
-                   is_24bit_audio,
-                   btif_media_cb.media_feeding.cfg.pcm.sampling_freq,
-                   btif_media_cb.media_feeding.cfg.pcm.bit_per_sample,
-                   UIPC_CH_ID_AV_AUDIO,
-                   btif_media_cb.TxAaMtuSize,
-                   UIPC_Read,
-                   btif_media_task_cb_packet_send,
-                   raise_priority_a2dp,
-                   test,
-                   trace);
-
-          A2d_aptx_thread = thread_new("aptx_media_worker");
-          if (A2d_aptx_thread ) {
-             thread_post(A2d_aptx_thread, A2d_aptx_thread_fn, NULL);
-          }
+        A2D_AptXCodecType aptX_codec_type = btif_media_task_get_aptX_codec_type();
+        BOOLEAN is_24bit_audio = true;
+
+        BOOLEAN test = false;
+        BOOLEAN trace = false;
+
+        A2D_start_aptX(btif_media_cb.aptxEncoderParams.encoder,
+                 aptX_codec_type,
+                 use_SCMS_T,
+                 is_24bit_audio,
+                 btif_media_cb.media_feeding.cfg.pcm.sampling_freq,
+                 btif_media_cb.media_feeding.cfg.pcm.bit_per_sample,
+                 UIPC_CH_ID_AV_AUDIO,
+                 btif_media_cb.TxAaMtuSize,
+                 UIPC_Read,
+                 btif_media_task_cb_packet_send,
+                 raise_priority_a2dp,
+                 test,
+                 trace);
+
         } else {
             APPL_TRACE_EVENT("starting timer %dms", BTIF_MEDIA_TIME_TICK);
 
@@ -3530,12 +3882,12 @@ static void btif_media_task_aa_stop_tx(void)
     {
         APPL_TRACE_IMP("%s media_alarm is %srunning", __func__,
                          alarm_is_scheduled(btif_media_cb.media_alarm)? "" : "not ");
-        const bool send_ack = alarm_is_scheduled(btif_media_cb.media_alarm);
+        const bool send_ack = alarm_is_scheduled(btif_media_cb.media_alarm) |
+                                             btif_is_remote_start_timer_scheduled();
 
-        if (isA2dAptXEnabled && A2D_aptx_sched_stop())
+        if (isA2dAptXEnabled && A2d_aptx_thread)
         {
-            thread_free(aptx_thread);
-            aptx_thread = NULL;
+            A2D_stop_aptX();
         }
         else
         {
@@ -3571,17 +3923,30 @@ static void btif_media_task_aa_stop_tx(void)
     {
         APPL_TRACE_IMP("%s tx_started: %d, tx_stop_initiated: %d",
             __func__, btif_media_cb.tx_started, btif_media_cb.tx_stop_initiated);
+        if (btif_media_cb.remote_start_alarm != NULL)
+        {
+            alarm_free(btif_media_cb.remote_start_alarm);
+            btif_media_cb.remote_start_alarm = NULL;
+            btif_dispatch_sm_event(BTIF_AV_RESET_REMOTE_STARTED_FLAG_EVT, NULL, 0);
+        }
         if (btif_media_cb.tx_started && !btif_media_cb.tx_stop_initiated)
             btif_media_send_vendor_stop();
         else
         {
             if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP ||
                 btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND)
+            {
+                BTIF_TRACE_DEBUG("Ack Pending Stop/Suspend");
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+            }
+            else if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
+            {
+                BTIF_TRACE_ERROR("Ack Pending Start while Disconnect in Progress");
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_DISCONNECT_IN_PROGRESS);
+            }
             else
             {
                 BTIF_TRACE_ERROR("Invalid cmd pending for ack");
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
             }
         }
     }
@@ -4173,9 +4538,6 @@ static void btif_media_aa_prep_sbc_2_send(UINT8 nb_frame,
             }
 
             /* Enqueue the encoded SBC frame in AA Tx Queue */
-            update_scheduling_stats(&btif_media_cb.stats.tx_queue_enqueue_stats,
-                                    timestamp_us,
-                                    BTIF_SINK_MEDIA_TIME_TICK_MS * 1000);
             uint8_t done_nb_frame = remain_nb_frame - nb_frame;
             remain_nb_frame = nb_frame;
             btif_media_cb.stats.tx_queue_total_frames += done_nb_frame;
@@ -4204,7 +4566,7 @@ static void btif_media_aa_prep_sbc_2_send(UINT8 nb_frame,
 static void btif_media_aa_prep_2_send(UINT8 nb_frame, uint64_t timestamp_us)
 {
     // Check for TX queue overflow
-
+    BD_ADDR peer_bda;
     if (nb_frame > MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ)
         nb_frame = MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ;
 
@@ -4213,13 +4575,23 @@ static void btif_media_aa_prep_2_send(UINT8 nb_frame, uint64_t timestamp_us)
         APPL_TRACE_WARNING("%s() - TX queue buffer count %d/%d", __func__,
                            fixed_queue_length(btif_media_cb.TxAaQ),
                            MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ - nb_frame);
+        // Keep track of drop-outs
         btif_media_cb.stats.tx_queue_dropouts++;
         btif_media_cb.stats.tx_queue_last_dropouts_us = timestamp_us;
 
+        // Flush all queued buffers...
+        size_t drop_n = fixed_queue_length(btif_media_cb.TxAaQ);
+        if (drop_n > btif_media_cb.stats.tx_queue_max_dropped_messages) {
+            btif_media_cb.stats.tx_queue_max_dropped_messages = drop_n;
+        }
         while (fixed_queue_length(btif_media_cb.TxAaQ)) {
             btif_media_cb.stats.tx_queue_total_dropped_messages++;
             osi_free(fixed_queue_try_dequeue(btif_media_cb.TxAaQ));
         }
+
+        // Request RSSI for log purposes if we had to flush buffers
+        btif_av_get_addr(peer_bda);
+        BTM_ReadRSSI(peer_bda, btm_read_rssi_cb);
     }
 
     // Transcode frame
@@ -4333,6 +4705,7 @@ void disconnect_a2dp_on_vendor_start_failure()
 {
     bt_bdaddr_t bd_addr;
     APPL_TRACE_IMP("disconnect_a2dp_on_vendor_start_failure");
+    btif_av_reset_reconfig_flag();
     btif_av_get_peer_addr(&bd_addr);
     btif_dispatch_sm_event(BTIF_AV_DISCONNECT_REQ_EVT,(char*)&bd_addr,
             sizeof(bt_bdaddr_t));
@@ -4349,20 +4722,25 @@ void btif_media_send_reset_vendor_state()
 
 void btif_media_start_vendor_command()
 {
-    APPL_TRACE_IMP("btif_media_start_vendor_command_exchange:\
-        vs_configs_exchanged:%u", btif_media_cb.vs_configs_exchanged);
+    APPL_TRACE_IMP("btif_media_start_vendor_command_exchange");
     btif_media_cb.tx_start_initiated = TRUE;
-    if(btif_media_cb.vs_configs_exchanged)
+    btif_media_cb.tx_enc_update_initiated = FALSE;
+
+    if (get_soc_type() == BT_SOC_SMD)
     {
-        btif_media_send_vendor_start();
+        APPL_TRACE_IMP("vs_configs_exchanged:%u", btif_media_cb.vs_configs_exchanged);
+        if(btif_media_cb.vs_configs_exchanged)
+        {
+            btif_media_send_vendor_start();
+        }
+        else
+        {
+            btif_media_send_vendor_write_sbc_cfg();
+        }
     }
     else
     {
-#if 0
-        btif_media_send_vendor_write_sbc_cfg();
-#else
         btif_media_send_vendor_selected_codec();
-#endif
     }
 }
 
@@ -4414,6 +4792,7 @@ void btif_media_a2dp_start_cb(tBTM_VSC_CMPL *param)
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
         else
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+        btif_av_reset_reconfig_flag();
     }
 }
 
@@ -4632,12 +5011,54 @@ BOOLEAN btif_media_send_vendor_media_chn_cfg()
     UINT8 param[8];
     bt_bdaddr_t bd_addr;
     BD_ADDR addr;
+    UINT8 codec_type = A2DP_CODEC_SBC;
+
+    if (btif_av_is_peer_edr() && (btif_av_peer_supports_3mbps() == FALSE)) {
+        // This condition would be satisfied only if the remote device is
+        // EDR and supports only 2 Mbps, but the effective AVDTP MTU size
+        // exceeds the 2DH5 packet size.
+        APPL_TRACE_DEBUG("%s The remote devce is EDR but does not support 3 Mbps", __func__);
+
+        if (btif_media_cb.TxAaMtuSize > MAX_2MBPS_AVDTP_MTU) {
+            APPL_TRACE_WARNING("%s Restricting AVDTP MTU size to %d",
+                __func__, MAX_2MBPS_AVDTP_MTU);
+            btif_media_cb.TxAaMtuSize = MAX_2MBPS_AVDTP_MTU;
+        }
+    }
+
+    codec_type = bta_av_co_get_current_codec();
+    if (codec_type == A2D_NON_A2DP_MEDIA_CT) {
+        UINT8* ptr = bta_av_co_get_current_codecInfo();
+        if (ptr) {
+            tA2D_APTX_CIE* codecInfo = (tA2D_APTX_CIE*) &ptr[BTA_AV_CFG_START_IDX];
+            if (codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID && codecInfo->codecId == A2D_APTX_CODEC_ID_BLUETOOTH)
+                   codec_type = A2DP_CODEC_APTX;
+            else if (codecInfo && codecInfo->vendorId == A2D_APTX_HD_VENDOR_ID && codecInfo->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH)
+                   codec_type = A2DP_CODEC_APTX_HD;
+        }
+    }
+
+    if ((codec_type == A2DP_CODEC_APTX) || (codec_type == A2DP_CODEC_APTX_HD))
+    {
+        if (btif_media_cb.TxAaMtuSize > MAX_2MBPS_AVDTP_MTU)
+        {
+            APPL_TRACE_IMP("Restricting AVDTP MTU size to 663 for APTx codecs");
+            btif_media_cb.TxAaMtuSize = MAX_2MBPS_AVDTP_MTU;
+        }
+    }
+
     btif_av_get_peer_addr(&bd_addr);
     memcpy(addr, bd_addr.address, sizeof(BD_ADDR));
     UINT16 acl_hdl = BTM_GetHCIConnHandle(addr, BT_TRANSPORT_BR_EDR);
     APPL_TRACE_IMP("btif_media_send_vendor_media_chn_cfg");
     APPL_TRACE_IMP("AVDTP mtu: %u, hdl: %u", btif_media_cb.TxAaMtuSize, acl_hdl);
 
+    if ((codec_type == A2DP_CODEC_SBC) && (btif_media_cb.max_bitpool <= BTIF_A2DP_MAX_BITPOOL_MQ))
+    {
+        APPL_TRACE_IMP("Restricting streaming MTU size for MQ Bitpool");
+        btif_media_cb.TxAaMtuSize = MAX_2MBPS_AVDTP_MTU;
+    }
+
     param[0] = VS_QHCI_WRITE_A2DP_MEDIA_CHANNEL_CFG;
     param[1] = 0; /*needs to send index for multi A2dp*/
     param[2] = (UINT8)(acl_hdl & 0x00ff);
@@ -4885,8 +5306,10 @@ void dump_codec_info(unsigned char *p_codec)
 
 void btif_debug_a2dp_dump(int fd)
 {
+    btif_a2dp_source_accumulate_stats(&btif_media_cb.stats,
+                                    &btif_media_cb.accumulated_stats);
     uint64_t now_us = time_now_us();
-    btif_media_stats_t *stats = &btif_media_cb.stats;
+    btif_media_stats_t *stats = &btif_media_cb.accumulated_stats;
     scheduling_stats_t *enqueue_stats = &stats->tx_queue_enqueue_stats;
     scheduling_stats_t *dequeue_stats = &stats->tx_queue_dequeue_stats;
     size_t ave_size;
@@ -5020,52 +5443,51 @@ void btif_debug_a2dp_dump(int fd)
 
 void btif_update_a2dp_metrics(void)
 {
-    uint64_t now_us = time_now_us();
-    btif_media_stats_t *stats = &btif_media_cb.stats;
-    scheduling_stats_t *dequeue_stats = &stats->tx_queue_dequeue_stats;
-    int32_t media_timer_min_ms = 0;
-    int32_t media_timer_max_ms = 0;
-    int32_t media_timer_avg_ms = 0;
-    int32_t buffer_overruns_max_count = 0;
-    int32_t buffer_overruns_total = 0;
-    float buffer_underruns_average = 0.0;
-    int32_t buffer_underruns_count = 0;
-
-    int64_t session_duration_sec =
-        (now_us - stats->session_start_us) / (1000 * 1000);
-
-    /* NOTE: Disconnect reason is unused */
-    const char *disconnect_reason = NULL;
-    uint32_t device_class = BTM_COD_MAJOR_AUDIO;
-
-    if (dequeue_stats->total_updates > 1) {
-        media_timer_min_ms = BTIF_SINK_MEDIA_TIME_TICK_MS -
-            (dequeue_stats->max_premature_scheduling_delta_us / 1000);
-        media_timer_max_ms = BTIF_SINK_MEDIA_TIME_TICK_MS +
-            (dequeue_stats->max_overdue_scheduling_delta_us / 1000);
-
-        uint64_t total_scheduling_count =
-            dequeue_stats->overdue_scheduling_count +
-            dequeue_stats->premature_scheduling_count +
-            dequeue_stats->exact_scheduling_count;
-        if (total_scheduling_count > 0) {
-            media_timer_avg_ms = dequeue_stats->total_scheduling_time_us /
-                (1000 * total_scheduling_count);
+    btif_media_stats_t* stats = &btif_media_cb.stats;
+    scheduling_stats_t* enqueue_stats = &stats->tx_queue_enqueue_stats;
+    A2dpSessionMetrics_t metrics;
+    metrics.media_timer_min_ms = -1;
+    metrics.media_timer_max_ms = -1;
+    metrics.media_timer_avg_ms = -1;
+    metrics.total_scheduling_count = -1;
+    metrics.buffer_overruns_max_count = -1;
+    metrics.buffer_overruns_total = -1;
+    metrics.buffer_underruns_average = -1.0;
+    metrics.buffer_underruns_count = -1;
+    metrics.audio_duration_ms = -1;
+    // session_start_us is 0 when btif_media_task_start_aa_req() is not called
+    // mark the metric duration as invalid (-1) in this case
+    if (stats->session_start_us != 0) {
+        int64_t session_end_us = stats->session_end_us == 0
+                               ? time_now_us()
+                               : stats->session_end_us;
+        metrics.audio_duration_ms = (session_end_us - stats->session_start_us) / 1000;
+    }
+    if (enqueue_stats->total_updates > 1) {
+        metrics.media_timer_min_ms = BTIF_SINK_MEDIA_TIME_TICK_MS -
+            (enqueue_stats->max_premature_scheduling_delta_us / 1000);
+        metrics.media_timer_max_ms = BTIF_SINK_MEDIA_TIME_TICK_MS +
+            (enqueue_stats->max_overdue_scheduling_delta_us / 1000);
+        metrics.total_scheduling_count
+            = enqueue_stats->overdue_scheduling_count +
+                enqueue_stats->premature_scheduling_count +
+                    enqueue_stats->exact_scheduling_count;
+        if (metrics.total_scheduling_count > 0) {
+            metrics.media_timer_avg_ms = enqueue_stats->total_scheduling_time_us /
+                (1000 * metrics.total_scheduling_count);
         }
-
-        buffer_overruns_max_count = stats->media_read_max_expected_frames;
-        buffer_overruns_total = stats->tx_queue_total_dropped_messages;
-        buffer_underruns_count = stats->media_read_total_underflow_count +
-            stats->media_read_total_underrun_count;
-        if (buffer_underruns_count > 0) {
-            buffer_underruns_average =
-                (stats->media_read_total_underflow_bytes + stats->media_read_total_underrun_bytes) / buffer_underruns_count;
+        metrics.buffer_overruns_max_count = stats->tx_queue_max_dropped_messages;
+        metrics.buffer_overruns_total = stats->tx_queue_total_dropped_messages;
+        metrics.buffer_underruns_count =
+            stats->media_read_total_underflow_count +
+                stats->media_read_total_underrun_count;
+        metrics.buffer_underruns_average = 0;
+        if (metrics.buffer_underruns_count > 0) {
+            metrics.buffer_underruns_average =
+                (stats->media_read_total_underflow_bytes +
+                    stats->media_read_total_underrun_bytes) /
+                        metrics.buffer_underruns_count;
         }
     }
-
-    metrics_a2dp_session(session_duration_sec, disconnect_reason, device_class,
-                         media_timer_min_ms, media_timer_max_ms,
-                         media_timer_avg_ms, buffer_overruns_max_count,
-                         buffer_overruns_total, buffer_underruns_average,
-                         buffer_underruns_count);
+    metrics_log_a2dp_session(&metrics);
 }
diff --git a/btif/src/btif_rc.c b/btif/src/btif_rc.c
index 5553f88..c3ca306 100644
--- a/btif/src/btif_rc.c
+++ b/btif/src/btif_rc.c
@@ -38,6 +38,7 @@
 #include "bta_api.h"
 #include "bta_av_api.h"
 #include "btif_av.h"
+#include "btif_media.h"
 #include "btif_common.h"
 #include "btif_util.h"
 #include "bt_common.h"
@@ -47,6 +48,7 @@
 #include "osi/include/list.h"
 #include "osi/include/properties.h"
 #include "btu.h"
+#include "stack/sdp/sdpint.h"
 #define RC_INVALID_TRACK_ID (0xFFFFFFFFFFFFFFFFULL)
 
 /*****************************************************************************
@@ -131,7 +133,7 @@
 
 #define FILL_PDU_QUEUE(idx, ctype, label, pending, index, cmd)                                 \
 {                                                                                              \
-    btif_rc_cb[index].rc_pdu_info[idx].ctype = ctype;                                          \
+    btif_rc_cb[index].rc_pdu_info[idx].ctype[idx] = ctype;                                     \
     TXN_LABEL_ENQUEUE(btif_rc_cb[index].rc_handle, btif_rc_cb[index].rc_pdu_info[idx].label,   \
             btif_rc_cb[index].rc_pdu_info[idx].front, btif_rc_cb[index].rc_pdu_info[idx].rear, \
             btif_rc_cb[index].rc_pdu_info[idx].size, label, cmd);                              \
@@ -154,12 +156,14 @@
             btif_rc_cb[index].rc_pdu_info[idx].rear,                                           \
             btif_rc_cb[index].rc_pdu_info[idx].size);                                          \
     send_metamsg_rsp(btif_rc_cb[index].rc_handle, curr_label,                                  \
-            btif_rc_cb[index].rc_pdu_info[idx].ctype, avrc_rsp);                               \
+            btif_rc_cb[index].rc_pdu_info[idx].ctype[idx], avrc_rsp);                          \
     BTIF_TRACE_DEBUG("%s txn label %d dequeued from txn queue, queue sz %d \n", __FUNCTION__,  \
             curr_label, btif_rc_cb[index].rc_pdu_info[idx].size);                              \
-    btif_rc_cb[index].rc_pdu_info[idx].ctype = 0;                                              \
     if (btif_rc_cb[index].rc_pdu_info[idx].size == 0)                                          \
+    {                                                                                          \
+        btif_rc_cb[index].rc_pdu_info[idx].ctype[idx] = 0;                                     \
         btif_rc_cb[index].rc_pdu_info[idx].is_rsp_pending = FALSE;                             \
+    }                                                                                          \
 }
 
 #define SEND_BROWSEMSG_RSP(idx , avrc_rsp, index)                                              \
@@ -176,12 +180,14 @@
             btif_rc_cb[index].rc_pdu_info[idx].rear,                                           \
             btif_rc_cb[index].rc_pdu_info[idx].size);                                          \
     send_browsemsg_rsp(btif_rc_cb[index].rc_handle, curr_label,                                \
-            btif_rc_cb[index].rc_pdu_info[idx].ctype, avrc_rsp);                               \
+            btif_rc_cb[index].rc_pdu_info[idx].ctype[idx], avrc_rsp);                          \
     BTIF_TRACE_DEBUG("%s txn label %d dequeued from txn queue, queue sz %d \n", __FUNCTION__,  \
             curr_label, btif_rc_cb[index].rc_pdu_info[idx].size);                              \
-    btif_rc_cb[index].rc_pdu_info[idx].ctype = 0;                                              \
     if (btif_rc_cb[index].rc_pdu_info[idx].size == 0)                                          \
+    {                                                                                          \
+        btif_rc_cb[index].rc_pdu_info[idx].ctype[idx] = 0;                                     \
         btif_rc_cb[index].rc_pdu_info[idx].is_rsp_pending = FALSE;                             \
+    }                                                                                          \
 }
 
 /*****************************************************************************
@@ -198,7 +204,7 @@ typedef struct
     int rear;
     int size;
     UINT8 label[MAX_TRANSACTIONS_PER_SESSION];
-    UINT8   ctype;
+    UINT8 ctype[MAX_TRANSACTIONS_PER_SESSION];
     BOOLEAN is_rsp_pending;
 } btif_rc_cmd_ctxt_t;
 
@@ -377,6 +383,7 @@ static int btif_rc_get_idx_by_addr(BD_ADDR address);
 static void send_browsemsg_rsp (UINT8 rc_handle, UINT8 label,
     tBTA_AV_CODE code, tAVRC_RESPONSE *pmetamsg_resp);
 
+static char const* key_id_to_str(uint16_t id);
 
 /*****************************************************************************
 **  Static variables
@@ -400,10 +407,12 @@ extern void btif_get_latest_playing_device(BD_ADDR address); //get the Playing d
 extern BOOLEAN btif_av_is_playing();
 extern BOOLEAN btif_av_is_device_connected(BD_ADDR address);
 extern void btif_av_trigger_dual_handoff(BOOLEAN handoff, BD_ADDR address);
-extern BOOLEAN btif_hf_is_call_idle();
+extern BOOLEAN btif_hf_is_call_vr_idle();
 extern BOOLEAN btif_av_is_current_device(BD_ADDR address);
 extern UINT16 btif_av_get_num_connected_devices(void);
 extern UINT16 btif_av_get_num_playing_devices(void);
+extern BOOLEAN btif_av_is_offload_supported();
+extern UINT8 btif_av_idx_by_bdaddr(BD_ADDR bd_addr);
 
 extern fixed_queue_t *btu_general_alarm_queue;
 
@@ -439,7 +448,7 @@ void send_key (int fd, uint16_t key, int pressed)
         return;
     }
 
-    BTIF_TRACE_IMP("AVRCP: Send key %d (%d) fd=%d", key, pressed, fd);
+    LOG_INFO(LOG_TAG, "AVRCP: Send key %s (%d) fd=%d", key_id_to_str(key), pressed, fd);
     send_event(fd, EV_KEY, key, pressed);
     send_event(fd, EV_SYN, SYN_REPORT, 0);
 }
@@ -606,7 +615,7 @@ void handle_rc_features(int index)
                          bdaddr_to_string(&avdtp_addr, addr1, sizeof(bdstr_t)),
                          bdaddr_to_string(&rc_addr, addr2, sizeof(bdstr_t)) );
 
-        if (interop_match_addr(INTEROP_DISABLE_ABSOLUTE_VOLUME, &rc_addr)
+        if (interop_match_addr(INTEROP_DISABLE_ABSOLUTE_VOLUME, (bt_bdaddr_t *)&rc_addr)
                 || absolute_volume_disabled()
                 || bdcmp(avdtp_addr.address, rc_addr.address))
             btif_rc_cb[index].rc_features &= ~BTA_AV_FEAT_ADV_CTRL;
@@ -1158,8 +1167,17 @@ void handle_rc_passthrough_cmd ( tBTA_AV_REMOTE_CMD *p_remote_cmd)
     }
 
     if (key_map[i].name == NULL)
+    {
         BTIF_TRACE_ERROR("%s AVRCP: unknown button 0x%02X %s", __FUNCTION__,
                         p_remote_cmd->rc_id, status);
+    }
+    else
+    {
+        BTIF_TRACE_ERROR("%s AVRCP:send passthrough cmd = %s to BT Apps ",
+                        __FUNCTION__, key_map[i].name);
+        bdcpy(remote_address.address, btif_rc_cb[index].rc_addr);
+        HAL_CBACK(bt_rc_callbacks, passthrough_cmd_cb, p_remote_cmd->rc_id, pressed, &remote_address);
+    }
 }
 
 /***************************************************************************
@@ -2195,6 +2213,28 @@ static void btif_rc_upstreams_evt(UINT16 event, tAVRC_COMMAND *pavrc_cmd, UINT8
     BTIF_TRACE_IMP("%s pdu: %s handle: 0x%x ctype:%x label:%x", __FUNCTION__,
         dump_rc_pdu(pavrc_cmd->pdu), btif_rc_cb[index].rc_handle, ctype, label);
 
+    if (interop_match_addr(INTEROP_DISABLE_PLAYER_APPLICATION_SETTING_CMDS,
+            (bt_bdaddr_t *) &remote_addr))
+    {
+        if (event == AVRC_PDU_LIST_PLAYER_APP_ATTR || event == AVRC_PDU_GET_PLAYER_APP_VALUE_TEXT ||
+            event == AVRC_PDU_GET_CUR_PLAYER_APP_VALUE || event == AVRC_PDU_SET_PLAYER_APP_VALUE ||
+            event == AVRC_PDU_GET_PLAYER_APP_ATTR_TEXT || event == AVRC_PDU_LIST_PLAYER_APP_VALUES)
+        {
+            send_reject_response (btif_rc_cb[index].rc_handle, label, pavrc_cmd->pdu,
+                                AVRC_STS_BAD_PARAM);
+            BTIF_TRACE_DEBUG("Blacklisted CK send AVRC_PDU_LIST_PLAYER_APP_ATTR reject");
+            return;
+        }
+        if ((pavrc_cmd->reg_notif.event_id == BTRC_EVT_APP_SETTINGS_CHANGED) &&
+                (event == AVRC_PDU_REGISTER_NOTIFICATION))
+        {
+            send_reject_response (btif_rc_cb[index].rc_handle, label, pavrc_cmd->pdu,
+                                AVRC_STS_BAD_PARAM);
+            btif_rc_cb[index].rc_notif[BTRC_EVT_APP_SETTINGS_CHANGED - 1].bNotify = FALSE;
+            BTIF_TRACE_DEBUG("Blacklisted CK send BTRC_EVT_APP_SETTINGS_CHANGED not implemented");
+            return;
+        }
+    }
     switch (event)
     {
         case AVRC_PDU_GET_PLAY_STATUS:
@@ -2367,6 +2407,17 @@ static void btif_rc_upstreams_evt(UINT16 event, tAVRC_COMMAND *pavrc_cmd, UINT8
                     }
                 }
             }
+#if (defined(AVCT_COVER_ART_INCLUDED) && (AVCT_COVER_ART_INCLUDED == TRUE))
+            int ver = AVRC_REV_INVALID;
+            ver = sdp_get_stored_avrc_tg_version (remote_addr.address);
+            if ((!(btif_rc_cb[index].rc_features & BTA_AV_FEAT_CA)) ||
+                  (ver < AVRC_REV_1_6) || (ver == AVRC_REV_INVALID))
+            {
+                BTIF_TRACE_IMP("remove the cover art elem attribute if remote doesn't support avrcp1.6");
+                if(num_attr == MAX_ELEM_ATTR_SIZE)
+                    num_attr--;
+            }
+#endif
             FILL_PDU_QUEUE(IDX_GET_ELEMENT_ATTR_RSP, ctype, label, TRUE, index, pavrc_cmd->pdu);
             HAL_CBACK(bt_rc_callbacks, get_element_attr_cb, num_attr, element_attrs, &remote_addr);
         }
@@ -2405,7 +2456,7 @@ static void btif_rc_upstreams_evt(UINT16 event, tAVRC_COMMAND *pavrc_cmd, UINT8
         {
             BTIF_TRACE_EVENT("%s() AVRC_PDU_SET_ADDRESSED_PLAYER", __FUNCTION__);
             FILL_PDU_QUEUE(IDX_SET_ADDRESS_PLAYER_RSP, ctype, label, TRUE, index, pavrc_cmd->pdu);
-            if (!btif_hf_is_call_idle())
+            if (!btif_hf_is_call_vr_idle())
             {
                 set_addrplayer_rsp(ERR_PLAYER_NOT_ADDRESED, &remote_addr); // send reject if call is in progress
                 return;
@@ -2525,7 +2576,17 @@ static void btif_rc_upstreams_evt(UINT16 event, tAVRC_COMMAND *pavrc_cmd, UINT8
                 num_attr_requested = idx;
                 BTIF_TRACE_ERROR("num_attr_requested: %d", num_attr_requested);
             }
-
+#if (defined(AVCT_COVER_ART_INCLUDED) && (AVCT_COVER_ART_INCLUDED == TRUE))
+            int ver = AVRC_REV_INVALID;
+            ver = sdp_get_stored_avrc_tg_version (remote_addr.address);
+            if ((!(btif_rc_cb[index].rc_features & BTA_AV_FEAT_CA)) ||
+                  (ver < AVRC_REV_1_6) || (ver == AVRC_REV_INVALID))
+            {
+                BTIF_TRACE_IMP("remove the cover art elem attribute if remote doesn't support avrcp1.6");
+                if(num_attr_requested == MAX_ELEM_ATTR_SIZE)
+                    num_attr_requested--;
+            }
+#endif
             if (btif_rc_cb[index].rc_connected == TRUE)
             {
                 FILL_PDU_QUEUE(IDX_GET_ITEM_ATTR_RSP, ctype, label, TRUE, index, pavrc_cmd->pdu);
@@ -2778,9 +2839,11 @@ static bt_status_t get_play_status_rsp(btrc_play_status_t play_status, uint32_t
 {
     tAVRC_RESPONSE avrc_rsp;
     int rc_index;
+    int av_index;
     CHECK_RC_CONNECTED
 
     rc_index = btif_rc_get_idx_by_addr(bd_addr->address);
+    av_index = btif_av_idx_by_bdaddr(bd_addr->address);
     if (rc_index == btif_max_rc_clients)
     {
         BTIF_TRACE_ERROR("-%s on unknown index = %d", __FUNCTION__);
@@ -2792,6 +2855,17 @@ static bt_status_t get_play_status_rsp(btrc_play_status_t play_status, uint32_t
     avrc_rsp.get_play_status.song_len = song_len;
     avrc_rsp.get_play_status.song_pos = song_pos;
     avrc_rsp.get_play_status.play_status = play_status;
+    BTIF_TRACE_ERROR("%s: play_status: %d",__FUNCTION__, avrc_rsp.get_play_status.play_status);
+    if ((avrc_rsp.get_play_status.play_status == BTRC_PLAYSTATE_PLAYING) &&
+         (btif_av_check_flag_remote_suspend(av_index)))
+    {
+        BTIF_TRACE_ERROR("%s: clear remote suspend flag: %d",__FUNCTION__, av_index);
+        btif_av_clear_remote_suspend_flag();
+        if (btif_av_is_offload_supported())
+        {
+            btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
+        }
+    }
 
     avrc_rsp.get_play_status.pdu = AVRC_PDU_GET_PLAY_STATUS;
     avrc_rsp.get_play_status.opcode = opcode_from_pdu(AVRC_PDU_GET_PLAY_STATUS);
@@ -3097,10 +3171,9 @@ static bt_status_t get_element_attr_rsp(uint8_t num_attr, btrc_element_attr_val_
     tAVRC_RESPONSE avrc_rsp;
     UINT32 i;
     tAVRC_ATTR_ENTRY element_attrs[MAX_ELEM_ATTR_SIZE];
-    int rc_index, valid_attr;
+    int rc_index;
     CHECK_RC_CONNECTED
 
-    valid_attr = 0;
     rc_index = btif_rc_get_idx_by_addr(bd_addr->address);
     if (rc_index == btif_max_rc_clients)
     {
@@ -3109,32 +3182,28 @@ static bt_status_t get_element_attr_rsp(uint8_t num_attr, btrc_element_attr_val_
     }
     BTIF_TRACE_DEBUG("- %s on index = %d", __FUNCTION__, rc_index);
 
-    memset(element_attrs, 0, sizeof(tAVRC_ATTR_ENTRY) * num_attr);
-
-    if (num_attr == 0)
+    if (num_attr == 0 || num_attr > MAX_ELEM_ATTR_SIZE)
     {
         avrc_rsp.get_play_status.status = AVRC_STS_BAD_PARAM;
     }
     else
     {
+        memset(element_attrs, 0, sizeof(tAVRC_ATTR_ENTRY) * num_attr);
         for (i=0; i<num_attr; i++)
         {
-            if ((UINT16)strlen((char *)p_attrs[i].text) != 0) {
-                element_attrs[valid_attr].attr_id = p_attrs[i].attr_id;
-                element_attrs[valid_attr].name.charset_id = AVRC_CHARSET_ID_UTF8;
-                element_attrs[valid_attr].name.str_len = (UINT16)strlen((char *)p_attrs[i].text);
-                element_attrs[valid_attr].name.p_str = p_attrs[i].text;
-                BTIF_TRACE_DEBUG("%s attr_id:0x%x, charset_id:0x%x, str_len:%d, str:%s",
-                    __FUNCTION__, (unsigned int)element_attrs[valid_attr].attr_id,
-                    element_attrs[valid_attr].name.charset_id,
-                    element_attrs[valid_attr].name.str_len,
-                    element_attrs[valid_attr].name.p_str);
-                valid_attr++;
-            }
+            element_attrs[i].attr_id = p_attrs[i].attr_id;
+            element_attrs[i].name.charset_id = AVRC_CHARSET_ID_UTF8;
+            element_attrs[i].name.str_len = (UINT16)strlen((char *)p_attrs[i].text);
+            element_attrs[i].name.p_str = p_attrs[i].text;
+            BTIF_TRACE_DEBUG("%s attr_id:0x%x, charset_id:0x%x, str_len:%d, str:%s",
+                __FUNCTION__, (unsigned int)element_attrs[i].attr_id,
+                element_attrs[i].name.charset_id,
+                element_attrs[i].name.str_len,
+                element_attrs[i].name.p_str);
         }
         avrc_rsp.get_play_status.status = AVRC_STS_NO_ERROR;
     }
-    avrc_rsp.get_elem_attrs.num_attr = valid_attr;
+    avrc_rsp.get_elem_attrs.num_attr = num_attr;
     avrc_rsp.get_elem_attrs.p_attrs = element_attrs;
     avrc_rsp.get_elem_attrs.pdu = AVRC_PDU_GET_ELEMENT_ATTR;
     avrc_rsp.get_elem_attrs.opcode = opcode_from_pdu(AVRC_PDU_GET_ELEMENT_ATTR);
@@ -3175,6 +3244,7 @@ static bt_status_t register_notification_rsp(btrc_event_id_t event_id,
     }
     memset(&(avrc_rsp.reg_notif), 0, sizeof(tAVRC_REG_NOTIF_RSP));
     avrc_rsp.reg_notif.event_id = event_id;
+    int av_index = btif_av_idx_by_bdaddr(bd_addr->address);
 
     switch(event_id)
     {
@@ -3184,8 +3254,18 @@ static bt_status_t register_notification_rsp(btrc_event_id_t event_id,
              * suspend within 3s after pause, and DUT within 3s
              * initiates Play
             */
-            if (avrc_rsp.reg_notif.param.play_status == PLAY_STATUS_PLAYING)
+            BTIF_TRACE_ERROR("%s: play_status: %d",__FUNCTION__,
+                                  avrc_rsp.reg_notif.param.play_status);
+            if ((avrc_rsp.reg_notif.param.play_status == PLAY_STATUS_PLAYING) &&
+                (btif_av_check_flag_remote_suspend(av_index)))
+            {
+                BTIF_TRACE_ERROR("%s: clear remote suspend flag: %d",__FUNCTION__,av_index );
                 btif_av_clear_remote_suspend_flag();
+                if (btif_av_is_offload_supported())
+                {
+                    btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
+                }
+            }
             break;
         case BTRC_EVT_TRACK_CHANGE:
             memcpy(&(avrc_rsp.reg_notif.param.track), &(p_param->track), sizeof(btrc_uid_t));
@@ -3194,6 +3274,12 @@ static bt_status_t register_notification_rsp(btrc_event_id_t event_id,
             avrc_rsp.reg_notif.param.play_pos = p_param->song_pos;
             break;
         case BTRC_EVT_APP_SETTINGS_CHANGED:
+            if (interop_match_addr(INTEROP_DISABLE_PLAYER_APPLICATION_SETTING_CMDS,
+                    (bt_bdaddr_t *) bd_addr))
+            {
+                BTIF_TRACE_DEBUG("Blacklisted CK for BTRC_EVT_APP_SETTINGS_CHANGED event");
+                return BT_STATUS_UNHANDLED;
+            }
             avrc_rsp.reg_notif.param.player_setting.num_attr = p_param->player_setting.num_attr;
             memcpy(&avrc_rsp.reg_notif.param.player_setting.attr_id,
                                        p_param->player_setting.attr_ids, 2);
@@ -3569,10 +3655,9 @@ static bt_status_t get_itemattr_rsp(uint8_t num_attr, btrc_element_attr_val_t *p
     tAVRC_RESPONSE avrc_rsp;
     UINT32 i;
     tAVRC_ATTR_ENTRY element_attrs[MAX_ELEM_ATTR_SIZE];
-    int valid_attr, rc_index = btif_rc_get_idx_by_addr(bd_addr->address);
+    int rc_index = btif_rc_get_idx_by_addr(bd_addr->address);
     CHECK_RC_CONNECTED
 
-    valid_attr = 0;
     if (rc_index == btif_max_rc_clients)
     {
         BTIF_TRACE_ERROR("%s: on unknown index", __FUNCTION__);
@@ -3580,32 +3665,28 @@ static bt_status_t get_itemattr_rsp(uint8_t num_attr, btrc_element_attr_val_t *p
     }
     BTIF_TRACE_DEBUG("- %s on index = %d", __FUNCTION__, rc_index);
 
-    memset(element_attrs, 0, sizeof(tAVRC_ATTR_ENTRY) * num_attr);
-
-    if (num_attr == 0)
+    if (num_attr == 0 || num_attr > MAX_ELEM_ATTR_SIZE)
     {
         avrc_rsp.get_attrs.status = AVRC_STS_INTERNAL_ERR;
     }
     else
     {
+        memset(element_attrs, 0, sizeof(tAVRC_ATTR_ENTRY) * num_attr);
         for (i=0; i<num_attr; i++)
         {
-            if ((UINT16)strlen((char *)p_attrs[i].text) != 0) {
-                element_attrs[valid_attr].attr_id = p_attrs[i].attr_id;
-                element_attrs[valid_attr].name.charset_id = AVRC_CHARSET_ID_UTF8;
-                element_attrs[valid_attr].name.str_len = (UINT16)strlen((char *)p_attrs[i].text);
-                element_attrs[valid_attr].name.p_str = p_attrs[i].text;
-                BTIF_TRACE_DEBUG("%s attr_id:0x%x, charset_id:0x%x, str_len:%d, str:%s",
-                    __FUNCTION__, (unsigned int)element_attrs[valid_attr].attr_id,
-                    element_attrs[valid_attr].name.charset_id,
-                    element_attrs[valid_attr].name.str_len,
-                    element_attrs[valid_attr].name.p_str);
-                valid_attr++;
-            }
+            element_attrs[i].attr_id = p_attrs[i].attr_id;
+            element_attrs[i].name.charset_id = AVRC_CHARSET_ID_UTF8;
+            element_attrs[i].name.str_len = (UINT16)strlen((char *)p_attrs[i].text);
+            element_attrs[i].name.p_str = p_attrs[i].text;
+            BTIF_TRACE_DEBUG("%s attr_id:0x%x, charset_id:0x%x, str_len:%d, str:%s",
+                __FUNCTION__, (unsigned int)element_attrs[i].attr_id,
+                element_attrs[i].name.charset_id,
+                element_attrs[i].name.str_len,
+                element_attrs[i].name.p_str);
         }
         avrc_rsp.get_attrs.status = AVRC_STS_NO_ERROR;
     }
-    avrc_rsp.get_attrs.attr_count = valid_attr;
+    avrc_rsp.get_attrs.attr_count = num_attr;
     avrc_rsp.get_attrs.p_attr_list = element_attrs;
     avrc_rsp.get_attrs.pdu = AVRC_PDU_GET_ITEM_ATTRIBUTES;
     avrc_rsp.get_attrs.opcode = opcode_from_pdu(AVRC_PDU_GET_ITEM_ATTRIBUTES);
@@ -6184,3 +6265,11 @@ static bool absolute_volume_disabled() {
     }
     return false;
 }
+
+static char const* key_id_to_str(uint16_t id) {
+    for (int i = 0; key_map[i].name != NULL; i++) {
+        if (id == key_map[i].mapped_id)
+            return key_map[i].name;
+    }
+    return "UNKNOWN KEY";
+}
diff --git a/btif/src/btif_sock_rfc.c b/btif/src/btif_sock_rfc.c
index d5522b7..dc014f0 100644
--- a/btif/src/btif_sock_rfc.c
+++ b/btif/src/btif_sock_rfc.c
@@ -551,13 +551,15 @@ static bool send_app_scn(rfc_slot_t *slot) {
   return sock_send_all(slot->fd, (const uint8_t*)&slot->scn, sizeof(slot->scn)) == sizeof(slot->scn);
 }
 
-static bool send_app_connect_signal(int fd, const bt_bdaddr_t* addr, int channel, int status, int send_fd) {
+static bool send_app_connect_signal(int fd, const bt_bdaddr_t* addr, int channel, int status,
+                                    int send_fd, int tx_mtu)
+{
   sock_connect_signal_t cs;
   cs.size = sizeof(cs);
   cs.bd_addr = *addr;
   cs.channel = channel;
   cs.status = status;
-  cs.max_rx_packet_size = 0; // not used for RFCOMM
+  cs.max_rx_packet_size = tx_mtu;
   cs.max_tx_packet_size = 0; // not used for RFCOMM
   if (send_fd == INVALID_FD)
     return sock_send_all(fd, (const uint8_t *)&cs, sizeof(cs)) == sizeof(cs);
@@ -612,7 +614,8 @@ static uint32_t on_srv_rfc_connect(tBTA_JV_RFCOMM_SRV_OPEN *p_open, uint32_t id)
   // Start monitoring the socket.
   btsock_thread_add_fd(pth, srv_rs->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_EXCEPTION, srv_rs->id);
   btsock_thread_add_fd(pth, accept_rs->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_RD, accept_rs->id);
-  send_app_connect_signal(srv_rs->fd, &accept_rs->addr, srv_rs->scn, 0, accept_rs->app_fd);
+  LOG_DEBUG(LOG_TAG, "%s  mtu = %d ", __func__,p_open->mtu);
+  send_app_connect_signal(srv_rs->fd, &accept_rs->addr, srv_rs->scn, 0, accept_rs->app_fd, p_open->mtu);
   accept_rs->app_fd = INVALID_FD;  // Ownership of the application fd has been transferred.
   new_listen_slot_id = srv_rs->id;
 
@@ -636,7 +639,8 @@ static void on_cli_rfc_connect(tBTA_JV_RFCOMM_OPEN *p_open, uint32_t id) {
   slot->rfc_port_handle = BTA_JvRfcommGetPortHdl(p_open->handle);
   memcpy(slot->addr.address, p_open->rem_bda, 6);
 
-  if (send_app_connect_signal(slot->fd, &slot->addr, slot->scn, 0, -1))
+  LOG_DEBUG(LOG_TAG, "%s  mtu = %d ", __func__,p_open->mtu);
+  if (send_app_connect_signal(slot->fd, &slot->addr, slot->scn, 0, -1, p_open->mtu))
     slot->f.connected = true;
   else
     LOG_ERROR(LOG_TAG, "%s unable to send connect completion signal to caller.", __func__);
diff --git a/btif/src/btif_sock_sdp.c b/btif/src/btif_sock_sdp.c
index 35721e5..6980c7a 100644
--- a/btif/src/btif_sock_sdp.c
+++ b/btif/src/btif_sock_sdp.c
@@ -98,6 +98,7 @@ static const tBTA_OP_FMT bta_ops_obj_fmt[OBEX_PUSH_NUM_FORMATS] = {
 
 #define UUID_MAX_LENGTH 16
 #define UUID_MATCHES(u1, u2) !memcmp(u1, u2, UUID_MAX_LENGTH)
+#define SPP_PROFILE_VERSION   0x0102
 
 // Adds a protocol list and service name (if provided) to an SDP record given by
 // |sdp_handle|, and marks it as browseable. This is a shortcut for defining a
@@ -351,6 +352,11 @@ static int add_spp_sdp(const char *name, const int channel) {
   if (!SDP_AddServiceClassIdList(handle, 1, &service))
     goto error;
 
+  // Add the FTP profile descriptor.
+  stage = "profile_descriptor_list";
+  if (!SDP_AddProfileDescriptorList(handle, UUID_SERVCLASS_SERIAL_PORT,
+                                    SPP_PROFILE_VERSION))
+    goto error;
   APPL_TRACE_DEBUG("add_spp_sdp: service registered successfully, "
                    "service_name: %s, handle 0x%08x)", name, handle);
 
diff --git a/btif/src/btif_storage.c b/btif/src/btif_storage.c
index aefbad2..b613eb5 100644
--- a/btif/src/btif_storage.c
+++ b/btif/src/btif_storage.c
@@ -165,7 +165,7 @@ extern void btif_gatts_add_bonded_dev_from_nv(BD_ADDR bda);
 
 static bt_status_t btif_in_fetch_bonded_ble_device(const char *remote_bd_addr,int add,
                                               btif_bonded_devices_t *p_bonded_devices);
-static bt_status_t btif_in_fetch_bonded_device(const char *bdstr);
+static bt_status_t btif_in_fetch_bonded_device(const char *bdstr, int *dev_type);
 
 /************************************************************************************
 **  Static functions
@@ -174,6 +174,8 @@ static bt_status_t btif_in_fetch_bonded_device(const char *bdstr);
 static int prop2cfg(bt_bdaddr_t *remote_bd_addr, bt_property_t *prop)
 {
     bdstr_t bdstr = {0};
+    int name_length = 0;
+    int dev_type = BT_DEVICE_TYPE_BREDR;
     if(remote_bd_addr)
         bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
     BTIF_TRACE_DEBUG("in, bd addr:%s, prop type:%d, len:%d", bdstr, prop->type, prop->len);
@@ -190,8 +192,10 @@ static int prop2cfg(bt_bdaddr_t *remote_bd_addr, bt_property_t *prop)
                                 BTIF_STORAGE_PATH_REMOTE_DEVTIME, (int)time(NULL));
             break;
         case BT_PROPERTY_BDNAME:
-            strncpy(value, (char*)prop->val, prop->len);
-            value[prop->len]='\0';
+            name_length = prop->len > BTM_MAX_LOC_BD_NAME_LEN ? BTM_MAX_LOC_BD_NAME_LEN:
+                                                                               prop->len;
+            strncpy(value, (char*)prop->val, name_length);
+            value[name_length]='\0';
             if(remote_bd_addr)
                 btif_config_set_str(bdstr,
                                 BTIF_STORAGE_PATH_REMOTE_NAME, value);
@@ -261,8 +265,14 @@ static int prop2cfg(bt_bdaddr_t *remote_bd_addr, bt_property_t *prop)
     }
 
     /* save changes if the device was bonded */
-    if (btif_in_fetch_bonded_device(bdstr) == BT_STATUS_SUCCESS) {
-      btif_config_flush();
+    if (btif_in_fetch_bonded_device(bdstr, &dev_type) == BT_STATUS_SUCCESS) {
+      // flush is expensive, avoid for BLE devices during BLE Scanning
+      if(dev_type == BT_DEVICE_TYPE_BREDR)
+      {
+        btif_config_flush();
+      } else {
+        btif_config_save();
+      }
     }
 
     return TRUE;
@@ -392,9 +402,10 @@ static int cfg2prop(bt_bdaddr_t *remote_bd_addr, bt_property_t *prop)
 ** Returns          BT_STATUS_SUCCESS if successful, BT_STATUS_FAIL otherwise
 **
 *******************************************************************************/
-static bt_status_t btif_in_fetch_bonded_device(const char *bdstr)
+static bt_status_t btif_in_fetch_bonded_device(const char *bdstr, int *p_dev_type)
 {
     BOOLEAN bt_linkkey_file_found=FALSE;
+    BOOLEAN bt_ltk_found=FALSE;
 
         LINK_KEY link_key;
         size_t size = sizeof(link_key);
@@ -411,17 +422,23 @@ static bt_status_t btif_in_fetch_bonded_device(const char *bdstr)
             }
         }
 #if (BLE_INCLUDED == TRUE)
-        if((btif_in_fetch_bonded_ble_device(bdstr, FALSE, NULL) != BT_STATUS_SUCCESS)
-                && (!bt_linkkey_file_found))
+        if (btif_in_fetch_bonded_ble_device(bdstr, FALSE, NULL) == BT_STATUS_SUCCESS)
+           bt_ltk_found = TRUE;
+
+        if(!bt_ltk_found && !bt_linkkey_file_found)
         {
-            BTIF_TRACE_DEBUG("Remote device:%s, no link key or ble key found", bdstr);
-            return BT_STATUS_FAIL;
+           BTIF_TRACE_DEBUG("Remote device:%s, no link key or ble key found", bdstr);
+           return BT_STATUS_FAIL;
+        } else {
+           btif_config_get_int(bdstr, "DevType", p_dev_type);
         }
 #else
         if((!bt_linkkey_file_found))
         {
             BTIF_TRACE_DEBUG("Remote device:%s, no link key found", bdstr);
             return BT_STATUS_FAIL;
+        } else {
+           btif_config_get_int(bdstr, "DevType", p_dev_type);
         }
 #endif
     return BT_STATUS_SUCCESS;
@@ -1346,6 +1363,7 @@ bt_status_t btif_storage_load_bonded_hid_info(void)
     uint16_t attr_mask;
     uint8_t  sub_class;
     uint8_t  app_id;
+    int      dev_type;
 
     memset(&dscp_info, 0, sizeof(dscp_info));
     for (const btif_config_section_iter_t *iter = btif_config_section_begin(); iter != btif_config_section_end(); iter = btif_config_section_next(iter)) {
@@ -1355,7 +1373,7 @@ bt_status_t btif_storage_load_bonded_hid_info(void)
 
         BTIF_TRACE_DEBUG("Remote device:%s", name);
         int value;
-        if(btif_in_fetch_bonded_device(name) == BT_STATUS_SUCCESS)
+        if(btif_in_fetch_bonded_device(name, &dev_type) == BT_STATUS_SUCCESS)
         {
             if(btif_config_get_int(name, "HidAttrMask", &value))
             {
@@ -1447,6 +1465,21 @@ bt_status_t btif_storage_remove_hid_info(bt_bdaddr_t *remote_bd_addr)
 
 /*******************************************************************************
 **
+** Function         btif_storage_get_num_bonded_devices
+**
+** Description      BTIF storage API - Gets the number of bonded devices
+**
+** Returns          the number of bonded devices
+**
+*******************************************************************************/
+int btif_storage_get_num_bonded_devices(void) {
+    btif_bonded_devices_t bonded_devices;
+    btif_in_fetch_bonded_devices(&bonded_devices, 0);
+    return bonded_devices.num_devices;
+}
+
+/*******************************************************************************
+**
 ** Function         btif_storage_read_hl_apps_cb
 **
 ** Description      BTIF storage API - Read HL application control block from NVRAM
diff --git a/btif/src/btif_vendor.c b/btif/src/btif_vendor.c
index a037fc9..7bc7703 100644
--- a/btif/src/btif_vendor.c
+++ b/btif/src/btif_vendor.c
@@ -37,15 +37,26 @@
 #include "btif_common.h"
 #include "btif_util.h"
 #include "btif_profile_queue.h"
+#include "stack_config.h"
+#include "stack_manager.h"
+#include "device/include/interop_config.h"
+#include "device/include/interop.h"
 
 #define BTA_SERVICE_ID_TO_SERVICE_MASK(id)  (1 << (id))
 extern bt_status_t btif_in_execute_service_request(tBTA_SERVICE_ID service_id,
                                                BOOLEAN b_enable);
-static btvendor_callbacks_t *bt_vendor_callbacks = NULL;
+static void get_logger_config_value(void);
+void btif_vendor_snooplog_status_event(UINT16, char *p_param);
+
+btvendor_callbacks_t *bt_vendor_callbacks = NULL;
 
 #define BTIF_VENDOR_BREDR_CLEANUP 1
 
 /*******************************************************************************
+** VENDOR INTERFACE FUNCTIONS
+*******************************************************************************/
+
+/*******************************************************************************
 **
 ** Function         btif_vendor_init
 **
@@ -56,7 +67,11 @@ static btvendor_callbacks_t *bt_vendor_callbacks = NULL;
 *******************************************************************************/
 static bt_status_t init( btvendor_callbacks_t* callbacks)
 {
+    LOG_ERROR(LOG_TAG,"init");
     bt_vendor_callbacks = callbacks;
+
+    get_logger_config_value();
+
     return BT_STATUS_SUCCESS;
 }
 
@@ -82,6 +97,7 @@ static void btif_vendor_bredr_cleanup_event(UINT16 event, char *p_param)
             btif_in_execute_service_request(i, FALSE);
         }
     }
+    btif_queue_release();
     HAL_CBACK(bt_vendor_callbacks, bredr_cleanup_cb, true);
 }
 
@@ -92,20 +108,41 @@ static void bredrcleanup(void)
                           NULL, 0, NULL);
 }
 
+static void capture_vnd_logs(void)
+{
+    LOG_INFO(LOG_TAG,"capture_vnd_logs");
+    GENERATE_VND_LOGS();
+}
+
 static void cleanup(void)
 {
     LOG_INFO(LOG_TAG,"cleanup");
     if (bt_vendor_callbacks)
         bt_vendor_callbacks = NULL;
 }
+
+// API's to match entries with in dynamic interop database
+static bool interop_db_match(int feature, int type, void *value) {
+    if ( type == INTEROP_BL_TYPE_ADDR)
+        return interop_database_match_addr((interop_feature_t)feature, (bt_bdaddr_t *)value);
+    else if ( type == INTEROP_BL_TYPE_NAME)
+        return interop_database_match_name((interop_feature_t)feature, (char *)value);
+    return false;
+}
+
 static const btvendor_interface_t btvendorInterface = {
     sizeof(btvendorInterface),
     init,
     ssrcleanup,
     bredrcleanup,
+    capture_vnd_logs,
     cleanup,
+    interop_db_match,
 };
 
+/*******************************************************************************
+** LOCAL FUNCTIONS
+*******************************************************************************/
 
 /*******************************************************************************
 **
@@ -121,3 +158,168 @@ const btvendor_interface_t *btif_vendor_get_interface()
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
     return &btvendorInterface;
 }
+
+
+#ifdef BLUEDROID_DEBUG
+/*******************************************************************************
+**
+** Function         set_logging_pref
+**
+** Description      Set logging preference property to control BT logging
+**                  based on config file or developer option
+**
+** Returns          void
+**
+*******************************************************************************/
+void set_logging_pref(uint16_t pref_val)
+{
+  char new_log_pref[2];
+  snprintf(new_log_pref, 2, "%d", pref_val);
+  property_set("persist.bluetooth.log_pref", new_log_pref);
+  LOG_INFO(LOG_TAG, "%s, New Logging preference value: %d", __func__, pref_val);
+}
+
+/*******************************************************************************
+**
+** Function         get_logging_pref
+**
+** Description      Returns current logging preference to set logging status
+**                  based on config file or developer option
+**
+** Returns          void
+**
+*******************************************************************************/
+uint16_t get_logging_pref()
+{
+  return (uint16_t)property_get_int32("persist.bluetooth.log_pref", NO_PREFERENCE);
+}
+#endif
+
+/*******************************************************************************
+**
+** Function         get_logger_config_value
+**
+** Description      Set logging option based on flag values set
+**                  in config file
+**
+** Returns          void
+**
+*******************************************************************************/
+static void get_logger_config_value()
+{
+  bool hci_ext_dump_enabled = false;
+  bool btsnoop_conf_from_file = false;
+
+  LOG_INFO(LOG_TAG, "%s", __func__);
+
+#ifdef BLUEDROID_DEBUG
+  uint16_t logging_pref;
+  logging_pref = get_logging_pref();
+
+  LOG_INFO(LOG_TAG, "%s, logging_pref = %d", __func__, logging_pref);
+  if(logging_pref == DEV_OPT_PREFERENCE)
+    return;
+#endif
+
+  stack_config_get_interface()->get_btsnoop_ext_options(&hci_ext_dump_enabled, &btsnoop_conf_from_file);
+
+  /* ToDo: Change dependency to work on one config option*/
+#ifdef BLUEDROID_DEBUG
+  if(!btsnoop_conf_from_file)
+    hci_ext_dump_enabled = true;
+#endif
+
+  if(hci_ext_dump_enabled)
+    bt_logger_enabled = true;
+}
+
+#ifdef BLUEDROID_DEBUG
+/*******************************************************************************
+**
+** Function         enable_bt_logger_debug
+**
+** Description      enable Bluetooth Unified logger based on values
+**                  from config file and developer option and current
+**                  logging preference.
+**
+** Returns          void
+**
+*******************************************************************************/
+void enable_bt_logger_debug(bool enable)
+{
+    if(stack_manager_get_interface()->get_stack_is_running()) {
+        if(enable && !bt_logger_enabled)
+        {
+            property_set("bluetooth.startbtlogger", "true");
+            usleep(500000);
+            bt_logger_enabled = true;
+            init_vnd_Logger();
+        }
+        set_logging_pref(DEV_OPT_PREFERENCE);
+    } else {
+        uint16_t curr_log_pref;
+        curr_log_pref = get_logging_pref();
+
+        LOG_INFO(LOG_TAG, "config_hci_snoop_log, curr_log_pref = %d", curr_log_pref);
+        if(curr_log_pref < DEV_OPT_PREFERENCE && enable != bt_logger_enabled) {
+            if(curr_log_pref == bt_logger_enabled) {
+                /*It means user have updated the logging option
+                 *from Developer Option while Bluetooth was Off.*/
+                bt_logger_enabled = enable;
+                set_logging_pref(DEV_OPT_PREFERENCE);
+            } else {
+                /*It means user have updated the logging option
+                 *from bt_stack.conf file.*/
+                set_logging_pref(bt_logger_enabled);
+            }
+        } else if(curr_log_pref == DEV_OPT_PREFERENCE && enable) {
+            bt_logger_enabled = enable;
+        }
+        LOG_INFO(LOG_TAG, "config_hci_snoop_log, logging status = %d", bt_logger_enabled);
+        if(bt_logger_enabled)
+            property_set("bluetooth.startbtlogger", "true");
+    }
+}
+#else
+/*******************************************************************************
+**
+** Function         enable_bt_logger
+**
+** Description      Enable Bluetooth Unified Logger based on input
+**                  from developer option.
+**
+** Returns          void
+**
+*******************************************************************************/
+void enable_bt_logger(bool enable)
+{
+    if(stack_manager_get_interface()->get_stack_is_running()) {
+        if(enable && !bt_logger_enabled)
+        {
+            property_set("bluetooth.startbtlogger", "true");
+            usleep(500000);
+            bt_logger_enabled = true;
+            init_vnd_Logger();
+        }
+    } else {
+        bt_logger_enabled = enable;
+        if(bt_logger_enabled)
+            property_set("bluetooth.startbtlogger", "true");
+    }
+}
+#endif
+
+/*******************************************************************************
+**
+** Function        btif_vendor_snooplog_status_event
+**
+** Description     updates snoop log status to application layer
+**
+** Returns         void
+**
+*******************************************************************************/
+void btif_vendor_snooplog_status_event(UINT16 status, char *p_param)
+{
+    LOG_INFO(LOG_TAG, "%s", __func__);
+    HAL_CBACK(bt_vendor_callbacks, update_snooplog_status_cb, status);
+}
diff --git a/btif/src/stack_manager.c b/btif/src/stack_manager.c
index 288f697..f6a5298 100644
--- a/btif/src/stack_manager.c
+++ b/btif/src/stack_manager.c
@@ -21,6 +21,7 @@
 #include "stack_manager.h"
 
 #include <hardware/bluetooth.h>
+#include <cutils/properties.h>
 
 #include "btcore/include/module.h"
 #include "btcore/include/osi_module.h"
@@ -53,6 +54,13 @@ static void event_clean_up_stack(void *context);
 static void event_signal_stack_up(void *context);
 static void event_signal_stack_down(void *context);
 
+extern void btif_vendor_snooplog_status_event(UINT16, char *p_param);
+extern void set_logging_pref(uint16_t pref_val);
+
+#ifdef BLUEDROID_DEBUG
+extern uint16_t get_logging_pref();
+#endif
+
 // Unvetted includes/imports, etc which should be removed or vetted in the future
 static future_t *hack_future;
 void bte_main_enable();
@@ -139,6 +147,18 @@ static void event_start_up_stack(UNUSED_ATTR void *context) {
 
   ensure_stack_is_initialized();
 
+  init_vnd_Logger();
+#ifdef BLUEDROID_DEBUG
+  uint16_t logging_pref;
+  logging_pref = get_logging_pref();
+
+  if(logging_pref != DEV_OPT_PREFERENCE) {
+    btif_transfer_context(btif_vendor_snooplog_status_event, bt_logger_enabled,
+                NULL, 0, NULL);
+    set_logging_pref(bt_logger_enabled);
+  }
+#endif
+
   LOG_INFO(LOG_TAG, "%s is bringing up the stack", __func__);
   future_t *local_hack_future = future_new();
   hack_future = local_hack_future;
@@ -200,8 +220,6 @@ static void event_clean_up_stack(void *context) {
   ensure_stack_is_not_running();
 
   LOG_INFO(LOG_TAG, "%s is cleaning up the stack", __func__);
-  future_t *local_hack_future = future_new();
-  hack_future = local_hack_future;
   stack_is_initialized = false;
 
   btif_cleanup_bluetooth();
@@ -211,7 +229,8 @@ static void event_clean_up_stack(void *context) {
   module_management_stop();
   LOG_INFO(LOG_TAG, "%s finished", __func__);
 
-cleanup:;
+cleanup:
+  clean_vnd_logger();
   semaphore_t *semaphore = (semaphore_t *)context;
   if (semaphore)
     semaphore_post(semaphore);
diff --git a/conf/Android.mk b/conf/Android.mk
index eb24b59..cd723da 100644
--- a/conf/Android.mk
+++ b/conf/Android.mk
@@ -21,7 +21,12 @@ LOCAL_SRC_FILES := $(LOCAL_MODULE)
 include $(BUILD_PREBUILT)
 
 include $(CLEAR_VARS)
-LOCAL_MODULE := iot_devlist.conf
+ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
+LOCAL_PATH := vendor/qcom/opensource/bluetooth/system_bt_ext/conf/
+else
+LOCAL_PATH := device/qcom/msm8909w/opensource/bluetooth/system_bt_ext/conf/
+endif
+LOCAL_MODULE := interop_database.conf
 LOCAL_MODULE_CLASS := ETC
 LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/bluetooth
 LOCAL_MODULE_TAGS := optional
diff --git a/conf/bt_did.conf b/conf/bt_did.conf
index ea89c06..5a29c73 100644
--- a/conf/bt_did.conf
+++ b/conf/bt_did.conf
@@ -7,7 +7,8 @@ primaryRecord = true
 
 # Vendor ID '0xFFFF' indicates no Device ID Service Record is present in the device
 # 0x000F = Broadcom Corporation (default)
-#vendorId = 0x000F
+# 0x001D = Qualcomm
+vendorId = 0x001D
 
 # Vendor ID Source
 # 0x0001 = Bluetooth SIG assigned Device ID Vendor ID value (default)
diff --git a/conf/bt_stack.conf b/conf/bt_stack.conf
index 4a99ef9..5516ac5 100644
--- a/conf/bt_stack.conf
+++ b/conf/bt_stack.conf
@@ -9,7 +9,7 @@ BtSnoopLogOutput=false
 BtSnoopExtDump=false
 
 # BtSnoop log output file
-BtSnoopFileName=/sdcard/btsnoop_hci.log
+BtSnoopFileName=/data/misc/bluetooth/logs/btsnoop_hci.log
 
 # Preserve existing BtSnoop log before overwriting
 BtSnoopSaveLog=false
@@ -78,4 +78,3 @@ TRC_PAN=2
 #  8 = SMP_PASSKEY_ENTRY_FAIL
 #  9 = SMP_NUMERIC_COMPAR_FAIL;
 #PTS_SmpFailureCase=0
-
diff --git a/device/Android.mk b/device/Android.mk
index c5b9377..bb9a061 100644
--- a/device/Android.mk
+++ b/device/Android.mk
@@ -31,10 +31,25 @@ LOCAL_C_INCLUDES := \
     $(LOCAL_PATH)/../stack/include \
     $(bluetooth_C_INCLUDES)
 
+ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
+LOCAL_C_INCLUDES += \
+    vendor/qcom/opensource/bluetooth/system_bt_ext
+else
+LOCAL_C_INCLUDES += \
+    device/qcom/msm8909w/opensource/bluetooth/system_bt_ext
+endif
+
 LOCAL_SRC_FILES := \
     src/classic/peer.c \
-    src/controller.c \
-    src/interop.c
+    src/controller.c
+
+ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
+LOCAL_SRC_FILES += \
+    ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/device/src/interop.c
+else
+LOCAL_SRC_FILES += \
+    ../../../device/qcom/msm8909w/opensource/bluetooth/system_bt_ext/device/src/interop.c
+endif
 
 LOCAL_MODULE := libbtdevice
 LOCAL_MODULE_TAGS := optional
diff --git a/device/include/controller.h b/device/include/controller.h
index 5372b57..159cd79 100644
--- a/device/include/controller.h
+++ b/device/include/controller.h
@@ -53,11 +53,14 @@ typedef struct controller_t {
   bool (*supports_rssi_with_inquiry_results)(void);
   bool (*supports_extended_inquiry_response)(void);
   bool (*supports_master_slave_role_switch)(void);
+  bool (*supports_set_le_privacy_mode)(void);
 
   bool (*supports_ble)(void);
   bool (*supports_ble_packet_extension)(void);
   bool (*supports_ble_connection_parameters_request)(void);
   bool (*supports_ble_privacy)(void);
+  bool (*supports_ble_two_mbps_rate)(void);
+  bool (*supports_ble_extended_advertisements)(void);
 
   // Get the cached acl data sizes for the controller.
   uint16_t (*get_acl_data_size_classic)(void);
@@ -81,6 +84,9 @@ typedef struct controller_t {
   void (*set_ble_resolving_list_max_size)(int resolving_list_max_size);
   uint8_t *(*get_local_supported_codecs)(uint8_t *number_of_codecs);
   bool (*supports_ble_offload_features)(void);
+
+  uint8_t (*get_ble_adv_ext_size)(void);
+  void (*set_ble_adv_ext_size)(int adv_ext_size);
 } controller_t;
 
 const controller_static_t *controller_get_static_interface();
diff --git a/device/include/interop.h b/device/include/interop.h
index e7583e5..8edcd01 100644
--- a/device/include/interop.h
+++ b/device/include/interop.h
@@ -25,13 +25,15 @@
 static const char INTEROP_MODULE[] = "interop_module";
 
 // NOTE:
-// Only add values at the end of this enum and do NOT delete values
-// as they may be used in dynamic device configuration.
+// Only add values at the end of this enum and before END_OF_INTEROP_LIST
+// do NOT delete values as they may be used in dynamic device configuration.
 typedef enum {
+
+  BEGINING_OF_INTEROP_LIST = 0,
   // Disable secure connections
   // This is for pre BT 4.1/2 devices that do not handle secure mode
   // very well.
-  INTEROP_DISABLE_LE_SECURE_CONNECTIONS = 0,
+  INTEROP_DISABLE_LE_SECURE_CONNECTIONS = BEGINING_OF_INTEROP_LIST,
 
   // Some devices have proven problematic during the pairing process, often
   // requiring multiple retries to complete pairing. To avoid degrading the user
@@ -101,6 +103,76 @@ typedef enum {
   // to preferred conn params immediately post connection. Disable automatic switching to
   // preferred conn params for such devices and allow them to explicity ask for it.
   INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS,
+
+  //Few carkit hfp version is hfp1.5 but it support hfp indicator, violate spec
+  //remove hfp indicator for such device
+  INTEROP_DISABLE_HF_INDICATOR,
+
+  // Few remote devices do not understand AVRCP version greater than 1.3. For these
+  // devices, we would like to blacklist them and advertise AVRCP version as 1.3
+  INTEROP_ADV_AVRCP_VER_1_3,
+
+  // certain remote A2DP sinks have issue playing back Music in AAC format.
+  // disable AAC for those headsets so that it switch to SBC
+  INTEROP_DISABLE_AAC_CODEC,
+
+  // Enable AAC only for whitelist of devices
+  INTEROP_ENABLE_AAC_CODEC,
+
+  // Some car kits notifies role switch supported but it rejects
+  // the role switch and after some attempts of role switch
+  // car kits will go to bad state.
+  INTEROP_DYNAMIC_ROLE_SWITCH,
+
+  // Disable role switch for headsets/car-kits
+  // Some car kits allow role switch but when DUT initiates role switch
+  // Remote will go to bad state and its leads to LMP time out.
+  INTEROP_DISABLE_ROLE_SWITCH,
+
+  // Disable role switch for headsets/car-kits
+  // Some car kits initiate a role switch but won't initiate encryption
+  // after role switch complete
+  INTEROP_DISABLE_ROLE_SWITCH_POLICY,
+
+  INTEROP_HFP_1_7_BLACKLIST,
+
+  // Some Carkits are not initiating AVRCP Browse Channel on
+  // seeing DUT's AVRCP version as v1.6. Hence fallback DUT's
+  // AVRCP version to v1.4 for those Carkits
+  INTEROP_STORE_REMOTE_AVRCP_VERSION_1_4,
+
+  // Devices requiring this workaround do not handle Bluetooth PBAP 1.2 version correctly,
+  // leading them to go in bad state. So for better interoperability respond with PBAP 1.1
+  // as supported version.
+  INTEROP_ADV_PBAP_VER_1_1,
+
+  // Devices requiring this workaround do not handle SSR max latency values as mentioned,
+  // in their SDP HID Record properly and lead to connection timeout or lags. To prevent
+  // such scenarios, device requiring this workaorund need to use specific ssr max latency
+  // values.
+  INTEROP_UPDATE_HID_SSR_MAX_LAT,
+  // Some Carkits being AVRCP v1.3 upon receiving Play Application Setting Command Response
+  // and notification, doesn't send Passthrough commands back to DUT in Streaming State
+  INTEROP_DISABLE_PLAYER_APPLICATION_SETTING_CMDS,
+
+  // Some remotes are very strict in receiving the call active
+  // indicator and SCO connection request order for MT call.
+  // If CIEV1,1 and SCO connection request are sent back to back
+  // to SOC, it may send SCO connection request first then CIEV1,1
+  // which may lead to remotes not rendering SCO audio.
+  INTEROP_DELAY_SCO_FOR_MT_CALL,
+  // Some remotes are taking too long to respond for codec negotiation.
+  // Disable codec negotiation for such remotes and directly initiate
+  // SCO Connection.
+  INTEROP_DISABLE_CODEC_NEGOTIATION,
+
+  // Some remotes are going into sniff mode during SCO connection process and taking time
+  // for SCO connection to complete. For such devices, disable sniff when SCO is
+  // connecting and enable it after SCO disconnection.
+  INTEROP_DISABLE_SNIFF_POLICY_DURING_SCO,
+
+  END_OF_INTEROP_LIST
+
 } interop_feature_t;
 
 // Check if a given |addr| matches a known interoperability workaround as identified
@@ -134,8 +206,16 @@ bool interop_match_manufacturer(const interop_feature_t feature, uint16_t manufa
 // Check if a given |vendor_id, product_id, name| matches a known interoperability workaround
 // as identified by the |interop_feature_t| enum. This API is used for simple name based lookups
 // where more information is not available.
-bool interop_match_hid_multitouch(const interop_feature_t feature,
-        uint16_t vendor_id, uint16_t product_id, const char *name);
+bool interop_match_vendor_product_ids(const interop_feature_t feature,
+        uint16_t vendor_id, uint16_t product_id);
+
+// Check if a given |addr| matches a known interoperability workaround as identified
+// by the |interop_feature_t| enum. This API is used for simple address based lookups
+// where more information is not available. No look-ups or random address resolution
+// are performed on |addr|. If address is matched, max latency for SSR stored for particular
+// remote device is returned.
+bool interop_match_addr_get_max_lat(const interop_feature_t feature,
+        const bt_bdaddr_t *addr, uint16_t *max_lat);
 
 // Add a dynamic interop database entry for a device matching the first |length| bytes
 // of |addr|, implementing the workaround identified by |feature|. |addr| may not be
diff --git a/device/include/interop_database.h b/device/include/interop_database.h
index 80cd461..4423aea 100644
--- a/device/include/interop_database.h
+++ b/device/include/interop_database.h
@@ -118,10 +118,32 @@ static const interop_addr_entry_t interop_addr_database[] = {
   // Dialog Keyboard and mouse
   {{{0x80, 0xea, 0xca,      0,0,0}}, 3, INTEROP_DISABLE_LE_SECURE_CONNECTIONS},
 
+  // Marvel CK used in Mercedes C300/BMW 640i
+  // For a more specific black listing(e.g. just for Mercedes), both BD addr
+  // and device name has to be added for AVRCP 1.3 blacklisting
+  {{{0xa0, 0x56, 0xb2,      0,0,0}}, 3, INTEROP_ADV_AVRCP_VER_1_3},
+
+  // Mazda Atenza
+  {{{0x04, 0xf8, 0xc2,      0,0,0}}, 3, INTEROP_DISABLE_ABSOLUTE_VOLUME},
+  // Remote not playing back Audio, suspected to be Audio encoder version diff
+  // Beats Solo 3
+  {{{0x20, 0x3c, 0xae,      0,0,0}}, 3, INTEROP_DISABLE_AAC_CODEC},
+  //Apple Airpods Headset
+  {{{0x4c, 0x32, 0x75,      0,0,0}}, 3, INTEROP_DISABLE_AAC_CODEC},
+  // Remote sending 128 as bitrate in place of 128000
+  // Cadillac
+  {{{0x28, 0xA1, 0x83,      0,0,0}}, 3, INTEROP_DISABLE_AAC_CODEC},
+  // Buick Verona
+  {{{0xAC, 0x7A, 0x4D,      0,0,0}}, 3, INTEROP_DISABLE_AAC_CODEC},
+  //Maruthi Brezzai
+  {{{0x28, 0xa1, 0x83,      0,0,0}}, 3, INTEROP_DISABLE_AAC_CODEC},
+  // Parrot Zik2.0
+  {{{0xA0, 0x14, 0x3D,      0,0,0}}, 3, INTEROP_DISABLE_AAC_CODEC},
+
 };
 
 typedef struct {
-  char name[40];
+  char name[249];
   size_t length;
   interop_feature_t feature;
 } interop_name_entry_t;
@@ -153,6 +175,12 @@ static const interop_name_entry_t interop_name_database[] = {
   //Below devices reject connection updated with preferred
   {"BSMBB09DS", 9, INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS},
   {"ELECOM", 6, INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS},
+  {"MB Bluetooth", 12, INTEROP_ADV_AVRCP_VER_1_3},
+
+  // HID Moto KZ500 Keyboard - Problematic SDP digitizer descriptor
+  {"Motorola Keyboard KZ500", 23, INTEROP_REMOVE_HID_DIG_DESCRIPTOR},
+  {"Motorola Keyboard KZ500 v122", 28, INTEROP_REMOVE_HID_DIG_DESCRIPTOR},
+
 };
 
 typedef struct {
@@ -171,12 +199,10 @@ static const interop_manufacturer_t interop_manufacturer_database[] = {
 typedef struct {
   uint16_t vendor_id;
   uint16_t product_id;
-  char name[40];
-  size_t length;
   interop_feature_t feature;
 } interop_hid_multitouch_t;
 
 static const interop_hid_multitouch_t interop_hid_multitouch_database[] = {
-  // Moto KZ500 Keyboard
-  {0x22b8, 0x093d, "Motorola Keyboard KZ500 v122", 28, INTEROP_REMOVE_HID_DIG_DESCRIPTOR},
+  // HID Moto KZ500 Keyboard - Problematic SDP digitizer descriptor
+  {0x22b8, 0x093d, INTEROP_REMOVE_HID_DIG_DESCRIPTOR},
 };
diff --git a/device/src/controller.c b/device/src/controller.c
index fad947e..d0a1469 100644
--- a/device/src/controller.c
+++ b/device/src/controller.c
@@ -21,6 +21,8 @@
 #include "device/include/controller.h"
 
 #include <assert.h>
+#include <string.h>
+#include <cutils/properties.h>
 
 #include "bt_types.h"
 #include "btcore/include/event_mask.h"
@@ -32,7 +34,8 @@
 #include "osi/include/log.h"
 #include "utils/include/bt_utils.h"
 
-const bt_event_mask_t BLE_EVENT_MASK = { "\x00\x00\x00\x00\x00\x00\x06\x7f" };
+const bt_event_mask_t BLE_EVENT_MASK = { "\x00\x00\x00\x00\x00\x0b\xfe\x7f" };
+const bt_event_mask_t BLE_EVENT_MASK_ALE_DISABLED = { "\x00\x00\x00\x00\x00\x08\x0e\x7f" };
 
 #if (BLE_INCLUDED)
 const bt_event_mask_t CLASSIC_EVENT_MASK = { HCI_DUMO_EVENT_MASK_EXT };
@@ -75,6 +78,7 @@ static bt_device_features_t features_ble;
 static uint16_t ble_suggested_default_data_length;
 static uint8_t local_supported_codecs[MAX_LOCAL_SUPPORTED_CODECS_SIZE];
 static uint8_t number_of_local_supported_codecs = 0;
+static uint8_t ble_adv_ext_size;
 
 static bool readable;
 static bool ble_supported;
@@ -82,25 +86,36 @@ static bool ble_offload_features_supported;
 static bool simple_pairing_supported;
 static bool secure_connections_supported;
 
+static bool adv_ext_enabled = false;
+
 #define AWAIT_COMMAND(command) future_await(hci->transmit_command_futured(command))
 
 // Module lifecycle functions
 
 void send_soc_log_command(bool value) {
   int soc_type = get_soc_type();
-  UINT8 param[5] = {0x10,0x03,0x00,0x00,0x01};
-  if (!value)
+  UINT8 param[5] = {0x10, 0x03, 0x00, 0x00, 0x01};
+  UINT8 param_cherokee[2] = {0x14, 0x01};
+  if (!value) {
     // Disable SoC logging
     param[1] = 0x02;
+    param_cherokee[1] = 0x00;
+  }
 
   if (soc_type == BT_SOC_SMD) {
     LOG_INFO(LOG_TAG, "%s for BT_SOC_SMD.", __func__);
-    BTM_VendorSpecificCommand(HCI_VS_HOST_LOG_OPCODE,5,param,NULL);
+    BTM_VendorSpecificCommand(HCI_VS_HOST_LOG_OPCODE, 5, param, NULL);
+  } else if (soc_type == BT_SOC_CHEROKEE) {
+    LOG_INFO(LOG_TAG, "%s for BT_SOC_CHEROKEE.", __func__);
+    BTM_VendorSpecificCommand(HCI_VS_HOST_LOG_OPCODE, 2, param_cherokee, NULL);
   }
+
 }
 
 static future_t *start_up(void) {
   BT_HDR *response;
+  int ret =0;
+  char value[PROPERTY_VALUE_MAX] = {'\0'};
 
   // Send the initial reset command
   response = AWAIT_COMMAND(packet_factory->make_reset());
@@ -221,6 +236,15 @@ static future_t *start_up(void) {
 #endif
 
 #if (BLE_INCLUDED == TRUE)
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+  ret = property_get("ble.ae_supported", value, NULL);
+  if (ret) {
+    adv_ext_enabled = (strcmp(value, "true") ==0) ? true : false;
+    LOG_INFO(LOG_TAG, "%s BLE Adv Extensions enabled:%d", __func__, adv_ext_enabled);
+  }
+#endif
+
   ble_supported = last_features_classic_page_index >= 1 && HCI_LE_HOST_SUPPORTED(features_classic[1].as_array);
   if (ble_supported) {
     // Request the ble white list size next
@@ -268,8 +292,19 @@ static future_t *start_up(void) {
             &ble_suggested_default_data_length);
     }
 
+    if (adv_ext_enabled && HCI_LE_ADV_EXTENSION_SUPPORTED(features_ble.as_array)) {
+        response = AWAIT_COMMAND(packet_factory->make_ble_read_adv_ext_size());
+        packet_parser->parse_ble_read_adv_ext_size_response(
+            response,
+            &ble_adv_ext_size);
+    }
+
     // Set the ble event mask next
-    response = AWAIT_COMMAND(packet_factory->make_ble_set_event_mask(&BLE_EVENT_MASK));
+    if (adv_ext_enabled) {
+        response = AWAIT_COMMAND(packet_factory->make_ble_set_event_mask(&BLE_EVENT_MASK));
+    } else {
+        response = AWAIT_COMMAND(packet_factory->make_ble_set_event_mask(&BLE_EVENT_MASK_ALE_DISABLED));
+    }
     packet_parser->parse_generic_command_complete(response);
   }
 #endif
@@ -387,6 +422,11 @@ static bool supports_reading_remote_extended_features(void) {
   return HCI_READ_REMOTE_EXT_FEATURES_SUPPORTED(supported_commands);
 }
 
+static bool supports_set_le_privacy_mode(void) {
+  assert(readable);
+  return (HCI_LE_SET_PRIVACY_MODE_SUPPORTED(supported_commands));
+}
+
 static bool supports_interlaced_inquiry_scan(void) {
   assert(readable);
   return HCI_LMP_INTERLACED_INQ_SCAN_SUPPORTED(features_classic[0].as_array);
@@ -418,6 +458,15 @@ static bool supports_ble_privacy(void) {
   return HCI_LE_ENHANCED_PRIVACY_SUPPORTED(features_ble.as_array);
 }
 
+static bool supports_ble_extended_advertisements(void) {
+  assert(readable);
+  assert(ble_supported);
+  if(adv_ext_enabled)
+    return HCI_LE_ADV_EXTENSION_SUPPORTED(features_ble.as_array);
+  else
+    return false;
+}
+
 static bool supports_ble_packet_extension(void) {
   assert(readable);
   assert(ble_supported);
@@ -436,6 +485,12 @@ static bool supports_ble_offload_features(void) {
   return ble_offload_features_supported;
 }
 
+static bool supports_ble_two_mbps_rate(void) {
+    assert(readable);
+    assert(ble_supported);
+    return HCI_LE_TWO_MBPS_SUPPORTED(features_ble.as_array);
+}
+
 static uint16_t get_acl_data_size_classic(void) {
   assert(readable);
   return acl_data_size_classic;
@@ -500,6 +555,18 @@ static const controller_static_t static_interface = {
   enable_soc_logging
 };
 
+static uint8_t get_ble_adv_ext_size(void) {
+    assert(readable);
+    assert(ble_supported);
+    return ble_adv_ext_size;
+}
+
+static void set_ble_adv_ext_size(int adv_sets) {
+    assert(readable);
+    assert(ble_supported);
+    ble_adv_ext_size = adv_sets;
+}
+
 static const controller_t interface = {
   get_is_ready,
 
@@ -520,11 +587,14 @@ static const controller_t interface = {
   supports_rssi_with_inquiry_results,
   supports_extended_inquiry_response,
   supports_master_slave_role_switch,
+  supports_set_le_privacy_mode,
 
   supports_ble,
   supports_ble_packet_extension,
   supports_ble_connection_parameters_request,
   supports_ble_privacy,
+  supports_ble_two_mbps_rate,
+  supports_ble_extended_advertisements,
 
   get_acl_data_size_classic,
   get_acl_data_size_ble,
@@ -541,7 +611,10 @@ static const controller_t interface = {
   get_ble_resolving_list_max_size,
   set_ble_resolving_list_max_size,
   get_local_supported_codecs,
-  supports_ble_offload_features
+  supports_ble_offload_features,
+
+  get_ble_adv_ext_size,
+  set_ble_adv_ext_size
 };
 
 const controller_static_t *controller_get_static_interface() {
diff --git a/device/src/interop.c b/device/src/interop.c
index 3a095f8..33f963f 100644
--- a/device/src/interop.c
+++ b/device/src/interop.c
@@ -86,21 +86,16 @@ bool interop_match_manufacturer(const interop_feature_t feature, uint16_t manufa
   return false;
 }
 
-bool interop_match_hid_multitouch(const interop_feature_t feature,
-        uint16_t vendor_id, uint16_t product_id, const char *name) {
-  assert(name);
-
+bool interop_match_vendor_product_ids(const interop_feature_t feature,
+        uint16_t vendor_id, uint16_t product_id) {
   const size_t db_size = sizeof(interop_hid_multitouch_database) / sizeof(interop_hid_multitouch_t);
 
   for (size_t i = 0; i != db_size; ++i) {
     if (vendor_id == interop_hid_multitouch_database[i].vendor_id &&
-        product_id == interop_hid_multitouch_database[i].product_id &&
-        strlen(name) >= interop_hid_multitouch_database[i].length &&
-        strncmp(name, interop_hid_multitouch_database[i].name,
-        interop_hid_multitouch_database[i].length) == 0) {
-      LOG_WARN(LOG_TAG, "%s() Device with vendor_id: %d product_id: %d name %s is a match for "
-          "interop hid multitouch workaround %s", __func__, vendor_id, product_id,
-          name, interop_feature_string_(feature));
+        product_id == interop_hid_multitouch_database[i].product_id) {
+      LOG_WARN(LOG_TAG, "%s() Device with vendor_id: %d product_id: %d is a match for "
+          "interop workaround %s", __func__, vendor_id, product_id,
+          interop_feature_string_(feature));
       return true;
     }
   }
@@ -160,6 +155,8 @@ static const char* interop_feature_string_(const interop_feature_t feature) {
     CASE_RETURN_STR(INTEROP_DISABLE_SNIFF_DURING_SCO)
     CASE_RETURN_STR(INTEROP_INCREASE_AG_CONN_TIMEOUT)
     CASE_RETURN_STR(INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS)
+    CASE_RETURN_STR(INTEROP_ADV_AVRCP_VER_1_3)
+    CASE_RETURN_STR(INTEROP_DISABLE_AAC_CODEC)
   }
 
   return "UNKNOWN";
diff --git a/doc/supported_features.md b/doc/supported_features.md
index 27fdaa6..60580e2 100644
--- a/doc/supported_features.md
+++ b/doc/supported_features.md
@@ -1,7 +1,7 @@
-# Fluoride 1.0
+# Fluoride 1.1
 
-Declaration ID: [D0026807](https://www.bluetooth.org/tpg/QLI_viewQDL.cfm?qid=26807)  
-Qualified Design ID: 67282
+Declaration ID: [D024527](https://www.bluetooth.org/tpg/QLI_viewQDL.cfm?qid=24527)
+Qualified Design ID: 83953
 
 Protocol / Profile | Version | Roles
 -------------------+---------+-------
diff --git a/hci/Android.mk b/hci/Android.mk
index 5e47732..ddb533d 100644
--- a/hci/Android.mk
+++ b/hci/Android.mk
@@ -19,7 +19,8 @@ LOCAL_SRC_FILES := \
     src/hci_packet_parser.c \
     src/low_power_manager.c \
     src/packet_fragmenter.c \
-    src/vendor.c
+    src/vendor.c \
+    ../EventLogTags.logtags
 
 LOCAL_C_INCLUDES += \
     $(LOCAL_PATH)/include \
@@ -37,6 +38,10 @@ ifeq ($(TARGET_BUILD_VARIANT),userdebug)
     LOCAL_CFLAGS += -DBTSNOOP_DEFAULT=TRUE
 endif
 
+ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
+LOCAL_CFLAGS += -DENABLE_DBG_FLAGS
+endif
+
 LOCAL_CFLAGS += $(bluetooth_CFLAGS)
 LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
 LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
diff --git a/hci/include/hci_packet_factory.h b/hci/include/hci_packet_factory.h
index 0056817..a6520ba 100644
--- a/hci/include/hci_packet_factory.h
+++ b/hci/include/hci_packet_factory.h
@@ -38,6 +38,7 @@ typedef struct {
   BT_HDR *(*make_ble_read_supported_states)(void);
   BT_HDR *(*make_ble_read_local_supported_features)(void);
   BT_HDR *(*make_ble_read_resolving_list_size)(void);
+  BT_HDR *(*make_ble_read_adv_ext_size)(void);
   BT_HDR *(*make_ble_read_suggested_default_data_length)(void);
   BT_HDR *(*make_ble_set_event_mask)(const bt_event_mask_t *event_mask);
   BT_HDR *(*make_read_local_supported_codecs)(void);
diff --git a/hci/include/hci_packet_parser.h b/hci/include/hci_packet_parser.h
index d09ac59..b83a71f 100644
--- a/hci/include/hci_packet_parser.h
+++ b/hci/include/hci_packet_parser.h
@@ -87,6 +87,11 @@ typedef struct {
     uint8_t *resolving_list_size_ptr
   );
 
+  void (*parse_ble_read_adv_ext_size_response) (
+    BT_HDR *response,
+    uint8_t *ble_adv_ext_size
+  );
+
   void (*parse_ble_read_suggested_default_data_length_response)(
     BT_HDR *response,
     uint16_t *ble_default_packet_length_ptr
diff --git a/hci/include/low_power_manager.h b/hci/include/low_power_manager.h
index 95f990a..138b3eb 100644
--- a/hci/include/low_power_manager.h
+++ b/hci/include/low_power_manager.h
@@ -41,6 +41,9 @@ typedef struct low_power_manager_t {
   // Tell the low power manager that you're done transmitting data. Must be
   // called on the thread provided at initialization time.
   void (*transmit_done)(void);
+
+  void (*start_idle_timer)(bool check_LPM);
+  void (*stop_idle_timer)();
 } low_power_manager_t;
 
 const low_power_manager_t *low_power_manager_get_interface();
diff --git a/hci/src/btsnoop.c b/hci/src/btsnoop.c
index edffa20..88c37f7 100644
--- a/hci/src/btsnoop.c
+++ b/hci/src/btsnoop.c
@@ -93,7 +93,7 @@ static future_t *start_up(void) {
 
   module_started = true;
   stack_config->get_btsnoop_ext_options(&hci_ext_dump_enabled, &btsnoop_conf_from_file);
-#if (BTSNOOP_DEFAULT == TRUE)
+#ifdef BLUEDROID_DEBUG
   if (btsnoop_conf_from_file == false) {
     hci_ext_dump_enabled = true;
   }
@@ -106,7 +106,7 @@ static future_t *start_up(void) {
 static future_t *shut_down(void) {
   module_started = false;
   if (hci_ext_dump_enabled == true) {
-    property_set("bluetooth.startbtsnoop", "false");
+    STOP_SNOOP_LOGGING();
   }
   update_logging();
 
@@ -176,15 +176,16 @@ static uint64_t btsnoop_timestamp(void) {
   tv.tv_sec += gmt_offset;
 
   // Timestamp is in microseconds.
-  uint64_t timestamp = tv.tv_sec * 1000 * 1000LL;
+  uint64_t timestamp = ((uint64_t)tv.tv_sec) * 1000 * 1000LL;
   timestamp += tv.tv_usec;
   timestamp += BTSNOOP_EPOCH_DELTA;
   return timestamp;
 }
 
 static void update_logging() {
+  bool btsnoop_log_output = stack_config->get_btsnoop_turned_on();
   bool should_log = module_started &&
-    (logging_enabled_via_api || stack_config->get_btsnoop_turned_on() || hci_ext_dump_enabled);
+    (logging_enabled_via_api || btsnoop_log_output || hci_ext_dump_enabled);
 
   if (should_log == is_logging)
     return;
@@ -192,10 +193,15 @@ static void update_logging() {
   is_logging = should_log;
   if (should_log) {
     btsnoop_net_open();
-
-    if (hci_ext_dump_enabled == true) {
-      property_set("bluetooth.startbtsnoop", "true");
+#ifdef BLUEDROID_DEBUG
+    if(!btsnoop_log_output)
+#endif
+    {
+      if (logging_enabled_via_api || hci_ext_dump_enabled == true) {
+        START_SNOOP_LOGGING();
+      }
     }
+
     const char *log_path = stack_config->get_btsnoop_log_path();
 
     // Save the old log if configured to do so
@@ -207,12 +213,15 @@ static void update_logging() {
         LOG_ERROR(LOG_TAG, "%s unable to rename '%s' to '%s': %s", __func__, log_path, last_log_path, strerror(errno));
     }
 
+    mode_t prevmask = umask(0);
     logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
     if (logfile_fd == INVALID_FD) {
       LOG_ERROR(LOG_TAG, "%s unable to open '%s': %s", __func__, log_path, strerror(errno));
       is_logging = false;
+      umask(prevmask);
       return;
     }
+    umask(prevmask);
 
     write(logfile_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
   } else {
diff --git a/hci/src/hci_hal_h4.c b/hci/src/hci_hal_h4.c
index 78674f1..a1a9b14 100644
--- a/hci/src/hci_hal_h4.c
+++ b/hci/src/hci_hal_h4.c
@@ -38,6 +38,8 @@
 // when streaming time sensitive data (A2DP).
 #define HCI_THREAD_PRIORITY -19
 
+#define BT_HCI_UNKNOWN_MESSAGE_TYPE_NUM 1010002
+
 // Our interface and modules we import
 static const hci_hal_t interface;
 static const hci_hal_callbacks_t *callbacks;
@@ -157,10 +159,11 @@ static size_t read_data(serial_data_type_t type, uint8_t *buffer, size_t max_siz
 }
 
 static void packet_finished(serial_data_type_t type) {
-  if (!stream_has_interpretation)
+  if (!stream_has_interpretation) {
     LOG_ERROR(LOG_TAG, "%s with no existing stream interpretation.", __func__);
-  else if (current_data_type != type)
+  } else if (current_data_type != type) {
     LOG_ERROR(LOG_TAG, "%s with different type than existing interpretation.", __func__);
+  }
 
 #if (defined(REMOVE_EAGER_THREADS) && (REMOVE_EAGER_THREADS == TRUE))
   if (uart_stream->rd_ptr == uart_stream->wr_ptr) {
@@ -311,7 +314,10 @@ static void event_uart_has_bytes(eager_reader_t *reader, UNUSED_ATTR void *conte
       return;
 
     if (type_byte < DATA_TYPE_ACL || type_byte > DATA_TYPE_EVENT) {
-      LOG_ERROR(LOG_TAG, "%s Unknown HCI message type. Dropping this byte 0x%x, min %x, max %x", __func__, type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
+      LOG_ERROR(LOG_TAG, "%s Unknown HCI message type 0x%x (min=0x%x max=0x%x). Aborting...",
+                __func__, type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
+      LOG_EVENT_INT(BT_HCI_UNKNOWN_MESSAGE_TYPE_NUM, type_byte);
+      assert(false && "Unknown HCI message type");
       return;
     }
 
diff --git a/hci/src/hci_layer.c b/hci/src/hci_layer.c
index 26cca4f..0b7e35a 100644
--- a/hci/src/hci_layer.c
+++ b/hci/src/hci_layer.c
@@ -55,6 +55,8 @@ bt_bdaddr_t btif_local_bd_addr;
 #define PREAMBLE_BUFFER_SIZE 4 // max preamble size, ACL
 #define RETRIEVE_ACL_LENGTH(preamble) ((((preamble)[3]) << 8) | (preamble)[2])
 
+#define BT_HCI_TIMEOUT_TAG_NUM 1010000
+
 static const uint8_t preamble_sizes[] = {
   HCI_COMMAND_PREAMBLE_SIZE,
   HCI_ACL_PREAMBLE_SIZE,
@@ -111,15 +113,22 @@ typedef enum {
     BT_SOC_RESERVED
 } bt_soc_type;
 
+typedef enum {
+  LPM_CONFIG_ALL,
+  LPM_CONFIG_TX,
+  LPM_CONFIG_NONE
+} low_power_config_t;
+
 // Using a define here, because it can be stringified for the property lookup
 #define DEFAULT_STARTUP_TIMEOUT_MS 8000
 #define STRING_VALUE_OF(x) #x
 
+low_power_config_t lpm_config = LPM_CONFIG_NONE;
+
 static const uint32_t EPILOG_TIMEOUT_MS = 3000;
 static const uint32_t COMMAND_PENDING_TIMEOUT_MS = 8000;
 
 extern int soc_type;
-static uint32_t HARDWARE_ERROR_TIMEOUT_MS = 2000;
 
 // Our interface
 static bool interface_created;
@@ -152,6 +161,7 @@ static fixed_queue_t *packet_queue;
 // Inbound-related
 static alarm_t *command_response_timer;
 static list_t *commands_pending_response;
+static list_t *commands_pending_in_queue;
 static pthread_mutex_t commands_pending_response_lock;
 static packet_receive_data_t incoming_packets[INBOUND_PACKET_TYPE_COUNT];
 
@@ -199,6 +209,22 @@ static future_t *start_up(void) {
   command_credits = 1;
   firmware_is_configured = false;
 
+  char prop_lpm_config[PROPERTY_VALUE_MAX];
+  osi_property_get("persist.service.bdroid.lpmcfg", prop_lpm_config, "all");
+  if (!strcmp(prop_lpm_config, "all")) {
+     // LPM configured for both Tx and Rx channels
+     lpm_config = LPM_CONFIG_ALL;
+  }
+  else if (!strcmp(prop_lpm_config, "tx")) {
+     // LPM configured for Tx channel only
+     lpm_config = LPM_CONFIG_TX;
+  }
+  else {
+     lpm_config = LPM_CONFIG_NONE;
+  }
+
+  LOG_INFO(LOG_TAG, "%s lpm configure value = %d.", __func__, lpm_config);
+
   pthread_mutex_init(&commands_pending_response_lock, NULL);
 
   // TODO(armansito): cutils/properties.h is only being used to pull-in runtime
@@ -254,6 +280,11 @@ static future_t *start_up(void) {
     LOG_ERROR(LOG_TAG, "%s unable to create list for commands pending response.", __func__);
     goto error;
   }
+  commands_pending_in_queue = list_new(NULL);
+  if (!commands_pending_in_queue) {
+    LOG_ERROR("%s unable to create list for commands pending response.", __func__);
+    goto error;
+  }
 
   memset(incoming_packets, 0, sizeof(incoming_packets));
 
@@ -329,6 +360,8 @@ static future_t *shut_down() {
   packet_queue = NULL;
   list_free(commands_pending_response);
   commands_pending_response = NULL;
+  list_free(commands_pending_in_queue);
+  commands_pending_in_queue = NULL;
 
   pthread_mutex_destroy(&commands_pending_response_lock);
 
@@ -517,6 +550,32 @@ static void hardware_error_timer_expired(UNUSED_ATTR void *context) {
   kill(getpid(), SIGKILL);
 }
 
+static void send_cmd_to_lower(waiting_command_t *wait_entry) {
+  // Move it to the list of commands awaiting response
+    pthread_mutex_lock(&commands_pending_response_lock);
+    list_append(commands_pending_response, wait_entry);
+    pthread_mutex_unlock(&commands_pending_response_lock);
+
+    // Send it off
+    if (LPM_CONFIG_TX == lpm_config) {
+        low_power_manager->stop_idle_timer();;
+    }
+    else {
+        low_power_manager->wake_assert();
+    }
+
+    if (LPM_CONFIG_TX == lpm_config) {
+        low_power_manager->start_idle_timer(false);
+    }
+    else {
+        low_power_manager->transmit_done();
+    }
+
+    packet_fragmenter->fragment_and_dispatch(wait_entry->command);
+
+    update_command_response_timer();
+}
+
 // Command/packet transmitting functions
 
 static void event_command_ready(fixed_queue_t *queue, UNUSED_ATTR void *context) {
@@ -528,17 +587,10 @@ static void event_command_ready(fixed_queue_t *queue, UNUSED_ATTR void *context)
     waiting_command_t *wait_entry = fixed_queue_dequeue(queue);
     command_credits--;
 
-    // Move it to the list of commands awaiting response
-    pthread_mutex_lock(&commands_pending_response_lock);
-    list_append(commands_pending_response, wait_entry);
-    pthread_mutex_unlock(&commands_pending_response_lock);
-
-    // Send it off
-    low_power_manager->wake_assert();
-    packet_fragmenter->fragment_and_dispatch(wait_entry->command);
-    low_power_manager->transmit_done();
-
-    update_command_response_timer();
+    send_cmd_to_lower(wait_entry);
+  } else {
+    waiting_command_t *wait_entry = fixed_queue_dequeue(queue);
+    list_append(commands_pending_in_queue, wait_entry);
   }
 }
 
@@ -590,6 +642,7 @@ static void command_timed_out(UNUSED_ATTR void *context) {
     // We shouldn't try to recover the stack from this command timeout.
     // If it's caused by a software bug, fix it. If it's a hardware bug, fix it.
     LOG_ERROR(LOG_TAG, "%s hci layer timeout waiting for response to a command. opcode: 0x%x", __func__, wait_entry->opcode);
+    LOG_EVENT_INT(BT_HCI_TIMEOUT_TAG_NUM, wait_entry->opcode);
   }
 
   LOG_ERROR("%s restarting the bluetooth process.", __func__);
@@ -604,18 +657,23 @@ static void command_timed_out(UNUSED_ATTR void *context) {
 
   if (soc_type == BT_SOC_ROME || soc_type == BT_SOC_CHEROKEE) {
     char value[PROPERTY_VALUE_MAX] = {0};
-    if( property_get("wc_transport.force_special_byte", value, "false") && !strcmp(value,"true")) {
+    uint32_t hardware_error_timeout_ms = 2000;
+    bool enabled = false;
+#ifdef ENABLE_DBG_FLAGS
+    enabled = true;
+#endif
+    if (property_get("wc_transport.force_special_byte", value, NULL))
+      enabled = (strcmp(value, "false") == 0) ? false : true;
+    if (enabled) {
       hardware_error_timer = alarm_new("hci.hardware_error_timer");
       if (!hardware_error_timer) {
         LOG_ERROR("%s unable to create hardware error timer.", __func__);
         usleep(2000000);
         kill(getpid(), SIGKILL);
       }
-      if(soc_type == BT_SOC_ROME)
-        HARDWARE_ERROR_TIMEOUT_MS = 2000000;
-      else if(soc_type == BT_SOC_CHEROKEE)
-        HARDWARE_ERROR_TIMEOUT_MS = 5000000;
-      alarm_set(hardware_error_timer, HARDWARE_ERROR_TIMEOUT_MS, hardware_error_timer_expired, NULL);
+      if(soc_type == BT_SOC_CHEROKEE)
+        hardware_error_timeout_ms = 5000;
+      alarm_set(hardware_error_timer, hardware_error_timeout_ms, hardware_error_timer_expired, NULL);
       return;
     }
   }
@@ -811,9 +869,9 @@ static bool filter_incoming_event(BT_HDR *packet) {
     // If a command generates a command status event, it won't be getting a command complete event
 
     wait_entry = get_waiting_command(opcode);
-    if (!wait_entry)
+    if (!wait_entry) {
       LOG_WARN(LOG_TAG, "%s command status event with no matching command. opcode: 0x%x", __func__, opcode);
-    else if (wait_entry->status_callback)
+    } else if (wait_entry->status_callback)
       wait_entry->status_callback(status, wait_entry->command, wait_entry->context);
 
     goto intercepted;
@@ -838,6 +896,16 @@ intercepted:
     buffer_allocator->free(packet);
   }
 
+  if(command_credits > 0) {
+     const list_node_t *node = list_begin(commands_pending_in_queue);
+
+     if(node != list_end(commands_pending_in_queue)) {
+       waiting_command_t *wait_entry = list_node(node);
+       command_credits--;
+       list_remove(commands_pending_in_queue, wait_entry);
+       send_cmd_to_lower(wait_entry);
+    }
+  }
   return true;
 }
 
@@ -852,7 +920,6 @@ void ssr_cleanup (int reason) {
    }
    if (vendor != NULL) {
        vendor->ssr_cleanup(reason);
-       hal->close(); //clean up the UART stream
    } else {
        LOG_ERROR("%s: vendor is NULL", __func__);
    }
diff --git a/hci/src/hci_packet_factory.c b/hci/src/hci_packet_factory.c
index d43d274..1e95ee3 100644
--- a/hci/src/hci_packet_factory.c
+++ b/hci/src/hci_packet_factory.c
@@ -133,6 +133,10 @@ static BT_HDR *make_ble_read_resolving_list_size(void) {
   return make_command_no_params(HCI_BLE_READ_RESOLVING_LIST_SIZE);
 }
 
+static BT_HDR *make_ble_read_adv_ext_size(void) {
+  return make_command_no_params(HCI_BLE_READ_NUM_ADV_SETS);
+}
+
 static BT_HDR *make_ble_read_suggested_default_data_length(void) {
     return make_command_no_params(HCI_BLE_READ_DEFAULT_DATA_LENGTH);
 }
@@ -200,6 +204,7 @@ static const hci_packet_factory_t interface = {
   make_ble_read_supported_states,
   make_ble_read_local_supported_features,
   make_ble_read_resolving_list_size,
+  make_ble_read_adv_ext_size,
   make_ble_read_suggested_default_data_length,
   make_ble_set_event_mask,
   make_read_local_supported_codecs,
diff --git a/hci/src/hci_packet_parser.c b/hci/src/hci_packet_parser.c
index 93d9f7e..3209e1f 100644
--- a/hci/src/hci_packet_parser.c
+++ b/hci/src/hci_packet_parser.c
@@ -207,6 +207,17 @@ static void parse_ble_read_resolving_list_size_response(
   buffer_allocator->free(response);
 }
 
+static void parse_ble_read_adv_ext_size_response(
+    BT_HDR *response,
+    uint8_t *ble_adv_ext_size) {
+
+  uint8_t *stream = read_command_complete_header(response, HCI_BLE_READ_NUM_ADV_SETS, 1 /* bytes after */);
+  assert(stream != NULL);
+  STREAM_TO_UINT8(*ble_adv_ext_size, stream);
+
+  buffer_allocator->free(response);
+}
+
 static void parse_ble_read_suggested_default_data_length_response(
     BT_HDR *response,
     uint16_t *ble_default_packet_length_ptr) {
@@ -273,6 +284,7 @@ static const hci_packet_parser_t interface = {
   parse_ble_read_supported_states_response,
   parse_ble_read_local_supported_features_response,
   parse_ble_read_resolving_list_size_response,
+  parse_ble_read_adv_ext_size_response,
   parse_ble_read_suggested_default_data_length_response,
   parse_read_local_supported_codecs_response,
   parse_ble_read_offload_features_response
diff --git a/hci/src/low_power_manager.c b/hci/src/low_power_manager.c
index 30d37e5..3c5984a 100644
--- a/hci/src/low_power_manager.c
+++ b/hci/src/low_power_manager.c
@@ -61,8 +61,8 @@ static void event_allow_device_sleep(void *context);
 static void event_idle_timeout(void *context);
 
 static void reset_state();
-static void start_idle_timer();
-static void stop_idle_timer();
+void start_idle_timer(bool check_LPM);
+void stop_idle_timer();
 
 static thread_fn event_functions[] = {
   event_disable,
@@ -127,9 +127,9 @@ static void wake_assert() {
 
 static void transmit_done() {
   transmit_is_done = true;
-  if (wake_state == LPM_WAKE_W4_TX_DONE) {
+  if (wake_state == LPM_WAKE_W4_TX_DONE || wake_state == LPM_WAKE_ASSERTED) {
     wake_state = LPM_WAKE_W4_TIMEOUT;
-    start_idle_timer();
+    start_idle_timer(true);
   }
 }
 
@@ -137,15 +137,17 @@ static void transmit_done() {
 
 static void enable(bool enable) {
   if (state == LPM_DISABLING) {
-    if (enable)
+    if (enable) {
       LOG_ERROR(LOG_TAG, "%s still processing prior disable request, cannot enable.", __func__);
-    else
+    } else {
       LOG_WARN(LOG_TAG, "%s still processing prior disable request, ignoring new request to disable.", __func__);
+    }
   } else if (state == LPM_ENABLING) {
-    if (enable)
+    if (enable) {
       LOG_ERROR(LOG_TAG, "%s still processing prior enable request, ignoring new request to enable.", __func__);
-    else
+    } else {
       LOG_WARN(LOG_TAG, "%s still processing prior enable request, cannot disable.", __func__);
+    }
   } else if (state == LPM_ENABLED && enable) {
     LOG_INFO(LOG_TAG, "%s already enabled.", __func__);
   } else if (state == LPM_DISABLED && !enable) {
@@ -163,7 +165,7 @@ static void allow_device_sleep() {
   if (state == LPM_ENABLED && wake_state == LPM_WAKE_ASSERTED) {
     if (transmit_is_done) {
       wake_state = LPM_WAKE_W4_TIMEOUT;
-      start_idle_timer();
+      start_idle_timer(true);
     } else {
       wake_state = LPM_WAKE_W4_TX_DONE;
     }
@@ -190,18 +192,22 @@ static void idle_timer_expired(UNUSED_ATTR void *context) {
     thread_post(thread, event_idle_timeout, NULL);
 }
 
-static void start_idle_timer() {
-  if (state == LPM_ENABLED) {
+void start_idle_timer(bool check_LPM) {
+  if (state == LPM_ENABLED || !check_LPM) {
     if (idle_timeout_ms == 0) {
        wake_deassert();
-    } else {
+    }
+    else {
        alarm_set(idle_alarm, idle_timeout_ms, idle_timer_expired, NULL);
     }
+
+    LOG_VERBOSE(LOG_TAG,"%s check_LPM = %d", __func__, check_LPM);
   }
 }
 
-static void stop_idle_timer() {
+void stop_idle_timer() {
   alarm_cancel(idle_alarm);
+  LOG_VERBOSE(LOG_TAG, "%s", __func__);
 }
 
 static void event_disable(UNUSED_ATTR void *context) {
@@ -240,7 +246,9 @@ static const low_power_manager_t interface = {
   cleanup,
   post_command,
   wake_assert,
-  transmit_done
+  transmit_done,
+  start_idle_timer,
+  stop_idle_timer
 };
 
 const low_power_manager_t *low_power_manager_get_interface() {
diff --git a/hci/src/packet_fragmenter.c b/hci/src/packet_fragmenter.c
index eae6905..06fb972 100644
--- a/hci/src/packet_fragmenter.c
+++ b/hci/src/packet_fragmenter.c
@@ -153,6 +153,7 @@ static void reassemble_and_dispatch(UNUSED_ATTR BT_HDR *packet) {
       if (acl_length < L2CAP_HEADER_SIZE) {
         LOG_WARN(LOG_TAG, "%s L2CAP packet too small (%d < %d). Dropping it.", __func__, packet->len, L2CAP_HEADER_SIZE);
         buffer_allocator->free(packet);
+        GENERATE_VND_LOGS();
         return;
       }
 
@@ -164,6 +165,7 @@ static void reassemble_and_dispatch(UNUSED_ATTR BT_HDR *packet) {
           ((full_length + sizeof(BT_HDR)) > BT_DEFAULT_BUFFER_SIZE)) {
         LOG_ERROR(LOG_TAG, "%s L2CAP packet has invalid length (%d). Dropping it.", __func__, l2cap_length);
         buffer_allocator->free(packet);
+        GENERATE_VND_LOGS();
         return;
       }
 
@@ -194,6 +196,7 @@ static void reassemble_and_dispatch(UNUSED_ATTR BT_HDR *packet) {
       if (!partial_packet) {
         LOG_WARN(LOG_TAG, "%s got continuation for unknown packet. Dropping it.", __func__);
         buffer_allocator->free(packet);
+        GENERATE_VND_LOGS();
         return;
       }
 
diff --git a/hci/test/hci_hal_h4_test.cpp b/hci/test/hci_hal_h4_test.cpp
index bf62405..1b861a0 100644
--- a/hci/test/hci_hal_h4_test.cpp
+++ b/hci/test/hci_hal_h4_test.cpp
@@ -192,17 +192,18 @@ static void expect_socket_data(int fd, char first_byte, char *data) {
   }
 }
 
-static void write_packet(int fd, char first_byte, char *data) {
+static void write_packet(int fd, char first_byte, const void *data,
+                         size_t datalen) {
   write(fd, &first_byte, 1);
-  write(fd, data, strlen(data));
+  write(fd, data, datalen);
 }
 
-static void write_packet_reentry(int fd, char first_byte, char *data) {
+static void write_packet_reentry(int fd, char first_byte, const void *data,
+                                 size_t datalen) {
   write(fd, &first_byte, 1);
 
-  int length = strlen(data);
-  for (int i = 0; i < length; i++) {
-    write(fd, &data[i], 1);
+  for (size_t i = 0; i < datalen; i++) {
+    write(fd, static_cast<const uint8_t *>(data) + i, 1);
     semaphore_wait(reentry_semaphore);
   }
 }
@@ -226,10 +227,11 @@ TEST_F(HciHalH4Test, test_transmit) {
 TEST_F(HciHalH4Test, test_read_synchronous) {
   reset_for(read_synchronous);
 
-  write_packet(sockfd[1], DATA_TYPE_ACL, acl_data);
-  write_packet(sockfd[1], HCI_BLE_EVENT, corrupted_data);
-  write_packet(sockfd[1], DATA_TYPE_SCO, sco_data);
-  write_packet(sockfd[1], DATA_TYPE_EVENT, event_data);
+  write_packet(sockfd[1], DATA_TYPE_ACL, acl_data, strlen(acl_data));
+  write_packet(sockfd[1], HCI_BLE_EVENT, corrupted_data,
+               sizeof(corrupted_data));
+  write_packet(sockfd[1], DATA_TYPE_SCO, sco_data, strlen(sco_data));
+  write_packet(sockfd[1], DATA_TYPE_EVENT, event_data, strlen(event_data));
 
   // Wait for all data to be received before calling the test good
   semaphore_wait(done);
@@ -242,7 +244,8 @@ TEST_F(HciHalH4Test, test_read_async_reentry) {
   reentry_semaphore = semaphore_new(0);
   reentry_i = 0;
 
-  write_packet_reentry(sockfd[1], DATA_TYPE_ACL, sample_data3);
+  write_packet_reentry(sockfd[1], DATA_TYPE_ACL, sample_data3,
+                       strlen(sample_data3));
 
   // write_packet_reentry ensures the data has been received
   semaphore_free(reentry_semaphore);
diff --git a/include/bt_logger_lib.h b/include/bt_logger_lib.h
new file mode 100644
index 0000000..30467af
--- /dev/null
+++ b/include/bt_logger_lib.h
@@ -0,0 +1,78 @@
+/*********************************************************************
+*
+* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of The Linux Foundation nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+************************************************************************/
+
+#include <stdio.h>
+#include <sys/types.h>
+
+/**
+ * Commands
+ */
+typedef enum  {
+    VENDOR_LOGGER_LOGS = 201, // Signifies Packet containing Logger Log
+    GENERATE_VND_LOG_SIGNAL, // Signifies command to generate logs
+    START_SNOOP_SIGNAL,
+    STOP_SNOOP_SIGNAL,
+    STOP_LOGGING_SIGNAL,
+} CommandTypes;
+
+void init_vnd_Logger(void);
+void clean_vnd_logger(void);
+
+typedef struct {
+    /** Set to sizeof(bt_vndor_interface_t) */
+    size_t          size;
+
+    /*
+     * Functions need to be implemented in Logger libray (libbt-logClient.so).
+     */
+
+    /*
+     *  Initialize logging by conneting client socket
+     *  to Logger process
+     */
+    int   (*init)(void);
+
+    /**  Sending Logs of Logger process */
+    void (*send_log_msg)(const char *tag, const char *fmt_str, va_list ap);
+    void (*send_log_data)(const char *tag, const char *fmt_str, ...);
+
+    /**  Sending Logs of Logger process */
+    void (*send_event)(char evt);
+
+    /** Closes the socket connection to logger process */
+    int  (*cleanup)(void);
+
+} bt_logger_interface_t;
+
+#define GENERATE_VND_LOGS() if(logger_interface)logger_interface->send_event(GENERATE_VND_LOG_SIGNAL)
+#define START_SNOOP_LOGGING() if(logger_interface)logger_interface->send_event(START_SNOOP_SIGNAL)
+#define STOP_SNOOP_LOGGING() if(logger_interface)logger_interface->send_event(STOP_SNOOP_SIGNAL)
diff --git a/include/bt_target.h b/include/bt_target.h
index 158f9a5..37ef9ae 100644
--- a/include/bt_target.h
+++ b/include/bt_target.h
@@ -575,21 +575,21 @@
 **
 ******************************************************************************/
 
-/* The maximum number of simultaneous links that L2CAP can support. */
-#ifndef MAX_ACL_CONNECTIONS
-#define MAX_L2CAP_LINKS             7
-#else
-#define MAX_L2CAP_LINKS             MAX_ACL_CONNECTIONS
+/* The maximum number of simultaneous channels that L2CAP can support. */
+#ifndef MAX_L2CAP_CHANNELS
+#define MAX_L2CAP_CHANNELS          20
 #endif
 
-/* The maximum number of simultaneous channels that L2CAP can support. */
+/* The maximum number of simultaneous links that L2CAP can support. */
 #ifndef MAX_L2CAP_CHANNELS
-#define MAX_L2CAP_CHANNELS          16
+#define MAX_L2CAP_LINKS             7
+#else
+#define MAX_L2CAP_LINKS             MAX_L2CAP_CHANNELS
 #endif
 
 /* The maximum number of simultaneous applications that can register with L2CAP. */
 #ifndef MAX_L2CAP_CLIENTS
-#define MAX_L2CAP_CLIENTS           15
+#define MAX_L2CAP_CLIENTS           19
 #endif
 
 /* The number of seconds of link inactivity before a link is disconnected. */
@@ -724,6 +724,14 @@
 #define BLE_INCLUDED            TRUE
 #endif
 
+/*LE_L2CAP_CODE*/
+/*LE Credit Based Flow Control Mode*/
+#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
+#ifndef LE_L2CAP_CFC_INCLUDED
+#define LE_L2CAP_CFC_INCLUDED        TRUE
+#endif  /*LE_L2CAP_CFC_INCLUDED */
+#endif /* BLE_INCLUDED */
+
 #ifndef BLE_ANDROID_CONTROLLER_SCAN_FILTER
 #define BLE_ANDROID_CONTROLLER_SCAN_FILTER            TRUE
 #endif
@@ -740,6 +748,10 @@
 #define BLE_PRIVACY_SPT         TRUE
 #endif
 
+#ifndef BLE_EXTENDED_ADV_SUPPORT
+#define BLE_EXTENDED_ADV_SUPPORT TRUE
+#endif
+
 /*
  * Enables or disables support for local privacy (ex. address rotation)
  */
@@ -825,7 +837,11 @@
 #endif
 
 #ifndef GATT_MAX_PHY_CHANNEL
+#ifndef MAX_L2CAP_CHANNELS
 #define GATT_MAX_PHY_CHANNEL        7
+#else
+#define GATT_MAX_PHY_CHANNEL        MAX_L2CAP_CHANNELS
+#endif
 #endif
 
 /* Used for conformance testing ONLY */
@@ -1393,7 +1409,11 @@
 #endif
 
 #ifndef HID_HOST_MAX_DEVICES
+#ifndef MAX_L2CAP_CHANNELS
 #define HID_HOST_MAX_DEVICES        7
+#else
+#define HID_HOST_MAX_DEVICES        MAX_L2CAP_CHANNELS
+#endif
 #endif
 
 #ifndef HID_HOST_MTU
@@ -1676,4 +1696,15 @@ The maximum number of payload octets that the local device can receive in a sing
 
 #include "bt_trace.h"
 
+/******************************************************************************
+**
+** Wear
+**
+******************************************************************************/
+
+/* Enable/disable LE IO capability overriding to no-input-no-output on first bond */
+#ifndef WEAR_LE_IO_CAP_OVERRIDE
+#define WEAR_LE_IO_CAP_OVERRIDE FALSE
+#endif
+
 #endif /* BT_TARGET_H */
diff --git a/include/bt_testapp.h b/include/bt_testapp.h
index e37930b..421b3fd 100644
--- a/include/bt_testapp.h
+++ b/include/bt_testapp.h
@@ -124,6 +124,14 @@ typedef struct {
     UINT8       (*GetChnlFcrMode)(UINT16 lcid);
     UINT16      (*SendFixedChnlData)(UINT16 fixed_cid, BD_ADDR rem_bda, BT_HDR *p_buf);
     void  (*Cleanup)(void);
+    bt_status_t (*RegisterLePsm) (UINT16 le_psm, BOOLEAN ConnType, UINT16 SecLevel,
+                                    UINT8 enc_key_size);
+    bt_status_t (*LeDeregister)(UINT16 psm);
+    UINT16 (*LeConnect) (UINT16 le_psm , BD_ADDR address, tL2CAP_LE_CFG_INFO *p_cfg);
+    BOOLEAN (*LeConnectRsp) (BD_ADDR p_bd_addr, UINT8 id, UINT16 lcid, UINT16 result,
+                             UINT16 status, tL2CAP_LE_CFG_INFO *p_cfg);
+    BOOLEAN (*LeFlowControl) (UINT16 lcid, UINT16 credits);
+    void (*LeFreeBuf)(BT_HDR *p_buf);
 } btl2cap_interface_t;
 
 typedef struct
diff --git a/include/bt_trace.h b/include/bt_trace.h
index aa93c93..744c63d 100644
--- a/include/bt_trace.h
+++ b/include/bt_trace.h
@@ -222,153 +222,156 @@ extern void BTA_setStackLog( const char* log_layer, int log_level);
 #define BT_TRACE(l,t,...)                        LogMsg((TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t)), ##__VA_ARGS__)
 #define BT_ERROR_TRACE(l,...)                    LogMsg(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | TRACE_TYPE_ERROR, ##__VA_ARGS__)
 
+#define VND_TRACE(l,t,...)                        vnd_LogMsg((TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t)), ##__VA_ARGS__)
+#define GENERATE_VENDOR_LOGS() vnd_GenerateLogs()
+
 /* Define tracing for the HCI unit
 */
 
-#define HCI_TRACE_ERROR(...)                     {if (btu_trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define HCI_TRACE_WARNING(...)                   {if (btu_trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define HCI_TRACE_EVENT(...)                     {if (btu_trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define HCI_TRACE_DEBUG(...)                     {if (btu_trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define HCI_TRACE_ERROR(...)                     {if (btu_trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define HCI_TRACE_WARNING(...)                   {if (btu_trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define HCI_TRACE_EVENT(...)                     {if (btu_trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define HCI_TRACE_DEBUG(...)                     {if (btu_trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 
 /* Define tracing for BTM
 */
-#define BTM_TRACE_ERROR(...)                     {if (btm_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define BTM_TRACE_WARNING(...)                   {if (btm_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define BTM_TRACE_API(...)                       {if (btm_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define BTM_TRACE_EVENT(...)                     {if (btm_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define BTM_TRACE_DEBUG(...)                     {if (btm_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define BTM_TRACE_ERROR(...)                     {if (btm_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define BTM_TRACE_WARNING(...)                   {if (btm_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define BTM_TRACE_API(...)                       {if (btm_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define BTM_TRACE_EVENT(...)                     {if (btm_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define BTM_TRACE_DEBUG(...)                     {if (btm_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BTM, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 
 /* Define tracing for the L2CAP unit
 */
-#define L2CAP_TRACE_ERROR(...)                   {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define L2CAP_TRACE_WARNING(...)                 {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define L2CAP_TRACE_API(...)                     {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define L2CAP_TRACE_EVENT(...)                   {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define L2CAP_TRACE_DEBUG(...)                   {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define L2CAP_TRACE_ERROR(...)                   {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define L2CAP_TRACE_WARNING(...)                 {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define L2CAP_TRACE_API(...)                     {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define L2CAP_TRACE_EVENT(...)                   {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define L2CAP_TRACE_DEBUG(...)                   {if (l2cb.l2cap_trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_L2CAP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 /* Define tracing for the SDP unit
 */
-#define SDP_TRACE_ERROR(...)                     {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define SDP_TRACE_WARNING(...)                   {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define SDP_TRACE_API(...)                       {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define SDP_TRACE_EVENT(...)                     {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define SDP_TRACE_DEBUG(...)                     {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define SDP_TRACE_ERROR(...)                     {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define SDP_TRACE_WARNING(...)                   {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define SDP_TRACE_API(...)                       {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define SDP_TRACE_EVENT(...)                     {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define SDP_TRACE_DEBUG(...)                     {if (sdp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SDP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 /* Define tracing for the RFCOMM unit
 */
-#define RFCOMM_TRACE_ERROR(...)                  {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define RFCOMM_TRACE_WARNING(...)                {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define RFCOMM_TRACE_API(...)                    {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define RFCOMM_TRACE_EVENT(...)                  {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define RFCOMM_TRACE_DEBUG(...)                  {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define RFCOMM_TRACE_ERROR(...)                  {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define RFCOMM_TRACE_WARNING(...)                {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define RFCOMM_TRACE_API(...)                    {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define RFCOMM_TRACE_EVENT(...)                  {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define RFCOMM_TRACE_DEBUG(...)                  {if (rfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_RFCOMM, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 /* Generic Access Profile traces */
-#define GAP_TRACE_ERROR(...)                     {if (gap_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define GAP_TRACE_EVENT(...)                     {if (gap_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define GAP_TRACE_API(...)                       {if (gap_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define GAP_TRACE_WARNING(...)                   {if (gap_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define GAP_TRACE_ERROR(...)                     {if (gap_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define GAP_TRACE_EVENT(...)                     {if (gap_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define GAP_TRACE_API(...)                       {if (gap_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define GAP_TRACE_WARNING(...)                   {if (gap_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_GAP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
 
 /* define traces for HID Host */
-#define HIDH_TRACE_ERROR(...)                     {if (hh_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define HIDH_TRACE_WARNING(...)                   {if (hh_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define HIDH_TRACE_API(...)                       {if (hh_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define HIDH_TRACE_EVENT(...)                     {if (hh_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define HIDH_TRACE_DEBUG(...)                     {if (hh_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define HIDH_TRACE_ERROR(...)                     {if (hh_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HID, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define HIDH_TRACE_WARNING(...)                   {if (hh_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HID, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define HIDH_TRACE_API(...)                       {if (hh_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HID, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define HIDH_TRACE_EVENT(...)                     {if (hh_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HID, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define HIDH_TRACE_DEBUG(...)                     {if (hh_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_HID, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_HID, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 /* define traces for BNEP */
 
-#define BNEP_TRACE_ERROR(...)                     {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define BNEP_TRACE_WARNING(...)                   {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define BNEP_TRACE_API(...)                       {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define BNEP_TRACE_EVENT(...)                     {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define BNEP_TRACE_DEBUG(...)                     {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define BNEP_TRACE_ERROR(...)                     {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define BNEP_TRACE_WARNING(...)                   {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define BNEP_TRACE_API(...)                       {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define BNEP_TRACE_EVENT(...)                     {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define BNEP_TRACE_DEBUG(...)                     {if (bnep_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_BNEP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 /* define traces for PAN */
 
-#define PAN_TRACE_ERROR(...)                     {if (pan_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define PAN_TRACE_WARNING(...)                   {if (pan_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define PAN_TRACE_API(...)                       {if (pan_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define PAN_TRACE_EVENT(...)                     {if (pan_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define PAN_TRACE_DEBUG(...)                     {if (pan_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define PAN_TRACE_ERROR(...)                     {if (pan_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define PAN_TRACE_WARNING(...)                   {if (pan_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define PAN_TRACE_API(...)                       {if (pan_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define PAN_TRACE_EVENT(...)                     {if (pan_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define PAN_TRACE_DEBUG(...)                     {if (pan_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_PAN, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 /* Define tracing for the A2DP profile
 */
-#define A2D_TRACE_ERROR(...)                      {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_ERROR,##__VA_ARGS__);}
-#define A2D_TRACE_WARNING(...)                    {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_WARNING,##__VA_ARGS__);}
-#define A2D_TRACE_EVENT(...)                      {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_EVENT,##__VA_ARGS__);}
-#define A2D_TRACE_DEBUG(...)                      {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_DEBUG,##__VA_ARGS__);}
-#define A2D_TRACE_API(...)                        {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_API,##__VA_ARGS__);}
+#define A2D_TRACE_ERROR(...)                      {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_ERROR,##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_ERROR,##__VA_ARGS__);}
+#define A2D_TRACE_WARNING(...)                    {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_WARNING,##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_WARNING,##__VA_ARGS__);}
+#define A2D_TRACE_EVENT(...)                      {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_EVENT,##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_EVENT,##__VA_ARGS__);}
+#define A2D_TRACE_DEBUG(...)                      {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_DEBUG,##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_DEBUG,##__VA_ARGS__);}
+#define A2D_TRACE_API(...)                        {if (a2d_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_API,##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_A2D, TRACE_TYPE_API,##__VA_ARGS__);}
 
 /* AVDTP
 */
-#define AVDT_TRACE_ERROR(...)                     {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define AVDT_TRACE_WARNING(...)                   {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define AVDT_TRACE_EVENT(...)                     {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define AVDT_TRACE_DEBUG(...)                     {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
-#define AVDT_TRACE_API(...)                       {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define AVDT_TRACE_ERROR(...)                     {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define AVDT_TRACE_WARNING(...)                   {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define AVDT_TRACE_EVENT(...)                     {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define AVDT_TRACE_DEBUG(...)                     {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define AVDT_TRACE_API(...)                       {if (avdt_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__);}
 
 /* Define tracing for the AVCTP protocol
 */
-#define AVCT_TRACE_ERROR(...)                     {if (avct_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define AVCT_TRACE_WARNING(...)                   {if (avct_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define AVCT_TRACE_EVENT(...)                     {if (avct_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define AVCT_TRACE_DEBUG(...)                     {if (avct_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
-#define AVCT_TRACE_API(...)                       {if (avct_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define AVCT_TRACE_ERROR(...)                     {if (avct_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define AVCT_TRACE_WARNING(...)                   {if (avct_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define AVCT_TRACE_EVENT(...)                     {if (avct_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define AVCT_TRACE_DEBUG(...)                     {if (avct_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define AVCT_TRACE_API(...)                       {if (avct_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__);}
 
 /* Define tracing for the AVRCP profile
 */
-#define AVRC_TRACE_ERROR(...)                      {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define AVRC_TRACE_WARNING(...)                    {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define AVRC_TRACE_EVENT(...)                      {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define AVRC_TRACE_DEBUG(...)                      {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
-#define AVRC_TRACE_API(...)                        {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define AVRC_TRACE_ERROR(...)                      {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define AVRC_TRACE_WARNING(...)                    {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define AVRC_TRACE_EVENT(...)                      {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define AVRC_TRACE_DEBUG(...)                      {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define AVRC_TRACE_API(...)                        {if (avrc_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_AVP, TRACE_TYPE_API, ##__VA_ARGS__);}
 
 /* MCAP
 */
-#define MCA_TRACE_ERROR(...)                     {if (mca_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define MCA_TRACE_WARNING(...)                   {if (mca_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define MCA_TRACE_EVENT(...)                     {if (mca_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define MCA_TRACE_DEBUG(...)                     {if (mca_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
-#define MCA_TRACE_API(...)                       {if (mca_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define MCA_TRACE_ERROR(...)                     {if (mca_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define MCA_TRACE_WARNING(...)                   {if (mca_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define MCA_TRACE_EVENT(...)                     {if (mca_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define MCA_TRACE_DEBUG(...)                     {if (mca_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define MCA_TRACE_API(...)                       {if (mca_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_MCA, TRACE_TYPE_API, ##__VA_ARGS__);}
 
 /* Define tracing for the ATT/GATT unit
 */
-#define GATT_TRACE_ERROR(...)                     {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define GATT_TRACE_WARNING(...)                   {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define GATT_TRACE_API(...)                       {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define GATT_TRACE_EVENT(...)                     {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define GATT_TRACE_DEBUG(...)                     {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define GATT_TRACE_ERROR(...)                     {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define GATT_TRACE_WARNING(...)                   {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define GATT_TRACE_API(...)                       {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define GATT_TRACE_EVENT(...)                     {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define GATT_TRACE_DEBUG(...)                     {if (gatt_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_ATT, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 /* Define tracing for the SMP unit
 */
-#define SMP_TRACE_ERROR(...)                     {if (smp_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define SMP_TRACE_WARNING(...)                   {if (smp_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define SMP_TRACE_API(...)                       {if (smp_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_API, ##__VA_ARGS__);}
-#define SMP_TRACE_EVENT(...)                     {if (smp_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define SMP_TRACE_DEBUG(...)                     {if (smp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define SMP_TRACE_ERROR(...)                     {if (smp_cb.trace_level >= BT_TRACE_LEVEL_ERROR) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_ERROR, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define SMP_TRACE_WARNING(...)                   {if (smp_cb.trace_level >= BT_TRACE_LEVEL_WARNING) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_WARNING, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define SMP_TRACE_API(...)                       {if (smp_cb.trace_level >= BT_TRACE_LEVEL_API) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_API, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_API, ##__VA_ARGS__);}
+#define SMP_TRACE_EVENT(...)                     {if (smp_cb.trace_level >= BT_TRACE_LEVEL_EVENT) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_EVENT, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define SMP_TRACE_DEBUG(...)                     {if (smp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) BT_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_DEBUG, ##__VA_ARGS__); else VND_TRACE(TRACE_LAYER_SMP, TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 extern UINT8 btif_trace_level;
 extern UINT8 audio_latency_trace_level;
 
 /* define traces for application */
 #define BTIF_TRACE_IMP(...)                      {LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
-#define BTIF_TRACE_ERROR(...)                    {if (btif_trace_level >= BT_TRACE_LEVEL_ERROR) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define BTIF_TRACE_WARNING(...)                  {if (btif_trace_level >= BT_TRACE_LEVEL_WARNING) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define BTIF_TRACE_API(...)                      {if (btif_trace_level >= BT_TRACE_LEVEL_API) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_API, ##__VA_ARGS__);}
-#define BTIF_TRACE_EVENT(...)                    {if (btif_trace_level >= BT_TRACE_LEVEL_EVENT) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define BTIF_TRACE_DEBUG(...)                    {if (btif_trace_level >= BT_TRACE_LEVEL_DEBUG) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define BTIF_TRACE_ERROR(...)                    {if (btif_trace_level >= BT_TRACE_LEVEL_ERROR) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_ERROR, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define BTIF_TRACE_WARNING(...)                  {if (btif_trace_level >= BT_TRACE_LEVEL_WARNING) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_WARNING, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_WARNING, ##__VA_ARGS__);}
+#define BTIF_TRACE_API(...)                      {if (btif_trace_level >= BT_TRACE_LEVEL_API) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_API, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_API, ##__VA_ARGS__);}
+#define BTIF_TRACE_EVENT(...)                    {if (btif_trace_level >= BT_TRACE_LEVEL_EVENT) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_EVENT, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define BTIF_TRACE_DEBUG(...)                    {if (btif_trace_level >= BT_TRACE_LEVEL_DEBUG) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 #define BTIF_TRACE_VERBOSE(...)                  {if (btif_trace_level >= BT_TRACE_LEVEL_VERBOSE) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
 
 /* define traces for application */
 #define APPL_TRACE_IMP(...)                      {LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
-#define APPL_TRACE_ERROR(...)                    {if (appl_trace_level >= BT_TRACE_LEVEL_ERROR) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_ERROR, ##__VA_ARGS__);}
-#define APPL_TRACE_WARNING(...)                  {if (appl_trace_level >= BT_TRACE_LEVEL_WARNING) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_WARNING, ##__VA_ARGS__);}
-#define APPL_TRACE_API(...)                      {if (appl_trace_level >= BT_TRACE_LEVEL_API) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_API, ##__VA_ARGS__);}
-#define APPL_TRACE_EVENT(...)                    {if (appl_trace_level >= BT_TRACE_LEVEL_EVENT) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_EVENT, ##__VA_ARGS__);}
-#define APPL_TRACE_DEBUG(...)                    {if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
+#define APPL_TRACE_ERROR(...)                    {if (appl_trace_level >= BT_TRACE_LEVEL_ERROR) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_ERROR, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define APPL_TRACE_WARNING(...)                  {if (appl_trace_level >= BT_TRACE_LEVEL_WARNING) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_WARNING, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_ERROR, ##__VA_ARGS__);}
+#define APPL_TRACE_API(...)                      {if (appl_trace_level >= BT_TRACE_LEVEL_API) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_API, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_API, ##__VA_ARGS__);}
+#define APPL_TRACE_EVENT(...)                    {if (appl_trace_level >= BT_TRACE_LEVEL_EVENT) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_EVENT, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_EVENT, ##__VA_ARGS__);}
+#define APPL_TRACE_DEBUG(...)                    {if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__); else vnd_LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 #define APPL_TRACE_VERBOSE(...)                  {if (appl_trace_level >= BT_TRACE_LEVEL_VERBOSE) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 #define APPL_TRACE_LATENCY_AUDIO(...)            {if (audio_latency_trace_level >= BT_TRACE_LEVEL_VERBOSE) LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | TRACE_TYPE_DEBUG, ##__VA_ARGS__);}
 
@@ -421,3 +424,5 @@ typedef struct {
 extern UINT8 appl_trace_level;
 
 void LogMsg (UINT32 trace_set_mask, const char *fmt_str, ...);
+void vnd_LogMsg (UINT32 trace_set_mask, const char *fmt_str, ...);
+void vnd_GenerateLogs();
diff --git a/main/Android.mk b/main/Android.mk
index 2286997..594b4d2 100644
--- a/main/Android.mk
+++ b/main/Android.mk
@@ -26,6 +26,16 @@ LOCAL_SRC_FILES+= \
 LOCAL_SRC_FILES+= \
 	../udrv/ulinux/uipc.c
 
+ifeq ($(BOARD_USES_WIPOWER),true)
+ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
+LOCAL_SRC_FILES += \
+       ../../../vendor/qcom/opensource/bluetooth/wipower-host/core/src/wipower.c
+else
+LOCAL_SRC_FILES += \
+       ../../../device/qcom/msm8909w/opensource/bluetooth/wipower-host/core/src/wipower.c
+endif
+endif
+
 LOCAL_C_INCLUDES+= . \
 	$(LOCAL_PATH)/../ \
 	$(LOCAL_PATH)/../bta/include \
@@ -56,6 +66,18 @@ LOCAL_C_INCLUDES+= . \
     external/zlib \
     $(call include-path-for, audio-utils)
 
+ifeq ($(BOARD_USES_WIPOWER),true)
+ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
+LOCAL_C_INCLUDES+= \
+       vendor/qcom/opensource/bluetooth/hal/include \
+       vendor/qcom/opensource/bluetooth/wipower-host/core/include
+else
+LOCAL_C_INCLUDES+= \
+       device/qcom/msm8909w/opensource/bluetooth/hal/include \
+       device/qcom/msm8909w/opensource/bluetooth/wipower-host/core/include
+endif
+endif
+
 LOCAL_SHARED_LIBRARIES := \
     libcutils \
     libdl \
@@ -100,6 +122,7 @@ LOCAL_LDLIBS := -Wl,-Bsymbolic,-Bsymbolic-functions
 LOCAL_REQUIRED_MODULES := \
     bt_did.conf \
     bt_stack.conf \
+    interop_database.conf \
     libbt-hci \
     libbt-vendor
 
diff --git a/main/bte_logmsg.c b/main/bte_logmsg.c
index ca10357..2d6d208 100644
--- a/main/bte_logmsg.c
+++ b/main/bte_logmsg.c
@@ -25,6 +25,7 @@
 #include <stdarg.h>
 #include <sys/time.h>
 #include <time.h>
+#include <dlfcn.h>
 
 #include "avrc_api.h"
 #include "bta_api.h"
@@ -66,6 +67,10 @@
 #define BTE_LOG_BUF_SIZE  1024
 #endif
 
+#define VND_PKT_SIZE_BLOCKS 4
+#define VND_PKT_HEADER_SIZE 5 //(VND_PKT_SIZE_BLOCKS + 1)
+#define VND_PKT_BODY_SIZE 1021
+
 #define BTE_LOG_MAX_SIZE  (BTE_LOG_BUF_SIZE - 12)
 
 #define MSG_BUFFER_OFFSET 0
@@ -198,6 +203,26 @@ void LogMsg(uint32_t trace_set_mask, const char *fmt_str, ...) {
   }
 }
 
+void vnd_LogMsg(uint32_t trace_set_mask, const char *fmt_str, ...) {
+  int trace_layer = TRACE_GET_LAYER(trace_set_mask);
+  const char *tag;
+  if (trace_layer >= TRACE_LAYER_MAX_NUM)
+    trace_layer = 0;
+
+  tag = bt_layer_tags[trace_layer];
+
+  va_list ap;
+  va_start(ap, fmt_str);
+  if(logger_interface)
+    logger_interface->send_log_msg(tag, fmt_str, ap);
+  va_end(ap);
+}
+
+void vnd_GenerateLogs() {
+  if(logger_interface)
+    logger_interface->send_event(GENERATE_VND_LOG_SIGNAL);
+}
+
 /* this function should go into BTAPP_DM for example */
 static uint8_t BTAPP_SetTraceLevel(uint8_t new_level) {
   if (new_level != 0xFF)
diff --git a/main/stack_config.c b/main/stack_config.c
index 7a894c9..f12a789 100644
--- a/main/stack_config.c
+++ b/main/stack_config.c
@@ -82,7 +82,8 @@ EXPORT_SYMBOL const module_t stack_config_module = {
 // Interface functions
 
 static const char *get_btsnoop_log_path(void) {
-  return config_get_string(config, CONFIG_DEFAULT_SECTION, BTSNOOP_LOG_PATH_KEY, "/data/misc/bluedroid/btsnoop_hci.log");
+  return config_get_string(config, CONFIG_DEFAULT_SECTION, BTSNOOP_LOG_PATH_KEY,
+      "/data/misc/bluetooth/logs/btsnoop_hci.log");
 }
 
 static bool get_btsnoop_turned_on(void) {
diff --git a/osi/Android.mk b/osi/Android.mk
index 4d372ec..bab6cd1 100644
--- a/osi/Android.mk
+++ b/osi/Android.mk
@@ -51,7 +51,8 @@ btosiCommonSrc := \
     ./src/socket_utils/socket_local_server.c \
     ./src/thread.c \
     ./src/time.c \
-    ./src/wakelock.c
+    ./src/wakelock.c \
+    ./src/vnd_log.c
 
 btosiCommonTestSrc := \
     ./test/AlarmTestHarness.cpp \
@@ -67,7 +68,9 @@ btosiCommonTestSrc := \
     ./test/future_test.cpp \
     ./test/hash_map_test.cpp \
     ./test/hash_map_utils_test.cpp \
+    ./test/leaky_bonded_queue_test.cpp \
     ./test/list_test.cpp \
+    ./test/metrics_test.cpp \
     ./test/properties_test.cpp \
     ./test/rand_test.cpp \
     ./test/reactor_test.cpp \
@@ -78,6 +81,7 @@ btosiCommonTestSrc := \
 
 btosiCommonIncludes := \
     $(LOCAL_PATH)/.. \
+    $(LOCAL_PATH)/../include \
     $(LOCAL_PATH)/../utils/include \
     $(LOCAL_PATH)/../stack/include \
     $(bluetooth_C_INCLUDES)
@@ -166,7 +170,7 @@ LOCAL_SRC_FILES := $(btosiCommonTestSrc)
 LOCAL_MODULE := net_test_osi
 LOCAL_MODULE_TAGS := tests
 LOCAL_SHARED_LIBRARIES := libc liblog libprotobuf-cpp-full libchrome libcutils
-LOCAL_STATIC_LIBRARIES := libosi libbt-protos
+LOCAL_STATIC_LIBRARIES := libosi libbt-protos libgmock
 
 LOCAL_CFLAGS += $(bluetooth_CFLAGS)
 LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
@@ -184,7 +188,7 @@ LOCAL_LDLIBS := -lrt -lpthread
 LOCAL_MODULE := net_test_osi
 LOCAL_MODULE_TAGS := tests
 LOCAL_SHARED_LIBRARIES := liblog libprotobuf-cpp-full libchrome
-LOCAL_STATIC_LIBRARIES := libosi-host libbt-protos
+LOCAL_STATIC_LIBRARIES := libosi-host libbt-protos libgmock_host
 
 LOCAL_CFLAGS += $(bluetooth_CFLAGS) -DOS_GENERIC
 LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
diff --git a/osi/BUILD.gn b/osi/BUILD.gn
index ed91fb1..80d7d3b 100644
--- a/osi/BUILD.gn
+++ b/osi/BUILD.gn
@@ -71,7 +71,9 @@ executable("net_test_osi") {
     "test/future_test.cpp",
     "test/hash_map_test.cpp",
     "test/hash_map_utils_test.cpp",
+    "test/leaky_bonded_queue_test.cpp",
     "test/list_test.cpp",
+    "test/metrics_test.cpp",
     "test/properties_test.cpp",
     "test/rand_test.cpp",
     "test/reactor_test.cpp",
@@ -88,6 +90,8 @@ executable("net_test_osi") {
   deps = [
     "//osi",
     "//third_party/googletest:gtest_main",
+    "//third_party/googletest:gmock_main",
+    "//third_party/libchrome:base",
   ]
 
   libs = [
diff --git a/osi/include/leaky_bonded_queue.h b/osi/include/leaky_bonded_queue.h
new file mode 100644
index 0000000..8259cdc
--- /dev/null
+++ b/osi/include/leaky_bonded_queue.h
@@ -0,0 +1,158 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+
+#include <memory>
+#include <mutex>
+#include <queue>
+
+namespace system_bt_osi {
+
+/*
+ *   LeakyBondedQueue<T>
+ *
+ * - LeakyLondedQueue<T> is a fixed size queue that leaks oldest item when
+ *   reaching its capacity. This is useful in creating memory bonded data
+ *   structure where freshness is more important than full coverage.
+ * - The queue is protected by a simple mutex and is thread-safe, although
+ *   improvements could be made to lock enqueue and dequeue separately, it
+ *   is not implemented at this moment due to lack of demand
+ * - The queue uses unique_ptr to automatically free its content when it is
+ *   destructed. It is the user's responsibility to implement T's destructor
+ *   correctly.
+ *
+ */
+template <class T>
+class LeakyBondedQueue {
+ public:
+  LeakyBondedQueue(size_t capacity);
+  /* Default destructor
+   *
+   * Call Clear() and free the queue structure itself
+   */
+  ~LeakyBondedQueue();
+  /*
+   * Add item NEW_ITEM to the underlining queue. If the queue is full, pop
+   * the oldest item
+   */
+  void Enqueue(T* new_item);
+  /*
+   * Add item NEW_ITEM to the underlining queue. If the queue is full, dequeue
+   * the oldest item and returns it to the caller. Return nullptr otherwise.
+   */
+  T* EnqueueWithPop(T* new_item);
+  /*
+   * Dequeues the oldest item from the queue. Return nullptr if queue is empty
+   */
+  T* Dequeue();
+  /*
+   * Returns the length of queue
+   */
+  size_t Length();
+  /*
+   * Returns the defined capacity of the queue
+   */
+  size_t Capacity();
+  /*
+   * Returns whether the queue is empty
+   */
+  bool Empty();
+  /*
+   * Pops all items from the queue
+   */
+  void Clear();
+
+ private:
+  // Put item in unique_ptr so that they get freed automatically when poped or
+  // when queue_ is freed
+  std::queue<std::unique_ptr<T>> queue_;
+  std::mutex lock_;
+  size_t capacity_;
+};
+
+/*
+* Definitions must be in the header for template classes
+*/
+
+template <class T>
+LeakyBondedQueue<T>::LeakyBondedQueue(size_t capacity) {
+  capacity_ = capacity;
+}
+
+template <class T>
+LeakyBondedQueue<T>::~LeakyBondedQueue() {}
+
+template <class T>
+void LeakyBondedQueue<T>::Enqueue(T* new_item) {
+  std::lock_guard<std::mutex> lock(lock_);
+  if ((queue_.size() + 1) > capacity_) {
+    queue_.pop();
+  }
+  std::unique_ptr<T> item_ptr(new_item);
+  queue_.push(std::move(item_ptr));
+}
+
+template <class T>
+T* LeakyBondedQueue<T>::EnqueueWithPop(T* new_item) {
+  std::lock_guard<std::mutex> lock(lock_);
+  T* old_item = nullptr;
+  if ((queue_.size() + 1) > capacity_) {
+    std::unique_ptr<T> item = std::move(queue_.front());
+    queue_.pop();
+    old_item = item.release();
+  }
+  std::unique_ptr<T> item_ptr(new_item);
+  queue_.push(std::move(item_ptr));
+  return old_item;
+}
+
+template <class T>
+T* LeakyBondedQueue<T>::Dequeue() {
+  std::lock_guard<std::mutex> lock(lock_);
+  std::unique_ptr<T> item = std::move(queue_.front());
+  queue_.pop();
+  return item.release();
+}
+
+template <class T>
+void LeakyBondedQueue<T>::Clear() {
+  std::lock_guard<std::mutex> lock(lock_);
+  while (!queue_.empty()) {
+    // unique_ptr does not need to be freed
+    queue_.pop();
+  }
+}
+
+template <class T>
+size_t LeakyBondedQueue<T>::Length() {
+  std::lock_guard<std::mutex> lock(lock_);
+  return queue_.size();
+}
+
+template <class T>
+size_t LeakyBondedQueue<T>::Capacity() {
+  return capacity_;
+}
+
+template <class T>
+bool LeakyBondedQueue<T>::Empty() {
+  std::lock_guard<std::mutex> lock(lock_);
+  return queue_.empty();
+}
+
+}  // namespace system_bt_osi
diff --git a/osi/include/log.h b/osi/include/log.h
index 738462e..a579ded 100644
--- a/osi/include/log.h
+++ b/osi/include/log.h
@@ -17,6 +17,12 @@
  ******************************************************************************/
 
 #pragma once
+#include <string.h>
+#include <stdbool.h>
+#include "include/bt_logger_lib.h"
+
+extern bt_logger_interface_t *logger_interface;
+extern bool bt_logger_enabled;
 
 /*
  * TODO(armansito): Work-around until we figure out a way to generate logs in a
@@ -39,14 +45,16 @@
 
 #include <cutils/log.h>
 
+//#define VNDLOG(tag, fmt, ## args) if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args)
+
 #if LOG_NDEBUG
 #define LOG_VERBOSE(...) ((void)0)
 #else  // LOG_NDEBUG
 #define LOG_VERBOSE(tag, fmt, args...) ALOG(LOG_VERBOSE, tag, fmt, ## args)
 #endif  // !LOG_NDEBUG
-#define LOG_DEBUG(tag, fmt, args...)   ALOG(LOG_DEBUG, tag, fmt, ## args )
-#define LOG_INFO(tag, fmt, args...)    ALOG(LOG_INFO, tag, fmt, ## args)
-#define LOG_WARN(tag, fmt, args...)    ALOG(LOG_WARN, tag, fmt, ## args)
-#define LOG_ERROR(tag, fmt, args...)   ALOG(LOG_ERROR, tag, fmt, ## args)
+#define LOG_DEBUG(tag, fmt, args...)   {if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args);ALOG(LOG_DEBUG, tag, fmt, ## args);}
+#define LOG_INFO(tag, fmt, args...)    {if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args);ALOG(LOG_INFO, tag, fmt, ## args);}
+#define LOG_WARN(tag, fmt, args...)    {if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args);ALOG(LOG_WARN, tag, fmt, ## args);}
+#define LOG_ERROR(tag, fmt, args...)   {if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args);ALOG(LOG_ERROR, tag, fmt, ## args);}
 
 #endif  /* defined(OS_GENERIC) */
diff --git a/osi/include/metrics.h b/osi/include/metrics.h
index 4855301..4ef12b2 100644
--- a/osi/include/metrics.h
+++ b/osi/include/metrics.h
@@ -20,6 +20,11 @@
 
 #include <stdint.h>
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+// Typedefs to hide protobuf definition to the rest of stack
+
 typedef enum {
   DEVICE_TYPE_UNKNOWN,
   DEVICE_TYPE_BREDR,
@@ -27,26 +32,12 @@ typedef enum {
   DEVICE_TYPE_DUMO,
 } device_type_t;
 
-// Record a pairing event at Unix epoch time |timestamp_ms|
-// |device_class| and |device_type| denote the type of device paired.
-// |disconnect_reason| is the HCI reason for pairing disconnection,
-// see stack/include/hcidefs.h
-void metrics_pair_event(uint32_t disconnect_reason, uint64_t timestamp_ms,
-                        uint32_t device_class, device_type_t device_type);
-
 typedef enum {
   WAKE_EVENT_UNKNOWN,
   WAKE_EVENT_ACQUIRED,
   WAKE_EVENT_RELEASED,
 } wake_event_type_t;
 
-// Record a wake event at Unix epoch time |timestamp_ms|.
-// |type| specifies whether it was acquired or relased,
-// |requestor| if provided is the service requesting the wake lock.
-// |name| is the name of the wake lock held.
-void metrics_wake_event(wake_event_type_t type, const char *requestor,
-                        const char *name, uint64_t timestamp_ms);
-
 typedef enum {
   SCAN_TYPE_UNKNOWN,
   SCAN_TECH_TYPE_LE,
@@ -54,44 +45,52 @@ typedef enum {
   SCAN_TECH_TYPE_BOTH,
 } scan_tech_t;
 
-// Record a scan event at Unix epoch time |timestamp_ms|.
-// |start| is true if this is the beginning of the scan.
-// |initiator| is a unique ID identifying the app starting the scan.
-// |type| is whether the scan reports BR/EDR, LE, or both.
-// |results| is the number of results to be reported.
-void metrics_scan_event(bool start, const char *initator, scan_tech_t type,
-                        uint32_t results, uint64_t timestamp_ms);
-
-// Record A2DP session information.
-// |session_duration_sec| is the session duration (in seconds).
-// |device_class| is the device class of the paired device.
-// |media_timer_min_ms| is the minimum scheduled time (in milliseconds)
-// of the media timer.
-// |media_timer_max_ms| is the maximum scheduled time (in milliseconds)
-// of the media timer.
-// |media_timer_avg_ms| is the average scheduled time (in milliseconds)
-// of the media timer.
-// |buffer_overruns_max_count| - TODO - not clear what this is.
-// |buffer_overruns_total| is the number of times the media buffer with
-// audio data has overrun.
-// |buffer_underruns_average| - TODO - not clear what this is.
-// |buffer_underruns_count| is the number of times there was no enough
-// audio data to add to the media buffer.
-void metrics_a2dp_session(int64_t session_duration_sec,
-                          const char *disconnect_reason,
-                          uint32_t device_class,
-                          int32_t media_timer_min_ms,
-                          int32_t media_timer_max_ms,
-                          int32_t media_timer_avg_ms,
-                          int32_t buffer_overruns_max_count,
-                          int32_t buffer_overruns_total,
-                          float buffer_underruns_average,
-                          int32_t buffer_underruns_count);
-
-// Writes the metrics, in packed protobuf format, into the descriptor |fd|.
-// If |clear| is true, metrics events are cleared afterwards.
-void metrics_write(int fd, bool clear);
-
-// Writes the metrics, in human-readable protobuf format, into the descriptor
-// |fd|. If |clear| is true, metrics events are cleared afterwards.
-void metrics_print(int fd, bool clear);
+typedef enum {
+  CONNECTION_TECHNOLOGY_TYPE_UNKNOWN,
+  CONNECTION_TECHNOLOGY_TYPE_LE,
+  CONNECTION_TECHNOLOGY_TYPE_BREDR,
+} connection_tech_t;
+
+typedef enum {
+  DISCONNECT_REASON_UNKNOWN,
+  DISCONNECT_REASON_METRICS_DUMP,
+  DISCONNECT_REASON_NEXT_START_WITHOUT_END_PREVIOUS,
+} disconnect_reason_t;
+
+typedef struct {
+  int64_t audio_duration_ms;
+  int32_t media_timer_min_ms;
+  int32_t media_timer_max_ms;
+  int32_t media_timer_avg_ms;
+  int64_t total_scheduling_count;
+  int32_t buffer_overruns_max_count;
+  int32_t buffer_overruns_total;
+  float buffer_underruns_average;
+  int32_t buffer_underruns_count;
+} A2dpSessionMetrics_t;
+
+void metrics_log_pair_event(uint32_t disconnect_reason, uint64_t timestamp_ms,
+                    uint32_t device_class, device_type_t device_type);
+
+void metrics_log_wake_event(wake_event_type_t type, const char* requestor,
+                    const char* name, uint64_t timestamp_ms);
+
+void metrics_log_scan_event(bool start, const char* initator, scan_tech_t type,
+                    uint32_t results, uint64_t timestamp_ms);
+
+void metrics_log_bluetooth_session_start(connection_tech_t connection_tech_type,
+                                uint64_t timestamp_ms);
+
+void metrics_log_bluetooth_session_end(disconnect_reason_t disconnect_reason,
+  uint64_t timestamp_ms);
+
+void metrics_log_bluetooth_session_device_info(uint32_t device_class,
+                                     device_type_t device_type);
+
+void metrics_log_a2dp_session(A2dpSessionMetrics_t* metrics);
+
+void metrics_write_base64(int fd, bool clear);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/osi/include/metrics_cpp.h b/osi/include/metrics_cpp.h
new file mode 100644
index 0000000..dcba21c
--- /dev/null
+++ b/osi/include/metrics_cpp.h
@@ -0,0 +1,230 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include <stdint.h>
+#include <memory>
+#include <string>
+
+namespace system_bt_osi {
+
+/* Values of A2DP metrics that we care about
+ *
+ *    audio_duration_ms : sum of audio duration (in milliseconds).
+ *    device_class: device class of the paired device.
+ *    media_timer_min_ms : minimum scheduled time (in milliseconds)
+ *                         of the media timer.
+ *    media_timer_max_ms: maximum scheduled time (in milliseconds)
+ *                        of the media timer.
+ *    media_timer_avg_ms: average scheduled time (in milliseconds)
+ *                        of the media timer.
+ *    buffer_overruns_max_count: TODO - not clear what this is.
+ *    buffer_overruns_total : number of times the media buffer with
+ *                            audio data has overrun
+ *    buffer_underruns_average: TODO - not clear what this is.
+ *    buffer_underruns_count: number of times there was no enough
+ *                            audio data to add to the media buffer.
+ * NOTE: Negative values are invalid
+*/
+class A2dpSessionMetrics {
+ public:
+  A2dpSessionMetrics() {}
+
+  /*
+   * Update the metrics value in the current metrics object using the metrics
+   * objects supplied
+   */
+  void Update(const A2dpSessionMetrics& metrics);
+
+  /*
+   * Compare whether two metrics objects are equal
+   */
+  bool operator==(const A2dpSessionMetrics& rhs) const;
+
+  /*
+   * Initialize all values to -1 which is invalid in order to make a distinction
+   * between 0 and invalid values
+   */
+  int64_t audio_duration_ms = -1;
+  int32_t media_timer_min_ms = -1;
+  int32_t media_timer_max_ms = -1;
+  int32_t media_timer_avg_ms = -1;
+  int64_t total_scheduling_count = -1;
+  int32_t buffer_overruns_max_count = -1;
+  int32_t buffer_overruns_total = -1;
+  float buffer_underruns_average = -1;
+  int32_t buffer_underruns_count = -1;
+};
+
+class BluetoothMetricsLogger {
+ public:
+  static BluetoothMetricsLogger* GetInstance() {
+    static BluetoothMetricsLogger* instance = new BluetoothMetricsLogger();
+    return instance;
+  }
+
+  /*
+   * Record a pairing event
+   *
+   * Parameters:
+   *    timestamp_ms: Unix epoch time in milliseconds
+   *    device_class: class of remote device
+   *    device_type: type of remote device
+   *    disconnect_reason: HCI reason for pairing disconnection.
+   *                       See: stack/include/hcidefs.h
+   */
+  void LogPairEvent(uint32_t disconnect_reason, uint64_t timestamp_ms,
+                    uint32_t device_class, device_type_t device_type);
+
+  /*
+   * Record a wake event
+   *
+   * Parameters:
+   *    timestamp_ms: Unix epoch time in milliseconds
+   *    type: whether it was acquired or released
+   *    requestor: if provided is the service requesting the wake lock
+   *    name: the name of the wake lock held
+   */
+  void LogWakeEvent(wake_event_type_t type, const std::string& requestor,
+                    const std::string& name, uint64_t timestamp_ms);
+
+  /*
+   * Record a scan event
+   *
+   * Parameters
+   *    timestamp_ms : Unix epoch time in milliseconds
+   *    start : true if this is the beginning of the scan
+   *    initiator: a unique ID identifying the app starting the scan
+   *    type: whether the scan reports BR/EDR, LE, or both.
+   *    results: number of results to be reported.
+   */
+  void LogScanEvent(bool start, const std::string& initator, scan_tech_t type,
+                    uint32_t results, uint64_t timestamp_ms);
+
+  /*
+   * Start logging a Bluetooth session
+   *
+   * A Bluetooth session is defined a a connection between this device and
+   * another remote device which may include multiple profiles and protocols
+   *
+   * Only one Bluetooth session can exist at one time. Calling this method twice
+   * without LogBluetoothSessionEnd will result in logging a premature end of
+   * current Bluetooth session
+   *
+   * Parameters:
+   *    connection_tech_type : type of connection technology
+   *    timestamp_ms : the timestamp for session start, 0 means now
+   *
+   */
+  void LogBluetoothSessionStart(connection_tech_t connection_tech_type,
+                                uint64_t timestamp_ms);
+
+  /*
+   * Stop logging a Bluetooth session and pushes it to the log queue
+   *
+   * If no Bluetooth session exist, this method exits immediately
+   *
+   * Parameters:
+   *    disconnect_reason : A string representation of disconnect reason
+   *    timestamp_ms : the timestamp of session end, 0 means now
+   *
+   */
+  void LogBluetoothSessionEnd(disconnect_reason_t disconnect_reason,
+                              uint64_t timestamp_ms);
+
+  /*
+   * Log information about remote device in a current Bluetooth session
+   *
+   * If a Bluetooth session does not exist, create one with default parameter
+   * and timestamp now
+   *
+   * Parameters:
+   *    device_class : device_class defined in btm_api_types.h
+   *    device_type : type of remote device
+   */
+  void LogBluetoothSessionDeviceInfo(uint32_t device_class,
+                                     device_type_t device_type);
+
+  /*
+   * Log A2DP Audio Session Information
+   *
+   * - Repeated calls to this method will override previous metrics if in the
+   *   same Bluetooth connection
+   * - If a Bluetooth session does not exist, create one with default parameter
+   *   and timestamp now
+   *
+   * Parameters:
+   *    a2dp_session_metrics - pointer to struct holding a2dp stats
+   *
+   */
+  void LogA2dpSession(const A2dpSessionMetrics& a2dp_session_metrics);
+
+  /*
+   * Writes the metrics, in base64 protobuf format, into the descriptor FD
+   * If CLEAR is true, metrics events are cleared afterwards.
+   */
+  void WriteBase64(int fd, bool clear);
+  void WriteBase64String(std::string* serialized, bool clear);
+  void WriteString(std::string* serialized, bool clear);
+
+  /*
+   * Reset the metrics logger by cleaning up its staging queues and existing
+   * protobuf objects.
+   */
+  void Reset();
+
+  /*
+   * Maximum number of log entries for each session or event
+   */
+  static const size_t kMaxNumBluetoothSession = 50;
+  static const size_t kMaxNumPairEvent = 50;
+  static const size_t kMaxNumWakeEvent = 1000;
+  static const size_t kMaxNumScanEvent = 50;
+
+ private:
+  BluetoothMetricsLogger();
+
+  /*
+   * When a Bluetooth session is on and the user initiates a metrics dump, we
+   * need to be able to upload whatever we have first. This method breaks the
+   * ongoing Bluetooth session into two sessions with the previous one labeled
+   * as "METRICS_DUMP" for the disconnect reason.
+   */
+  void CutoffSession();
+
+  /*
+   * Build the internal metrics object using information gathered
+   */
+  void Build();
+
+  /*
+   * Reset objects related to current Bluetooth session
+   */
+  void ResetSession();
+
+  /*
+   * Reset the underlining BluetoothLog object
+   */
+  void ResetLog();
+
+  /*
+   * PIMPL style implementation to hide internal dependencies
+   */
+  struct impl;
+  std::unique_ptr<impl> const pimpl_;
+};
+
+} // namespace system_bt_osi
diff --git a/osi/src/alarm.c b/osi/src/alarm.c
index bb6e106..be43b84 100644
--- a/osi/src/alarm.c
+++ b/osi/src/alarm.c
@@ -636,19 +636,21 @@ static void timer_callback(UNUSED_ATTR void *ptr) {
 // thread for that alarm.
 static void callback_dispatch(UNUSED_ATTR void *context) {
   while (true) {
+    period_ms_t just_now;
     semaphore_wait(alarm_expired);
     if (!dispatcher_thread_active)
       break;
 
     pthread_mutex_lock(&monitor);
     alarm_t *alarm;
+    just_now = now();
 
     // Take into account that the alarm may get cancelled before we get to it.
     // We're done here if there are no alarms or the alarm at the front is in
     // the future. Release the monitor lock and exit right away since there's
     // nothing left to do.
     if (list_is_empty(alarms) ||
-        (alarm = list_front(alarms))->deadline > now()) {
+        (alarm = list_front(alarms))->deadline > just_now) {
       reschedule_root_alarm();
       pthread_mutex_unlock(&monitor);
       continue;
@@ -656,6 +658,9 @@ static void callback_dispatch(UNUSED_ATTR void *context) {
 
     list_remove(alarms, alarm);
 
+    if(just_now - alarm->deadline > 1000)
+      LOG_DEBUG(LOG_TAG, "%s Delay in timer callback", __func__);
+
     if (alarm->is_periodic) {
       alarm->prev_deadline = alarm->deadline;
       schedule_next_instance(alarm);
diff --git a/osi/src/config.c b/osi/src/config.c
index 8a3e230..93adc9e 100644
--- a/osi/src/config.c
+++ b/osi/src/config.c
@@ -34,6 +34,7 @@
 #include "osi/include/allocator.h"
 #include "osi/include/list.h"
 #include "osi/include/log.h"
+#include "osi/include/compat.h"
 
 typedef struct {
   char *key;
@@ -326,7 +327,12 @@ bool config_save(const config_t *config, const char *filename) {
 
   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {
     const section_t *section = (const section_t *)list_node(node);
-    if (fprintf(fp, "[%s]\n", section->name) < 0) {
+    if (section->name[0] == '#') {
+        if (fprintf(fp, "%s", section->name) < 0) {
+            LOG_ERROR(LOG_TAG, "%s unable to write to file '%s': %s", __func__, temp_filename, strerror(errno));
+            goto error;
+        }
+    } else if (fprintf(fp, "[%s]\n", section->name) < 0) {
       LOG_ERROR(LOG_TAG, "%s unable to write to file '%s': %s", __func__, temp_filename, strerror(errno));
       goto error;
     }
@@ -417,31 +423,55 @@ static bool config_parse(FILE *fp, config_t *config) {
   assert(config != NULL);
 
   int line_num = 0;
-  char line[1024];
-  char section[1024];
+  char line[1024] = { '\0' };
+  char section[1024] = { '\0' };
+  char comment[1024] = { '\0' };
+  bool skip_entries = false;
   strcpy(section, CONFIG_DEFAULT_SECTION);
 
   while (fgets(line, sizeof(line), fp)) {
     char *line_ptr = trim(line);
     ++line_num;
 
-    // Skip blank and comment lines.
-    if (*line_ptr == '\0' || *line_ptr == '#')
+    // ignore the line if the line length is more than 1023
+    if (strlen(line) == 1023){
+        int ch = '\0';
+        // read until next line or EOF
+        while(((ch = fgetc(fp)) != EOF) && (ch != '\n'));
+        continue;
+    }
+
+    // Skip blanks.
+    if (*line_ptr == '\0')
       continue;
 
-    if (*line_ptr == '[') {
+    if (*line_ptr == '#') {
+        strlcpy(comment, line_ptr, 1024);
+
+        if(!section_find(config, comment)) {
+            section_t *sec = section_new(comment);
+            if (sec)
+                list_append(config->sections, sec);
+        }
+    } else if (*line_ptr == '[') {
       size_t len = strlen(line_ptr);
       if (line_ptr[len - 1] != ']') {
         LOG_DEBUG(LOG_TAG, "%s unterminated section name on line %d.", __func__, line_num);
-        return false;
+        skip_entries = true;
+        continue;
       }
       strncpy(section, line_ptr + 1, len - 2);
       section[len - 2] = '\0';
+      skip_entries = false;
     } else {
       char *split = strchr(line_ptr, '=');
+      if(skip_entries) {
+        LOG_DEBUG(LOG_TAG, "%s skip entries due invalid section line %d.", __func__, line_num);
+        continue;
+      }
       if (!split) {
         LOG_DEBUG(LOG_TAG, "%s no key/value separator found on line %d.", __func__, line_num);
-        return false;
+        continue;
       }
 
       *split = '\0';
diff --git a/osi/src/eager_reader.c b/osi/src/eager_reader.c
index 07a944c..86fcecc 100644
--- a/osi/src/eager_reader.c
+++ b/osi/src/eager_reader.c
@@ -259,9 +259,9 @@ static void inbound_data_waiting(void *context) {
     // the semaphore by the number of bytes we just read
     eventfd_write(reader->bytes_available_fd, bytes_read);
   } else {
-    if (bytes_read == 0)
+    if (bytes_read == 0){
       LOG_WARN(LOG_TAG, "%s fd said bytes existed, but none were found.", __func__);
-    else
+    } else
       LOG_WARN(LOG_TAG, "%s unable to read from file descriptor: %s", __func__, strerror(errno));
 
     reader->allocator->free(buffer);
diff --git a/osi/src/metrics.cpp b/osi/src/metrics.cpp
index 064f99e..9a91983 100644
--- a/osi/src/metrics.cpp
+++ b/osi/src/metrics.cpp
@@ -15,28 +15,37 @@
  *  limitations under the License.
  *
  ******************************************************************************/
-
-
 #define LOG_TAG "bt_osi_metrics"
 
-extern "C" {
-#include "osi/include/metrics.h"
+#include <unistd.h>
+#include <algorithm>
+#include <cerrno>
+#include <chrono>
+#include <cstdint>
+#include <cstring>
+#include <memory>
+#include <mutex>
 
-#include <errno.h>
+#include <base/base64.h>
+#include <base/logging.h>
 
+#include "osi/include/leaky_bonded_queue.h"
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
-}
+#include "stack/include/btm_api.h"
 
 #include "osi/src/protos/bluetooth.pb.h"
 
-#include <base/base64.h>
-#include <google/protobuf/text_format.h>
-#include <mutex>
+#include "osi/include/metrics.h"
+#include "osi/include/metrics_cpp.h"
+
+namespace system_bt_osi {
 
 using clearcut::connectivity::A2DPSession;
 using clearcut::connectivity::BluetoothLog;
 using clearcut::connectivity::BluetoothSession;
+using clearcut::connectivity::BluetoothSession_ConnectionTechnologyType;
+using clearcut::connectivity::BluetoothSession_DisconnectReasonType;
 using clearcut::connectivity::DeviceInfo;
 using clearcut::connectivity::DeviceInfo_DeviceType;
 using clearcut::connectivity::PairEvent;
@@ -46,156 +55,378 @@ using clearcut::connectivity::ScanEvent_ScanEventType;
 using clearcut::connectivity::WakeEvent;
 using clearcut::connectivity::WakeEvent_WakeEventType;
 
-BluetoothLog *pending;
-std::mutex log_lock;
+uint64_t metrics_time_get_os_boottime_us(void) {
+  struct timespec ts_now;
+  clock_gettime(CLOCK_BOOTTIME, &ts_now);
 
-static void lazy_initialize(void) {
-  if (pending == nullptr) {
-    pending = BluetoothLog::default_instance().New();
-  }
+  return ((uint64_t)ts_now.tv_sec * 1000000L) +
+         ((uint64_t)ts_now.tv_nsec / 1000);
 }
 
-void metrics_pair_event(uint32_t disconnect_reason, uint64_t timestamp_ms,
-                        uint32_t device_class, device_type_t device_type) {
-  std::lock_guard<std::mutex> lock(log_lock);
-  lazy_initialize();
-
-  PairEvent *event = pending->add_pair_event();
-
-  DeviceInfo *info = event->mutable_device_paired_with();
-
-  info->set_device_class(device_class);
-
-  DeviceInfo_DeviceType type = DeviceInfo::DEVICE_TYPE_UNKNOWN;
-
-  if (device_type == DEVICE_TYPE_BREDR)
-    type = DeviceInfo::DEVICE_TYPE_BREDR;
-  if (device_type == DEVICE_TYPE_LE)
-    type = DeviceInfo::DEVICE_TYPE_LE;
-  if (device_type == DEVICE_TYPE_DUMO)
-    type = DeviceInfo::DEVICE_TYPE_DUMO;
+/*
+ * Get current OS boot time in millisecond
+ */
+static int64_t time_get_os_boottime_ms(void) {
+  return metrics_time_get_os_boottime_us() / 1000;
+}
 
-  info->set_device_type(type);
+static float combine_averages(float avg_a, int64_t ct_a, float avg_b,
+                              int64_t ct_b) {
+  if (ct_a > 0 && ct_b > 0) {
+    return (avg_a * ct_a + avg_b * ct_b) / (ct_a + ct_b);
+  } else if (ct_b > 0) {
+    return avg_b;
+  } else {
+    return avg_a;
+  }
+}
 
-  event->set_disconnect_reason(disconnect_reason);
+static int32_t combine_averages(int32_t avg_a, int64_t ct_a, int32_t avg_b,
+                                int64_t ct_b) {
+  if (ct_a > 0 && ct_b > 0) {
+    return (avg_a * ct_a + avg_b * ct_b) / (ct_a + ct_b);
+  } else if (ct_b > 0) {
+    return avg_b;
+  } else {
+    return avg_a;
+  }
+}
 
-  event->set_event_time_millis(timestamp_ms);
+void A2dpSessionMetrics::Update(const A2dpSessionMetrics& metrics) {
+  if (metrics.audio_duration_ms >= 0) {
+    audio_duration_ms = std::max(static_cast<int64_t>(0), audio_duration_ms);
+    audio_duration_ms += metrics.audio_duration_ms;
+  }
+  if (metrics.media_timer_min_ms >= 0) {
+    if (media_timer_min_ms < 0) {
+      media_timer_min_ms = metrics.media_timer_min_ms;
+    } else {
+      media_timer_min_ms =
+          std::min(media_timer_min_ms, metrics.media_timer_min_ms);
+    }
+  }
+  if (metrics.media_timer_max_ms >= 0) {
+    media_timer_max_ms =
+        std::max(media_timer_max_ms, metrics.media_timer_max_ms);
+  }
+  if (metrics.media_timer_avg_ms >= 0 && metrics.total_scheduling_count >= 0) {
+    if (media_timer_avg_ms < 0 || total_scheduling_count < 0) {
+      media_timer_avg_ms = metrics.media_timer_avg_ms;
+      total_scheduling_count = metrics.total_scheduling_count;
+    } else {
+      media_timer_avg_ms = combine_averages(
+          media_timer_avg_ms, total_scheduling_count,
+          metrics.media_timer_avg_ms, metrics.total_scheduling_count);
+      total_scheduling_count += metrics.total_scheduling_count;
+    }
+  }
+  if (metrics.buffer_overruns_max_count >= 0) {
+    buffer_overruns_max_count =
+        std::max(buffer_overruns_max_count, metrics.buffer_overruns_max_count);
+  }
+  if (metrics.buffer_overruns_total >= 0) {
+    buffer_overruns_total =
+        std::max(static_cast<int32_t>(0), buffer_overruns_total);
+    buffer_overruns_total += metrics.buffer_overruns_total;
+  }
+  if (metrics.buffer_underruns_average >= 0 &&
+      metrics.buffer_underruns_count >= 0) {
+    if (buffer_underruns_average < 0 || buffer_underruns_count < 0) {
+      buffer_underruns_average = metrics.buffer_underruns_average;
+      buffer_underruns_count = metrics.buffer_underruns_count;
+    } else {
+      buffer_underruns_average = combine_averages(
+          buffer_underruns_average, buffer_underruns_count,
+          metrics.buffer_underruns_average, metrics.buffer_underruns_count);
+      buffer_underruns_count += metrics.buffer_underruns_count;
+    }
+  }
 }
 
-void metrics_wake_event(wake_event_type_t type, const char *requestor,
-                        const char *name, uint64_t timestamp_ms) {
-  std::lock_guard<std::mutex> lock(log_lock);
-  lazy_initialize();
+bool A2dpSessionMetrics::operator==(const A2dpSessionMetrics& rhs) const {
+  return audio_duration_ms == rhs.audio_duration_ms &&
+         media_timer_min_ms == rhs.media_timer_min_ms &&
+         media_timer_max_ms == rhs.media_timer_max_ms &&
+         media_timer_avg_ms == rhs.media_timer_avg_ms &&
+         total_scheduling_count == rhs.total_scheduling_count &&
+         buffer_overruns_max_count == rhs.buffer_overruns_max_count &&
+         buffer_overruns_total == rhs.buffer_overruns_total &&
+         buffer_underruns_average == rhs.buffer_underruns_average &&
+         buffer_underruns_count == rhs.buffer_underruns_count;
+}
 
-  WakeEvent *event = pending->add_wake_event();
+static DeviceInfo_DeviceType get_device_type(device_type_t type) {
+  switch (type) {
+    case DEVICE_TYPE_BREDR:
+      return DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR;
+    case DEVICE_TYPE_LE:
+      return DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_LE;
+    case DEVICE_TYPE_DUMO:
+      return DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_DUMO;
+    case DEVICE_TYPE_UNKNOWN:
+    default:
+      return DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_UNKNOWN;
+  }
+}
 
-  WakeEvent_WakeEventType waketype = WakeEvent::UNKNOWN;
+static BluetoothSession_ConnectionTechnologyType get_connection_tech_type(
+    connection_tech_t type) {
+  switch (type) {
+    case CONNECTION_TECHNOLOGY_TYPE_LE:
+      return BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE;
+    case CONNECTION_TECHNOLOGY_TYPE_BREDR:
+      return BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR;
+    case CONNECTION_TECHNOLOGY_TYPE_UNKNOWN:
+    default:
+      return BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN;
+  }
+}
 
-  if (type == WAKE_EVENT_ACQUIRED)
-    waketype = WakeEvent::ACQUIRED;
-  if (type == WAKE_EVENT_RELEASED)
-    waketype = WakeEvent::RELEASED;
+static ScanEvent_ScanTechnologyType get_scan_tech_type(scan_tech_t type) {
+  switch (type) {
+    case SCAN_TECH_TYPE_LE:
+      return ScanEvent_ScanTechnologyType::
+          ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_LE;
+    case SCAN_TECH_TYPE_BREDR:
+      return ScanEvent_ScanTechnologyType::
+          ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BREDR;
+    case SCAN_TECH_TYPE_BOTH:
+      return ScanEvent_ScanTechnologyType::
+          ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BOTH;
+    case SCAN_TYPE_UNKNOWN:
+    default:
+      return ScanEvent_ScanTechnologyType::
+          ScanEvent_ScanTechnologyType_SCAN_TYPE_UNKNOWN;
+  }
+}
 
-  event->set_wake_event_type(waketype);
+static WakeEvent_WakeEventType get_wake_event_type(wake_event_type_t type) {
+  switch (type) {
+    case WAKE_EVENT_ACQUIRED:
+      return WakeEvent_WakeEventType::WakeEvent_WakeEventType_ACQUIRED;
+    case WAKE_EVENT_RELEASED:
+      return WakeEvent_WakeEventType::WakeEvent_WakeEventType_RELEASED;
+    case WAKE_EVENT_UNKNOWN:
+    default:
+      return WakeEvent_WakeEventType::WakeEvent_WakeEventType_UNKNOWN;
+  }
+}
 
-  if (requestor)
-    event->set_requestor(requestor);
+static BluetoothSession_DisconnectReasonType get_disconnect_reason_type(
+  disconnect_reason_t type) {
+  switch (type) {
+    case DISCONNECT_REASON_METRICS_DUMP:
+      return BluetoothSession_DisconnectReasonType::
+        BluetoothSession_DisconnectReasonType_METRICS_DUMP;
+    case DISCONNECT_REASON_NEXT_START_WITHOUT_END_PREVIOUS:
+      return BluetoothSession_DisconnectReasonType::
+        BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS;
+    case DISCONNECT_REASON_UNKNOWN:
+    default:
+      return BluetoothSession_DisconnectReasonType::
+        BluetoothSession_DisconnectReasonType_UNKNOWN;
+  }
+}
 
-  if (name)
-    event->set_name(name);
+struct BluetoothMetricsLogger::impl {
+  impl(size_t max_bluetooth_session, size_t max_pair_event,
+       size_t max_wake_event, size_t max_scan_event)
+      : bt_session_queue_(
+            new LeakyBondedQueue<BluetoothSession>(max_bluetooth_session)),
+        pair_event_queue_(new LeakyBondedQueue<PairEvent>(max_pair_event)),
+        wake_event_queue_(new LeakyBondedQueue<WakeEvent>(max_wake_event)),
+        scan_event_queue_(new LeakyBondedQueue<ScanEvent>(max_scan_event)) {
+    bluetooth_log_ = BluetoothLog::default_instance().New();
+    bluetooth_session_ = nullptr;
+    bluetooth_session_start_time_ms_ = 0;
+    a2dp_session_metrics_ = A2dpSessionMetrics();
+  }
 
+  /* Bluetooth log lock protected */
+  BluetoothLog* bluetooth_log_;
+  std::recursive_mutex bluetooth_log_lock_;
+  /* End Bluetooth log lock protected */
+  /* Bluetooth session lock protected */
+  BluetoothSession* bluetooth_session_;
+  uint64_t bluetooth_session_start_time_ms_;
+  A2dpSessionMetrics a2dp_session_metrics_;
+  std::recursive_mutex bluetooth_session_lock_;
+  /* End bluetooth session lock protected */
+  std::unique_ptr<LeakyBondedQueue<BluetoothSession>> bt_session_queue_;
+  std::unique_ptr<LeakyBondedQueue<PairEvent>> pair_event_queue_;
+  std::unique_ptr<LeakyBondedQueue<WakeEvent>> wake_event_queue_;
+  std::unique_ptr<LeakyBondedQueue<ScanEvent>> scan_event_queue_;
+};
+
+BluetoothMetricsLogger::BluetoothMetricsLogger()
+    : pimpl_(new impl(kMaxNumBluetoothSession, kMaxNumPairEvent,
+                      kMaxNumWakeEvent, kMaxNumScanEvent)) {}
+
+void BluetoothMetricsLogger::LogPairEvent(uint32_t disconnect_reason,
+                                          uint64_t timestamp_ms,
+                                          uint32_t device_class,
+                                          device_type_t device_type) {
+  PairEvent* event = new PairEvent();
+  DeviceInfo* info = event->mutable_device_paired_with();
+  info->set_device_class(device_class);
+  info->set_device_type(get_device_type(device_type));
+  event->set_disconnect_reason(disconnect_reason);
   event->set_event_time_millis(timestamp_ms);
+  pimpl_->pair_event_queue_->Enqueue(event);
+  {
+    std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_log_lock_);
+    pimpl_->bluetooth_log_->set_num_pair_event(
+        pimpl_->bluetooth_log_->num_pair_event() + 1);
+  }
 }
 
-void metrics_scan_event(bool start, const char *initator, scan_tech_t type,
-                        uint32_t results, uint64_t timestamp_ms) {
-  std::lock_guard<std::mutex> lock(log_lock);
-  lazy_initialize();
-
-  ScanEvent *event = pending->add_scan_event();
+void BluetoothMetricsLogger::LogWakeEvent(wake_event_type_t type,
+                                          const std::string& requestor,
+                                          const std::string& name,
+                                          uint64_t timestamp_ms) {
+  WakeEvent* event = new WakeEvent();
+  event->set_wake_event_type(get_wake_event_type(type));
+  event->set_requestor(requestor);
+  event->set_name(name);
+  event->set_event_time_millis(timestamp_ms);
+  pimpl_->wake_event_queue_->Enqueue(event);
+  {
+    std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_log_lock_);
+    pimpl_->bluetooth_log_->set_num_wake_event(
+        pimpl_->bluetooth_log_->num_wake_event() + 1);
+  }
+}
 
-  if (start)
+void BluetoothMetricsLogger::LogScanEvent(bool start,
+                                          const std::string& initator,
+                                          scan_tech_t type, uint32_t results,
+                                          uint64_t timestamp_ms) {
+  ScanEvent* event = new ScanEvent();
+  if (start) {
     event->set_scan_event_type(ScanEvent::SCAN_EVENT_START);
-  else
+  } else {
     event->set_scan_event_type(ScanEvent::SCAN_EVENT_STOP);
-
-  if (initator)
-    event->set_initiator(initator);
-
-  ScanEvent::ScanTechnologyType scantype = ScanEvent::SCAN_TYPE_UNKNOWN;
-
-  if (type == SCAN_TECH_TYPE_LE)
-    scantype = ScanEvent::SCAN_TECH_TYPE_LE;
-  if (type == SCAN_TECH_TYPE_BREDR)
-    scantype = ScanEvent::SCAN_TECH_TYPE_BREDR;
-  if (type == SCAN_TECH_TYPE_BOTH)
-    scantype = ScanEvent::SCAN_TECH_TYPE_BOTH;
-
-  event->set_scan_technology_type(scantype);
-
+  }
+  event->set_initiator(initator);
+  event->set_scan_technology_type(get_scan_tech_type(type));
   event->set_number_results(results);
-
   event->set_event_time_millis(timestamp_ms);
+  pimpl_->scan_event_queue_->Enqueue(event);
+  {
+    std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_log_lock_);
+    pimpl_->bluetooth_log_->set_num_scan_event(
+        pimpl_->bluetooth_log_->num_scan_event() + 1);
+  }
+}
+
+void BluetoothMetricsLogger::LogBluetoothSessionStart(
+    connection_tech_t connection_tech_type, uint64_t timestamp_ms) {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_session_lock_);
+  if (pimpl_->bluetooth_session_ != nullptr) {
+    LogBluetoothSessionEnd(DISCONNECT_REASON_NEXT_START_WITHOUT_END_PREVIOUS,
+      0);
+  }
+  if (timestamp_ms == 0) {
+    timestamp_ms = time_get_os_boottime_ms();
+  }
+  pimpl_->bluetooth_session_start_time_ms_ = timestamp_ms;
+  pimpl_->bluetooth_session_ = new BluetoothSession();
+  pimpl_->bluetooth_session_->set_connection_technology_type(
+      get_connection_tech_type(connection_tech_type));
+}
+
+void BluetoothMetricsLogger::LogBluetoothSessionEnd(
+    disconnect_reason_t disconnect_reason, uint64_t timestamp_ms) {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_session_lock_);
+  if (pimpl_->bluetooth_session_ == nullptr) {
+    return;
+  }
+  if (timestamp_ms == 0) {
+    timestamp_ms = time_get_os_boottime_ms();
+  }
+  int64_t session_duration_sec =
+      (timestamp_ms - pimpl_->bluetooth_session_start_time_ms_) / 1000;
+  pimpl_->bluetooth_session_->set_session_duration_sec(session_duration_sec);
+  pimpl_->bluetooth_session_->set_disconnect_reason_type(
+    get_disconnect_reason_type(disconnect_reason));
+  pimpl_->bt_session_queue_->Enqueue(pimpl_->bluetooth_session_);
+  pimpl_->bluetooth_session_ = nullptr;
+  {
+    std::lock_guard<std::recursive_mutex> log_lock(pimpl_->bluetooth_log_lock_);
+    pimpl_->bluetooth_log_->set_num_bluetooth_session(
+        pimpl_->bluetooth_log_->num_bluetooth_session() + 1);
+  }
 }
 
-void metrics_a2dp_session(int64_t session_duration_sec,
-                          const char *disconnect_reason,
-                          uint32_t device_class,
-                          int32_t media_timer_min_ms,
-                          int32_t media_timer_max_ms,
-                          int32_t media_timer_avg_ms,
-                          int32_t buffer_overruns_max_count,
-                          int32_t buffer_overruns_total,
-                          float buffer_underruns_average,
-                          int32_t buffer_underruns_count) {
-  std::lock_guard<std::mutex> lock(log_lock);
-  lazy_initialize();
-
-  BluetoothSession *bt_session = pending->add_session();
-
-  // Set connection type: for A2DP it is always BR/EDR
-  BluetoothSession::ConnectionTechnologyType conn_type =
-    BluetoothSession::CONNECTION_TECHNOLOGY_TYPE_BREDR;
-  bt_session->set_connection_technology_type(conn_type);
-
-  bt_session->set_session_duration_sec(session_duration_sec);
-  if (disconnect_reason != NULL)
-    bt_session->set_disconnect_reason(disconnect_reason);
-
-  // Set device: class and type are pre-defined
-  DeviceInfo *info = bt_session->mutable_device_connected_to();
+void BluetoothMetricsLogger::LogBluetoothSessionDeviceInfo(
+    uint32_t device_class, device_type_t device_type) {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_session_lock_);
+  if (pimpl_->bluetooth_session_ == nullptr) {
+    LogBluetoothSessionStart(CONNECTION_TECHNOLOGY_TYPE_UNKNOWN, 0);
+  }
+  DeviceInfo* info = pimpl_->bluetooth_session_->mutable_device_connected_to();
   info->set_device_class(device_class);
   info->set_device_type(DeviceInfo::DEVICE_TYPE_BREDR);
+}
 
-  A2DPSession *a2dp_session = bt_session->mutable_a2dp_session();
-  a2dp_session->set_media_timer_min_millis(media_timer_min_ms);
-  a2dp_session->set_media_timer_max_millis(media_timer_max_ms);
-  a2dp_session->set_media_timer_avg_millis(media_timer_avg_ms);
-  a2dp_session->set_buffer_overruns_max_count(buffer_overruns_max_count);
-  a2dp_session->set_buffer_overruns_total(buffer_overruns_total);
-  a2dp_session->set_buffer_underruns_average(buffer_underruns_average);
-  a2dp_session->set_buffer_underruns_count(buffer_underruns_count);
+void BluetoothMetricsLogger::LogA2dpSession(
+    const A2dpSessionMetrics& a2dp_session_metrics) {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_session_lock_);
+  if (pimpl_->bluetooth_session_ == nullptr) {
+    // When no bluetooth session exist, create one on system's behalf
+    // Set connection type: for A2DP it is always BR/EDR
+    LogBluetoothSessionStart(CONNECTION_TECHNOLOGY_TYPE_BREDR, 0);
+    LogBluetoothSessionDeviceInfo(BTM_COD_MAJOR_AUDIO, DEVICE_TYPE_BREDR);
+  }
+  // Accumulate metrics
+  pimpl_->a2dp_session_metrics_.Update(a2dp_session_metrics);
+  // Get or allocate new A2DP session object
+  A2DPSession* a2dp_session =
+      pimpl_->bluetooth_session_->mutable_a2dp_session();
+  a2dp_session->set_audio_duration_millis(
+      pimpl_->a2dp_session_metrics_.audio_duration_ms);
+  a2dp_session->set_media_timer_min_millis(
+      pimpl_->a2dp_session_metrics_.media_timer_min_ms);
+  a2dp_session->set_media_timer_max_millis(
+      pimpl_->a2dp_session_metrics_.media_timer_max_ms);
+  a2dp_session->set_media_timer_avg_millis(
+      pimpl_->a2dp_session_metrics_.media_timer_avg_ms);
+  a2dp_session->set_buffer_overruns_max_count(
+      pimpl_->a2dp_session_metrics_.buffer_overruns_max_count);
+  a2dp_session->set_buffer_overruns_total(
+      pimpl_->a2dp_session_metrics_.buffer_overruns_total);
+  a2dp_session->set_buffer_underruns_average(
+      pimpl_->a2dp_session_metrics_.buffer_underruns_average);
+  a2dp_session->set_buffer_underruns_count(
+      pimpl_->a2dp_session_metrics_.buffer_underruns_count);
 }
 
-void metrics_write(int fd, bool clear) {
-  log_lock.lock();
+void BluetoothMetricsLogger::WriteString(std::string* serialized, bool clear) {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_log_lock_);
+  LOG_DEBUG(LOG_TAG, "%s building metrics", __func__);
+  Build();
   LOG_DEBUG(LOG_TAG, "%s serializing metrics", __func__);
-  lazy_initialize();
-
-  std::string serialized;
-  if (!pending->SerializeToString(&serialized)) {
+  if (!pimpl_->bluetooth_log_->SerializeToString(serialized)) {
     LOG_ERROR(LOG_TAG, "%s: error serializing metrics", __func__);
     return;
   }
-
   if (clear) {
-    pending->Clear();
+    pimpl_->bluetooth_log_->Clear();
   }
-  log_lock.unlock();
+}
 
-  std::string protoBase64;
-  base::Base64Encode(serialized, &protoBase64);
+void BluetoothMetricsLogger::WriteBase64String(std::string* serialized,
+                                               bool clear) {
+  this->WriteString(serialized, clear);
+  base::Base64Encode(*serialized, serialized);
+}
 
+void BluetoothMetricsLogger::WriteBase64(int fd, bool clear) {
+  std::string protoBase64;
+  this->WriteBase64String(&protoBase64, clear);
   ssize_t ret;
   OSI_NO_INTR(ret = write(fd, protoBase64.c_str(), protoBase64.size()));
   if (ret == -1) {
@@ -204,23 +435,137 @@ void metrics_write(int fd, bool clear) {
   }
 }
 
-void metrics_print(int fd, bool clear) {
-  log_lock.lock();
-  LOG_DEBUG(LOG_TAG, "%s printing metrics", __func__);
-  lazy_initialize();
-
-  std::string pretty_output;
-  google::protobuf::TextFormat::PrintToString(*pending, &pretty_output);
+void BluetoothMetricsLogger::CutoffSession() {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_session_lock_);
+  if (pimpl_->bluetooth_session_ != nullptr) {
+    BluetoothSession* new_bt_session =
+        new BluetoothSession(*pimpl_->bluetooth_session_);
+    new_bt_session->clear_a2dp_session();
+    new_bt_session->clear_rfcomm_session();
+    LogBluetoothSessionEnd(DISCONNECT_REASON_METRICS_DUMP, 0);
+    pimpl_->bluetooth_session_ = new_bt_session;
+    pimpl_->bluetooth_session_start_time_ms_ = time_get_os_boottime_ms();
+    pimpl_->a2dp_session_metrics_ = A2dpSessionMetrics();
+  }
+}
 
-  if (clear) {
-    pending->Clear();
+void BluetoothMetricsLogger::Build() {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_log_lock_);
+  CutoffSession();
+  BluetoothLog* bluetooth_log = pimpl_->bluetooth_log_;
+  while (!pimpl_->bt_session_queue_->Empty() &&
+         static_cast<size_t>(bluetooth_log->session_size()) <=
+             pimpl_->bt_session_queue_->Capacity()) {
+    bluetooth_log->mutable_session()->AddAllocated(
+        pimpl_->bt_session_queue_->Dequeue());
+  }
+  while (!pimpl_->pair_event_queue_->Empty() &&
+         static_cast<size_t>(bluetooth_log->pair_event_size()) <=
+             pimpl_->pair_event_queue_->Capacity()) {
+    bluetooth_log->mutable_pair_event()->AddAllocated(
+        pimpl_->pair_event_queue_->Dequeue());
+  }
+  while (!pimpl_->scan_event_queue_->Empty() &&
+         static_cast<size_t>(bluetooth_log->scan_event_size()) <=
+             pimpl_->scan_event_queue_->Capacity()) {
+    bluetooth_log->mutable_scan_event()->AddAllocated(
+        pimpl_->scan_event_queue_->Dequeue());
+  }
+  while (!pimpl_->wake_event_queue_->Empty() &&
+         static_cast<size_t>(bluetooth_log->wake_event_size()) <=
+             pimpl_->wake_event_queue_->Capacity()) {
+    bluetooth_log->mutable_wake_event()->AddAllocated(
+        pimpl_->wake_event_queue_->Dequeue());
   }
-  log_lock.unlock();
+  while (!pimpl_->bt_session_queue_->Empty() &&
+         static_cast<size_t>(bluetooth_log->wake_event_size()) <=
+             pimpl_->wake_event_queue_->Capacity()) {
+    bluetooth_log->mutable_wake_event()->AddAllocated(
+        pimpl_->wake_event_queue_->Dequeue());
+  }
+}
 
-  ssize_t ret;
-  OSI_NO_INTR(ret = write(fd, pretty_output.c_str(), pretty_output.size()));
-  if (ret == -1) {
-    LOG_ERROR(LOG_TAG, "%s: error writing to dumpsys fd: %s (%d)", __func__,
-              strerror(errno), errno);
+void BluetoothMetricsLogger::ResetSession() {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_session_lock_);
+  if (pimpl_->bluetooth_session_ != nullptr) {
+    delete pimpl_->bluetooth_session_;
+    pimpl_->bluetooth_session_ = nullptr;
   }
+  pimpl_->bluetooth_session_start_time_ms_ = 0;
+  pimpl_->a2dp_session_metrics_ = A2dpSessionMetrics();
+}
+
+void BluetoothMetricsLogger::ResetLog() {
+  std::lock_guard<std::recursive_mutex> lock(pimpl_->bluetooth_log_lock_);
+  pimpl_->bluetooth_log_->Clear();
+}
+
+void BluetoothMetricsLogger::Reset() {
+  ResetSession();
+  ResetLog();
+  pimpl_->bt_session_queue_->Clear();
+  pimpl_->pair_event_queue_->Clear();
+  pimpl_->wake_event_queue_->Clear();
+  pimpl_->scan_event_queue_->Clear();
+}
+
+}  // namespace system_bt_osi
+
+using system_bt_osi::BluetoothMetricsLogger;
+
+void metrics_log_pair_event(uint32_t disconnect_reason, uint64_t timestamp_ms,
+                    uint32_t device_class, device_type_t device_type) {
+  BluetoothMetricsLogger::GetInstance()->LogPairEvent(disconnect_reason,
+    timestamp_ms, device_class, device_type);
+}
+
+void metrics_log_wake_event(wake_event_type_t type, const char* requestor,
+                    const char* name, uint64_t timestamp_ms) {
+  std::string requestor_str(requestor);
+  std::string name_str(name);
+  BluetoothMetricsLogger::GetInstance()->LogWakeEvent(type, requestor_str,
+    name_str, timestamp_ms);
+}
+
+void metrics_log_scan_event(bool start, const char* initator, scan_tech_t type,
+                    uint32_t results, uint64_t timestamp_ms) {
+  std::string initator_str(initator);
+  BluetoothMetricsLogger::GetInstance()->LogScanEvent(start, initator_str, type,
+    results, timestamp_ms);
+}
+
+void metrics_log_bluetooth_session_start(connection_tech_t connection_tech_type,
+                                uint64_t timestamp_ms) {
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      connection_tech_type, 0);
+}
+
+void metrics_log_bluetooth_session_end(disconnect_reason_t disconnect_reason,
+  uint64_t timestamp_ms) {
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionEnd(
+    disconnect_reason, timestamp_ms);
+}
+
+void metrics_log_bluetooth_session_device_info(uint32_t device_class,
+                                     device_type_t device_type) {
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionDeviceInfo(
+    device_class, device_type);
+}
+
+void metrics_log_a2dp_session(A2dpSessionMetrics_t* metrics) {
+  system_bt_osi::A2dpSessionMetrics metrics_obj;
+  metrics_obj.audio_duration_ms = metrics->audio_duration_ms;
+  metrics_obj.media_timer_min_ms = metrics->media_timer_min_ms;
+  metrics_obj.media_timer_max_ms = metrics->media_timer_max_ms;
+  metrics_obj.media_timer_avg_ms = metrics->media_timer_avg_ms;
+  metrics_obj.total_scheduling_count = metrics->total_scheduling_count;
+  metrics_obj.buffer_overruns_max_count = metrics->buffer_overruns_max_count;
+  metrics_obj.buffer_overruns_total = metrics->buffer_overruns_total;
+  metrics_obj.buffer_underruns_average = metrics->buffer_underruns_average;
+  metrics_obj.buffer_underruns_count = metrics->buffer_underruns_count;
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics_obj);
+}
+
+void metrics_write_base64(int fd, bool clear) {
+  BluetoothMetricsLogger::GetInstance()->WriteBase64(fd, clear);
 }
diff --git a/osi/src/metrics_linux.cpp b/osi/src/metrics_linux.cpp
index f013236..f634516 100644
--- a/osi/src/metrics_linux.cpp
+++ b/osi/src/metrics_linux.cpp
@@ -15,46 +15,230 @@
  *  limitations under the License.
  *
  ******************************************************************************/
+#define LOG_TAG "bt_osi_metrics"
 
+#include <unistd.h>
+#include <algorithm>
+#include <cerrno>
+#include <chrono>
+#include <cstdint>
+#include <cstring>
+#include <memory>
+#include <mutex>
 
-#define LOG_TAG "bt_osi_metrics"
+#include <base/base64.h>
+#include <base/logging.h>
+
+#include "osi/include/leaky_bonded_queue.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+#include "osi/include/time.h"
 
-extern "C" {
 #include "osi/include/metrics.h"
+#include "osi/include/metrics_cpp.h"
+
+
+namespace system_bt_osi {
+
+// Maximum number of log entries for each repeated field
+#define MAX_NUM_BLUETOOTH_SESSION 50
+#define MAX_NUM_PAIR_EVENT 50
+#define MAX_NUM_WAKE_EVENT 50
+#define MAX_NUM_SCAN_EVENT 50
+
+static float combine_averages(float avg_a, int64_t ct_a, float avg_b,
+                              int64_t ct_b) {
+  if (ct_a > 0 && ct_b > 0) {
+    return (avg_a * ct_a + avg_b * ct_b) / (ct_a + ct_b);
+  } else if (ct_b > 0) {
+    return avg_b;
+  } else {
+    return avg_a;
+  }
+}
+
+static int32_t combine_averages(int32_t avg_a, int64_t ct_a, int32_t avg_b,
+                                int64_t ct_b) {
+  if (ct_a > 0 && ct_b > 0) {
+    return (avg_a * ct_a + avg_b * ct_b) / (ct_a + ct_b);
+  } else if (ct_b > 0) {
+    return avg_b;
+  } else {
+    return avg_a;
+  }
+}
+
+void A2dpSessionMetrics::Update(const A2dpSessionMetrics& metrics) {
+  if (metrics.audio_duration_ms > 0) {
+    audio_duration_ms = std::max(static_cast<int64_t>(0), audio_duration_ms);
+    audio_duration_ms += metrics.audio_duration_ms;
+  }
+  if (metrics.media_timer_min_ms > 0) {
+    if (media_timer_min_ms < 0) {
+      media_timer_min_ms = metrics.media_timer_min_ms;
+    } else {
+      media_timer_min_ms =
+          std::min(media_timer_min_ms, metrics.media_timer_min_ms);
+    }
+  }
+  if (metrics.media_timer_max_ms > 0) {
+    media_timer_max_ms =
+        std::max(media_timer_max_ms, metrics.media_timer_max_ms);
+  }
+  if (metrics.media_timer_avg_ms > 0 && metrics.total_scheduling_count > 0) {
+    if (media_timer_avg_ms < 0 || total_scheduling_count < 0) {
+      media_timer_avg_ms = metrics.media_timer_avg_ms;
+      total_scheduling_count = metrics.total_scheduling_count;
+    } else {
+      media_timer_avg_ms = combine_averages(
+          media_timer_avg_ms, total_scheduling_count,
+          metrics.media_timer_avg_ms, metrics.total_scheduling_count);
+      total_scheduling_count += metrics.total_scheduling_count;
+    }
+  }
+  if (metrics.buffer_overruns_max_count > 0) {
+    buffer_overruns_max_count =
+        std::max(buffer_overruns_max_count, metrics.buffer_overruns_max_count);
+  }
+  if (metrics.buffer_overruns_total > 0) {
+    buffer_overruns_total =
+        std::max(static_cast<int32_t>(0), buffer_overruns_total);
+    buffer_overruns_total += metrics.buffer_overruns_total;
+  }
+  if (metrics.buffer_underruns_average > 0 &&
+      metrics.buffer_underruns_count > 0) {
+    if (buffer_underruns_average < 0 || buffer_underruns_count < 0) {
+      buffer_underruns_average = metrics.buffer_underruns_average;
+      buffer_underruns_count = metrics.buffer_underruns_count;
+    } else {
+      buffer_underruns_average = combine_averages(
+          metrics.buffer_underruns_average, metrics.buffer_underruns_count,
+          buffer_underruns_average, buffer_underruns_count);
+      buffer_underruns_count += metrics.buffer_underruns_count;
+    }
+  }
+}
+
+bool A2dpSessionMetrics::operator==(const A2dpSessionMetrics& rhs) const {
+  return audio_duration_ms == rhs.audio_duration_ms &&
+         media_timer_min_ms == rhs.media_timer_min_ms &&
+         media_timer_max_ms == rhs.media_timer_max_ms &&
+         media_timer_avg_ms == rhs.media_timer_avg_ms &&
+         total_scheduling_count == rhs.total_scheduling_count &&
+         buffer_overruns_max_count == rhs.buffer_overruns_max_count &&
+         buffer_overruns_total == rhs.buffer_overruns_total &&
+         buffer_underruns_average == rhs.buffer_underruns_average &&
+         buffer_underruns_count == rhs.buffer_underruns_count;
+}
+
+struct BluetoothMetricsLogger::impl {
+  // TODO(siyuanh): Implement for linux
+};
+
+BluetoothMetricsLogger::BluetoothMetricsLogger() : pimpl_(new impl) {}
+
+void BluetoothMetricsLogger::LogPairEvent(uint32_t disconnect_reason,
+                                          uint64_t timestamp_ms,
+                                          uint32_t device_class,
+                                          device_type_t device_type) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::LogWakeEvent(wake_event_type_t type,
+                                          const std::string& requestor,
+                                          const std::string& name,
+                                          uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::LogScanEvent(bool start,
+                                          const std::string& initator,
+                                          scan_tech_t type, uint32_t results,
+                                          uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::LogBluetoothSessionStart(
+    connection_tech_t connection_tech_type, uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::LogBluetoothSessionEnd(
+    const std::string& disconnect_reason, uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::LogBluetoothSessionDeviceInfo(
+    uint32_t device_class, device_type_t device_type) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::LogA2dpSession(
+    const A2dpSessionMetrics& a2dp_session_metrics) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::WriteString(std::string* serialized, bool clear) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::WriteBase64String(std::string* serialized,
+                                               bool clear) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::WriteBase64(int fd, bool clear) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::CutoffSession() {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::Build() {
+  // TODO(siyuanh): Implement for linux
+}
+
+void BluetoothMetricsLogger::Reset() {
+  // TODO(siyuanh): Implement for linux
+}
+
+}  // namespace system_bt_osi
+
+void metrics_log_pair_event(uint32_t disconnect_reason, uint64_t timestamp_ms,
+                    uint32_t device_class, device_type_t device_type) {
+  // TODO(siyuanh): Implement for linux
+}
+
+void metrics_log_wake_event(wake_event_type_t type, const char* requestor,
+                    const char* name, uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
 }
 
-void metrics_pair_event(uint32_t disconnect_reason, uint64_t timestamp_ms,
-                        uint32_t device_class, device_type_t device_type) {
-  //TODO(jpawlowski): implement
+void metrics_log_scan_event(bool start, const char* initator, scan_tech_t type,
+                    uint32_t results, uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
 }
 
-void metrics_wake_event(wake_event_type_t type, const char *requestor,
-                        const char *name, uint64_t timestamp_ms) {
-  //TODO(jpawlowski): implement
+void metrics_log_bluetooth_session_start(connection_tech_t connection_tech_type,
+                                uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
 }
 
-void metrics_scan_event(bool start, const char *initator, scan_tech_t type,
-                        uint32_t results, uint64_t timestamp_ms) {
-  //TODO(jpawlowski): implement
+void metrics_log_bluetooth_session_end(const char* disconnect_reason,
+  uint64_t timestamp_ms) {
+  // TODO(siyuanh): Implement for linux
 }
 
-void metrics_a2dp_session(int64_t session_duration_sec,
-                          const char *disconnect_reason,
-                          uint32_t device_class,
-                          int32_t media_timer_min_ms,
-                          int32_t media_timer_max_ms,
-                          int32_t media_timer_avg_ms,
-                          int32_t buffer_overruns_max_count,
-                          int32_t buffer_overruns_total,
-                          float buffer_underruns_average,
-                          int32_t buffer_underruns_count) {
-  //TODO(jpawlowski): implement
+void metrics_log_bluetooth_session_device_info(uint32_t device_class,
+                                     device_type_t device_type) {
+  // TODO(siyuanh): Implement for linux
 }
 
-void metrics_write(int fd, bool clear) {
-  //TODO(jpawlowski): implement
+void metrics_log_a2dp_session(A2dpSessionMetrics_t* metrics) {
+  // TODO(siyuanh): Implement for linux
 }
 
-void metrics_print(int fd, bool clear) {
-  //TODO(jpawlowski): implement
+void metrics_write_base64(int fd, bool clear) {
+  // TODO(siyuanh): Implement for linux
 }
diff --git a/osi/src/protos/bluetooth.proto b/osi/src/protos/bluetooth.proto
index 9a233ad..14c1ef2 100644
--- a/osi/src/protos/bluetooth.proto
+++ b/osi/src/protos/bluetooth.proto
@@ -24,6 +24,21 @@ message BluetoothLog {
 
   // Scan event information.
   repeated ScanEvent scan_event = 4;
+
+  // Number of bonded devices.
+  optional int32 num_bonded_devices = 5;
+
+  // Number of BluetoothSession including discarded ones beyond capacity
+  optional int64 num_bluetooth_session = 6;
+
+  // Number of PairEvent including discarded ones beyond capacity
+  optional int64 num_pair_event = 7;
+
+  // Number of WakeEvent including discarded ones beyond capacity
+  optional int64 num_wake_event = 8;
+
+  // Number of ScanEvent including discarded ones beyond capacity
+  optional int64 num_scan_event = 9;
 }
 
 // The information about the device.
@@ -63,6 +78,17 @@ message BluetoothSession {
      CONNECTION_TECHNOLOGY_TYPE_BREDR = 2;
   }
 
+  enum DisconnectReasonType {
+    UNKNOWN = 0;
+
+    // A metrics dump takes a snapshot of current Bluetooth session and thus
+    // is not a real disconnect, but a discontinuation in metrics logging.
+    // This enum indicates this situation.
+    METRICS_DUMP = 1;
+
+    NEXT_START_WITHOUT_END_PREVIOUS = 2;
+  }
+
   // Duration of the session.
   optional int64 session_duration_sec = 2;
 
@@ -70,7 +96,7 @@ message BluetoothSession {
   optional ConnectionTechnologyType connection_technology_type = 3;
 
   // Reason for disconnecting.
-  optional string disconnect_reason = 4;
+  optional string disconnect_reason = 4 [deprecated=true];
 
   // The information about the device which it is connected to.
   optional DeviceInfo device_connected_to = 5;
@@ -78,8 +104,11 @@ message BluetoothSession {
   // The information about the RFComm session.
   optional RFCommSession rfcomm_session = 6;
 
-  // The information about the A2DP session.
+  // The information about the A2DP audio session.
   optional A2DPSession a2dp_session = 7;
+
+  // Numeric reason for disconnecting as defined in metrics.h
+  optional DisconnectReasonType disconnect_reason_type = 8;
 }
 
 message RFCommSession {
@@ -91,7 +120,7 @@ message RFCommSession {
   optional int32 tx_bytes = 2;
 }
 
-// Session information that gets logged for every A2DP session.
+// Session information that gets logged for A2DP session.
 message A2DPSession {
 
   // Media timer in milliseconds.
@@ -114,6 +143,9 @@ message A2DPSession {
 
   // Buffer underruns count.
   optional int32 buffer_underruns_count = 7;
+
+  // Total audio time in this A2DP session
+  optional int64 audio_duration_millis = 8;
 }
 
 message PairEvent {
diff --git a/osi/src/vnd_log.c b/osi/src/vnd_log.c
new file mode 100644
index 0000000..a330f88
--- /dev/null
+++ b/osi/src/vnd_log.c
@@ -0,0 +1,89 @@
+/******************************************************************************
+Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+******************************************************************************/
+
+#define LOG_TAG "bt_vnd_log"
+
+#include <errno.h>
+#include <string.h>
+#include <dlfcn.h>
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+static const char *LOGGER_LIBRARY_NAME = "libbt-logClient.so";
+static const char *LOGGER_LIBRARY_SYMBOL_NAME = "BLUETOOTH_LOGGER_LIB_INTERFACE";
+
+static void *lib_handle;
+bt_logger_interface_t *logger_interface = NULL;
+bool bt_logger_enabled = false;
+
+void init_vnd_Logger(void)
+{
+  if(!bt_logger_enabled)
+  {
+    LOG_ERROR(LOG_TAG, "%s, Logger Not enabled from config file",  __func__);
+    return;
+  }
+
+  if(logger_interface)
+  {
+    LOG_ERROR(LOG_TAG, "%s, Vendor Logger is already initialized",  __func__);
+    return;
+  }
+
+  lib_handle = dlopen(LOGGER_LIBRARY_NAME, RTLD_NOW);
+
+  if (!lib_handle) {
+    LOG_ERROR(LOG_TAG, "%s unable to open %s: %s", __func__, LOGGER_LIBRARY_NAME, dlerror());
+    return;
+  }
+
+  logger_interface = (bt_logger_interface_t *)dlsym(lib_handle, LOGGER_LIBRARY_SYMBOL_NAME);
+  if (!logger_interface) {
+    LOG_ERROR(LOG_TAG, "%s unable to find symbol %s in %s: %s", __func__, LOGGER_LIBRARY_SYMBOL_NAME, LOGGER_LIBRARY_NAME, dlerror());
+    return;
+  }
+
+  logger_interface->init();
+}
+
+void clean_vnd_logger()
+{
+  if(!bt_logger_enabled)
+    return;
+
+  if(logger_interface)
+    logger_interface->cleanup();
+
+  logger_interface = NULL;
+
+  if(lib_handle)
+    dlclose(lib_handle);
+
+  lib_handle = NULL;
+}
diff --git a/osi/src/wakelock.c b/osi/src/wakelock.c
index fc19cc4..9681bd0 100644
--- a/osi/src/wakelock.c
+++ b/osi/src/wakelock.c
@@ -294,7 +294,7 @@ static void update_wakelock_acquired_stats(bt_status_t acquired_status) {
 
   pthread_mutex_unlock(&monitor);
 
-  metrics_wake_event(WAKE_EVENT_ACQUIRED, NULL, WAKE_LOCK_ID, now_ms);
+  metrics_log_wake_event(WAKE_EVENT_ACQUIRED, "", "", now_ms);
 }
 
 //
@@ -338,7 +338,7 @@ static void update_wakelock_released_stats(bt_status_t released_status) {
 
   pthread_mutex_unlock(&monitor);
 
-  metrics_wake_event(WAKE_EVENT_RELEASED, NULL, WAKE_LOCK_ID, now_ms);
+  metrics_log_wake_event(WAKE_EVENT_RELEASED, "", "", now_ms);
 }
 
 void wakelock_debug_dump(int fd) {
diff --git a/osi/test/leaky_bonded_queue_test.cpp b/osi/test/leaky_bonded_queue_test.cpp
new file mode 100644
index 0000000..c538101
--- /dev/null
+++ b/osi/test/leaky_bonded_queue_test.cpp
@@ -0,0 +1,242 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+#include <base/logging.h>
+
+#include "osi/include/leaky_bonded_queue.h"
+
+namespace testing {
+
+using system_bt_osi::LeakyBondedQueue;
+
+#define ITEM_EQ(a, b)              \
+  do {                             \
+    EXPECT_EQ(a, b);               \
+    EXPECT_EQ(a->index, b->index); \
+  } while (0)
+
+class Item {
+ public:
+  Item(int i) { index = i; }
+  virtual ~Item() {}
+  int index;
+};
+
+class MockItem : public Item {
+ public:
+  MockItem(int i) : Item(i) {}
+  ~MockItem() { Destruct(); }
+  MOCK_METHOD0(Destruct, void());
+};
+
+TEST(LeakyBondedQueueTest, TestEnqueueDequeue) {
+  MockItem* item1 = new MockItem(1);
+  MockItem* item2 = new MockItem(2);
+  MockItem* item3 = new MockItem(3);
+  MockItem* item4 = new MockItem(4);
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(3);
+  EXPECT_EQ(queue->Capacity(), static_cast<size_t>(3));
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  queue->Enqueue(item2);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  queue->Enqueue(item3);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(3));
+  EXPECT_CALL(*item1, Destruct()).Times(1);
+  queue->Enqueue(item4);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(3));
+  MockItem* item2_2 = queue->Dequeue();
+  MockItem* item3_3 = queue->Dequeue();
+  MockItem* item4_4 = queue->Dequeue();
+  EXPECT_THAT(item2_2, NotNull());
+  ITEM_EQ(item2_2, item2);
+  EXPECT_THAT(item3_3, NotNull());
+  ITEM_EQ(item3_3, item3);
+  EXPECT_THAT(item4_4, NotNull());
+  ITEM_EQ(item4_4, item4);
+  LOG(INFO) << "All done release items";
+  EXPECT_CALL(*item2_2, Destruct()).Times(1);
+  delete item2_2;
+  EXPECT_CALL(*item3_3, Destruct()).Times(1);
+  delete item3_3;
+  EXPECT_CALL(*item4_4, Destruct()).Times(1);
+  delete item4_4;
+  delete queue;
+}
+
+TEST(LeakyBondedQueueTest, TestEnqueueDequeue2) {
+  MockItem* item1 = new MockItem(1);
+  MockItem* item2 = new MockItem(2);
+  MockItem* item3 = new MockItem(3);
+  MockItem* item4 = new MockItem(4);
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(2);
+  EXPECT_EQ(queue->Capacity(), static_cast<size_t>(2));
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  MockItem* item1_1 = queue->Dequeue();
+  ITEM_EQ(item1, item1_1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item2);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  queue->Enqueue(item3);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item2, Destruct()).Times(1);
+  queue->Enqueue(item4);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item3, Destruct()).Times(1);
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  MockItem* item4_4_4 = queue->Dequeue();
+  MockItem* item1_1_1 = queue->Dequeue();
+  ITEM_EQ(item4_4_4, item4);
+  ITEM_EQ(item1_1_1, item1);
+  EXPECT_CALL(*item1_1_1, Destruct()).Times(1);
+  delete item1_1_1;
+  EXPECT_CALL(*item4_4_4, Destruct()).Times(1);
+  delete item4_4_4;
+  delete queue;
+}
+
+TEST(LeakyBondedQueueTest, TestEnqueuePop) {
+  MockItem* item1 = new MockItem(1);
+  MockItem* item2 = new MockItem(2);
+  MockItem* item3 = new MockItem(3);
+  MockItem* item4 = new MockItem(4);
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(2);
+  EXPECT_EQ(queue->Capacity(), static_cast<size_t>(2));
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  MockItem* item1_1 = queue->Dequeue();
+  ITEM_EQ(item1, item1_1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item2);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  queue->Enqueue(item3);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  MockItem* item2_2 = queue->EnqueueWithPop(item4);
+  EXPECT_THAT(item2_2, NotNull());
+  ITEM_EQ(item2_2, item2);
+  EXPECT_CALL(*item2, Destruct()).Times(1);
+  delete item2_2;
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  MockItem* item3_3 = queue->EnqueueWithPop(item1);
+  EXPECT_THAT(item3_3, NotNull());
+  ITEM_EQ(item3_3, item3);
+  EXPECT_CALL(*item3, Destruct()).Times(1);
+  delete item3_3;
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  MockItem* item4_4_4 = queue->Dequeue();
+  MockItem* item1_1_1 = queue->Dequeue();
+  ITEM_EQ(item4_4_4, item4);
+  ITEM_EQ(item1_1_1, item1);
+  EXPECT_CALL(*item1_1_1, Destruct()).Times(1);
+  delete item1_1_1;
+  EXPECT_CALL(*item4_4_4, Destruct()).Times(1);
+  delete item4_4_4;
+  delete queue;
+}
+
+TEST(LeakyBondedQueueTest, TestQueueClear) {
+  MockItem* item1 = new MockItem(1);
+  MockItem* item2 = new MockItem(2);
+  MockItem* item3 = new MockItem(3);
+  MockItem* item4 = new MockItem(4);
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(2);
+  EXPECT_EQ(queue->Capacity(), static_cast<size_t>(2));
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  MockItem* item1_1 = queue->Dequeue();
+  ITEM_EQ(item1, item1_1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item2);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  queue->Enqueue(item3);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item2, Destruct()).Times(1);
+  queue->Enqueue(item4);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item3, Destruct()).Times(1);
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item1, Destruct()).Times(1);
+  EXPECT_CALL(*item4, Destruct()).Times(1);
+  queue->Clear();
+  delete queue;
+}
+
+TEST(LeakyBondedQueueTest, TestQueueFree) {
+  MockItem* item1 = new MockItem(1);
+  MockItem* item2 = new MockItem(2);
+  MockItem* item3 = new MockItem(3);
+  MockItem* item4 = new MockItem(4);
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(2);
+  EXPECT_EQ(queue->Capacity(), static_cast<size_t>(2));
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  MockItem* item1_1 = queue->Dequeue();
+  ITEM_EQ(item1, item1_1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(0));
+  queue->Enqueue(item2);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(1));
+  queue->Enqueue(item3);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item2, Destruct()).Times(1);
+  queue->Enqueue(item4);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item3, Destruct()).Times(1);
+  queue->Enqueue(item1);
+  EXPECT_EQ(queue->Length(), static_cast<size_t>(2));
+  EXPECT_CALL(*item1, Destruct()).Times(1);
+  EXPECT_CALL(*item4, Destruct()).Times(1);
+  delete queue;
+}
+
+TEST(LeakyBondedQueueTest, TestPushNull) {
+  MockItem* item1 = nullptr;
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(2);
+  queue->Enqueue(item1);
+  MockItem* item1_1 = queue->Dequeue();
+  EXPECT_THAT(item1_1, IsNull());
+}
+
+TEST(LeakyBondedQueueTest, TestPushNullOverflowQueue) {
+  MockItem* item1 = nullptr;
+  MockItem* item2 = nullptr;
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(1);
+  queue->Enqueue(item1);
+  queue->Enqueue(item2);
+  MockItem* item2_2 = queue->Dequeue();
+  EXPECT_THAT(item2_2, IsNull());
+}
+
+TEST(LeakyBondedQueueTest, TestPushNullDeleteQueue) {
+  MockItem* item1 = nullptr;
+  MockItem* item2 = nullptr;
+  LeakyBondedQueue<MockItem>* queue = new LeakyBondedQueue<MockItem>(2);
+  queue->Enqueue(item1);
+  queue->Enqueue(item2);
+  delete queue;
+}
+}
diff --git a/osi/test/metrics_test.cpp b/osi/test/metrics_test.cpp
new file mode 100644
index 0000000..597e4b3
--- /dev/null
+++ b/osi/test/metrics_test.cpp
@@ -0,0 +1,805 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include <chrono>
+#include <cstdint>
+#include <string>
+#include <thread>
+#include <vector>
+
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+#include <base/logging.h>
+
+#include "osi/include/metrics.h"
+#include "osi/include/metrics_cpp.h"
+#include "osi/include/time.h"
+#include "osi/src/protos/bluetooth.pb.h"
+
+#define BTM_COD_MAJOR_AUDIO_TEST 0x04
+
+namespace testing {
+
+using clearcut::connectivity::A2DPSession;
+using clearcut::connectivity::BluetoothLog;
+using clearcut::connectivity::BluetoothSession;
+using clearcut::connectivity::BluetoothSession_ConnectionTechnologyType;
+using clearcut::connectivity::BluetoothSession_DisconnectReasonType;
+using clearcut::connectivity::DeviceInfo;
+using clearcut::connectivity::DeviceInfo_DeviceType;
+using clearcut::connectivity::PairEvent;
+using clearcut::connectivity::RFCommSession;
+using clearcut::connectivity::ScanEvent;
+using clearcut::connectivity::ScanEvent_ScanTechnologyType;
+using clearcut::connectivity::ScanEvent_ScanEventType;
+using clearcut::connectivity::WakeEvent;
+using clearcut::connectivity::WakeEvent_WakeEventType;
+using system_bt_osi::BluetoothMetricsLogger;
+using system_bt_osi::A2dpSessionMetrics;
+
+namespace {
+const size_t kMaxEventGenerationLimit = 5000;
+}
+
+uint64_t metrics_time_get_os_boottime_us(void) {
+  struct timespec ts_now;
+  clock_gettime(CLOCK_BOOTTIME, &ts_now);
+
+  return ((uint64_t)ts_now.tv_sec * 1000000L) +
+         ((uint64_t)ts_now.tv_nsec / 1000);
+}
+
+/*
+ * Get current OS boot time in millisecond
+ */
+static int64_t time_get_os_boottime_ms(void) {
+  return metrics_time_get_os_boottime_us() / 1000;
+}
+
+static void sleep_ms(int64_t t) {
+  std::this_thread::sleep_for(std::chrono::milliseconds(t));
+}
+
+DeviceInfo* MakeDeviceInfo(int32_t device_class,
+                           DeviceInfo_DeviceType device_type) {
+  DeviceInfo* info = new DeviceInfo();
+  info->set_device_class(device_class);
+  info->set_device_type(device_type);
+  return info;
+}
+
+PairEvent* MakePairEvent(int32_t disconnect_reason, int64_t timestamp_ms,
+                         DeviceInfo* device_info) {
+  PairEvent* event = new PairEvent();
+  event->set_disconnect_reason(disconnect_reason);
+  event->set_event_time_millis(timestamp_ms);
+  if (device_info) event->set_allocated_device_paired_with(device_info);
+  return event;
+}
+
+WakeEvent* MakeWakeEvent(WakeEvent_WakeEventType event_type,
+                         const std::string& requestor, const std::string& name,
+                         int64_t timestamp_ms) {
+  WakeEvent* event = new WakeEvent();
+  event->set_wake_event_type(event_type);
+  event->set_requestor(requestor);
+  event->set_name(name);
+  event->set_event_time_millis(timestamp_ms);
+  return event;
+}
+
+ScanEvent* MakeScanEvent(ScanEvent_ScanEventType event_type,
+                         const std::string& initiator,
+                         ScanEvent_ScanTechnologyType tech_type,
+                         int32_t num_results, int64_t timestamp_ms) {
+  ScanEvent* event = new ScanEvent();
+  event->set_scan_event_type(event_type);
+  event->set_initiator(initiator);
+  event->set_scan_technology_type(tech_type);
+  event->set_number_results(num_results);
+  event->set_event_time_millis(timestamp_ms);
+  return event;
+}
+
+A2DPSession* MakeA2DPSession(const A2dpSessionMetrics& metrics) {
+  A2DPSession* session = new A2DPSession();
+  session->set_media_timer_min_millis(metrics.media_timer_min_ms);
+  session->set_media_timer_max_millis(metrics.media_timer_max_ms);
+  session->set_media_timer_avg_millis(metrics.media_timer_avg_ms);
+  session->set_buffer_overruns_max_count(metrics.buffer_overruns_max_count);
+  session->set_buffer_overruns_total(metrics.buffer_overruns_total);
+  session->set_buffer_underruns_average(metrics.buffer_underruns_average);
+  session->set_buffer_underruns_count(metrics.buffer_underruns_count);
+  session->set_audio_duration_millis(metrics.audio_duration_ms);
+  return session;
+}
+
+BluetoothSession* MakeBluetoothSession(
+    int64_t session_duration_sec,
+    BluetoothSession_ConnectionTechnologyType conn_type,
+    BluetoothSession_DisconnectReasonType disconnect_reason,
+    DeviceInfo* device_info, RFCommSession* rfcomm_session,
+    A2DPSession* a2dp_session) {
+  BluetoothSession* session = new BluetoothSession();
+  if (a2dp_session) session->set_allocated_a2dp_session(a2dp_session);
+  if (rfcomm_session) session->set_allocated_rfcomm_session(rfcomm_session);
+  if (device_info) session->set_allocated_device_connected_to(device_info);
+  session->set_session_duration_sec(session_duration_sec);
+  session->set_connection_technology_type(conn_type);
+  session->set_disconnect_reason_type(disconnect_reason);
+  return session;
+}
+
+BluetoothLog* MakeBluetoothLog(std::vector<BluetoothSession*> bt_sessions,
+                               std::vector<PairEvent*> pair_events,
+                               std::vector<WakeEvent*> wake_events,
+                               std::vector<ScanEvent*> scan_events) {
+  BluetoothLog* bt_log = new BluetoothLog();
+  for (BluetoothSession* session : bt_sessions) {
+    bt_log->mutable_session()->AddAllocated(session);
+  }
+  bt_sessions.clear();
+  for (PairEvent* event : pair_events) {
+    bt_log->mutable_pair_event()->AddAllocated(event);
+  }
+  pair_events.clear();
+  for (WakeEvent* event : wake_events) {
+    bt_log->mutable_wake_event()->AddAllocated(event);
+  }
+  wake_events.clear();
+  for (ScanEvent* event : scan_events) {
+    bt_log->mutable_scan_event()->AddAllocated(event);
+  }
+  scan_events.clear();
+  return bt_log;
+}
+
+void GenerateWakeEvents(size_t start, size_t end,
+                        std::vector<WakeEvent*>* wake_events) {
+  for (size_t i = start; i < end; ++i) {
+    wake_events->push_back(MakeWakeEvent(
+        i % 2 == 0 ? WakeEvent_WakeEventType::WakeEvent_WakeEventType_ACQUIRED
+                   : WakeEvent_WakeEventType::WakeEvent_WakeEventType_RELEASED,
+        "TEST_REQ", "TEST_NAME", i));
+  }
+}
+
+#define COMPARE_A2DP_METRICS(a, b)                                       \
+  do {                                                                   \
+    EXPECT_EQ(a.audio_duration_ms, b.audio_duration_ms);                 \
+    EXPECT_EQ(a.media_timer_min_ms, b.media_timer_min_ms);               \
+    EXPECT_EQ(a.media_timer_max_ms, b.media_timer_max_ms);               \
+    EXPECT_EQ(a.media_timer_avg_ms, b.media_timer_avg_ms);               \
+    EXPECT_EQ(a.total_scheduling_count, b.total_scheduling_count);       \
+    EXPECT_EQ(a.buffer_overruns_max_count, b.buffer_overruns_max_count); \
+    EXPECT_EQ(a.buffer_overruns_total, b.buffer_overruns_total);         \
+    EXPECT_THAT(a.buffer_underruns_average,                              \
+                FloatNear(b.buffer_underruns_average, 0.01));            \
+    a.buffer_underruns_average = b.buffer_underruns_average;             \
+    EXPECT_EQ(a.buffer_underruns_count, b.buffer_underruns_count);       \
+  } while (0)
+
+/*
+ * metrics_sum = metrics1 + metrics2
+ */
+TEST(BluetoothA2DPSessionMetricsTest, TestUpdateNormal) {
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  A2dpSessionMetrics metrics_sum;
+  metrics1.audio_duration_ms = 10;
+  metrics2.audio_duration_ms = 25;
+  metrics_sum.audio_duration_ms = 35;
+  metrics1.media_timer_min_ms = 10;
+  metrics2.media_timer_min_ms = 25;
+  metrics_sum.media_timer_min_ms = 10;
+  metrics1.media_timer_max_ms = 100;
+  metrics2.media_timer_max_ms = 200;
+  metrics_sum.media_timer_max_ms = 200;
+  metrics1.media_timer_avg_ms = 50;
+  metrics1.total_scheduling_count = 50;
+  metrics2.media_timer_avg_ms = 100;
+  metrics2.total_scheduling_count = 50;
+  metrics_sum.media_timer_avg_ms = 75;
+  metrics_sum.total_scheduling_count = 100;
+  metrics1.buffer_overruns_max_count = 70;
+  metrics2.buffer_overruns_max_count = 80;
+  metrics_sum.buffer_overruns_max_count = 80;
+  metrics1.buffer_underruns_average = 80;
+  metrics1.buffer_underruns_count = 1200;
+  metrics2.buffer_underruns_average = 130;
+  metrics2.buffer_underruns_count = 2400;
+  metrics_sum.buffer_underruns_average = 113.33333333;
+  metrics_sum.buffer_underruns_count = 3600;
+  metrics1.Update(metrics2);
+  COMPARE_A2DP_METRICS(metrics1, metrics_sum);
+  EXPECT_TRUE(metrics1 == metrics_sum);
+  EXPECT_EQ(metrics1, metrics_sum);
+}
+
+TEST(BluetoothA2DPSessionMetricsTest, TestUpdateNew) {
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  A2dpSessionMetrics metrics_sum;
+  metrics2.audio_duration_ms = 25;
+  metrics_sum.audio_duration_ms = 25;
+  metrics2.media_timer_min_ms = 25;
+  metrics_sum.media_timer_min_ms = 25;
+  metrics2.media_timer_max_ms = 200;
+  metrics_sum.media_timer_max_ms = 200;
+  metrics2.media_timer_avg_ms = 100;
+  metrics2.total_scheduling_count = 50;
+  metrics_sum.media_timer_avg_ms = 100;
+  metrics_sum.total_scheduling_count = 50;
+  metrics2.buffer_overruns_max_count = 80;
+  metrics_sum.buffer_overruns_max_count = 80;
+  metrics2.buffer_underruns_average = 130;
+  metrics2.buffer_underruns_count = 2400;
+  metrics_sum.buffer_underruns_average = 130;
+  metrics_sum.buffer_underruns_count = 2400;
+  metrics1.Update(metrics2);
+  COMPARE_A2DP_METRICS(metrics1, metrics_sum);
+  EXPECT_TRUE(metrics1 == metrics_sum);
+  EXPECT_EQ(metrics1, metrics_sum);
+}
+
+TEST(BluetoothA2DPSessionMetricsTest, TestNullUpdate) {
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  A2dpSessionMetrics metrics_sum;
+  metrics2.audio_duration_ms = 25;
+  metrics_sum.audio_duration_ms = 25;
+  metrics2.media_timer_min_ms = 25;
+  metrics_sum.media_timer_min_ms = 25;
+  metrics2.media_timer_max_ms = 200;
+  metrics_sum.media_timer_max_ms = 200;
+  metrics2.media_timer_avg_ms = 100;
+  metrics2.total_scheduling_count = 50;
+  metrics_sum.media_timer_avg_ms = 100;
+  metrics_sum.total_scheduling_count = 50;
+  metrics2.buffer_overruns_max_count = 80;
+  metrics_sum.buffer_overruns_max_count = 80;
+  metrics2.buffer_underruns_average = 130;
+  metrics2.buffer_underruns_count = 2400;
+  metrics_sum.buffer_underruns_average = 130;
+  metrics_sum.buffer_underruns_count = 2400;
+  metrics2.Update(metrics1);
+  COMPARE_A2DP_METRICS(metrics2, metrics_sum);
+  EXPECT_TRUE(metrics2 == metrics_sum);
+  EXPECT_EQ(metrics2, metrics_sum);
+}
+
+TEST(BluetoothA2DPSessionMetricsTest, TestPartialUpdate) {
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  A2dpSessionMetrics metrics_sum;
+  metrics1.audio_duration_ms = 10;
+  metrics2.audio_duration_ms = 25;
+  metrics_sum.audio_duration_ms = 35;
+  metrics1.media_timer_min_ms = 10;
+  metrics_sum.media_timer_min_ms = 10;
+  metrics1.media_timer_max_ms = 100;
+  metrics_sum.media_timer_max_ms = 100;
+  metrics1.media_timer_avg_ms = 50;
+  metrics1.total_scheduling_count = 50;
+  metrics2.media_timer_avg_ms = 100;
+  metrics_sum.media_timer_avg_ms = 50;
+  metrics_sum.total_scheduling_count = 50;
+  metrics1.buffer_overruns_max_count = 70;
+  metrics_sum.buffer_overruns_max_count = 70;
+  metrics1.buffer_underruns_average = 80;
+  metrics1.buffer_underruns_count = 1200;
+  metrics2.buffer_underruns_count = 2400;
+  metrics_sum.buffer_underruns_average = 80;
+  metrics_sum.buffer_underruns_count = 1200;
+  metrics1.Update(metrics2);
+  COMPARE_A2DP_METRICS(metrics1, metrics_sum);
+  EXPECT_TRUE(metrics1 == metrics_sum);
+  EXPECT_EQ(metrics1, metrics_sum);
+}
+
+class BluetoothMetricsLoggerTest : public Test {
+ protected:
+  // Use to hold test protos
+  std::vector<PairEvent*> pair_events_;
+  std::vector<WakeEvent*> wake_events_;
+  std::vector<ScanEvent*> scan_events_;
+  std::vector<BluetoothSession*> bt_sessions_;
+  int64_t num_pair_event_ = 0;
+  int64_t num_wake_event_ = 0;
+  int64_t num_scan_event_ = 0;
+  int64_t num_bt_session_ = 0;
+  BluetoothLog* bt_log_;
+  std::string bt_log_str_;
+  std::string bt_log_ascii_str_;
+
+  void UpdateLog() {
+    for (BluetoothSession* session : bt_sessions_) {
+      bt_log_->mutable_session()->AddAllocated(session);
+    }
+    if (num_bt_session_ > 0) {
+      bt_log_->set_num_bluetooth_session(num_bt_session_);
+    } else if (bt_sessions_.size() > 0) {
+      bt_log_->set_num_bluetooth_session(bt_sessions_.size());
+    }
+    bt_sessions_.clear();
+    for (PairEvent* event : pair_events_) {
+      bt_log_->mutable_pair_event()->AddAllocated(event);
+    }
+    if (num_pair_event_ > 0) {
+      bt_log_->set_num_pair_event(num_pair_event_);
+    } else if (pair_events_.size() > 0) {
+      bt_log_->set_num_pair_event(pair_events_.size());
+    }
+    pair_events_.clear();
+    for (WakeEvent* event : wake_events_) {
+      bt_log_->mutable_wake_event()->AddAllocated(event);
+    }
+    if (num_wake_event_ > 0) {
+      bt_log_->set_num_wake_event(num_wake_event_);
+    } else if (wake_events_.size() > 0) {
+      bt_log_->set_num_wake_event(wake_events_.size());
+    }
+    wake_events_.clear();
+    for (ScanEvent* event : scan_events_) {
+      bt_log_->mutable_scan_event()->AddAllocated(event);
+    }
+    if (num_scan_event_ > 0) {
+      bt_log_->set_num_scan_event(num_scan_event_);
+    } else if (scan_events_.size() > 0) {
+      bt_log_->set_num_scan_event(scan_events_.size());
+    }
+    scan_events_.clear();
+    bt_log_->SerializeToString(&bt_log_str_);
+  }
+
+  void ClearLog() {
+    for (BluetoothSession* session : bt_sessions_) {
+      session->Clear();
+      delete session;
+    }
+    bt_sessions_.clear();
+    for (PairEvent* event : pair_events_) {
+      event->Clear();
+      delete event;
+    }
+    pair_events_.clear();
+    for (WakeEvent* event : wake_events_) {
+      event->Clear();
+      delete event;
+    }
+    wake_events_.clear();
+    for (ScanEvent* event : scan_events_) {
+      event->Clear();
+      delete event;
+    }
+    scan_events_.clear();
+    bt_log_->Clear();
+  }
+
+  void SetUp() {
+    bt_log_ = new BluetoothLog();
+    // Clear existing metrics entries, if any
+    BluetoothMetricsLogger::GetInstance()->Reset();
+  }
+  void TearDown() {
+    // Clear remaining metrics entries, if any
+    BluetoothMetricsLogger::GetInstance()->Reset();
+    ClearLog();
+    delete bt_log_;
+  }
+
+ public:
+};
+
+TEST_F(BluetoothMetricsLoggerTest, PairEventTest) {
+  pair_events_.push_back(MakePairEvent(
+      35, 12345,
+      MakeDeviceInfo(
+          42, DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR)));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogPairEvent(
+      35, 12345, 42, DEVICE_TYPE_BREDR);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+TEST_F(BluetoothMetricsLoggerTest, WakeEventTest) {
+  wake_events_.push_back(
+      MakeWakeEvent(WakeEvent_WakeEventType::WakeEvent_WakeEventType_ACQUIRED,
+                    "TEST_REQ", "TEST_NAME", 12345));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogWakeEvent(
+      WAKE_EVENT_ACQUIRED, "TEST_REQ", "TEST_NAME", 12345);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+TEST_F(BluetoothMetricsLoggerTest, WakeEventOverrunTest) {
+  GenerateWakeEvents(kMaxEventGenerationLimit -
+    BluetoothMetricsLogger::kMaxNumWakeEvent,
+    kMaxEventGenerationLimit, &wake_events_);
+  num_wake_event_ = kMaxEventGenerationLimit;
+  UpdateLog();
+  for (size_t i = 0; i < kMaxEventGenerationLimit; ++i) {
+    BluetoothMetricsLogger::GetInstance()->LogWakeEvent(
+        i % 2 == 0 ? WAKE_EVENT_ACQUIRED : WAKE_EVENT_RELEASED,
+        "TEST_REQ", "TEST_NAME", i);
+  }
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+TEST_F(BluetoothMetricsLoggerTest, ScanEventTest) {
+  scan_events_.push_back(MakeScanEvent(
+      ScanEvent_ScanEventType::ScanEvent_ScanEventType_SCAN_EVENT_STOP,
+      "TEST_INITIATOR", ScanEvent_ScanTechnologyType::
+                            ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BREDR,
+      42, 123456));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogScanEvent(
+      false, "TEST_INITIATOR", SCAN_TECH_TYPE_BREDR, 42, 123456);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+TEST_F(BluetoothMetricsLoggerTest, BluetoothSessionTest) {
+  bt_sessions_.push_back(MakeBluetoothSession(
+      10,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE,
+      BluetoothSession_DisconnectReasonType::
+          BluetoothSession_DisconnectReasonType_UNKNOWN,
+      nullptr, nullptr, nullptr));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      CONNECTION_TECHNOLOGY_TYPE_LE, 123456);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionEnd(
+      DISCONNECT_REASON_UNKNOWN, 133456);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+TEST_F(BluetoothMetricsLoggerTest, BluetoothSessionDumpBeforeEndTest) {
+  bt_sessions_.push_back(MakeBluetoothSession(
+      1,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE,
+      BluetoothSession_DisconnectReasonType::
+          BluetoothSession_DisconnectReasonType_METRICS_DUMP,
+      nullptr, nullptr, nullptr));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      CONNECTION_TECHNOLOGY_TYPE_LE, time_get_os_boottime_ms());
+  sleep_ms(1000);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+TEST_F(BluetoothMetricsLoggerTest, BluetoothSessionStartBeforeEndTest) {
+  bt_sessions_.push_back(MakeBluetoothSession(
+      1,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN,
+      BluetoothSession_DisconnectReasonType::
+          BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS,
+      nullptr, nullptr, nullptr));
+  bt_sessions_.push_back(MakeBluetoothSession(
+      2,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE,
+      BluetoothSession_DisconnectReasonType::
+          BluetoothSession_DisconnectReasonType_METRICS_DUMP,
+      nullptr, nullptr, nullptr));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      CONNECTION_TECHNOLOGY_TYPE_UNKNOWN, 0);
+  sleep_ms(1000);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      CONNECTION_TECHNOLOGY_TYPE_LE, 0);
+  sleep_ms(2000);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+/*
+ * Test Case: A2DPSessionTwoUpdatesTest
+ *
+ * 1. Create Instance
+ * 2. LogBluetoothSessionStart
+ * 3. LogBluetoothSessionDeviceInfo
+ * 4. LogA2dpSession
+ * 5. LogA2dpSession
+ * 6. LogBluetoothSessionEnd
+ * 7. WriteString
+ *
+ */
+TEST_F(BluetoothMetricsLoggerTest, A2DPSessionTwoUpdatesTest) {
+  /* Same metrics from BluetoothA2DPSessionMetricsTest.TestUpdateNormal */
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  A2dpSessionMetrics metrics_sum;
+  metrics1.audio_duration_ms = 10;
+  metrics2.audio_duration_ms = 25;
+  metrics_sum.audio_duration_ms = 35;
+  metrics1.media_timer_min_ms = 10;
+  metrics2.media_timer_min_ms = 25;
+  metrics_sum.media_timer_min_ms = 10;
+  metrics1.media_timer_max_ms = 100;
+  metrics2.media_timer_max_ms = 200;
+  metrics_sum.media_timer_max_ms = 200;
+  metrics1.media_timer_avg_ms = 50;
+  metrics1.total_scheduling_count = 50;
+  metrics2.media_timer_avg_ms = 100;
+  metrics2.total_scheduling_count = 50;
+  metrics_sum.media_timer_avg_ms = 75;
+  metrics_sum.total_scheduling_count = 100;
+  metrics1.buffer_overruns_max_count = 70;
+  metrics2.buffer_overruns_max_count = 80;
+  metrics_sum.buffer_overruns_max_count = 80;
+  metrics1.buffer_underruns_average = 80;
+  metrics1.buffer_underruns_count = 1200;
+  metrics2.buffer_underruns_average = 130;
+  metrics2.buffer_underruns_count = 2400;
+  metrics_sum.buffer_underruns_average = 113.33333333;
+  metrics_sum.buffer_underruns_count = 3600;
+  DeviceInfo* info = MakeDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST,
+      DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR);
+  A2DPSession* session = MakeA2DPSession(metrics_sum);
+  bt_sessions_.push_back(MakeBluetoothSession(
+      10,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR,
+      BluetoothSession_DisconnectReasonType::BluetoothSession_DisconnectReasonType_UNKNOWN,
+      info, nullptr, session));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      CONNECTION_TECHNOLOGY_TYPE_BREDR, 123456);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST, DEVICE_TYPE_BREDR);
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics1);
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics2);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionEnd(
+      DISCONNECT_REASON_UNKNOWN, 133456);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+/*
+ * Test Case: A2DPSessionTwoUpdatesSeparatedbyDumpTest
+ *
+ * 1. Create Instance
+ * 2. LogBluetoothSessionStart
+ * 3. LogBluetoothSessionDeviceInfo
+ * 4. LogA2dpSession
+ * 5. WriteString
+ * 6. LogA2dpSession
+ * 7. LogBluetoothSessionEnd
+ * 8. WriteString
+ *
+ */
+TEST_F(BluetoothMetricsLoggerTest, A2DPSessionTwoUpdatesSeparatedbyDumpTest) {
+  /* Same metrics from BluetoothA2DPSessionMetricsTest.TestUpdateNormal */
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  metrics1.audio_duration_ms = 10;
+  metrics2.audio_duration_ms = 25;
+  metrics1.media_timer_min_ms = 10;
+  metrics2.media_timer_min_ms = 25;
+  metrics1.media_timer_max_ms = 100;
+  metrics2.media_timer_max_ms = 200;
+  metrics1.media_timer_avg_ms = 50;
+  metrics1.total_scheduling_count = 50;
+  metrics2.media_timer_avg_ms = 100;
+  metrics2.total_scheduling_count = 50;
+  metrics1.buffer_overruns_max_count = 70;
+  metrics2.buffer_overruns_max_count = 80;
+  metrics1.buffer_underruns_average = 80;
+  metrics1.buffer_underruns_count = 1200;
+  metrics2.buffer_underruns_average = 130;
+  metrics2.buffer_underruns_count = 2400;
+  DeviceInfo* info = MakeDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST,
+      DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR);
+  A2DPSession* session = MakeA2DPSession(metrics1);
+  bt_sessions_.push_back(MakeBluetoothSession(
+      1,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR,
+      BluetoothSession_DisconnectReasonType::
+          BluetoothSession_DisconnectReasonType_METRICS_DUMP,
+      info, nullptr, session));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      CONNECTION_TECHNOLOGY_TYPE_BREDR, 0);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST, DEVICE_TYPE_BREDR);
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics1);
+  sleep_ms(1000);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+  ClearLog();
+  info = MakeDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST,
+      DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR);
+  session = MakeA2DPSession(metrics2);
+  bt_sessions_.push_back(MakeBluetoothSession(
+      1,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR,
+      BluetoothSession_DisconnectReasonType::BluetoothSession_DisconnectReasonType_UNKNOWN,
+      info, nullptr, session));
+  UpdateLog();
+  sleep_ms(1000);
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics2);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionEnd(
+      DISCONNECT_REASON_UNKNOWN, 0);
+  msg_str.clear();
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+/*
+ * Test Case 1: A2DPSessionOnlyTest
+ *
+ * 1. Create Instance
+ * 4. LogA2dpSession
+ * 5. WriteString
+ * 6. LogA2dpSession
+ * 8. WriteString
+ *
+ */
+TEST_F(BluetoothMetricsLoggerTest, A2DPSessionOnlyTest) {
+  /* Same metrics from BluetoothA2DPSessionMetricsTest.TestUpdateNormal */
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  A2dpSessionMetrics metrics_sum;
+  metrics1.audio_duration_ms = 10;
+  metrics2.audio_duration_ms = 25;
+  metrics_sum.audio_duration_ms = 35;
+  metrics1.media_timer_min_ms = 10;
+  metrics2.media_timer_min_ms = 25;
+  metrics_sum.media_timer_min_ms = 10;
+  metrics1.media_timer_max_ms = 100;
+  metrics2.media_timer_max_ms = 200;
+  metrics_sum.media_timer_max_ms = 200;
+  metrics1.media_timer_avg_ms = 50;
+  metrics1.total_scheduling_count = 50;
+  metrics2.media_timer_avg_ms = 100;
+  metrics2.total_scheduling_count = 50;
+  metrics_sum.media_timer_avg_ms = 75;
+  metrics_sum.total_scheduling_count = 100;
+  metrics1.buffer_overruns_max_count = 70;
+  metrics2.buffer_overruns_max_count = 80;
+  metrics_sum.buffer_overruns_max_count = 80;
+  metrics1.buffer_underruns_average = 80;
+  metrics1.buffer_underruns_count = 1200;
+  metrics2.buffer_underruns_average = 130;
+  metrics2.buffer_underruns_count = 2400;
+  metrics_sum.buffer_underruns_average = 113.33333333;
+  metrics_sum.buffer_underruns_count = 3600;
+  DeviceInfo* info = MakeDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST,
+      DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR);
+  A2DPSession* session = MakeA2DPSession(metrics_sum);
+  bt_sessions_.push_back(MakeBluetoothSession(
+      1,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR,
+      BluetoothSession_DisconnectReasonType::BluetoothSession_DisconnectReasonType_METRICS_DUMP,
+      info, nullptr, session));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics1);
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics2);
+  sleep_ms(1000);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+
+/*
+ * Test Case: A2DPSessionDumpBeforeTwoUpdatesTest
+ *
+ * 1. Create Instance
+ * 2. LogBluetoothSessionStart
+ * 3. LogBluetoothSessionDeviceInfo
+ * 5. WriteString
+ * 6. LogA2dpSession
+ * 7. LogA2dpSession
+ * 8. LogBluetoothSessionEnd
+ * 9. WriteString
+ *
+ */
+TEST_F(BluetoothMetricsLoggerTest, A2DPSessionDumpBeforeTwoUpdatesTest) {
+  /* Same metrics from BluetoothA2DPSessionMetricsTest.TestUpdateNormal */
+  A2dpSessionMetrics metrics1;
+  A2dpSessionMetrics metrics2;
+  A2dpSessionMetrics metrics_sum;
+  metrics1.audio_duration_ms = 10;
+  metrics2.audio_duration_ms = 25;
+  metrics_sum.audio_duration_ms = 35;
+  metrics1.media_timer_min_ms = 10;
+  metrics2.media_timer_min_ms = 25;
+  metrics_sum.media_timer_min_ms = 10;
+  metrics1.media_timer_max_ms = 100;
+  metrics2.media_timer_max_ms = 200;
+  metrics_sum.media_timer_max_ms = 200;
+  metrics1.media_timer_avg_ms = 50;
+  metrics1.total_scheduling_count = 50;
+  metrics2.media_timer_avg_ms = 100;
+  metrics2.total_scheduling_count = 50;
+  metrics_sum.media_timer_avg_ms = 75;
+  metrics_sum.total_scheduling_count = 100;
+  metrics1.buffer_overruns_max_count = 70;
+  metrics2.buffer_overruns_max_count = 80;
+  metrics_sum.buffer_overruns_max_count = 80;
+  metrics1.buffer_underruns_average = 80;
+  metrics1.buffer_underruns_count = 1200;
+  metrics2.buffer_underruns_average = 130;
+  metrics2.buffer_underruns_count = 2400;
+  metrics_sum.buffer_underruns_average = 113.33333333;
+  metrics_sum.buffer_underruns_count = 3600;
+  DeviceInfo* info = MakeDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST,
+      DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR);
+  bt_sessions_.push_back(MakeBluetoothSession(
+      1,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR,
+      BluetoothSession_DisconnectReasonType::BluetoothSession_DisconnectReasonType_METRICS_DUMP,
+      info, nullptr, nullptr));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionStart(
+      CONNECTION_TECHNOLOGY_TYPE_BREDR, 0);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST, DEVICE_TYPE_BREDR);
+  sleep_ms(1000);
+  std::string msg_str;
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+  ClearLog();
+  info = MakeDeviceInfo(
+      BTM_COD_MAJOR_AUDIO_TEST,
+      DeviceInfo_DeviceType::DeviceInfo_DeviceType_DEVICE_TYPE_BREDR);
+  A2DPSession* session = MakeA2DPSession(metrics_sum);
+  bt_sessions_.push_back(MakeBluetoothSession(
+      1,
+      BluetoothSession_ConnectionTechnologyType::
+          BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR,
+      BluetoothSession_DisconnectReasonType::BluetoothSession_DisconnectReasonType_UNKNOWN,
+      info, nullptr, session));
+  UpdateLog();
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics1);
+  BluetoothMetricsLogger::GetInstance()->LogA2dpSession(metrics2);
+  sleep_ms(1000);
+  BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionEnd(
+      DISCONNECT_REASON_UNKNOWN, 0);
+  msg_str.clear();
+  BluetoothMetricsLogger::GetInstance()->WriteString(&msg_str, true);
+  EXPECT_THAT(msg_str, StrEq(bt_log_str_));
+}
+}
diff --git a/service/gatt_server_old.cpp b/service/gatt_server_old.cpp
index f775be9..9c535d0 100644
--- a/service/gatt_server_old.cpp
+++ b/service/gatt_server_old.cpp
@@ -44,6 +44,8 @@ extern "C" {
 #include "osi/include/osi.h"
 }  // extern "C"
 
+bt_logger_interface_t *logger_interface = NULL;
+
 namespace {
 
 const size_t kMaxGattAttributeSize = 512;
diff --git a/stack/Android.mk b/stack/Android.mk
index 4c77e8d..8e5d7c6 100644
--- a/stack/Android.mk
+++ b/stack/Android.mk
@@ -35,6 +35,13 @@ LOCAL_C_INCLUDES:= \
                    $(LOCAL_PATH)/../ \
                    $(bluetooth_C_INCLUDES)
 
+ifneq ($(TARGET_SUPPORTS_WEARABLES),true)
+LOCAL_C_INCLUDES+= \
+                   vendor/qcom/opensource/bluetooth/system_bt_ext
+else
+LOCAL_C_INCLUDES+= \
+                   device/qcom/msm8909w/opensource/bluetooth/system_bt_ext
+endif
 LOCAL_SRC_FILES:= \
     ./a2dp/a2d_api.c \
     ./a2dp/a2d_sbc.c \
diff --git a/stack/a2dp/a2d_aptx.c b/stack/a2dp/a2d_aptx.c
index c74e1e9..05011bb 100644
--- a/stack/a2dp/a2d_aptx.c
+++ b/stack/a2dp/a2d_aptx.c
@@ -39,6 +39,7 @@
 
 #include <string.h>
 #include <dlfcn.h>
+#include "osi/include/mutex.h"
 #include "osi/include/thread.h"
 #include "bt_utils.h"
 #include "a2d_api.h"
@@ -265,6 +266,42 @@ BOOLEAN A2D_check_and_init_aptX(void)
 
 /*******************************************************************************
 **
+** Function         A2D_start_aptX
+**
+** Description      This function Start aptX
+**
+** Returns          Nothing
+**
+*******************************************************************************/
+void A2D_start_aptX(void *encoder, A2D_AptXCodecType aptX_codec_type,
+                        BOOLEAN use_SCMS_T, BOOLEAN is_24bit_audio,
+                        UINT16 sample_rate, UINT8 format_bits,
+                        UINT8 channel, UINT16 MTU, A2D_AptXReadFn read_fn,
+                        A2D_AptXBufferSendFn send_fn,
+                        A2D_AptXSetPriorityFn set_priority_fn,
+                        BOOLEAN test, BOOLEAN trace)
+{
+    A2D_TRACE_DEBUG("%s", __func__);
+    mutex_global_lock();
+
+    A2d_aptx_thread_fn = A2D_aptx_sched_start (encoder, aptX_codec_type,
+              use_SCMS_T, is_24bit_audio, sample_rate, format_bits,
+              channel, MTU, read_fn, send_fn, set_priority_fn, test, trace);
+
+    A2d_aptx_thread = thread_new("aptx_media_worker");
+    if (A2d_aptx_thread)
+    {
+        thread_post(A2d_aptx_thread, A2d_aptx_thread_fn, NULL);
+    }
+
+    mutex_global_unlock();
+    return;
+}
+
+
+
+/*******************************************************************************
+**
 ** Function         A2D_deinit_aptX
 **
 ** Description      This function de-initialized aptX
@@ -287,17 +324,17 @@ void A2D_deinit_aptX(void)
 
 /*******************************************************************************
 **
-** Function         A2D_close_aptX
+** Function         A2D_stop_aptX
 **
-** Description      This function close aptX
+** Description      This function remove aptX thread
 **
 ** Returns          Nothing
 **
 *******************************************************************************/
-void A2D_close_aptX(void)
+void A2D_stop_aptX(void)
 {
     A2D_TRACE_DEBUG("%s", __func__);
-
+    mutex_global_lock();
     if (A2dAptXSchedLibHandle)
     {
         // remove aptX thread
@@ -308,6 +345,24 @@ void A2D_close_aptX(void)
             A2d_aptx_thread = NULL;
         }
     }
+    mutex_global_unlock();
+    return;
+}
+/*******************************************************************************
+**
+** Function         A2D_close_aptX
+**
+** Description      This function close aptX
+**
+** Returns          Nothing
+**
+*******************************************************************************/
+void A2D_close_aptX(void)
+{
+    A2D_TRACE_DEBUG("%s", __func__);
+
+    // remove aptX thread
+    A2D_stop_aptX();
 
     // de-initialize aptX HD
     A2D_deinit_aptX_HD();
diff --git a/stack/avct/avct_api.c b/stack/avct/avct_api.c
index 3826221..df5615d 100644
--- a/stack/avct/avct_api.c
+++ b/stack/avct/avct_api.c
@@ -499,6 +499,29 @@ UINT16 AVCT_MsgReq(UINT8 handle, UINT8 label, UINT8 cr, BT_HDR *p_msg)
     return result;
 }
 
+/*******************************************************************************
+**
+** Function         AVCT_CheckIncomingConn
+**
+** Description      Check for incoming connection in progress
+**
+** Return           TRUE if incoming connection in progress, FALSE otherwise
+******************************************************************************/
+BOOLEAN AVCT_CheckIncomingConn(BD_ADDR peer_addr)
+{
+    tAVCT_LCB *p_lcb;
+
+    p_lcb = avct_lcb_by_bd(peer_addr);
+    if (p_lcb != NULL)
+    {
+        if (p_lcb->ch_state != AVCT_CH_IDLE)
+        {
+            AVCT_TRACE_ERROR("%s: Incoming AVCT connection in progress",__func__);
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
 /******************************************************************************
 **
 ** Function         AVCT_SetTraceLevel
diff --git a/stack/avct/avct_l2c.c b/stack/avct/avct_l2c.c
index 2310390..4ae2f65 100644
--- a/stack/avct/avct_l2c.c
+++ b/stack/avct/avct_l2c.c
@@ -556,6 +556,11 @@ void avct_l2c_config_ind_cback(UINT16 lcid, tL2CAP_CFG_INFO *p_cfg)
         }
         AVCT_TRACE_DEBUG("ch_state cfi: %d ", p_lcb->ch_state);
     }
+    else
+    {
+        AVCT_TRACE_ERROR("%s: p_lcb is null",__func__);
+        L2CA_DisconnectReq(lcid);
+    }
 }
 
 #if (AVCT_BROWSE_INCLUDED == TRUE)
diff --git a/stack/avdt/avdt_ccb_act.c b/stack/avdt/avdt_ccb_act.c
index 2f43a35..8cc9bf4 100644
--- a/stack/avdt/avdt_ccb_act.c
+++ b/stack/avdt/avdt_ccb_act.c
@@ -24,6 +24,7 @@
  ******************************************************************************/
 
 #include <string.h>
+#include "btif_av_co.h"
 #include "bt_types.h"
 #include "bt_target.h"
 #include "bt_utils.h"
@@ -33,6 +34,9 @@
 #include "bt_common.h"
 #include "btu.h"
 #include "btm_api.h"
+#include "device/include/interop.h"
+#include "a2d_api.h"
+#include <hardware/bluetooth.h>
 
 extern fixed_queue_t *btu_general_alarm_queue;
 
@@ -160,56 +164,52 @@ void avdt_ccb_hdl_discover_cmd(tAVDT_CCB *p_ccb, tAVDT_CCB_EVT *p_data)
     tAVDT_SEP_INFO      sep_info[AVDT_NUM_SEPS];
     tAVDT_SCB           *p_scb = &avdt_cb.scb[0];
     int                 i;
+    bt_bdaddr_t remote_bdaddr;
+    bdcpy(remote_bdaddr.address, p_ccb->peer_addr);
 
     p_data->msg.discover_rsp.p_sep_info = sep_info;
     p_data->msg.discover_rsp.num_seps = 0;
 
-    /* for all allocated scbs */
+    /* If this ccb, has done setconf and is doing discover again
+     * we should show SEP for which setconfig was done earlier
+     * This is done for IOP with some remotes */
     for (i = 0; i < AVDT_NUM_SEPS; i++, p_scb++)
     {
-        if (p_scb->allocated)
+        if((p_ccb != NULL)&& (p_scb->p_ccb != NULL)&&(p_scb->p_ccb == p_ccb))
         {
+            AVDT_TRACE_EVENT(" CCB already tied to SCB[%d] ",i);
             /* copy sep info */
             sep_info[p_data->msg.discover_rsp.num_seps].in_use = p_scb->in_use;
             sep_info[p_data->msg.discover_rsp.num_seps].seid = i + 1;
             sep_info[p_data->msg.discover_rsp.num_seps].media_type = p_scb->cs.media_type;
             sep_info[p_data->msg.discover_rsp.num_seps].tsep = p_scb->cs.tsep;
-
             p_data->msg.discover_rsp.num_seps++;
+            avdt_ccb_event(p_ccb, AVDT_CCB_API_DISCOVER_RSP_EVT, p_data);
+            return;
         }
     }
-    /* adjust inuse. Mark all the SEP of a perticualr cluster in use
-     * if one of the SEP is in use to avoid incoming connection failure
-     */
-    if (p_data->msg.discover_rsp.num_seps > 2
-        && avdt_scb_get_max_av_client() > 1)
+    p_scb = &avdt_cb.scb[0];
+    /* for all allocated scbs */
+    for (i = 0; i < AVDT_NUM_SEPS; i++, p_scb++)
     {
-        int i,j;
-        int num_sep = p_data->msg.discover_rsp.num_seps;
-        int num_stream  = avdt_scb_get_max_av_client();
-        int num_codecs = num_sep/num_stream;
-        BOOLEAN is_busy = false;
-
-        for (i = 0; i < num_sep; i += num_codecs)
+        if ((p_scb->allocated) && (!p_scb->in_use))
         {
-            is_busy = false;
-            for (j = i; j < (i+num_codecs); j++)
-            {
-                if (sep_info[j].in_use)
-                {
-                    is_busy = true;
-                    break;
-                }
-            }
-            if (is_busy)
-            {
-                for (j = i; j < (i+num_codecs); j++)
-                {
-                    sep_info[j].in_use = is_busy;
-                }
+            /* if the codec type is AAC and if the peer address is blacklisted */
+            if (p_scb->cs.cfg.codec_info[AVDT_CODEC_TYPE_INDEX] == A2D_MEDIA_CT_M24 &&
+                   !bta_av_co_audio_is_aac_enabled(&remote_bdaddr)) {
+                AVDT_TRACE_EVENT("%s: skipping AAC advertise\n", __func__);
+                continue;
             }
+            /* copy sep info */
+            sep_info[p_data->msg.discover_rsp.num_seps].in_use = p_scb->in_use;
+            sep_info[p_data->msg.discover_rsp.num_seps].seid = i + 1;
+            sep_info[p_data->msg.discover_rsp.num_seps].media_type = p_scb->cs.media_type;
+            sep_info[p_data->msg.discover_rsp.num_seps].tsep = p_scb->cs.tsep;
+
+            p_data->msg.discover_rsp.num_seps++;
         }
     }
+
     /* send response */
     avdt_ccb_event(p_ccb, AVDT_CCB_API_DISCOVER_RSP_EVT, p_data);
 }
diff --git a/stack/avdt/avdt_l2c.c b/stack/avdt/avdt_l2c.c
index 557893b..8e8b5fc 100644
--- a/stack/avdt/avdt_l2c.c
+++ b/stack/avdt/avdt_l2c.c
@@ -210,8 +210,9 @@ void avdt_l2c_connect_ind_cback(BD_ADDR bd_addr, UINT16 lcid, UINT16 psm, UINT8
             p_tbl->id   = id;
             p_tbl->state = AVDT_AD_ST_SEC_ACP;
             p_tbl->cfg_flags = AVDT_L2C_CFG_CONN_ACP;
-
-            if (interop_match_addr(INTEROP_2MBPS_LINK_ONLY, (const bt_bdaddr_t *)&bd_addr)) {
+            bt_bdaddr_t remote_bdaddr;
+            bdcpy(remote_bdaddr.address, bd_addr);
+            if (interop_match_addr(INTEROP_2MBPS_LINK_ONLY, (const bt_bdaddr_t *)&remote_bdaddr)) {
                 // Disable 3DH packets for AVDT ACL to improve sensitivity on HS
                 tACL_CONN *p_acl_cb = btm_bda_to_acl(bd_addr, BT_TRANSPORT_BR_EDR);
                 /* Fix for below klockwork issue
@@ -342,8 +343,10 @@ void avdt_l2c_connect_cfm_cback(UINT16 lcid, UINT16 result)
                         p_tbl->state = AVDT_AD_ST_SEC_INT;
                         p_tbl->lcid = lcid;
                         p_tbl->cfg_flags = AVDT_L2C_CFG_CONN_INT;
+                        bt_bdaddr_t remote_address;
+                        bdcpy(remote_address.address, p_ccb->peer_addr);
 
-                        if (interop_match_addr(INTEROP_2MBPS_LINK_ONLY, (const bt_bdaddr_t *) &p_ccb->peer_addr)) {
+                        if (interop_match_addr(INTEROP_2MBPS_LINK_ONLY, (const bt_bdaddr_t *) &remote_address)) {
                             // Disable 3DH packets for AVDT ACL to improve sensitivity on HS
                             tACL_CONN *p_acl_cb = btm_bda_to_acl(p_ccb->peer_addr, BT_TRANSPORT_BR_EDR);
                             /* Fix for below klockwork issue
diff --git a/stack/avdt/avdt_scb_act.c b/stack/avdt/avdt_scb_act.c
index 0775b09..666c732 100644
--- a/stack/avdt/avdt_scb_act.c
+++ b/stack/avdt/avdt_scb_act.c
@@ -817,6 +817,91 @@ void avdt_scb_hdl_security_rsp(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
                               (tAVDT_CTRL *) &p_data->msg.security_cmd);
 }
 
+void avdt_set_scbs_busy(tAVDT_SCB *ptr_scb)
+{
+    AVDT_TRACE_DEBUG(" avdt_set_scbs_busy ");
+    tAVDT_SCB       *p_scb = &avdt_cb.scb[0];
+    UINT8 reg_id = ptr_scb->cs.registration_id;
+    int i = 0;
+    for (i = 0; i < AVDT_NUM_SEPS; i++, p_scb++)
+    {
+        AVDT_TRACE_DEBUG(" avdt_set_scbs_busy SCB[%d] reg_id, sep_type ", i, p_scb->cs.registration_id, p_scb->cs.tsep);
+        if ((p_scb->allocated) && (p_scb->cs.registration_id == reg_id) && (p_scb->cs.tsep == ptr_scb->cs.tsep))
+        {
+            AVDT_TRACE_DEBUG(" Setting SCB[%d].in_use as true", i);
+            p_scb->in_use = TRUE;
+        }
+    }
+}
+
+void avdt_set_scbs_free(tAVDT_SCB *ptr_scb)
+{
+    AVDT_TRACE_DEBUG(" avdt_set_scbs_free ");
+    tAVDT_SCB       *p_scb = &avdt_cb.scb[0];
+    UINT8 reg_id = ptr_scb->cs.registration_id;
+    int i = 0;
+    for (i = 0; i < AVDT_NUM_SEPS; i++, p_scb++)
+    {
+        AVDT_TRACE_DEBUG(" avdt_set_scbs_free SCB[%d] reg_id, sep_type ", i, p_scb->cs.registration_id, p_scb->cs.tsep);
+        if ((p_scb->allocated) && (p_scb->cs.registration_id == reg_id) && (p_scb->cs.tsep == ptr_scb->cs.tsep))
+        {
+            AVDT_TRACE_DEBUG(" Setting SCB[%d].in_use as false ", i);
+            p_scb->in_use = FALSE;
+        }
+    }
+}
+
+/*******************************************************************************
+**
+** Function         avdt_check_sep_state
+**
+** Description      This function checks if either of the SEID is in use in the
+**                  cluster of a stream in which the ACP SEP for the remote
+**                  initiated connection belongs to.
+**
+** Returns          True if one SEID in the cluster is busy, False otherwise
+**
+*******************************************************************************/
+BOOLEAN avdt_check_sep_state(tAVDT_SCB *p_scb)
+{
+    int i,j;
+    int num_sep = 0,sep_offset;
+    int num_stream = avdt_scb_get_max_av_client();
+    if (num_stream == 1)
+        return false;
+    for (i = 0;i < AVDT_NUM_SEPS; i++)
+    {
+        tAVDT_SCB *temp_scb = &avdt_cb.scb[i];
+        if (p_scb == temp_scb)
+            break;
+    }
+    if (i < AVDT_NUM_SEPS)
+    {
+        sep_offset = i;
+        tAVDT_SCB *temp_scb = &avdt_cb.scb[0];
+        for (j = 0; j < AVDT_NUM_SEPS; j++, temp_scb++)
+        {
+            if (temp_scb->allocated)
+                num_sep++;
+        }
+        int num_stream  = avdt_scb_get_max_av_client();
+        int num_codecs = num_sep/num_stream;
+        for (i = 0; i < num_sep;i += num_codecs)
+        {
+            BOOLEAN in_use = false;
+            for (j = i;j < (i+num_codecs); j++)
+            {
+                tAVDT_SCB *temp_scb = &avdt_cb.scb[j];
+                if (temp_scb->in_use)
+                    in_use = true;
+            }
+            if (in_use && (sep_offset >= i && sep_offset < j))
+                return true;
+        }
+    }
+    return false;
+}
+
 /*******************************************************************************
 **
 ** Function         avdt_scb_hdl_setconfig_cmd
@@ -831,8 +916,10 @@ void avdt_scb_hdl_security_rsp(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 void avdt_scb_hdl_setconfig_cmd(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     tAVDT_CFG *p_cfg;
+    AVDT_TRACE_WARNING("avdt_scb_hdl_setconfig_cmd: SCB in use: %d, Conn in progress: %d",
+        p_scb->in_use, avdt_cb.conn_in_progress);
 
-    if (!p_scb->in_use)
+    if ((!p_scb->in_use) && !(avdt_check_sep_state(p_scb)) && (!avdt_cb.conn_in_progress))
     {
         p_cfg = p_data->msg.config_cmd.p_cfg;
         if(p_scb->cs.cfg.codec_info[AVDT_CODEC_TYPE_INDEX] == p_cfg->codec_info[AVDT_CODEC_TYPE_INDEX])
@@ -842,6 +929,7 @@ void avdt_scb_hdl_setconfig_cmd(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 
             /* copy info to scb */
             p_scb->p_ccb = avdt_ccb_by_idx(p_data->msg.config_cmd.hdr.ccb_idx);
+            avdt_set_scbs_busy(p_scb);
             p_scb->peer_seid = p_data->msg.config_cmd.int_seid;
             memcpy(&p_scb->req_cfg, p_cfg, sizeof(tAVDT_CFG));
             /* call app callback */
@@ -1688,7 +1776,7 @@ void avdt_scb_snd_setconfig_req(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
     }
 #endif
     memcpy(&p_scb->req_cfg, p_data->msg.config_cmd.p_cfg, sizeof(tAVDT_CFG));
-
+    avdt_set_scbs_busy(p_scb);
     avdt_msg_send_cmd(p_scb->p_ccb, p_scb, AVDT_SIG_SETCONFIG, &p_data->msg);
 
     /* tell ccb to open channel */
@@ -2061,6 +2149,7 @@ void avdt_scb_transport_channel_timer(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 void avdt_scb_clr_vars(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
 {
     UNUSED(p_data);
+    avdt_set_scbs_free(p_scb);
     p_scb->in_use = FALSE;
     p_scb->p_ccb = NULL;
     p_scb->peer_seid = 0;
diff --git a/stack/avrc/avrc_api.c b/stack/avrc/avrc_api.c
index ade3b85..20fc71c 100644
--- a/stack/avrc/avrc_api.c
+++ b/stack/avrc/avrc_api.c
@@ -681,7 +681,7 @@ static void avrc_msg_cback(UINT8 handle, UINT8 label, UINT8 cr,
             case AVRC_OP_VENDOR:
                 p_data  = (UINT8 *)(p_pkt+1) + p_pkt->offset;
                 p_begin = p_data;
-                if (p_pkt->len < AVRC_VENDOR_HDR_SIZE) /* 6 = ctype, subunit*, opcode & CO_ID */
+                if (p_pkt->len <= AVRC_VENDOR_HDR_SIZE) /* 6 = ctype, subunit*, opcode & CO_ID */
                 {
                     if (cr == AVCT_CMD)
                         reject = TRUE;
@@ -693,6 +693,7 @@ static void avrc_msg_cback(UINT8 handle, UINT8 label, UINT8 cr,
                 AVRC_BE_STREAM_TO_CO_ID(p_msg->company_id, p_data);
                 p_msg->p_vendor_data   = p_data;
                 p_msg->vendor_len      = p_pkt->len - (p_data - p_begin);
+                AVRC_TRACE_DEBUG(" vendor_len %d", p_msg->vendor_len);
 
 #if (AVRC_METADATA_INCLUDED == TRUE)
                 UINT8 drop_code = 0;
@@ -1182,3 +1183,15 @@ UINT16 AVRC_PassRsp(UINT8 handle, UINT8 label, tAVRC_MSG_PASS *p_msg)
     return AVRC_NO_RESOURCES;
 }
 
+/******************************************************************************
+**
+** Function         AVRC_CheckIncomfingConn
+**
+** Description      Check for incoming connection in progress
+**
+** Returns          TRUE if incoming ocnnection in progress, FALSE otherwise
+******************************************************************************/
+BOOLEAN AVRC_CheckIncomingConn(BD_ADDR peer_addr)
+{
+    return AVCT_CheckIncomingConn(peer_addr);
+}
diff --git a/stack/btm/btm_acl.c b/stack/btm/btm_acl.c
index 0ca7d67..481a6ce 100644
--- a/stack/btm/btm_acl.c
+++ b/stack/btm/btm_acl.c
@@ -47,7 +47,7 @@
 #include "l2c_int.h"
 #include "hcidefs.h"
 #include "bt_utils.h"
-
+#include "device/include/interop_config.h"
 
 extern fixed_queue_t *btu_general_alarm_queue;
 
@@ -58,73 +58,6 @@ static void btm_process_remote_ext_features (tACL_CONN *p_acl_cb, UINT8 num_read
 /* 3 seconds timeout waiting for responses */
 #define BTM_DEV_REPLY_TIMEOUT_MS (3 * 1000)
 
-/* Black listed car kits/headsets for incoming role switch */
-static const UINT8 btm_role_switch_black_list_prefix1[][3] = {{0x00, 0x0d, 0xfd}  /* MOT EQ5 */
-                                                             ,{0x00, 0x1b, 0xdc} /* BSHSBE20 */
-                                                             ,{0x00, 0x07, 0x04} /* Infiniti G37 2011 */
-                                                             ,{0xa4, 0x15, 0x66} /* Motorola Whisper */
-                                                            };
-/* Black listed car kits/headsets for outgoing role switch */
-static const UINT8 btm_role_switch_black_list_prefix2[][3] = {{0xfc, 0xc2, 0xde}  /* Toyota Prius 2015 */
-                                                             ,{0x00, 0x26, 0xb4} /* NAC FORD,2013 Lincoln */
-                                                             ,{0x00, 0x04, 0x3e} /* OBU II Bluetooth dongle */
-                                                             ,{0x00, 0x23, 0x01}  /* Roman R9020 */
-                                                             ,{0x00, 0x26, 0xb4} /* NAC FORD,2013 Lincoln */
-                                                             ,{0x1c, 0x48, 0xf9} /* Jabra Storm */
-                                                            };
-
-/*******************************************************************************
-**
-** Function         btm_blacklistted_for_incoming_role_switch
-**
-** Description      This function is called to find the blacklisted carkits
-**                  for role switch.
-**
-** Returns          TRUE, if black listed
-**
-*******************************************************************************/
-BOOLEAN btm_blacklistted_for_incoming_role_switch (BD_ADDR addr)
-{
-    int blacklistsize = 0;
-    int i =0;
-
-    blacklistsize = sizeof(btm_role_switch_black_list_prefix1)/sizeof(btm_role_switch_black_list_prefix1[0]);
-    for (i=0; i < blacklistsize; i++)
-    {
-        if (0 == memcmp(btm_role_switch_black_list_prefix1[i], addr, 3))
-        {
-            return TRUE;
-        }
-    }
-    return FALSE;
-}
-
-/*******************************************************************************
-**
-** Function         btm_blacklistted_for_outgoing_role_switch
-**
-** Description      This function is called to find the blacklisted carkits
-**                  for role switch.
-**
-** Returns          TRUE, if black listed
-**
-*******************************************************************************/
-BOOLEAN btm_blacklistted_for_outgoing_role_switch (BD_ADDR addr)
-{
-    int blacklistsize = 0;
-    int i =0;
-
-    blacklistsize = sizeof(btm_role_switch_black_list_prefix2)/sizeof(btm_role_switch_black_list_prefix2[0]);
-    for (i=0; i < blacklistsize; i++)
-    {
-        if (0 == memcmp(btm_role_switch_black_list_prefix2[i], addr, 3))
-        {
-            return TRUE;
-        }
-    }
-    return FALSE;
-}
-
 /*******************************************************************************
 **
 ** Function         btm_acl_init
@@ -162,7 +95,7 @@ void btm_acl_init (void)
 **                  NULL if not found.
 **
 *******************************************************************************/
-tACL_CONN *btm_bda_to_acl (BD_ADDR bda, tBT_TRANSPORT transport)
+tACL_CONN *btm_bda_to_acl (const BD_ADDR bda, tBT_TRANSPORT transport)
 {
     tACL_CONN   *p = &btm_cb.acl_db[0];
     UINT16       xx;
@@ -564,6 +497,8 @@ void btm_acl_update_busy_level (tBTM_BLI_EVENT event)
     UINT8 busy_level = btm_cb.busy_level;
     BTM_TRACE_DEBUG ("btm_acl_update_busy_level");
     BOOLEAN old_inquiry_state = btm_cb.is_inquiry;
+    /*Initialize busy_level_flags to 0*/
+    evt.busy_level_flags = 0;
     switch (event)
     {
         case BTM_BLI_ACL_UP_EVT:
@@ -681,8 +616,8 @@ tBTM_STATUS BTM_SwitchRole (BD_ADDR remote_bd_addr, UINT8 new_role, tBTM_CMPL_CB
     BD_ADDR_PTR  p_bda;
 #endif
 
-    /* Make sure the local device supports switching */
-    if (!controller_get_interface()->supports_master_slave_role_switch())
+    /* Make sure the local/remote devices supports switching */
+    if (!btm_dev_support_switch(remote_bd_addr))
         return(BTM_MODE_UNSUPPORTED);
 
     if (btm_cb.devcb.p_switch_role_cb && p_cb)
@@ -699,8 +634,10 @@ tBTM_STATUS BTM_SwitchRole (BD_ADDR remote_bd_addr, UINT8 new_role, tBTM_CMPL_CB
     if ((p = btm_bda_to_acl(remote_bd_addr, BT_TRANSPORT_BR_EDR)) == NULL)
         return(BTM_UNKNOWN_ADDR);
 
+    bt_bdaddr_t remote_address;
+    bdcpy(remote_address.address, remote_bd_addr);
     /* Finished if already in desired role */
-    if ((p->link_role == new_role) || btm_blacklistted_for_outgoing_role_switch(remote_bd_addr))
+    if ((p->link_role == new_role) || (interop_database_match_addr(INTEROP_DISABLE_ROLE_SWITCH, (bt_bdaddr_t *)&remote_address)))
         return(BTM_SUCCESS);
 
 #if BTM_SCO_INCLUDED == TRUE
@@ -719,7 +656,7 @@ tBTM_STATUS BTM_SwitchRole (BD_ADDR remote_bd_addr, UINT8 new_role, tBTM_CMPL_CB
         return(BTM_BUSY);
     }
 
-    if (is_device_present(IOT_ROLE_CHANGE_BLACKLIST, remote_bd_addr))
+    if (interop_database_match_addr(INTEROP_DYNAMIC_ROLE_SWITCH, (bt_bdaddr_t *)&remote_address))
     {
 #if (defined(BTM_SAFE_REATTEMPT_ROLE_SWITCH) && BTM_SAFE_REATTEMPT_ROLE_SWITCH == TRUE)
         p_dev_rec = btm_find_dev (remote_bd_addr);
@@ -832,10 +769,15 @@ void btm_acl_encrypt_change (UINT16 handle, UINT8 status, UINT8 encr_enable)
                       handle, status, encr_enable);
     xx = btm_handle_to_acl_index(handle);
     /* don't assume that we can never get a bad hci_handle */
-    if (xx < MAX_L2CAP_LINKS)
+    if (xx < MAX_L2CAP_LINKS) {
         p = &btm_cb.acl_db[xx];
-    else
+    } else {
+        GENERATE_VENDOR_LOGS();
         return;
+    }
+
+    if (status != HCI_SUCCESS)
+        GENERATE_VENDOR_LOGS();
 
     /* Process Role Switch if active */
     if (p->switch_role_state == BTM_ACL_SWKEY_STATE_ENCRYPTION_OFF)
@@ -922,12 +864,15 @@ tBTM_STATUS BTM_SetLinkPolicy (BD_ADDR remote_bda, UINT16 *settings)
     /* First, check if hold mode is supported */
     if (*settings != HCI_DISABLE_ALL_LM_MODES)
     {
+        bt_bdaddr_t remote_address;
+        bdcpy(remote_address.address, remote_bda);
         if ( (*settings & HCI_ENABLE_MASTER_SLAVE_SWITCH) && (!HCI_SWITCH_SUPPORTED(localFeatures)) )
         {
             *settings &= (~HCI_ENABLE_MASTER_SLAVE_SWITCH);
             BTM_TRACE_API ("BTM_SetLinkPolicy switch not supported (settings: 0x%04x)", *settings );
         }
-        if ( (*settings & HCI_ENABLE_MASTER_SLAVE_SWITCH) && (btm_blacklistted_for_incoming_role_switch(remote_bda)) )
+        if ( (*settings & HCI_ENABLE_MASTER_SLAVE_SWITCH) &&
+            (interop_database_match_addr(INTEROP_DISABLE_ROLE_SWITCH_POLICY, (bt_bdaddr_t *)&remote_address)) )
         {
             *settings &= (~HCI_ENABLE_MASTER_SLAVE_SWITCH);
             BTM_TRACE_API ("BTM_SetLinkPolicy switch not supported (settings: 0x%04x)", *settings );
@@ -1000,6 +945,43 @@ void BTM_SetDefaultLinkPolicy (UINT16 settings)
     btsnd_hcic_write_def_policy_set(settings);
 }
 
+
+void btm_use_preferred_conn_params(BD_ADDR bda) {
+    tL2C_LCB *p_lcb = l2cu_find_lcb_by_bd_addr (bda, BT_TRANSPORT_LE);
+    tBTM_SEC_DEV_REC    *p_dev_rec = btm_find_or_alloc_dev (bda);
+
+    /* If there are any preferred connection parameters, set them now */
+    if ( (p_dev_rec->conn_params.min_conn_int     >= BTM_BLE_CONN_INT_MIN ) &&
+         (p_dev_rec->conn_params.min_conn_int     <= BTM_BLE_CONN_INT_MAX ) &&
+         (p_dev_rec->conn_params.max_conn_int     >= BTM_BLE_CONN_INT_MIN ) &&
+         (p_dev_rec->conn_params.max_conn_int     <= BTM_BLE_CONN_INT_MAX ) &&
+         (p_dev_rec->conn_params.slave_latency    <= BTM_BLE_CONN_LATENCY_MAX ) &&
+         (p_dev_rec->conn_params.supervision_tout >= BTM_BLE_CONN_SUP_TOUT_MIN) &&
+         (p_dev_rec->conn_params.supervision_tout <= BTM_BLE_CONN_SUP_TOUT_MAX) &&
+         ((p_lcb->min_interval < p_dev_rec->conn_params.min_conn_int &&
+          p_dev_rec->conn_params.min_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ||
+          (p_lcb->min_interval > p_dev_rec->conn_params.max_conn_int) ||
+          (p_lcb->latency > p_dev_rec->conn_params.slave_latency) ||
+          (p_lcb->timeout > p_dev_rec->conn_params.supervision_tout)))
+    {
+        BTM_TRACE_DEBUG ("%s: HANDLE=%d min_conn_int=%d max_conn_int=%d slave_latency=%d supervision_tout=%d", __func__,
+                            p_lcb->handle, p_dev_rec->conn_params.min_conn_int, p_dev_rec->conn_params.max_conn_int,
+                            p_dev_rec->conn_params.slave_latency, p_dev_rec->conn_params.supervision_tout);
+
+        p_lcb->min_interval =  p_dev_rec->conn_params.min_conn_int;
+        p_lcb->max_interval = p_dev_rec->conn_params.max_conn_int;
+        p_lcb->timeout      = p_dev_rec->conn_params.supervision_tout;
+        p_lcb->latency      = p_dev_rec->conn_params.slave_latency;
+
+        btsnd_hcic_ble_upd_ll_conn_params (p_lcb->handle,
+                                           p_dev_rec->conn_params.min_conn_int,
+                                           p_dev_rec->conn_params.max_conn_int,
+                                           p_dev_rec->conn_params.slave_latency,
+                                           p_dev_rec->conn_params.supervision_tout,
+                                           0, 0);
+    }
+}
+
 /*******************************************************************************
 **
 ** Function         btm_read_remote_version_complete
@@ -1039,8 +1021,9 @@ void btm_read_remote_version_complete (UINT8 *p)
             }
 
 #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
-            if (p_acl_cb->transport == BT_TRANSPORT_LE){
+            if (p_acl_cb->transport == BT_TRANSPORT_LE) {
                 l2cble_notify_le_connection (p_acl_cb->remote_addr);
+                btm_use_preferred_conn_params(p_acl_cb->remote_addr);
             }
 #endif  // (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
                 BTM_TRACE_WARNING ("btm_read_remote_version_complete: BDA: %02x-%02x-%02x-%02x-%02x-%02x",
@@ -1525,7 +1508,7 @@ UINT16 btm_get_acl_disc_reason_code (void)
 ** Returns          the handle of the connection, or 0xFFFF if none.
 **
 *******************************************************************************/
-UINT16 BTM_GetHCIConnHandle (BD_ADDR remote_bda, tBT_TRANSPORT transport)
+UINT16 BTM_GetHCIConnHandle (const BD_ADDR remote_bda, tBT_TRANSPORT transport)
 {
     tACL_CONN   *p;
     BTM_TRACE_DEBUG ("BTM_GetHCIConnHandle");
@@ -1579,6 +1562,8 @@ void btm_blacklist_role_change_device (BD_ADDR bd_addr, UINT8 hci_status)
     tACL_CONN  *p = btm_bda_to_acl(bd_addr, BT_TRANSPORT_BR_EDR);
     tBTM_SEC_DEV_REC  *p_dev_rec = btm_find_dev (bd_addr);
     UINT32 cod = 0;
+    bt_bdaddr_t remote_bdaddr;
+    bdcpy(remote_bdaddr.address, bd_addr);
 
     if(!p || !p_dev_rec)
     {
@@ -1592,25 +1577,20 @@ void btm_blacklist_role_change_device (BD_ADDR bd_addr, UINT8 hci_status)
         ((p->switch_role_state == BTM_ACL_SWKEY_STATE_SWITCHING) ||
          (p->switch_role_state == BTM_ACL_SWKEY_STATE_IN_PROGRESS)) &&
         ((cod & COD_AUDIO_DEVICE) == COD_AUDIO_DEVICE) &&
-        (!is_device_present(IOT_ROLE_CHANGE_BLACKLIST, bd_addr)))
+        (!interop_database_match_addr(INTEROP_DYNAMIC_ROLE_SWITCH, (bt_bdaddr_t *)&remote_bdaddr)))
     {
         p->switch_role_failed_attempts++;
         if(p->switch_role_failed_attempts == BTM_MAX_SW_ROLE_FAILED_ATTEMPTS)
         {
             BTM_TRACE_WARNING ("btm_blacklist_device: BDA: %02x-%02x-%02x-%02x-%02x-%02x",
                 bd_addr[0], bd_addr[1], bd_addr[2], bd_addr[3], bd_addr[4], bd_addr[5]);
-            add_iot_device(IOT_DEV_CONF_FILE, IOT_ROLE_CHANGE_BLACKLIST,
-                            bd_addr, METHOD_BD);
+            interop_database_add_addr(INTEROP_DYNAMIC_ROLE_SWITCH, (bt_bdaddr_t *)&remote_bdaddr, 3);
         }
     }
     else if(hci_status == HCI_SUCCESS)
     {
 #if (defined(BTM_SAFE_REATTEMPT_ROLE_SWITCH) && BTM_SAFE_REATTEMPT_ROLE_SWITCH == TRUE)
-        if (is_device_present(IOT_ROLE_CHANGE_BLACKLIST, bd_addr))
-        {
-            remove_iot_device(IOT_DEV_CONF_FILE, IOT_ROLE_CHANGE_BLACKLIST,
-                            bd_addr, METHOD_BD);
-        }
+        interop_database_remove_addr(INTEROP_DYNAMIC_ROLE_SWITCH, (bt_bdaddr_t *)&remote_bdaddr);
 #endif
         p->switch_role_failed_attempts = 0;
     }
@@ -1647,6 +1627,8 @@ void btm_acl_role_changed (UINT8 hci_status, BD_ADDR bd_addr, UINT8 new_role)
         /* it could be a failure */
         if (hci_status != HCI_SUCCESS)
             btm_acl_report_role_change(hci_status, bd_addr);
+
+        GENERATE_VENDOR_LOGS();
         return;
     }
 
@@ -1669,6 +1651,7 @@ void btm_acl_role_changed (UINT8 hci_status, BD_ADDR bd_addr, UINT8 new_role)
     else
     {
         /* so the BTM_BL_ROLE_CHG_EVT uses the old role */
+        GENERATE_VENDOR_LOGS();
         new_role = p->link_role;
     }
 
@@ -2396,10 +2379,12 @@ void btm_read_tx_power_complete(UINT8 *p, BOOLEAN is_ble)
 *******************************************************************************/
 void btm_read_rssi_timeout(UNUSED_ATTR void *data)
 {
+    tBTM_RSSI_RESULTS  results;
     tBTM_CMPL_CB  *p_cb = btm_cb.devcb.p_rssi_cmpl_cb;
     btm_cb.devcb.p_rssi_cmpl_cb = NULL;
+    results.status = BTM_DEVICE_TIMEOUT;
     if (p_cb)
-        (*p_cb)((void *) NULL);
+        (*p_cb)(&results);
 }
 
 /*******************************************************************************
@@ -2763,6 +2748,7 @@ BOOLEAN  btm_acl_notif_conn_collision (BD_ADDR bda)
 {
     tBTM_BL_EVENT_DATA  evt_data;
 
+    GENERATE_VENDOR_LOGS();
     /* Report possible collision to the upper layer. */
     if (btm_cb.p_bl_changed_cb)
     {
diff --git a/stack/btm/btm_ble.c b/stack/btm/btm_ble.c
index 8f11564..9645cc5 100644
--- a/stack/btm/btm_ble.c
+++ b/stack/btm/btm_ble.c
@@ -51,6 +51,7 @@ extern void smp_link_encrypted(BD_ADDR bda, UINT8 encr_enable);
 extern BOOLEAN smp_proc_ltk_request(BD_ADDR bda);
 #endif
 extern void gatt_notify_enc_cmpl(BD_ADDR bd_addr);
+
 /*******************************************************************************/
 /* External Function to be called by other modules                             */
 /*******************************************************************************/
@@ -70,20 +71,15 @@ extern void gatt_notify_enc_cmpl(BD_ADDR bd_addr);
 ** Returns          TRUE if added OK, else FALSE
 **
 *******************************************************************************/
-BOOLEAN BTM_SecAddBleDevice (BD_ADDR bd_addr, BD_NAME bd_name, tBT_DEVICE_TYPE dev_type,
+BOOLEAN BTM_SecAddBleDevice (const BD_ADDR bd_addr, BD_NAME bd_name, tBT_DEVICE_TYPE dev_type,
                              tBLE_ADDR_TYPE addr_type)
 {
     BTM_TRACE_DEBUG ("%s: dev_type=0x%x", __func__, dev_type);
-    tBTM_SEC_DEV_REC  *p_dev_rec = btm_find_dev(bd_addr);
 
-    if (!p_dev_rec) {
-        if (list_length(btm_cb.sec_dev_rec) > BTM_SEC_MAX_DEVICE_RECORDS) {
-            BTM_TRACE_ERROR("%s: %d max devices reached!", __func__, BTM_SEC_MAX_DEVICE_RECORDS);
-            return FALSE;
-        }
-
-        p_dev_rec = osi_calloc(sizeof(tBTM_SEC_DEV_REC));
-        list_append(btm_cb.sec_dev_rec, p_dev_rec);
+    tBTM_SEC_DEV_REC *p_dev_rec = btm_find_dev(bd_addr);
+    if (!p_dev_rec)
+    {
+        p_dev_rec = btm_sec_allocate_dev_rec();
 
         memcpy(p_dev_rec->bd_addr, bd_addr, BD_ADDR_LEN);
         p_dev_rec->hci_handle = BTM_GetHCIConnHandle(bd_addr, BT_TRANSPORT_BR_EDR);
@@ -489,11 +485,10 @@ void BTM_BleOobDataReply(BD_ADDR bd_addr, UINT8 res, UINT8 len, UINT8 *p_data)
     tSMP_STATUS res_smp = (res == BTM_SUCCESS) ? SMP_SUCCESS : SMP_OOB_FAIL;
     tBTM_SEC_DEV_REC  *p_dev_rec = btm_find_dev (bd_addr);
 
-    BTM_TRACE_DEBUG ("BTM_BleOobDataReply");
+    BTM_TRACE_DEBUG ("%s:", __func__);
 
-    if (p_dev_rec == NULL)
-    {
-        BTM_TRACE_ERROR("BTM_BleOobDataReply() to Unknown device");
+    if (p_dev_rec == NULL) {
+        BTM_TRACE_ERROR("%s: Unknown device", __func__);
         return;
     }
 
@@ -502,6 +497,47 @@ void BTM_BleOobDataReply(BD_ADDR bd_addr, UINT8 res, UINT8 len, UINT8 *p_data)
 #endif
 }
 
+/*******************************************************************************
+**
+** Function         BTM_BleSecureConnectionOobDataReply
+**
+** Description      This function is called to provide the OOB data for
+**                  SMP in response to BTM_LE_OOB_REQ_EVT when secure connection
+**                  data is available
+**
+** Parameters:      bd_addr     - Address of the peer device
+**                  p_c         - pointer to Confirmation.
+**                  p_r         - pointer to Randomizer
+**
+*******************************************************************************/
+void BTM_BleSecureConnectionOobDataReply(BD_ADDR bd_addr,
+                                         uint8_t *p_c, uint8_t *p_r)
+{
+#if SMP_INCLUDED == TRUE
+    tBTM_SEC_DEV_REC  *p_dev_rec = btm_find_dev (bd_addr);
+
+    BTM_TRACE_DEBUG ("%s:", __func__);
+
+    if (p_dev_rec == NULL) {
+        BTM_TRACE_ERROR("%s: Unknown device", __func__);
+        return;
+    }
+
+    p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+
+    tSMP_SC_OOB_DATA oob;
+    memset(&oob, 0, sizeof(tSMP_SC_OOB_DATA));
+
+    oob.peer_oob_data.present = true;
+    memcpy(&oob.peer_oob_data.randomizer, p_r, BT_OCTET16_LEN);
+    memcpy(&oob.peer_oob_data.commitment, p_c, BT_OCTET16_LEN);
+    oob.peer_oob_data.addr_rcvd_from.type = p_dev_rec->ble.ble_addr_type;
+    memcpy(&oob.peer_oob_data.addr_rcvd_from.bda, bd_addr, sizeof(BD_ADDR));
+
+    SMP_SecureConnectionOobDataReply((uint8_t*)&oob);
+#endif
+}
+
 /******************************************************************************
 **
 ** Function         BTM_BleSetConnScanParams
@@ -751,6 +787,31 @@ void BTM_BleReceiverTest(UINT8 rx_freq, tBTM_CMPL_CB *p_cmd_cmpl_cback)
 
 /*******************************************************************************
 **
+** Function         BTM_BleEnhReceiverTest
+**
+** Description      This function is called to start the LE Enhanced Receiver
+**                  test
+**
+** Parameter        rx_freq - Frequency Range
+**                  phy - Phy to be used
+**                  mod_index - Modulation index
+**                  p_cmd_cmpl_cback - Command Complete callback
+**
+*******************************************************************************/
+void BTM_BleEnhReceiverTest(UINT8 rx_freq, UINT8 phy, UINT8 mod_index,
+                              tBTM_CMPL_CB *p_cmd_cmpl_cback)
+{
+     btm_cb.devcb.p_le_test_cmd_cmpl_cb = p_cmd_cmpl_cback;
+
+     if (btsnd_hcic_ble_enh_receiver_test(rx_freq, phy, mod_index) == FALSE)
+     {
+          BTM_TRACE_ERROR("%s: Unable to Trigger LE Enhanced receiver test",
+                               __FUNCTION__);
+     }
+}
+
+/*******************************************************************************
+**
 ** Function         BTM_BleTransmitterTest
 **
 ** Description      This function is called to start the LE Transmitter test
@@ -773,6 +834,32 @@ void BTM_BleTransmitterTest(UINT8 tx_freq, UINT8 test_data_len,
 
 /*******************************************************************************
 **
+** Function         BTM_BleEnhTransmitterTest
+**
+** Description      This function is called to start the LE Enhanced Transmitter test
+**
+** Parameter        tx_freq - Frequency Range
+**                  test_data_len - Length in bytes of payload data in each packet
+**                  packet_payload - Pattern to use in the payload
+**                  phy - Phy to be used
+**                  p_cmd_cmpl_cback - Command Complete callback
+**
+*******************************************************************************/
+void BTM_BleEnhTransmitterTest(UINT8 tx_freq, UINT8 test_data_len,
+                                 UINT8 packet_payload, UINT8 phy,
+                                 tBTM_CMPL_CB *p_cmd_cmpl_cback)
+{
+     btm_cb.devcb.p_le_test_cmd_cmpl_cb = p_cmd_cmpl_cback;
+     if (btsnd_hcic_ble_enh_transmitter_test(tx_freq, test_data_len,
+              packet_payload, phy) == FALSE)
+     {
+          BTM_TRACE_ERROR("%s: Unable to Trigger LE Enhanced transmitter test",
+                               __FUNCTION__);
+     }
+}
+
+/*******************************************************************************
+**
 ** Function         BTM_BleTestEnd
 **
 ** Description      This function is called to stop the in-progress TX or RX test
@@ -849,6 +936,8 @@ BOOLEAN BTM_UseLeLink (BD_ADDR bd_addr)
 tBTM_STATUS BTM_SetBleDataLength(BD_ADDR bd_addr, UINT16 tx_pdu_length)
 {
     tACL_CONN *p_acl = btm_bda_to_acl(bd_addr, BT_TRANSPORT_LE);
+    UINT16 tx_time = BTM_BLE_DATA_TX_TIME_MAX_LEGACY;
+
     BTM_TRACE_DEBUG("%s: tx_pdu_length =%d", __FUNCTION__, tx_pdu_length);
 
     if (!controller_get_interface()->supports_ble_packet_extension())
@@ -870,9 +959,11 @@ tBTM_STATUS BTM_SetBleDataLength(BD_ADDR bd_addr, UINT16 tx_pdu_length)
         else if (tx_pdu_length < BTM_BLE_DATA_SIZE_MIN)
             tx_pdu_length =  BTM_BLE_DATA_SIZE_MIN;
 
+        if (controller_get_interface()->get_bt_version()->hci_version >= HCI_PROTO_VERSION_5_0)
+            tx_time = BTM_BLE_DATA_TX_TIME_MAX;
+
         /* always set the TxTime to be max, as controller does not care for now */
-        btsnd_hcic_ble_set_data_length(p_acl->hci_handle, tx_pdu_length,
-                                            BTM_BLE_DATA_TX_TIME_MAX);
+        btsnd_hcic_ble_set_data_length(p_acl->hci_handle, tx_pdu_length, tx_time);
 
         return BTM_SUCCESS;
     }
@@ -974,6 +1065,47 @@ tBTM_SEC_ACTION btm_ble_determine_security_act(BOOLEAN is_originator, BD_ADDR bd
 
 /*******************************************************************************
 **
+** Function         BTM_SetBlePhy
+**
+** Description      This function is to set BLE tx and rx PHY
+**
+** Returns          BTM_SUCCESS if success; otherwise failed.
+**
+*******************************************************************************/
+tBTM_STATUS BTM_SetBlePhy(BD_ADDR bd_addr, UINT8 all_phy, UINT8 tx_phy,
+                          UINT8 rx_phy, UINT16 phy_options)
+{
+    tACL_CONN *p_acl = btm_bda_to_acl(bd_addr, BT_TRANSPORT_LE);
+    BTM_TRACE_DEBUG("%s: all_phy=0x%0x, tx_phy=0x%0x, rx_phy=0x%0x",
+                    __func__, all_phy, tx_phy, rx_phy);
+
+    if (!controller_get_interface()->supports_ble_two_mbps_rate())
+    {
+        BTM_TRACE_ERROR("%s failed, request not supported", __func__);
+        return BTM_ILLEGAL_VALUE;
+    }
+
+    if ((p_acl != NULL) && (!HCI_LE_TWO_MBPS_SUPPORTED(p_acl->peer_le_features)))
+    {
+        BTM_TRACE_ERROR("%s failed, peer does not support request", __func__);
+        return BTM_ILLEGAL_VALUE;
+    }
+
+    if (p_acl != NULL)
+    {
+        btsnd_hcic_ble_set_data_rate (p_acl->hci_handle, all_phy, tx_phy,
+                                      rx_phy, phy_options);
+        return BTM_SUCCESS;
+    }
+    else
+    {
+        BTM_TRACE_ERROR("%s: Wrong mode: no LE link exist or LE not supported",__func__);
+        return BTM_WRONG_MODE;
+    }
+}
+
+/*******************************************************************************
+**
 ** Function         btm_ble_start_sec_check
 **
 ** Description      This function is to check and set the security required for
@@ -1048,6 +1180,30 @@ BOOLEAN btm_ble_start_sec_check(BD_ADDR bd_addr, UINT16 psm, BOOLEAN is_originat
 
 /*******************************************************************************
 **
+** Function         BTM_SetDefaultBlePhy
+**
+** Description      This function is to set default BLE tx and rx PHY
+**
+** Returns          BTM_SUCCESS if success; otherwise failed.
+**
+*******************************************************************************/
+tBTM_STATUS BTM_SetDefaultBlePhy(UINT8 all_phy, UINT8 tx_phy, UINT8 rx_phy)
+{
+    BTM_TRACE_DEBUG("%s: all_phy=0x%0x, tx_phy=0x%0x, rx_phy=0x%0x",
+                    __func__, all_phy, tx_phy, rx_phy);
+
+    if (!controller_get_interface()->supports_ble_two_mbps_rate())
+    {
+        BTM_TRACE_ERROR("%s failed, request not supported", __func__);
+        return BTM_ILLEGAL_VALUE;
+    }
+
+    btsnd_hcic_ble_set_default_data_rate (all_phy, tx_phy, rx_phy);
+    return BTM_SUCCESS;
+}
+
+/*******************************************************************************
+**
 ** Function         btm_ble_rand_enc_complete
 **
 ** Description      This function is the callback functions for HCI_Rand command
@@ -1802,21 +1958,30 @@ UINT8 btm_ble_br_keys_req(tBTM_SEC_DEV_REC *p_dev_rec, tBTM_LE_IO_REQ *p_data)
 ** Returns          void
 **
 *******************************************************************************/
-static void btm_ble_resolve_random_addr_on_conn_cmpl(void * p_rec, void *p_data)
+static void btm_ble_resolve_random_addr_on_conn_cmpl(void * p_rec, void *p_data, BOOLEAN extended)
 {
     UINT8   *p = (UINT8 *)p_data;
     tBTM_SEC_DEV_REC    *match_rec = (tBTM_SEC_DEV_REC *) p_rec;
-    UINT8       role, bda_type;
+    UINT8       role, bda_type, sub_code;
     UINT16      handle;
     BD_ADDR     bda;
+    BD_ADDR     local_rpa, peer_rpa;
     UINT16      conn_interval, conn_latency, conn_timeout;
     BOOLEAN     match = FALSE;
+    UNUSED(extended);
 
+    --p;
+    STREAM_TO_UINT8(sub_code, p);
     ++p;
     STREAM_TO_UINT16   (handle, p);
     STREAM_TO_UINT8    (role, p);
     STREAM_TO_UINT8    (bda_type, p);
     STREAM_TO_BDADDR   (bda, p);
+    if (sub_code == BTM_BLE_ENHC_CONN_SUB_CODE)
+    {
+        STREAM_TO_BDADDR   (local_rpa, p);
+        STREAM_TO_BDADDR   (peer_rpa, p);
+    }
     STREAM_TO_UINT16   (conn_interval, p);
     STREAM_TO_UINT16   (conn_latency, p);
     STREAM_TO_UINT16   (conn_timeout, p);
@@ -1970,7 +2135,7 @@ void btm_ble_conn_complete(UINT8 *p, UINT16 evt_len, BOOLEAN enhanced)
            the device has been paired */
         if (!match && BTM_BLE_IS_RESOLVE_BDA(bda))
         {
-            btm_ble_resolve_random_addr(bda, btm_ble_resolve_random_addr_on_conn_cmpl, p_data);
+            btm_ble_resolve_random_addr(bda, btm_ble_resolve_random_addr_on_conn_cmpl, p_data, FALSE);
         }
         else
 #endif
@@ -1985,16 +2150,16 @@ void btm_ble_conn_complete(UINT8 *p, UINT16 evt_len, BOOLEAN enhanced)
             l2cble_conn_comp (handle, role, bda, bda_type, conn_interval,
                               conn_latency, conn_timeout);
 
+        }
 #if (BLE_PRIVACY_SPT == TRUE)
-            if (enhanced)
-            {
-                btm_ble_refresh_local_resolvable_private_addr(bda, local_rpa);
+        if (enhanced)
+        {
+            btm_ble_refresh_local_resolvable_private_addr(bda, local_rpa);
 
-                if (peer_addr_type & BLE_ADDR_TYPE_ID_BIT)
-                    btm_ble_refresh_peer_resolvable_private_addr(bda, peer_rpa, BLE_ADDR_RANDOM);
-            }
-#endif
+            if (peer_addr_type & BLE_ADDR_TYPE_ID_BIT)
+                btm_ble_refresh_peer_resolvable_private_addr(bda, peer_rpa, BLE_ADDR_RANDOM);
         }
+#endif
     }
     else
     {
@@ -2084,7 +2249,7 @@ UINT8 btm_proc_smp_cback(tSMP_EVT event, BD_ADDR bd_addr, tSMP_EVT_DATA *p_data)
                    (*btm_cb.api.p_le_callback) (event, bd_addr, (tBTM_LE_EVT_DATA *)p_data);
                 }
 
-                if (event == SMP_COMPLT_EVT)
+                if (event == SMP_COMPLT_EVT && !p_data->cmplt.smp_over_br)
                 {
                     BTM_TRACE_DEBUG ("evt=SMP_COMPLT_EVT before update sec_level=0x%x sec_flags=0x%x", p_data->cmplt.sec_level , p_dev_rec->sec_flags );
 
@@ -2117,6 +2282,7 @@ UINT8 btm_proc_smp_cback(tSMP_EVT event, BD_ADDR bd_addr, tSMP_EVT_DATA *p_data)
                     {
                         BTM_TRACE_DEBUG ("Pairing failed - prepare to remove ACL");
                         l2cu_start_post_bond_timer(p_dev_rec->ble_hci_handle);
+                        GENERATE_VENDOR_LOGS();
                     }
 #endif
 
@@ -2684,6 +2850,47 @@ void btm_ble_reset_id( void )
     }
 }
 
+/*******************************************************************************
+**
+** Function         btm_ble_set_random_address
+**
+** Description      This function set a random address to local controller.
+**                  It also temporarily disable scans and adv before sending
+**                  the command to the controller
+**
+** Returns          void
+**
+*******************************************************************************/
+void btm_ble_set_random_address(BD_ADDR random_bda)
+{
+    tBTM_LE_RANDOM_CB *p_cb = &btm_cb.ble_ctr_cb.addr_mgnt_cb;
+    tBTM_BLE_CB *p_ble_cb = &btm_cb.ble_ctr_cb;
+    BOOLEAN     adv_mode = btm_cb.ble_ctr_cb.inq_var.adv_mode;
+
+    BTM_TRACE_DEBUG ("%s", __func__);
+    if (btm_ble_get_conn_st() == BLE_DIR_CONN)
+    {
+        BTM_TRACE_ERROR("%s: Cannot set random address. Direct conn ongoing", __func__);
+        return;
+    }
+
+    if (adv_mode  == BTM_BLE_ADV_ENABLE)
+        btsnd_hcic_ble_set_adv_enable (BTM_BLE_ADV_DISABLE);
+    if (BTM_BLE_IS_SCAN_ACTIVE(p_ble_cb->scan_activity))
+        btm_ble_stop_scan();
+    btm_ble_suspend_bg_conn();
+
+    memcpy(p_cb->private_addr, random_bda, BD_ADDR_LEN);
+    btsnd_hcic_ble_set_random_addr(p_cb->private_addr);
+
+    if (adv_mode  == BTM_BLE_ADV_ENABLE)
+        btsnd_hcic_ble_set_adv_enable (BTM_BLE_ADV_ENABLE);
+    if (BTM_BLE_IS_SCAN_ACTIVE(p_ble_cb->scan_activity))
+        btm_ble_start_scan();
+    btm_ble_resume_bg_conn();
+
+}
+
     #if BTM_BLE_CONFORMANCE_TESTING == TRUE
 /*******************************************************************************
 **
diff --git a/stack/btm/btm_ble_addr.c b/stack/btm/btm_ble_addr.c
index 81fff53..b1b7167 100644
--- a/stack/btm/btm_ble_addr.c
+++ b/stack/btm/btm_ble_addr.c
@@ -60,7 +60,7 @@ static void btm_gen_resolve_paddr_cmpl(tSMP_ENC *p)
         p_cb->private_addr[4] = p->param_buf[1];
         p_cb->private_addr[3] = p->param_buf[2];
         /* set it to controller */
-        btsnd_hcic_ble_set_random_addr(p_cb->private_addr);
+        btm_ble_set_random_address(p_cb->private_addr);
 
         p_cb->own_addr_type = BLE_ADDR_RANDOM;
 
@@ -356,7 +356,7 @@ static BOOLEAN btm_ble_match_random_bda(void *data, void *context)
 **                  address is matched to.
 **
 *******************************************************************************/
-void btm_ble_resolve_random_addr(BD_ADDR random_bda, tBTM_BLE_RESOLVE_CBACK * p_cback, void *p)
+void btm_ble_resolve_random_addr(BD_ADDR random_bda, tBTM_BLE_RESOLVE_CBACK * p_cback, void *p, BOOLEAN extended)
 {
     tBTM_LE_RANDOM_CB   *p_mgnt_cb = &btm_cb.ble_ctr_cb.addr_mgnt_cb;
 
@@ -365,6 +365,7 @@ void btm_ble_resolve_random_addr(BD_ADDR random_bda, tBTM_BLE_RESOLVE_CBACK * p_
         p_mgnt_cb->p = p;
         p_mgnt_cb->busy = TRUE;
         memcpy(p_mgnt_cb->random_bda, random_bda, BD_ADDR_LEN);
+        p_mgnt_cb->extended = extended;
         /* start to resolve random address */
         /* check for next security record */
 
@@ -374,9 +375,9 @@ void btm_ble_resolve_random_addr(BD_ADDR random_bda, tBTM_BLE_RESOLVE_CBACK * p_
         BTM_TRACE_EVENT("%s:  %sresolved", __func__, (p_dev_rec == NULL ? "not " : ""));
         p_mgnt_cb->busy = FALSE;
 
-        (*p_cback)(p_dev_rec, p);
+        (*p_cback)(p_dev_rec, p, extended);
     } else {
-        (*p_cback)(NULL, p);
+        (*p_cback)(NULL, p, extended);
     }
 }
 #endif
@@ -463,7 +464,8 @@ BOOLEAN btm_random_pseudo_to_identity_addr(BD_ADDR random_pseudo, UINT8 *p_stati
         {
             * p_static_addr_type = p_dev_rec->ble.static_addr_type;
             memcpy(random_pseudo, p_dev_rec->ble.static_addr, BD_ADDR_LEN);
-            if (controller_get_interface()->supports_ble_privacy())
+            if (controller_get_interface()->supports_ble_privacy() &&
+                !controller_get_interface()->supports_ble_extended_advertisements())
                 *p_static_addr_type |= BLE_ADDR_TYPE_ID_BIT;
             return TRUE;
         }
diff --git a/stack/btm/btm_ble_batchscan.c b/stack/btm/btm_ble_batchscan.c
index 95609de..2b329b5 100644
--- a/stack/btm/btm_ble_batchscan.c
+++ b/stack/btm/btm_ble_batchscan.c
@@ -123,6 +123,10 @@ void btm_ble_batchscan_filter_track_adv_vse_cback(UINT8 len, UINT8 *p)
 
         BTM_TRACE_EVENT("track_adv_vse_cback called: %d, %d, %d", adv_data.filt_index,
                          adv_data.addr_type, adv_data.advertiser_state);
+
+        // Make sure the device is known
+        BTM_SecAddBleDevice(adv_data.bd_addr.address, NULL, BT_DEVICE_TYPE_BLE, adv_data.addr_type);
+
         ble_advtrack_cb.p_track_cback(&adv_data);
         return;
     }
diff --git a/stack/btm/btm_ble_bgconn.c b/stack/btm/btm_ble_bgconn.c
index 0d12f7e..3dd01bc 100644
--- a/stack/btm/btm_ble_bgconn.c
+++ b/stack/btm/btm_ble_bgconn.c
@@ -126,18 +126,32 @@ void btm_update_scanner_filter_policy(tBTM_BLE_SFP scan_policy)
     p_inq->sfp = scan_policy;
     p_inq->scan_type = p_inq->scan_type == BTM_BLE_SCAN_MODE_NONE ? BTM_BLE_SCAN_MODE_ACTI : p_inq->scan_type;
 
-    if (btm_cb.cmn_ble_vsc_cb.extended_scan_support == 0)
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
     {
-        btsnd_hcic_ble_set_scan_params(p_inq->scan_type, (UINT16)scan_interval,
-                                       (UINT16)scan_window,
-                                       btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
-                                       scan_policy);
+        btsnd_hcic_ble_set_extended_scan_params(1 /*LE 1M PHY*/, p_inq->scan_type, (UINT16)scan_interval,
+                                                (UINT16)scan_window,
+                                                (UINT16)scan_interval,
+                                                (UINT16)scan_window,
+                                                btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                                BTM_BLE_DEFAULT_SFP);
     }
     else
+#endif
     {
-        btm_ble_send_extended_scan_params(p_inq->scan_type, scan_interval, scan_window,
-                                          btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
-                                          scan_policy);
+        if (btm_cb.cmn_ble_vsc_cb.extended_scan_support == 0)
+        {
+            btsnd_hcic_ble_set_scan_params(p_inq->scan_type, (UINT16)scan_interval,
+                                           (UINT16)scan_window,
+                                           btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                           scan_policy);
+        }
+        else
+        {
+            btm_ble_send_extended_scan_params(p_inq->scan_type, scan_interval, scan_window,
+                                              btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                              scan_policy);
+        }
     }
 }
 /*******************************************************************************
@@ -390,30 +404,61 @@ BOOLEAN btm_ble_start_auto_conn(BOOLEAN start)
                     && controller_get_interface()->supports_ble_privacy())
             {
                 own_addr_type |= BLE_ADDR_TYPE_ID_BIT;
-                peer_addr_type |= BLE_ADDR_TYPE_ID_BIT;
+                if (!controller_get_interface()->supports_ble_extended_advertisements())
+                {
+                    peer_addr_type |= BLE_ADDR_TYPE_ID_BIT;
+                }
             }
 #endif
-
-            if (!btsnd_hcic_ble_create_ll_conn (scan_int,  /* UINT16 scan_int      */
-                                                scan_win,    /* UINT16 scan_win      */
-                                                0x01,                   /* UINT8 white_list     */
-                                                peer_addr_type,        /* UINT8 addr_type_peer */
-                                                dummy_bda,              /* BD_ADDR bda_peer     */
-                                                own_addr_type,          /* UINT8 addr_type_own */
-                                                BTM_BLE_CONN_INT_MIN_DEF,   /* UINT16 conn_int_min  */
-                                                BTM_BLE_CONN_INT_MAX_DEF,   /* UINT16 conn_int_max  */
-                                                BTM_BLE_CONN_SLAVE_LATENCY_DEF,  /* UINT16 conn_latency  */
-                                                BTM_BLE_CONN_TIMEOUT_DEF,        /* UINT16 conn_timeout  */
-                                                0,                       /* UINT16 min_len       */
-                                                0))                      /* UINT16 max_len       */
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+            if (controller_get_interface()->supports_ble_extended_advertisements())
             {
-                /* start auto connection failed */
-                exec =  FALSE;
-                p_cb->wl_state &= ~BTM_BLE_WL_INIT;
+                if (!btsnd_hcic_ble_ext_create_ll_conn (1 /*LE 1M PHY*/, scan_int,  /* UINT16 scan_int      */
+                                                    scan_win,    /* UINT16 scan_win      */
+                                                    0x01,                   /* UINT8 white_list     */
+                                                    peer_addr_type,        /* UINT8 addr_type_peer */
+                                                    dummy_bda,              /* BD_ADDR bda_peer     */
+                                                    own_addr_type,          /* UINT8 addr_type_own */
+                                                    BTM_BLE_CONN_INT_MIN_DEF,   /* UINT16 conn_int_min  */
+                                                    BTM_BLE_CONN_INT_MAX_DEF,   /* UINT16 conn_int_max  */
+                                                    BTM_BLE_CONN_SLAVE_LATENCY_DEF,  /* UINT16 conn_latency  */
+                                                    BTM_BLE_CONN_TIMEOUT_DEF,        /* UINT16 conn_timeout  */
+                                                    0,                       /* UINT16 min_len       */
+                                                    0))                      /* UINT16 max_len       */
+                {
+                    /* start auto connection failed */
+                    exec =  FALSE;
+                    p_cb->wl_state &= ~BTM_BLE_WL_INIT;
+                }
+                else
+                {
+                    btm_ble_set_conn_st (BLE_BG_CONN);
+                }
             }
             else
+#endif
             {
-                btm_ble_set_conn_st (BLE_BG_CONN);
+                if (!btsnd_hcic_ble_create_ll_conn (scan_int,  /* UINT16 scan_int      */
+                                                    scan_win,    /* UINT16 scan_win      */
+                                                    0x01,                   /* UINT8 white_list     */
+                                                    peer_addr_type,        /* UINT8 addr_type_peer */
+                                                    dummy_bda,              /* BD_ADDR bda_peer     */
+                                                    own_addr_type,          /* UINT8 addr_type_own */
+                                                    BTM_BLE_CONN_INT_MIN_DEF,   /* UINT16 conn_int_min  */
+                                                    BTM_BLE_CONN_INT_MAX_DEF,   /* UINT16 conn_int_max  */
+                                                    BTM_BLE_CONN_SLAVE_LATENCY_DEF,  /* UINT16 conn_latency  */
+                                                    BTM_BLE_CONN_TIMEOUT_DEF,        /* UINT16 conn_timeout  */
+                                                    0,                       /* UINT16 min_len       */
+                                                    0))                      /* UINT16 max_len       */
+                {
+                    /* start auto connection failed */
+                    exec =  FALSE;
+                    p_cb->wl_state &= ~BTM_BLE_WL_INIT;
+                }
+                else
+                {
+                    btm_ble_set_conn_st (BLE_BG_CONN);
+                }
             }
         }
         else
@@ -472,27 +517,41 @@ BOOLEAN btm_ble_start_select_conn(BOOLEAN start, tBTM_BLE_SEL_CBACK *p_select_cb
             btm_cb.ble_ctr_cb.inq_var.scan_type = BTM_BLE_SCAN_MODE_PASS;
 
             /* Process advertising packets only from devices in the white list */
-            if (btm_cb.cmn_ble_vsc_cb.extended_scan_support == 0)
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+            if (controller_get_interface()->supports_ble_extended_advertisements())
             {
-                /* use passive scan by default */
-                if (!btsnd_hcic_ble_set_scan_params(BTM_BLE_SCAN_MODE_PASS,
-                                                    scan_int,
-                                                    scan_win,
-                                                    p_cb->addr_mgnt_cb.own_addr_type,
-                                                    SP_ADV_WL))
-                {
-                    return FALSE;
-                }
+                btsnd_hcic_ble_set_extended_scan_params(1 /*LE 1M PHY*/, BTM_BLE_SCAN_MODE_PASS, scan_int,
+                                                        scan_win,
+                                                        scan_int,
+                                                        scan_win,
+                                                        p_cb->addr_mgnt_cb.own_addr_type,
+                                                        SP_ADV_WL);
             }
             else
+#endif
             {
-                if (!btm_ble_send_extended_scan_params(BTM_BLE_SCAN_MODE_PASS,
-                                                       scan_int,
-                                                       scan_win,
-                                                       p_cb->addr_mgnt_cb.own_addr_type,
-                                                       SP_ADV_WL))
+                if (btm_cb.cmn_ble_vsc_cb.extended_scan_support == 0)
                 {
-                    return FALSE;
+                    /* use passive scan by default */
+                    if (!btsnd_hcic_ble_set_scan_params(BTM_BLE_SCAN_MODE_PASS,
+                                                        scan_int,
+                                                        scan_win,
+                                                        p_cb->addr_mgnt_cb.own_addr_type,
+                                                        SP_ADV_WL))
+                    {
+                        return FALSE;
+                    }
+                }
+                else
+                {
+                    if (!btm_ble_send_extended_scan_params(BTM_BLE_SCAN_MODE_PASS,
+                                                           scan_int,
+                                                           scan_win,
+                                                           p_cb->addr_mgnt_cb.own_addr_type,
+                                                           SP_ADV_WL))
+                    {
+                        return FALSE;
+                    }
                 }
             }
 
@@ -506,8 +565,18 @@ BOOLEAN btm_ble_start_select_conn(BOOLEAN start, tBTM_BLE_SEL_CBACK *p_select_cb
 #if BLE_PRIVACY_SPT == TRUE
                 btm_ble_enable_resolving_list_for_platform(BTM_BLE_RL_SCAN);
 #endif
-                if (!btsnd_hcic_ble_set_scan_enable(TRUE, TRUE)) /* duplicate filtering enabled */
-                     return FALSE;
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+                if (controller_get_interface()->supports_ble_extended_advertisements())
+                {
+                    if (!btsnd_hcic_ble_set_extended_scan_enable(TRUE,TRUE, 0, 0))
+                        return FALSE;
+                }
+                else
+#endif
+                {
+                    if (!btsnd_hcic_ble_set_scan_enable(TRUE, TRUE)) /* duplicate filtering enabled */
+                        return FALSE;
+                }
 
                  /* mark up inquiry status flag */
                  p_cb->scan_activity |= BTM_LE_SELECT_CONN_ACTIVE;
diff --git a/stack/btm/btm_ble_gap.c b/stack/btm/btm_ble_gap.c
index c366e00..1a1ddf8 100644
--- a/stack/btm/btm_ble_gap.c
+++ b/stack/btm/btm_ble_gap.c
@@ -45,6 +45,7 @@
 #include "gattdefs.h"
 #include "l2c_int.h"
 #include "osi/include/log.h"
+#include "osi/include/time.h"
 
 #define BTM_BLE_NAME_SHORT                  0x01
 #define BTM_BLE_NAME_CMPL                   0x02
@@ -65,13 +66,15 @@ static tBTM_BLE_VSC_CB cmn_ble_vsc_cb;
 static tBTM_BLE_CTRL_FEATURES_CBACK    *p_ctrl_le_feature_rd_cmpl_cback = NULL;
 #endif
 
+static tBTM_BLE_CTRL_FEATURES_CBACK    *p_ext_adv_ctrl_le_feature_rd_cmpl_cback = NULL;
+
 /*******************************************************************************
 **  Local functions
 *******************************************************************************/
 static void btm_ble_update_adv_flag(UINT8 flag);
-static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt_type, UINT8 *p);
+static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT16 evt_type, UINT8 *p, BOOLEAN extended);
 UINT8 *btm_ble_build_adv_data(tBTM_BLE_AD_MASK *p_data_mask, UINT8 **p_dst,
-                              tBTM_BLE_ADV_DATA *p_data);
+                              tBTM_BLE_ADV_DATA *p_data, UINT16 max_len);
 static UINT8 btm_set_conn_mode_adv_init_addr(tBTM_BLE_INQ_CB *p_cb,
                                      BD_ADDR_PTR p_peer_addr_ptr,
                                      tBLE_ADDR_TYPE *p_peer_addr_type,
@@ -351,17 +354,21 @@ BOOLEAN btm_ble_send_extended_scan_params(UINT8 scan_type, UINT32 scan_int,
 ** Returns          void
 **
 *******************************************************************************/
-tBTM_STATUS BTM_BleObserve(BOOLEAN start, UINT8 duration,
+tBTM_STATUS BTM_BleObserve(BOOLEAN start, UINT16 duration, UINT16 period,
                            tBTM_INQ_RESULTS_CB *p_results_cb, tBTM_CMPL_CB *p_cmpl_cb)
 {
     tBTM_BLE_INQ_CB *p_inq = &btm_cb.ble_ctr_cb.inq_var;
     tBTM_STATUS status = BTM_WRONG_MODE;
 
-    UINT32 scan_interval = !p_inq->scan_interval ? BTM_BLE_GAP_DISC_SCAN_INT : p_inq->scan_interval;
-    UINT32 scan_window = !p_inq->scan_window ? BTM_BLE_GAP_DISC_SCAN_WIN : p_inq->scan_window;
+    UINT16 scan_interval = !p_inq->scan_interval ? BTM_BLE_GAP_DISC_SCAN_INT : p_inq->scan_interval;
+    UINT16 scan_window = !p_inq->scan_window ? BTM_BLE_GAP_DISC_SCAN_WIN : p_inq->scan_window;
+
+    p_inq->scan_duration = duration;
+    p_inq->scan_period = period;
 
-    BTM_TRACE_EVENT ("%s : scan_type:%d, %d, %d", __func__, btm_cb.btm_inq_vars.scan_type,
-                      p_inq->scan_interval, p_inq->scan_window);
+    BTM_TRACE_EVENT ("%s : scan_type:%d, scan_interval_phy1 ::%d, scan_window_phy1::%d scan_interval_phy2 ::%d, scan_window_phy2:: %d",
+                __func__, btm_cb.btm_inq_vars.scan_type,
+                scan_interval, scan_window, p_inq->scan_interval_coded, p_inq->scan_window_coded);
 
     if (!controller_get_interface()->supports_ble())
         return BTM_ILLEGAL_VALUE;
@@ -391,18 +398,32 @@ tBTM_STATUS BTM_BleObserve(BOOLEAN start, UINT8 duration,
                 btm_ble_enable_resolving_list_for_platform(BTM_BLE_RL_SCAN);
             #endif
 
-            if (cmn_ble_vsc_cb.extended_scan_support == 0)
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+            if (controller_get_interface()->supports_ble_extended_advertisements())
             {
-                btsnd_hcic_ble_set_scan_params(p_inq->scan_type, (UINT16)scan_interval,
-                                               (UINT16)scan_window,
-                                               btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
-                                               BTM_BLE_DEFAULT_SFP);
+                btsnd_hcic_ble_set_extended_scan_params(p_inq->scan_phys, p_inq->scan_type, (UINT16)scan_interval,
+                                                        (UINT16)scan_window,
+                                                        p_inq->scan_interval_coded,
+                                                        p_inq->scan_window_coded,
+                                                        btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                                        BTM_BLE_DEFAULT_SFP);
             }
             else
+#endif
             {
-                btm_ble_send_extended_scan_params(p_inq->scan_type, scan_interval, scan_window,
-                                                  btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
-                                                  BTM_BLE_DEFAULT_SFP);
+                if (cmn_ble_vsc_cb.extended_scan_support == 0)
+                {
+                    btsnd_hcic_ble_set_scan_params(p_inq->scan_type, (UINT16)scan_interval,
+                                                   (UINT16)scan_window,
+                                                   btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                                   BTM_BLE_DEFAULT_SFP);
+                }
+                else
+                {
+                    btm_ble_send_extended_scan_params(p_inq->scan_type, scan_interval, scan_window,
+                                                      btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                                      BTM_BLE_DEFAULT_SFP);
+                }
             }
 
             p_inq->scan_duplicate_filter = BTM_BLE_DUPLICATE_DISABLE;
@@ -557,8 +578,13 @@ static void btm_ble_vendor_capability_vsc_cmpl_cback (tBTM_VSC_CMPL *p_vcs_cplt_
          btm_cb.cmn_ble_vsc_cb.adv_inst_max, btm_cb.cmn_ble_vsc_cb.rpa_offloading,
          btm_cb.cmn_ble_vsc_cb.energy_support, btm_cb.cmn_ble_vsc_cb.extended_scan_support);
 
-    if (BTM_BleMaxMultiAdvInstanceCount() > 0)
-        btm_ble_multi_adv_init();
+    if ((btm_cb.cmn_ble_vsc_cb.adv_inst_max > 0)
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        &&
+        (controller_get_interface()->get_ble_adv_ext_size() == 0)
+#endif
+       )
+        btm_ble_multi_adv_init(btm_cb.cmn_ble_vsc_cb.adv_inst_max);
 
     if (btm_cb.cmn_ble_vsc_cb.max_filter > 0)
         btm_ble_adv_filter_init();
@@ -599,6 +625,25 @@ extern void BTM_BleGetVendorCapabilities(tBTM_BLE_VSC_CB *p_cmn_vsc_cb)
     }
 }
 
+/*******************************************************************************
+**
+** Function         BTM_BleGetAdvExtCapabilities
+**
+** Description      This function reads local LE features
+**
+** Parameters       p_cmn_vsc_cb : Locala LE capability structure
+**
+** Returns          void
+**
+*******************************************************************************/
+extern void BTM_BleGetAdvExtCapabilities(tBTM_BLE_ADV_EXT_CB *p_ble_adv_ext_cb)
+{
+    BTM_TRACE_DEBUG("BTM_BleGetAdvExtCapabilities");
+
+    if (NULL != p_ble_adv_ext_cb)
+        *p_ble_adv_ext_cb = btm_cb.ble_adv_ext_cb;
+}
+
 /******************************************************************************
 **
 ** Function         BTM_BleReadControllerFeatures
@@ -633,6 +678,69 @@ extern void BTM_BleReadControllerFeatures(tBTM_BLE_CTRL_FEATURES_CBACK  *p_vsc_c
     return ;
 }
 
+/******************************************************************************
+**
+** Function         BTM_BleReadExtAdvControllerFeatures
+**
+** Description      Reads BLE specific controller features
+**
+** Parameters:      tBTM_BLE_CTRL_FEATURES_CBACK : Callback to notify when features are read
+**
+** Returns          void
+**
+*******************************************************************************/
+extern void BTM_BleReadExtAdvControllerFeatures(tBTM_BLE_CTRL_FEATURES_CBACK  *p_vsc_cback)
+{
+
+    BTM_TRACE_DEBUG("BTM_BleReadExtAdvControllerFeatures");
+
+    p_ext_adv_ctrl_le_feature_rd_cmpl_cback = p_vsc_cback;
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
+    {
+        btm_ble_extended_configure_inst_size();
+    }
+#endif
+
+    return ;
+}
+
+/*******************************************************************************
+**
+** Function         btm_ble_read_inst_length_complete
+**
+** Description      This function is a callback event of read instance length
+**
+** Returns          void
+**
+*******************************************************************************/
+
+void btm_ble_read_inst_length_complete(UINT8* p, UINT16 evt_len)
+{
+    UINT8 status;
+    UINT16 inst_len;
+
+    UNUSED(evt_len);
+
+    STREAM_TO_UINT8 (status, p);
+
+    if (status != HCI_SUCCESS)
+    {
+        BTM_TRACE_ERROR ("%s, HCI command failure", __func__);
+        return;
+    }
+
+    STREAM_TO_UINT16 (inst_len, p);
+
+    BTM_TRACE_EVENT ("%s, status: %d, inst size = %d", __func__, status, inst_len);
+    btm_ble_update_multi_adv_inst_data_length(inst_len);
+
+    btm_cb.ble_adv_ext_cb.adv_inst_max = controller_get_interface()->get_ble_adv_ext_size();
+    btm_cb.ble_adv_ext_cb.adv_data_len_max = inst_len;
+    if (p_ext_adv_ctrl_le_feature_rd_cmpl_cback != NULL)
+        p_ext_adv_ctrl_le_feature_rd_cmpl_cback(status);
+}
+
 /*******************************************************************************
 **
 ** Function         BTM_BleEnableMixedPrivacyMode
@@ -723,8 +831,13 @@ BOOLEAN BTM_BleConfigPrivacy(BOOLEAN privacy_mode)
 *******************************************************************************/
 extern UINT8  BTM_BleMaxMultiAdvInstanceCount(void)
 {
-    return btm_cb.cmn_ble_vsc_cb.adv_inst_max < BTM_BLE_MULTI_ADV_MAX ?
-        btm_cb.cmn_ble_vsc_cb.adv_inst_max : BTM_BLE_MULTI_ADV_MAX;
+    if (!controller_get_interface()->get_is_ready()) {
+        BTM_TRACE_ERROR("%s() controller interface not ready", __func__);
+        return 0;
+    }
+
+    return controller_get_interface()->get_ble_adv_ext_size() < BTM_BLE_MULTI_ADV_MAX ?
+        controller_get_interface()->get_ble_adv_ext_size() : BTM_BLE_MULTI_ADV_MAX;
 }
 
 #if BLE_PRIVACY_SPT == TRUE
@@ -737,17 +850,25 @@ extern UINT8  BTM_BleMaxMultiAdvInstanceCount(void)
 ** Returns          void
 **
 *******************************************************************************/
-static void btm_ble_resolve_random_addr_on_adv(void * p_rec, void *p)
+static void btm_ble_resolve_random_addr_on_adv(void * p_rec, void *p, BOOLEAN extended)
 {
     tBTM_SEC_DEV_REC    *match_rec = (tBTM_SEC_DEV_REC *) p_rec;
     UINT8       addr_type = BLE_ADDR_RANDOM;
     BD_ADDR     bda;
     UINT8       *pp = (UINT8 *)p + 1;
-    UINT8           evt_type;
+    UINT16      evt_type;
 
     BTM_TRACE_EVENT ("btm_ble_resolve_random_addr_on_adv ");
 
-    STREAM_TO_UINT8    (evt_type, pp);
+    if(extended)
+    {
+        STREAM_TO_UINT16    (evt_type, pp);
+    }
+    else
+    {
+        STREAM_TO_UINT8    (evt_type, pp);
+    }
+
     STREAM_TO_UINT8    (addr_type, pp);
     STREAM_TO_BDADDR   (bda, pp);
 
@@ -766,7 +887,7 @@ static void btm_ble_resolve_random_addr_on_adv(void * p_rec, void *p)
         }
     }
 
-    btm_ble_process_adv_pkt_cont(bda, addr_type, evt_type, pp);
+    btm_ble_process_adv_pkt_cont(bda, addr_type, evt_type, pp, extended);
 
     return;
 }
@@ -1143,8 +1264,9 @@ void BTM_BleReadAdvParams (UINT16 *adv_int_min, UINT16 *adv_int_max,
 ** Returns          void
 **
 *******************************************************************************/
-void BTM_BleSetScanParams(tGATT_IF client_if, UINT32 scan_interval, UINT32 scan_window,
-                          tBLE_SCAN_MODE scan_mode,
+void BTM_BleSetScanParams(tGATT_IF client_if, UINT8 scan_phys, UINT32 scan_interval,
+                          UINT32 scan_window, UINT16 scan_interval_coded,
+                          UINT16 scan_window_coded, tBLE_SCAN_MODE scan_mode,
                           tBLE_SCAN_PARAM_SETUP_CBACK scan_setup_status_cback)
 {
     tBTM_BLE_INQ_CB *p_cb = &btm_cb.ble_ctr_cb.inq_var;
@@ -1173,9 +1295,21 @@ void BTM_BleSetScanParams(tGATT_IF client_if, UINT32 scan_interval, UINT32 scan_
        (scan_mode == BTM_BLE_SCAN_MODE_ACTI || scan_mode == BTM_BLE_SCAN_MODE_PASS))
     {
         p_cb->scan_type = scan_mode;
+        p_cb->scan_phys = scan_phys;
         p_cb->scan_interval = scan_interval;
         p_cb->scan_window = scan_window;
 
+        if(scan_interval_coded > 0 && scan_window_coded >0)
+        {
+            if(BTM_BLE_ISVALID_PARAM(scan_interval_coded, BTM_BLE_SCAN_INT_MIN, max_scan_interval) &&
+            BTM_BLE_ISVALID_PARAM(scan_window_coded, BTM_BLE_SCAN_WIN_MIN, max_scan_window) &&
+            (scan_mode == BTM_BLE_SCAN_MODE_ACTI || scan_mode == BTM_BLE_SCAN_MODE_PASS))
+            {
+                p_cb->scan_interval_coded = scan_interval_coded;
+                p_cb->scan_window_coded = scan_window_coded;
+            }
+        }
+
         if (scan_setup_status_cback != NULL)
             scan_setup_status_cback(client_if, BTM_SUCCESS);
     }
@@ -1212,7 +1346,7 @@ tBTM_STATUS BTM_BleWriteScanRsp(tBTM_BLE_AD_MASK data_mask, tBTM_BLE_ADV_DATA *p
         return BTM_ILLEGAL_VALUE;
 
     memset(rsp_data, 0, BTM_BLE_AD_DATA_LEN);
-    btm_ble_build_adv_data(&data_mask, &p, p_data);
+    btm_ble_build_adv_data(&data_mask, &p, p_data, BTM_BLE_AD_DATA_LEN);
 
     if (btsnd_hcic_ble_set_scan_rsp_data((UINT8)(p - rsp_data), rsp_data))
     {
@@ -1255,7 +1389,7 @@ tBTM_STATUS BTM_BleWriteAdvData(tBTM_BLE_AD_MASK data_mask, tBTM_BLE_ADV_DATA *p
     p = p_cb_data->ad_data;
     p_cb_data->data_mask = data_mask;
 
-    p_cb_data->p_flags = btm_ble_build_adv_data(&mask, &p, p_data);
+    p_cb_data->p_flags = btm_ble_build_adv_data(&mask, &p, p_data, BTM_BLE_AD_DATA_LEN);
 
     p_cb_data->p_pad = p;
 
@@ -1287,7 +1421,7 @@ tBTM_STATUS BTM_BleWriteAdvData(tBTM_BLE_AD_MASK data_mask, tBTM_BLE_ADV_DATA *p
 ** Returns          pointer of ADV data
 **
 *******************************************************************************/
-UINT8 *BTM_CheckAdvData( UINT8 *p_adv, UINT8 type, UINT8 *p_length)
+UINT8 *BTM_CheckAdvData( UINT8 *p_adv, UINT8 type, UINT8 *p_length, UINT16 adv_data_len)
 {
     UINT8 *p = p_adv;
     UINT8 length;
@@ -1296,7 +1430,7 @@ UINT8 *BTM_CheckAdvData( UINT8 *p_adv, UINT8 type, UINT8 *p_length)
 
     STREAM_TO_UINT8(length, p);
 
-    while ( length && (p - p_adv <= BTM_BLE_CACHE_ADV_DATA_MAX))
+    while ( length && (p - p_adv <= adv_data_len))
     {
         STREAM_TO_UINT8(adv_type, p);
 
@@ -1356,12 +1490,12 @@ UINT16 BTM_BleReadConnectability()
 ** Description      This function is called build the adv data and rsp data.
 *******************************************************************************/
 UINT8 *btm_ble_build_adv_data(tBTM_BLE_AD_MASK *p_data_mask, UINT8 **p_dst,
-                              tBTM_BLE_ADV_DATA *p_data)
+                              tBTM_BLE_ADV_DATA *p_data, UINT16 max_len)
 {
     UINT32 data_mask = *p_data_mask;
     UINT8   *p = *p_dst,
     *p_flag = NULL;
-    UINT16  len = BTM_BLE_AD_DATA_LEN, cp_len = 0;
+    UINT16  len = max_len, cp_len = 0;
     UINT8   i = 0;
     tBTM_BLE_PROP_ELEM      *p_elem;
 
@@ -1987,28 +2121,63 @@ tBTM_STATUS btm_ble_start_inquiry (UINT8 mode, UINT8   duration)
 
     if (!BTM_BLE_IS_SCAN_ACTIVE(p_ble_cb->scan_activity))
     {
-        btsnd_hcic_ble_set_scan_params(BTM_BLE_SCAN_MODE_ACTI,
-                                        BTM_BLE_LOW_LATENCY_SCAN_INT,
-                                        BTM_BLE_LOW_LATENCY_SCAN_WIN,
-                                        btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
-                                        SP_ADV_ALL);
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        if (controller_get_interface()->supports_ble_extended_advertisements())
+        {
+            btsnd_hcic_ble_set_extended_scan_params(0x01 /*LE 1M */,BTM_BLE_SCAN_MODE_ACTI,
+                                BTM_BLE_LOW_LATENCY_SCAN_INT,
+                                BTM_BLE_LOW_LATENCY_SCAN_WIN,
+                                BTM_BLE_LOW_LATENCY_SCAN_INT,
+                                BTM_BLE_LOW_LATENCY_SCAN_WIN,
+                                btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                SP_ADV_ALL);
+        }
+        else
+#endif
+        {
+            btsnd_hcic_ble_set_scan_params(BTM_BLE_SCAN_MODE_ACTI,
+                                                    BTM_BLE_LOW_LATENCY_SCAN_INT,
+                                                    BTM_BLE_LOW_LATENCY_SCAN_WIN,
+                                                    btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                                    SP_ADV_ALL);
+        }
 #if (defined BLE_PRIVACY_SPT && BLE_PRIVACY_SPT == TRUE)
         /* enable IRK list */
         btm_ble_enable_resolving_list_for_platform(BTM_BLE_RL_SCAN);
 #endif
         p_ble_cb->inq_var.scan_duplicate_filter  = BTM_BLE_DUPLICATE_DISABLE;
+        p_ble_cb->inq_var.scan_duration  = 0;
+        p_ble_cb->inq_var.scan_period  = 0;
         status = btm_ble_start_scan();
     }
     else if ((p_ble_cb->inq_var.scan_interval != BTM_BLE_LOW_LATENCY_SCAN_INT) ||
             (p_ble_cb->inq_var.scan_window != BTM_BLE_LOW_LATENCY_SCAN_WIN)) {
         BTM_TRACE_DEBUG("%s, restart LE scan with low latency scan params", __FUNCTION__);
-        btsnd_hcic_ble_set_scan_enable(BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE);
-        btsnd_hcic_ble_set_scan_params(BTM_BLE_SCAN_MODE_ACTI,
-                                        BTM_BLE_LOW_LATENCY_SCAN_INT,
-                                        BTM_BLE_LOW_LATENCY_SCAN_WIN,
-                                        btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
-                                        SP_ADV_ALL);
-        btsnd_hcic_ble_set_scan_enable(BTM_BLE_SCAN_ENABLE, BTM_BLE_DUPLICATE_DISABLE);
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        if (controller_get_interface()->supports_ble_extended_advertisements())
+        {
+            btsnd_hcic_ble_set_extended_scan_enable(BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE,0/*duration*/, 0/*period*/);
+            btsnd_hcic_ble_set_extended_scan_params(0x01 /*LE 1M */,BTM_BLE_SCAN_MODE_ACTI,
+                                BTM_BLE_LOW_LATENCY_SCAN_INT,
+                                BTM_BLE_LOW_LATENCY_SCAN_WIN,
+                                BTM_BLE_LOW_LATENCY_SCAN_INT,
+                                BTM_BLE_LOW_LATENCY_SCAN_WIN,
+                                btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                SP_ADV_ALL);
+            btsnd_hcic_ble_set_extended_scan_enable(BTM_BLE_SCAN_ENABLE, BTM_BLE_DUPLICATE_DISABLE,0/*duration*/, 0/*period*/);
+        }
+        else
+#endif
+        {
+            btsnd_hcic_ble_set_scan_enable(BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE);
+            btsnd_hcic_ble_set_scan_params(BTM_BLE_SCAN_MODE_ACTI,
+                                           BTM_BLE_LOW_LATENCY_SCAN_INT,
+                                           BTM_BLE_LOW_LATENCY_SCAN_WIN,
+                                           btm_cb.ble_ctr_cb.addr_mgnt_cb.own_addr_type,
+                                           SP_ADV_ALL);
+            btsnd_hcic_ble_set_scan_enable(BTM_BLE_SCAN_ENABLE, BTM_BLE_DUPLICATE_DISABLE);
+        }
     }
 
     if (status == BTM_CMD_STARTED)
@@ -2292,36 +2461,52 @@ static void btm_ble_parse_adv_data(tBTM_INQ_INFO *p_info, UINT8 *p_data,
 ** Returns          void
 **
 *******************************************************************************/
-void btm_ble_cache_adv_data(tBTM_INQ_RESULTS *p_cur, UINT8 data_len, UINT8 *p, UINT8 evt_type)
+void btm_ble_cache_adv_data(tBTM_INQ_RESULTS *p_cur, UINT8 data_len, UINT8 *p, UINT16 evt_type, BOOLEAN extended)
 {
-    tBTM_BLE_INQ_CB     *p_le_inq_cb = &btm_cb.ble_ctr_cb.inq_var;
-    UINT8 *p_cache;
-    UINT8 length;
-    UNUSED(p_cur);
+    tBTM_BLE_INQ_DATA_CB     *p_le_inq_cb = &p_cur->inq_data;
+    UINT8 *p_adv_data_cache;
+    tBTM_BLE_INQ_CB     *p_le_adv_data_cb = &btm_cb.ble_ctr_cb.inq_var;
 
-    /* cache adv report/scan response data */
-    if (evt_type != BTM_BLE_SCAN_RSP_EVT)
+    if(p_le_inq_cb->adv_len == 0)
+    {
+        if (controller_get_interface()->supports_ble_extended_advertisements())
+        {
+            //if evt type is Extended and Complete data, then allocate 255 bytes of adv data
+            if(extended && ((evt_type & BTM_BLE_EXT_LEGACY_ADV_MASK) == 0) &&
+                    ((evt_type & BTM_BLE_EXT_ADV_EVT_DATA_MASK) == 0))
+            {
+                p_le_inq_cb->adv_data_cache = osi_calloc((sizeof(UINT8)) * (HCI_COMMAND_SIZE));
+            }
+            //if evt type is Extended and Incomplete data, then allocate controller's max supported bytes
+            else if(extended && ((evt_type & BTM_BLE_EXT_LEGACY_ADV_MASK) == 0) &&
+                    ((evt_type & BTM_BLE_EXT_ADV_EVT_DATA_INCMPL_MASK) == BTM_BLE_EXT_ADV_EVT_DATA_INCMPL_MASK))
+            {
+                p_le_inq_cb->adv_data_cache = osi_calloc(sizeof(UINT8) * (btm_cb.ble_adv_ext_cb.adv_data_len_max));
+            }
+            else
+            {
+                p_le_inq_cb->adv_data_cache = osi_calloc((sizeof(UINT8)) * (BTM_BLE_CACHE_ADV_DATA_MAX));
+            }
+        }
+        else
+            p_le_inq_cb->adv_data_cache = p_le_adv_data_cb->adv_data_cache;
+    }
+
+    /* cache adv report/scan response data ,check for only legacy adv's scan rsp evt*/
+    if (((!extended && (evt_type != BTM_BLE_SCAN_RSP_EVT)) ||
+        (extended && ((evt_type & BTM_BLE_EXT_LEGACY_ADV_MASK) == BTM_BLE_EXT_LEGACY_ADV_MASK) &&
+        ((evt_type & BTM_BLE_EXT_SCAN_RSP_EVT_MASK) != BTM_BLE_EXT_SCAN_RSP_EVT_MASK))))
     {
         p_le_inq_cb->adv_len = 0;
-        memset(p_le_inq_cb->adv_data_cache, 0, BTM_BLE_CACHE_ADV_DATA_MAX);
+        memset(p_le_inq_cb->adv_data_cache, 0, sizeof(UINT8) * (BTM_BLE_CACHE_ADV_DATA_MAX));
     }
 
-    if (data_len > 0)
+    p_adv_data_cache = &p_le_inq_cb->adv_data_cache[p_le_inq_cb->adv_len];
+
+    if(data_len > 0)
     {
-        p_cache = &p_le_inq_cb->adv_data_cache[p_le_inq_cb->adv_len];
-        STREAM_TO_UINT8(length, p);
-        while ( length && ((p_le_inq_cb->adv_len + length + 1) <= BTM_BLE_CACHE_ADV_DATA_MAX))
-        {
-            /* copy from the length byte & data into cache */
-            memcpy(p_cache, p-1, length+1);
-            /* advance the cache pointer past data */
-            p_cache += length+1;
-            /* increment cache length */
-            p_le_inq_cb->adv_len += length+1;
-            /* skip the length of data */
-            p += length;
-            STREAM_TO_UINT8(length, p);
-        }
+        p_le_inq_cb->adv_len += data_len;
+        memcpy(p_adv_data_cache, p, sizeof(UINT8) * data_len);
     }
 
     /* parse service UUID from adv packet and save it in inq db eir_uuid */
@@ -2345,10 +2530,14 @@ UINT8 btm_ble_is_discoverable(BD_ADDR bda, UINT8 evt_type, UINT8 *p)
     UINT8               *p_flag, flag = 0, rt = 0;
     UINT8                data_len;
     tBTM_INQ_PARMS      *p_cond = &btm_cb.btm_inq_vars.inqparms;
-    tBTM_BLE_INQ_CB     *p_le_inq_cb = &btm_cb.ble_ctr_cb.inq_var;
+    tBTM_BLE_INQ_DATA_CB   *p_le_inq_cb;
+    tINQ_DB_ENT          *p_i;
 
     UNUSED(p);
 
+    p_i = btm_inq_db_find (bda);
+    p_le_inq_cb = &p_i->inq_info.results.inq_data;
+
     /* for observer, always "discoverable */
     if (BTM_BLE_IS_OBS_ACTIVE(btm_cb.ble_ctr_cb.scan_activity))
         rt |= BTM_BLE_OBS_RESULT;
@@ -2368,7 +2557,7 @@ UINT8 btm_ble_is_discoverable(BD_ADDR bda, UINT8 evt_type, UINT8 *p)
     if (p_le_inq_cb->adv_len != 0)
     {
         if ((p_flag = BTM_CheckAdvData(p_le_inq_cb->adv_data_cache,
-            BTM_BLE_AD_TYPE_FLAG, &data_len)) != NULL)
+            BTM_BLE_AD_TYPE_FLAG, &data_len, p_le_inq_cb->adv_len)) != NULL)
         {
             flag = * p_flag;
 
@@ -2519,6 +2708,39 @@ static void btm_ble_appearance_to_cod(UINT16 appearance, UINT8 *dev_class)
 
 /*******************************************************************************
 **
+** Function         btm_ble_is_adv_reportable
+**
+** Description      Checks whether the adv event type is reportable to upper layers.
+**
+** Parameters
+**
+** Returns          void
+**
+*******************************************************************************/
+BOOLEAN btm_ble_is_adv_reportable(BOOLEAN extended, UINT16 evt_type)
+{
+    BOOLEAN to_report = TRUE;
+    if ((!extended && btm_cb.ble_ctr_cb.inq_var.scan_type == BTM_BLE_SCAN_MODE_ACTI &&
+        (evt_type == BTM_BLE_CONNECT_EVT || evt_type == BTM_BLE_DISCOVER_EVT)) ||
+        //Legacy adv in extended adv report, update only the scan response evt
+        (extended && btm_cb.ble_ctr_cb.inq_var.scan_type == BTM_BLE_SCAN_MODE_ACTI &&
+        ((evt_type & BTM_BLE_EXT_LEGACY_ADV_MASK) == BTM_BLE_EXT_LEGACY_ADV_MASK) &&
+        ((evt_type & BTM_BLE_EXT_SCAN_RSP_EVT_MASK) != BTM_BLE_EXT_SCAN_RSP_EVT_MASK)) ||
+        /*Non Legacy adv in extended adv report, update scan rsp evt,connectable only and
+          non connectable-non scannable adv evts */
+        (extended && btm_cb.ble_ctr_cb.inq_var.scan_type == BTM_BLE_SCAN_MODE_ACTI &&
+        ((evt_type & BTM_BLE_EXT_LEGACY_ADV_MASK) == 0) &&
+        ((evt_type & BTM_BLE_EXT_SCAN_RSP_EVT_MASK) != BTM_BLE_EXT_SCAN_RSP_EVT_MASK) &&
+        ((evt_type & BTM_BLE_EXT_CONN_ADV_MASK) != BTM_BLE_EXT_CONN_ADV_MASK) &&
+        (evt_type != 0)))
+        {
+            to_report = FALSE;
+        }
+    return to_report;
+}
+
+/*******************************************************************************
+**
 ** Function         btm_ble_update_inq_result
 **
 ** Description      Update adv packet information into inquiry result.
@@ -2528,7 +2750,7 @@ static void btm_ble_appearance_to_cod(UINT16 appearance, UINT8 *dev_class)
 ** Returns          void
 **
 *******************************************************************************/
-BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT8 evt_type, UINT8 *p)
+BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT16 evt_type, UINT8 *p, BOOLEAN extended)
 {
     BOOLEAN             to_report = TRUE;
     tBTM_INQ_RESULTS     *p_cur = &p_i->inq_info.results;
@@ -2536,30 +2758,79 @@ BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT8 evt_t
     UINT8               *p_flag;
     tBTM_INQUIRY_VAR_ST  *p_inq = &btm_cb.btm_inq_vars;
     UINT8                data_len, rssi;
-    tBTM_BLE_INQ_CB     *p_le_inq_cb = &btm_cb.ble_ctr_cb.inq_var;
     UINT8 *p1;
     UINT8               *p_uuid16;
+    UINT8                pri_phy, sec_phy, adv_sid, txpower, direct_addr_type;
+    UINT16               periodic_adv_int;
+    BD_ADDR              direct_bda;
+    tBTM_BLE_INQ_DATA_CB  *p_le_inq_cb = &p_cur->inq_data;
+    UINT8 *p_cache;
+    UINT8 length = 0;
+    UINT16 adv_data_size = 0;
+
+
+    BTM_TRACE_EVENT("btm_ble_update_inq_result evt_type= %d", evt_type);
+
+    if(extended)
+    {
+        STREAM_TO_UINT8 (pri_phy, p);
+        STREAM_TO_UINT8 (sec_phy, p);
+        STREAM_TO_UINT8 (adv_sid, p);
+        STREAM_TO_UINT8 (txpower, p);
+        STREAM_TO_UINT8 (rssi, p);
+        STREAM_TO_UINT16 (periodic_adv_int, p);
+        STREAM_TO_UINT8 (direct_addr_type, p);
+        STREAM_TO_BDADDR (direct_bda, p);
+    }
 
     STREAM_TO_UINT8    (data_len, p);
 
-    if (data_len > BTM_BLE_ADV_DATA_LEN_MAX)
+    if (!extended && (data_len > BTM_BLE_ADV_DATA_LEN_MAX))
+    {
+        BTM_TRACE_WARNING("EIR data too long for legacy adv %d. discard", data_len);
+        return FALSE;
+    }
+    else if (extended && (data_len >  btm_cb.ble_adv_ext_cb.adv_data_len_max))
+    {
+        BTM_TRACE_WARNING("Adv data too long for extended adv %d. discard", data_len);
+        return FALSE;
+    }
+
+    if(extended && ((evt_type & BTM_BLE_EXT_ADV_EVT_DATA_MASK) == BTM_BLE_EXT_ADV_EVT_DATA_INCMPL_TRUNC_MASK))
     {
-        BTM_TRACE_WARNING("EIR data too long %d. discard", data_len);
+        BTM_TRACE_WARNING("Adv data for extended adv is truncated:: discard");
+        p_le_inq_cb->adv_len = 0;
+        if (controller_get_interface()->supports_ble_extended_advertisements() && p_le_inq_cb->adv_data_cache)
+        {
+            osi_free_and_reset((void **)&p_le_inq_cb->adv_data_cache);
+            p_le_inq_cb->adv_data_cache = NULL;
+        }
+
         return FALSE;
     }
-    btm_ble_cache_adv_data(p_cur, data_len, p, evt_type);
 
-    p1 = (p + data_len);
-    STREAM_TO_UINT8 (rssi, p1);
+    btm_ble_cache_adv_data(p_cur, data_len, p, evt_type, extended);
+
+    if(!extended)
+    {
+        p1 = (p + data_len);
+        STREAM_TO_UINT8 (rssi, p1);
+    }
 
     /* Save the info */
     p_cur->inq_result_type = BTM_INQ_RESULT_BLE;
     p_cur->ble_addr_type    = addr_type;
     p_cur->rssi = rssi;
 
+    p_cur->pri_phy = pri_phy;
+    p_cur->sec_phy = sec_phy;
+    p_cur->adv_sid = adv_sid;
+    p_cur->periodic_adv_int = periodic_adv_int;
+    p_cur->direct_addr_type = direct_addr_type;
+    memcpy(p_cur->direct_bda, direct_bda, BD_ADDR_LEN);
+
     /* active scan, always wait until get scan_rsp to report the result */
-    if ((btm_cb.ble_ctr_cb.inq_var.scan_type == BTM_BLE_SCAN_MODE_ACTI &&
-         (evt_type == BTM_BLE_CONNECT_EVT || evt_type == BTM_BLE_DISCOVER_EVT)))
+    if (!btm_ble_is_adv_reportable(extended, evt_type))
     {
         BTM_TRACE_DEBUG("btm_ble_update_inq_result scan_rsp=false, to_report=false,\
                               scan_type_active=%d", btm_cb.ble_ctr_cb.inq_var.scan_type);
@@ -2574,14 +2845,38 @@ BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT8 evt_t
     else
         p_cur->device_type |= BT_DEVICE_TYPE_BLE;
 
-    if (evt_type != BTM_BLE_SCAN_RSP_EVT)
+    if ((!extended && evt_type != BTM_BLE_SCAN_RSP_EVT) ||
+        (extended && ((evt_type & BTM_BLE_EXT_SCAN_RSP_EVT_MASK) != BTM_BLE_EXT_SCAN_RSP_EVT_MASK)))
         p_cur->ble_evt_type     = evt_type;
 
     p_i->inq_count = p_inq->inq_counter;   /* Mark entry for current inquiry */
 
+    if(extended && ((evt_type & BTM_BLE_EXT_ADV_EVT_DATA_MASK) == BTM_BLE_EXT_ADV_EVT_DATA_INCMPL_MASK))
+        return FALSE;
+
+    /* Perform length check of each adv data */
+    if (p_le_inq_cb->adv_len > 0 && p_le_inq_cb->adv_data_cache)
+    {
+        p_cache = &p_le_inq_cb->adv_data_cache[0];
+
+        STREAM_TO_UINT8(length, p_cache);
+        while (length && ((adv_data_size + length + 1) <= p_le_inq_cb->adv_len))
+        {
+            adv_data_size += length+1;
+            p_cache += length;
+            if (adv_data_size < p_le_inq_cb->adv_len)
+            {
+                /* skip the length of data */
+                STREAM_TO_UINT8(length, p_cache);
+            }
+        }
+
+        p_le_inq_cb->adv_len = adv_data_size;
+    }
+
     if (p_le_inq_cb->adv_len != 0)
     {
-        if ((p_flag = BTM_CheckAdvData(p_le_inq_cb->adv_data_cache, BTM_BLE_AD_TYPE_FLAG, &len)) != NULL)
+        if ((p_flag = BTM_CheckAdvData(p_le_inq_cb->adv_data_cache, BTM_BLE_AD_TYPE_FLAG, &len, p_le_inq_cb->adv_len)) != NULL)
             p_cur->flag = * p_flag;
     }
 
@@ -2591,7 +2886,7 @@ BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT8 evt_t
          * then try to convert the appearance value to a class of device value Bluedroid can use.
          * Otherwise fall back to trying to infer if it is a HID device based on the service class.
          */
-        p_uuid16 = BTM_CheckAdvData(p_le_inq_cb->adv_data_cache, BTM_BLE_AD_TYPE_APPEARANCE, &len);
+        p_uuid16 = BTM_CheckAdvData(p_le_inq_cb->adv_data_cache, BTM_BLE_AD_TYPE_APPEARANCE, &len, p_le_inq_cb->adv_len);
         if (p_uuid16 && len == 2)
         {
             btm_ble_appearance_to_cod((UINT16)p_uuid16[0] | (p_uuid16[1] << 8), p_cur->dev_class);
@@ -2599,7 +2894,7 @@ BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT8 evt_t
         else
         {
             if ((p_uuid16 = BTM_CheckAdvData(p_le_inq_cb->adv_data_cache,
-                                             BTM_BLE_AD_TYPE_16SRV_CMPL, &len)) != NULL)
+                                             BTM_BLE_AD_TYPE_16SRV_CMPL, &len, p_le_inq_cb->adv_len)) != NULL)
             {
                 UINT8 i;
                 for (i = 0; i + 2 <= len; i = i + 2)
@@ -2619,7 +2914,8 @@ BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT8 evt_t
 
     /* if BR/EDR not supported is not set, assume is a DUMO device */
     if ((p_cur->flag & BTM_BLE_BREDR_NOT_SPT) == 0 &&
-         evt_type != BTM_BLE_CONNECT_DIR_EVT)
+         ((!extended && evt_type != BTM_BLE_CONNECT_DIR_EVT) ||
+         (extended &&  ((evt_type & BTM_BLE_EXT_CONNECT_DIR_EVT_MASK) != BTM_BLE_EXT_CONNECT_DIR_EVT_MASK))))
     {
         if (p_cur->ble_addr_type != BLE_ADDR_RANDOM)
         {
@@ -2690,10 +2986,10 @@ void btm_send_sel_conn_callback(BD_ADDR remote_bda, UINT8 evt_type, UINT8 *p_dat
     /* get the device name if exist in ADV data */
     if (data_len != 0)
     {
-        p_dev_name = BTM_CheckAdvData(p_data, BTM_BLE_AD_TYPE_NAME_CMPL, &len);
+        p_dev_name = BTM_CheckAdvData(p_data, BTM_BLE_AD_TYPE_NAME_CMPL, &len, BTM_BLE_ADV_DATA_LEN_MAX);
 
         if (p_dev_name == NULL)
-            p_dev_name = BTM_CheckAdvData(p_data, BTM_BLE_AD_TYPE_NAME_SHORT, &len);
+            p_dev_name = BTM_CheckAdvData(p_data, BTM_BLE_AD_TYPE_NAME_SHORT, &len, BTM_BLE_ADV_DATA_LEN_MAX);
 
         if (p_dev_name)
             memcpy(remname, p_dev_name, len);
@@ -2708,6 +3004,26 @@ void btm_send_sel_conn_callback(BD_ADDR remote_bda, UINT8 evt_type, UINT8 *p_dat
 
 /*******************************************************************************
 **
+** Function         btm_ble_scan_timeout_evt
+**
+** Description      This function is called when adv packet report events are
+**                  received from the device. It updates the inquiry database.
+**                  If the inquiry database is full, the oldest entry is discarded.
+**
+** Parameters
+**
+** Returns          void
+**
+*******************************************************************************/
+void btm_ble_scan_timeout_evt (void)
+{
+    BTM_TRACE_DEBUG("btm_ble_scan_timeout_evt:");
+
+}
+
+
+/*******************************************************************************
+**
 ** Function         btm_ble_process_adv_pkt
 **
 ** Description      This function is called when adv packet report events are
@@ -2719,13 +3035,15 @@ void btm_send_sel_conn_callback(BD_ADDR remote_bda, UINT8 evt_type, UINT8 *p_dat
 ** Returns          void
 **
 *******************************************************************************/
-void btm_ble_process_adv_pkt (UINT8 *p_data)
+void btm_ble_process_adv_pkt (UINT8 *p_data, BOOLEAN extended)
 {
     BD_ADDR             bda;
-    UINT8               evt_type = 0, *p = p_data;
+    UINT8               *p = p_data;
     UINT8               addr_type = 0;
     UINT8               num_reports;
     UINT8               data_len;
+    UINT16              evt_type=0;
+    UINT8               *p1;
 #if (defined BLE_PRIVACY_SPT && BLE_PRIVACY_SPT == TRUE)
     BOOLEAN             match = FALSE;
 #endif
@@ -2740,10 +3058,19 @@ void btm_ble_process_adv_pkt (UINT8 *p_data)
     while (num_reports--)
     {
         /* Extract inquiry results */
-        STREAM_TO_UINT8    (evt_type, p);
+        if(extended)
+        {
+            STREAM_TO_UINT16    (evt_type, p);
+        }
+        else
+        {
+            STREAM_TO_UINT8    (evt_type, p);
+        }
+
         STREAM_TO_UINT8    (addr_type, p);
         STREAM_TO_BDADDR   (bda, p);
 
+        p1 = p;
 #if (defined BLE_PRIVACY_SPT && BLE_PRIVACY_SPT == TRUE)
         /* map address to security record */
         match = btm_identity_addr_to_random_pseudo(bda, &addr_type, FALSE);
@@ -2753,16 +3080,29 @@ void btm_ble_process_adv_pkt (UINT8 *p_data)
         /* always do RRA resolution on host */
         if (!match && BTM_BLE_IS_RESOLVE_BDA(bda))
         {
-            btm_ble_resolve_random_addr(bda, btm_ble_resolve_random_addr_on_adv, p_data);
+            btm_ble_resolve_random_addr(bda, btm_ble_resolve_random_addr_on_adv, p_data, extended);
         }
         else
 #endif
-            btm_ble_process_adv_pkt_cont(bda, addr_type, evt_type, p);
+            btm_ble_process_adv_pkt_cont(bda, addr_type, evt_type, p, extended);
 
-        STREAM_TO_UINT8(data_len, p);
-
-        /* Advance to the next event data_len + rssi byte */
-        p += data_len + 1;
+        if(num_reports)
+        {
+            if(extended)
+            {
+                p1 += 14;
+                STREAM_TO_UINT8(data_len, p1);
+                p1 += data_len;
+            }
+            else
+            {
+                STREAM_TO_UINT8(data_len, p1);
+                /* Advance to the next event data_len + rssi byte */
+                p1 += data_len + 1;
+            }
+            p = p1;
+            p_data = p1;
+        }
     }
 }
 
@@ -2778,16 +3118,18 @@ void btm_ble_process_adv_pkt (UINT8 *p_data)
 ** Returns          void
 **
 *******************************************************************************/
-static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt_type, UINT8 *p)
+static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT16 evt_type, UINT8 *p, BOOLEAN extended)
 {
     tINQ_DB_ENT          *p_i;
     tBTM_INQUIRY_VAR_ST  *p_inq = &btm_cb.btm_inq_vars;
     tBTM_INQ_RESULTS_CB  *p_inq_results_cb = p_inq->p_inq_results_cb;
     tBTM_INQ_RESULTS_CB  *p_obs_results_cb = btm_cb.ble_ctr_cb.p_obs_results_cb;
-    tBTM_BLE_INQ_CB      *p_le_inq_cb = &btm_cb.ble_ctr_cb.inq_var;
+    tBTM_BLE_INQ_DATA_CB *p_le_inq_cb;
     BOOLEAN     update = TRUE;
     UINT8       result = 0;
 
+    BTM_TRACE_EVENT("%s::bda::%02x%02x%02x%02x%02x%02x",__func__, bda[0],bda[1],bda[2],bda[3],bda[4],bda[5]);
+
     p_i = btm_inq_db_find (bda);
 
     /* Check if this address has already been processed for this inquiry */
@@ -2816,6 +3158,9 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     {
         if ((p_i = btm_inq_db_new (bda)) != NULL)
         {
+            p_le_inq_cb = &p_i->inq_info.results.inq_data;
+            p_le_inq_cb->adv_len = 0;
+
             p_inq->inq_cmpl_info.num_resp++;
         }
         else
@@ -2825,14 +3170,19 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     {
         p_inq->inq_cmpl_info.num_resp++;
     }
+    p_le_inq_cb = &p_i->inq_info.results.inq_data;
+
+    p_i->time_of_resp = time_get_os_boottime_ms();
+
     /* update the LE device information in inquiry database */
-    if (!btm_ble_update_inq_result(p_i, addr_type, evt_type, p))
+    if (!btm_ble_update_inq_result(p_i, addr_type, evt_type, p, extended))
         return;
 
+
     if ((result = btm_ble_is_discoverable(bda, evt_type, p)) == 0)
     {
-      LOG_WARN(LOG_TAG, "%s device is no longer discoverable so discarding advertising packet pkt",
-          __func__);
+        LOG_WARN(LOG_TAG, "%s device is no longer discoverable so discarding advertising packet pkt",
+                __func__);
         return;
     }
     if (!update)
@@ -2864,6 +3214,7 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     if (btm_cb.ble_ctr_cb.bg_conn_type == BTM_BLE_CONN_SELECTIVE)
     {
         if (result & BTM_BLE_SEL_CONN_RESULT)
+            //TODO might need to take care of UINT16 evt_type in this callback.
             btm_send_sel_conn_callback(bda, evt_type, p, addr_type);
         else
         {
@@ -2872,6 +3223,8 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     }
     else
     {
+        p_i->inq_info.results.adv_data_len = p_le_inq_cb->adv_len;
+
         if (p_inq_results_cb && (result & BTM_BLE_INQ_RESULT))
         {
             (p_inq_results_cb)((tBTM_INQ_RESULTS *) &p_i->inq_info.results, p_le_inq_cb->adv_data_cache);
@@ -2880,6 +3233,15 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
         {
             (p_obs_results_cb)((tBTM_INQ_RESULTS *) &p_i->inq_info.results, p_le_inq_cb->adv_data_cache);
         }
+
+        //Deallocate memory for adv data cache
+        if(controller_get_interface()->supports_ble_extended_advertisements() && p_le_inq_cb->adv_data_cache)
+        {
+            osi_free_and_reset((void **)&p_le_inq_cb->adv_data_cache);
+            p_le_inq_cb->adv_data_cache = NULL;
+        }
+
+        p_le_inq_cb->adv_len = 0;
     }
 }
 
@@ -2897,12 +3259,26 @@ tBTM_STATUS btm_ble_start_scan(void)
     tBTM_BLE_INQ_CB *p_inq = &btm_cb.ble_ctr_cb.inq_var;
     tBTM_STATUS status = BTM_CMD_STARTED;
 
+    BTM_TRACE_ERROR("btm_ble_start_scan extended scan");
     /* start scan, disable duplicate filtering */
-    if (!btsnd_hcic_ble_set_scan_enable (BTM_BLE_SCAN_ENABLE, p_inq->scan_duplicate_filter))
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
     {
-        status = BTM_NO_RESOURCES;
+        if (!btsnd_hcic_ble_set_extended_scan_enable (BTM_BLE_SCAN_ENABLE, p_inq->scan_duplicate_filter, p_inq->scan_duration, p_inq->scan_period))
+        {
+            status = BTM_NO_RESOURCES;
+        }
     }
     else
+#endif
+    {
+        if (!btsnd_hcic_ble_set_scan_enable (BTM_BLE_SCAN_ENABLE, p_inq->scan_duplicate_filter))
+        {
+            status = BTM_NO_RESOURCES;
+        }
+    }
+
+    if(status == BTM_CMD_STARTED)
     {
         if (p_inq->scan_type == BTM_BLE_SCAN_MODE_ACTI)
             btm_ble_set_topology_mask(BTM_BLE_STATE_ACTIVE_SCAN_BIT);
@@ -2923,13 +3299,22 @@ tBTM_STATUS btm_ble_start_scan(void)
 *******************************************************************************/
 void btm_ble_stop_scan(void)
 {
-    BTM_TRACE_EVENT ("btm_ble_stop_scan ");
+    BTM_TRACE_EVENT ("btm_ble_stop_scan");
 
     /* Clear the inquiry callback if set */
     btm_cb.ble_ctr_cb.inq_var.scan_type = BTM_BLE_SCAN_MODE_NONE;
 
     /* stop discovery now */
-    btsnd_hcic_ble_set_scan_enable (BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE);
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
+    {
+        btsnd_hcic_ble_set_extended_scan_enable (BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE, 0, 0);
+    }
+    else
+#endif
+    {
+        btsnd_hcic_ble_set_scan_enable (BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE);
+    }
 
     btm_update_scanner_filter_policy(SP_ADV_ALL);
 
@@ -2953,6 +3338,8 @@ void btm_ble_stop_inquiry(void)
 
     p_ble_cb->scan_activity &=  ~BTM_BLE_INQUIRY_MASK;
 
+    p_ble_cb->inq_var.scan_duration = 0;
+    p_ble_cb->inq_var.scan_period = 0;
     /* If no more scan activity, stop LE scan now */
     if (!BTM_BLE_IS_SCAN_ACTIVE(p_ble_cb->scan_activity))
         btm_ble_stop_scan();
@@ -3229,6 +3616,10 @@ void btm_ble_read_remote_features_complete(UINT8 *p)
                 break;
             }
         }
+        /* Set PHY for the connection to 2Mbps, no coding preference */
+        BTM_SetBlePhy(p_acl_cb->remote_addr, 0,
+                      BTM_DATA_RATE_TWO|BTM_DATA_RATE_ONE,
+                      BTM_DATA_RATE_TWO|BTM_DATA_RATE_ONE, 0);
     }
 
 }
@@ -3399,6 +3790,8 @@ void btm_ble_init(void)
     p_cb->cur_states       = 0;
     p_cb->conn_pending_q = fixed_queue_new(SIZE_MAX);
 
+    memset(&(btm_cb.ble_adv_ext_cb), 0 , sizeof(tBTM_BLE_ADV_EXT_CB));
+
     p_cb->inq_var.adv_mode = BTM_BLE_ADV_DISABLE;
     p_cb->inq_var.scan_type = BTM_BLE_SCAN_MODE_NONE;
     p_cb->inq_var.adv_chnl_map = BTM_BLE_DEFAULT_ADV_CHNL_MAP;
diff --git a/stack/btm/btm_ble_int.h b/stack/btm/btm_ble_int.h
index 166cb5e..70ee1a9 100644
--- a/stack/btm/btm_ble_int.h
+++ b/stack/btm/btm_ble_int.h
@@ -50,8 +50,11 @@
 #define BTM_BLE_NAME_REQUEST    0x40
 #define BTM_BLE_OBSERVE         0x80
 
-#define BTM_BLE_MAX_WL_ENTRY        1
-#define BTM_BLE_AD_DATA_LEN         31
+#define BTM_BLE_MAX_WL_ENTRY           1
+#define BTM_BLE_AD_DATA_LEN            31
+#define BTM_BLE_EXTENDED_AD_DATA_LEN   2000
+
+#define BTM_BLE_EXT_ADV_MAX_FRAG_NUM   20
 
 #define BTM_BLE_ENC_MASK    0x03
 
@@ -135,10 +138,15 @@ typedef struct
 {
     UINT16 discoverable_mode;
     UINT16 connectable_mode;
+    UINT8 scan_phys;
     UINT32 scan_window;
     UINT32 scan_interval;
+    UINT16 scan_window_coded;
+    UINT16 scan_interval_coded;
     UINT8 scan_type; /* current scan type: active or passive */
     UINT8 scan_duplicate_filter; /* duplicate filter enabled for scan */
+    UINT16 scan_duration;
+    UINT16 scan_period;
     UINT16 adv_interval_min;
     UINT16 adv_interval_max;
     tBTM_BLE_AFP afp; /* advertising filter policy */
@@ -169,7 +177,7 @@ typedef struct
 
 
 /* random address resolving complete callback */
-typedef void (tBTM_BLE_RESOLVE_CBACK) (void * match_rec, void *p);
+typedef void (tBTM_BLE_RESOLVE_CBACK) (void * match_rec, void *p, BOOLEAN extended);
 
 typedef void (tBTM_BLE_ADDR_CBACK) (BD_ADDR_PTR static_random, void *p);
 
@@ -183,6 +191,7 @@ typedef struct
     tBTM_BLE_ADDR_CBACK         *p_generate_cback;
     void                        *p;
     alarm_t                     *refresh_raddr_timer;
+    BOOLEAN                     extended;
 } tBTM_LE_RANDOM_CB;
 
 #define BTM_BLE_MAX_BG_CONN_DEV_NUM    10
@@ -217,6 +226,9 @@ typedef UINT8 tBTM_BLE_WL_STATE;
 #define BTM_BLE_RL_INIT         1
 #define BTM_BLE_RL_SCAN         2
 #define BTM_BLE_RL_ADV          4
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+#define BTM_BLE_RL_EXT_ADV      8
+#endif
 typedef UINT8 tBTM_BLE_RL_STATE;
 
 /* BLE connection state */
@@ -290,6 +302,10 @@ typedef struct
 #define BTM_PRIVACY_MIXED   3              /* BLE privacy mixed mode, broadcom propietary mode */
 typedef UINT8 tBTM_PRIVACY_MODE;
 
+/* 2Mbps PHY support*/
+#define BTM_DATA_RATE_TWO   2
+#define BTM_DATA_RATE_ONE   1
+
 /* data length change event callback */
 typedef void (tBTM_DATA_LENGTH_CHANGE_CBACK) (UINT16 max_tx_length, UINT16 max_rx_length);
 
@@ -350,7 +366,8 @@ extern "C" {
 
 extern void btm_ble_adv_raddr_timer_timeout(void *data);
 extern void btm_ble_refresh_raddr_timer_timeout(void *data);
-extern void btm_ble_process_adv_pkt (UINT8 *p);
+extern void btm_ble_process_adv_pkt (UINT8 *p, BOOLEAN extended);
+
 extern void btm_ble_proc_scan_rsp_rpt (UINT8 *p);
 extern tBTM_STATUS btm_ble_read_remote_name(BD_ADDR remote_bda, tBTM_INQ_INFO *p_cur, tBTM_CMPL_CB *p_cb);
 extern BOOLEAN btm_ble_cancel_remote_name(BD_ADDR remote_bda);
@@ -375,7 +392,7 @@ extern void btm_read_ble_local_supported_states_complete(UINT8 *p, UINT16 evt_le
 extern tBTM_BLE_CONN_ST btm_ble_get_conn_st(void);
 extern void btm_ble_set_conn_st(tBTM_BLE_CONN_ST new_st);
 extern UINT8 *btm_ble_build_adv_data(tBTM_BLE_AD_MASK *p_data_mask, UINT8 **p_dst,
-                                     tBTM_BLE_ADV_DATA *p_data);
+                                     tBTM_BLE_ADV_DATA *p_data, UINT16 max_len);
 extern tBTM_STATUS btm_ble_start_adv(void);
 extern tBTM_STATUS btm_ble_stop_adv(void);
 extern tBTM_STATUS btm_ble_start_scan(void);
@@ -438,7 +455,7 @@ extern void btm_ble_dequeue_direct_conn_req(BD_ADDR rem_bda);
 /* BLE address management */
 extern void btm_gen_resolvable_private_addr (void *p_cmd_cplt_cback);
 extern void btm_gen_non_resolvable_private_addr (tBTM_BLE_ADDR_CBACK *p_cback, void *p);
-extern void btm_ble_resolve_random_addr(BD_ADDR random_bda, tBTM_BLE_RESOLVE_CBACK * p_cback, void *p);
+extern void btm_ble_resolve_random_addr(BD_ADDR random_bda, tBTM_BLE_RESOLVE_CBACK * p_cback, void *p, BOOLEAN extended);
 extern void btm_gen_resolve_paddr_low(tBTM_RAND_ENC *p);
 
 /*  privacy function */
@@ -460,8 +477,18 @@ extern void btm_ble_resolving_list_init(UINT8 max_irk_list_sz);
 extern void btm_ble_resolving_list_cleanup(void);
 #endif
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && BLE_EXTENDED_ADV_SUPPORT == TRUE)
+extern void btm_ble_read_inst_length_complete (UINT8* p, UINT16 evt_len);
+extern void btm_ble_adv_extension_operation_complete (UINT8* p, UINT16 hcidm);
+extern void btm_ble_adv_set_terminated_evt (UINT8* p);
+extern void btm_ble_multi_adv_enable_all(UINT8 enable);
+extern void btm_ble_scan_timeout_evt(void);
+extern void btm_ble_extended_configure_inst_size(void);
+#endif
+
+extern void btm_ble_update_multi_adv_inst_data_length (UINT16 inst_len);
 extern void btm_ble_multi_adv_configure_rpa (tBTM_BLE_MULTI_ADV_INST *p_inst);
-extern void btm_ble_multi_adv_init(void);
+extern void btm_ble_multi_adv_init(UINT8 max_adv_inst);
 extern void* btm_ble_multi_adv_get_ref(UINT8 inst_id);
 extern void btm_ble_multi_adv_cleanup(void);
 extern void btm_ble_multi_adv_reenable(UINT8 inst_id);
@@ -474,6 +501,7 @@ extern void btm_ble_adv_filter_cleanup(void);
 extern BOOLEAN btm_ble_topology_check(tBTM_BLE_STATE_MASK request);
 extern BOOLEAN btm_ble_clear_topology_mask(tBTM_BLE_STATE_MASK request_state);
 extern BOOLEAN btm_ble_set_topology_mask(tBTM_BLE_STATE_MASK request_state);
+extern void btm_ble_set_random_address(BD_ADDR random_bda);
 
 #if BTM_BLE_CONFORMANCE_TESTING == TRUE
 extern void btm_ble_set_no_disc_if_pair_fail (BOOLEAN disble_disc);
diff --git a/stack/btm/btm_ble_multi_adv.c b/stack/btm/btm_ble_multi_adv.c
index e7d5efc..1d6840a 100644
--- a/stack/btm/btm_ble_multi_adv.c
+++ b/stack/btm/btm_ble_multi_adv.c
@@ -21,6 +21,7 @@
 
 #include "bt_target.h"
 #include "device/include/controller.h"
+#include "stack_config.h"
 
 #if (BLE_INCLUDED == TRUE)
 #include "bt_types.h"
@@ -39,16 +40,30 @@
 #define BTM_BLE_MULTI_ADV_SET_PARAM_LEN                 24
 #define BTM_BLE_MULTI_ADV_WRITE_DATA_LEN                (BTM_BLE_AD_DATA_LEN + 3)
 #define BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR_LEN           8
+#define BTM_BLE_EXTENDED_ADV_TIMEOUT                    0x3C
 
 #define BTM_BLE_MULTI_ADV_CB_EVT_MASK   0xF0
 #define BTM_BLE_MULTI_ADV_SUBCODE_MASK  0x0F
 
+#ifdef WIPOWER_SUPPORTED
+#define WIPOWER_16_UUID_LSB 0xFE
+#define WIPOWER_16_UUID_MSB 0xFF
+static bool is_wipower_adv = false;
+#endif
+
+#define BTM_BLE_EXTENDED_LEGACY_MASK    0x10
+
 /************************************************************************************
 **  Static variables
 ************************************************************************************/
 tBTM_BLE_MULTI_ADV_CB  btm_multi_adv_cb;
 tBTM_BLE_MULTI_ADV_INST_IDX_Q btm_multi_adv_idx_q;
 pthread_mutex_t btm_multi_adv_lock = PTHREAD_MUTEX_INITIALIZER;
+tBTM_BLE_EXT_ADV_ENABLE_CB btm_ble_ext_enable_cb;
+
+#ifdef WIPOWER_SUPPORTED
+UINT8 wipower_inst_id = BTM_BLE_MULTI_ADV_DEFAULT_STD;
+#endif
 
 /************************************************************************************
 **  Externs
@@ -66,6 +81,15 @@ static inline BOOLEAN is_btm_multi_adv_cb_valid()
     else
         return TRUE;
 }
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+/************************************************************************************
+** Local declaration
+************************************************************************************/
+static tBTM_STATUS btm_ble_extended_adv_set_params (tBTM_BLE_MULTI_ADV_INST *p_inst,
+                                             tBTM_BLE_ADV_PARAMS *p_params,
+                                             UINT8 cb_evt);
+static tBTM_STATUS btm_ble_enable_extended_adv (BOOLEAN enable, UINT8 inst_id, UINT16 duration, UINT8 max_ext_adv_evts, UINT8 cb_evt);
+#endif
 
 /*******************************************************************************
 **
@@ -79,13 +103,15 @@ static inline BOOLEAN is_btm_multi_adv_cb_valid()
 *******************************************************************************/
 void btm_ble_multi_adv_enq_op_q(UINT8 opcode, UINT8 inst_id, UINT8 cb_evt)
 {
+    UINT8 max_adv_instance = BTM_BleMaxMultiAdvInstanceCount();
     tBTM_BLE_MULTI_ADV_OPQ  *p_op_q = &btm_multi_adv_cb.op_q;
 
     p_op_q->p_inst_id[p_op_q->next_idx] = inst_id;
 
     p_op_q->p_sub_code[p_op_q->next_idx] = (opcode |(cb_evt << 4));
 
-    p_op_q->next_idx = (p_op_q->next_idx + 1) %  BTM_BleMaxMultiAdvInstanceCount();
+    if (max_adv_instance > 0)
+       p_op_q->next_idx = (p_op_q->next_idx + 1) %  max_adv_instance;
 }
 
 /*******************************************************************************
@@ -100,13 +126,15 @@ void btm_ble_multi_adv_enq_op_q(UINT8 opcode, UINT8 inst_id, UINT8 cb_evt)
 *******************************************************************************/
 void btm_ble_multi_adv_deq_op_q(UINT8 *p_opcode, UINT8 *p_inst_id, UINT8 *p_cb_evt)
 {
+    UINT8 max_adv_instance = BTM_BleMaxMultiAdvInstanceCount();
     tBTM_BLE_MULTI_ADV_OPQ  *p_op_q = &btm_multi_adv_cb.op_q;
 
     *p_inst_id = p_op_q->p_inst_id[p_op_q->pending_idx] & 0x7F;
     *p_cb_evt = (p_op_q->p_sub_code[p_op_q->pending_idx] >> 4);
     *p_opcode = (p_op_q->p_sub_code[p_op_q->pending_idx] & BTM_BLE_MULTI_ADV_SUBCODE_MASK);
 
-    p_op_q->pending_idx = (p_op_q->pending_idx + 1) %  BTM_BleMaxMultiAdvInstanceCount();
+    if (max_adv_instance > 0)
+       p_op_q->pending_idx = (p_op_q->pending_idx + 1) % max_adv_instance;
 }
 
 /*******************************************************************************
@@ -128,6 +156,12 @@ void btm_ble_multi_adv_vsc_cmpl_cback (tBTM_VSC_CMPL *p_params)
     tBTM_BLE_MULTI_ADV_INST *p_inst ;
     UINT8   cb_evt = 0, opcode;
 
+    if (!controller_get_interface()->get_is_ready())
+    {
+        BTM_TRACE_ERROR("btm_ble_multi_adv_vsc_cmpl_cback controller not ready. returning!");
+        return;
+    }
+
     if (len  < 2)
     {
         BTM_TRACE_ERROR("wrong length for btm_ble_multi_adv_vsc_cmpl_cback");
@@ -357,22 +391,34 @@ tBTM_STATUS btm_ble_multi_adv_set_params (tBTM_BLE_MULTI_ADV_INST *p_inst,
 tBTM_STATUS btm_ble_multi_adv_write_rpa (tBTM_BLE_MULTI_ADV_INST *p_inst, BD_ADDR random_addr)
 {
     UINT8           param[BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR_LEN], *pp = param;
-    tBTM_STATUS     rt;
+    tBTM_STATUS     rt = BTM_NO_RESOURCES;
 
     BTM_TRACE_EVENT ("%s-BD_ADDR:%02x-%02x-%02x-%02x-%02x-%02x,inst_id:%d",
                       __FUNCTION__, random_addr[5], random_addr[4], random_addr[3], random_addr[2],
                       random_addr[1], random_addr[0], p_inst->inst_id);
 
-    memset(param, 0, BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR_LEN);
-
-    UINT8_TO_STREAM (pp, BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR);
-    BDADDR_TO_STREAM(pp, random_addr);
-    UINT8_TO_STREAM(pp,  p_inst->inst_id);
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
+    {
+        rt = btm_ble_add_multi_adv_rpa(random_addr, BLE_ADDR_RANDOM);
+        return rt;
+    }
+    else
+#endif
+    {
+        memset(param, 0, BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR_LEN);
 
-    if ((rt = BTM_VendorSpecificCommand (HCI_BLE_MULTI_ADV_OCF,
+        UINT8_TO_STREAM (pp, BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR);
+        BDADDR_TO_STREAM(pp, random_addr);
+        UINT8_TO_STREAM(pp,  p_inst->inst_id);
+        rt = BTM_VendorSpecificCommand (HCI_BLE_MULTI_ADV_OCF,
                                     BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR_LEN,
                                     param,
-                                    btm_ble_multi_adv_vsc_cmpl_cback)) == BTM_CMD_STARTED)
+                                    btm_ble_multi_adv_vsc_cmpl_cback);
+    }
+
+
+    if (rt == BTM_CMD_STARTED)
     {
         /* start a periodical timer to refresh random addr */
         /* TODO: is the above comment correct - is the timer periodical? */
@@ -398,6 +444,12 @@ tBTM_STATUS btm_ble_multi_adv_write_rpa (tBTM_BLE_MULTI_ADV_INST *p_inst, BD_ADD
 *******************************************************************************/
 void btm_ble_multi_adv_gen_rpa_cmpl(tBTM_RAND_ENC *p)
 {
+    if (!controller_get_interface()->get_is_ready())
+    {
+        BTM_TRACE_ERROR("btm_ble_multi_adv_gen_rpa_cmpl controller module is not ready!");
+        return;
+    }
+
 #if (SMP_INCLUDED == TRUE)
     tSMP_ENC    output;
     UINT8 index = 0;
@@ -498,6 +550,29 @@ void btm_ble_multi_adv_configure_rpa (tBTM_BLE_MULTI_ADV_INST *p_inst)
 
 /*******************************************************************************
 **
+** Function         btm_ble_update_multi_adv_inst_data_length
+**
+** Description      This function set the random address for the adv instance
+**
+** Parameters       advertise parameters used for this instance.
+**
+** Returns          none
+**
+*******************************************************************************/
+void btm_ble_update_multi_adv_inst_data_length (UINT16 inst_len)
+{
+    int index;
+    tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[0];
+    BTM_TRACE_ERROR("btm_ble_update_multi_adv_inst_data_length inst_len:%d",inst_len);
+
+    for (index = 0; index <  BTM_BleMaxMultiAdvInstanceCount() - 1; index++, p_inst++)
+    {
+        p_inst->len = inst_len;
+    }
+}
+
+/*******************************************************************************
+**
 ** Function         btm_ble_multi_adv_reenable
 **
 ** Description      This function re-enable adv instance upon a connection establishment.
@@ -537,7 +612,7 @@ void btm_ble_multi_adv_reenable(UINT8 inst_id)
 *******************************************************************************/
 void btm_ble_multi_adv_enb_privacy(BOOLEAN enable)
 {
-    UINT8 i;
+    int i;
     tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[0];
 
     for (i = 0; i <  BTM_BleMaxMultiAdvInstanceCount() - 1; i ++, p_inst++)
@@ -550,6 +625,25 @@ void btm_ble_multi_adv_enb_privacy(BOOLEAN enable)
     }
 }
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+/*******************************************************************************
+**
+** Function         btm_ble_extended_configure_inst_size
+**
+** Description      This function gathers max length of advertiement sets
+**
+** Parameters       none.
+**
+** Returns          none.
+**
+*******************************************************************************/
+void btm_ble_extended_configure_inst_size()
+{
+    BTM_TRACE_DEBUG ("%s", __func__);
+    btsnd_hcic_ble_read_extended_max_adv_len();
+}
+#endif
+
 /*******************************************************************************
 **
 ** Function         BTM_BleEnableAdvInstance
@@ -568,13 +662,13 @@ void btm_ble_multi_adv_enb_privacy(BOOLEAN enable)
 tBTM_STATUS BTM_BleEnableAdvInstance (tBTM_BLE_ADV_PARAMS *p_params,
                                       tBTM_BLE_MULTI_ADV_CBACK *p_cback,void *p_ref)
 {
-    UINT8 i;
+    int i;
     tBTM_STATUS rt = BTM_NO_RESOURCES;
     tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[0];
 
     BTM_TRACE_EVENT("BTM_BleEnableAdvInstance called");
 
-    if (0 == btm_cb.cmn_ble_vsc_cb.adv_inst_max)
+    if (0 == BTM_BleMaxMultiAdvInstanceCount())
     {
         BTM_TRACE_ERROR("Controller does not support Multi ADV");
         return BTM_ERR_PROCESSING;
@@ -592,8 +686,18 @@ tBTM_STATUS BTM_BleEnableAdvInstance (tBTM_BLE_ADV_PARAMS *p_params,
         {
             p_inst->in_use = TRUE;
             /* configure adv parameter */
-            if (p_params)
-                rt = btm_ble_multi_adv_set_params(p_inst, p_params, 0);
+            if (p_params) {
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+                if (controller_get_interface()->supports_ble_extended_advertisements())
+                {
+                    rt = btm_ble_extended_adv_set_params(p_inst, p_params, 0);
+                }
+                else
+#endif
+                {
+                    rt = btm_ble_multi_adv_set_params(p_inst, p_params, 0);
+                }
+            }
             else
                 rt = BTM_CMD_STARTED;
 
@@ -603,8 +707,22 @@ tBTM_STATUS BTM_BleEnableAdvInstance (tBTM_BLE_ADV_PARAMS *p_params,
 
             if (BTM_CMD_STARTED == rt)
             {
-                if ((rt = btm_ble_enable_multi_adv (TRUE, p_inst->inst_id,
-                          BTM_BLE_MULTI_ADV_ENB_EVT)) == BTM_CMD_STARTED)
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+                if (controller_get_interface()->supports_ble_extended_advertisements()) {
+                    p_inst->in_use = FALSE;
+                    btm_ble_enable_resolving_list (BTM_BLE_RL_EXT_ADV);
+                    p_inst->in_use = TRUE;
+                    rt = btm_ble_enable_extended_adv (TRUE, p_inst->inst_id,
+                                                      p_inst->duration, p_params->max_ext_adv_evts, BTM_BLE_EXTENDED_ADV_ENB_EVT);
+                }
+                else
+#endif
+                {
+                    rt = btm_ble_enable_multi_adv (TRUE, p_inst->inst_id,
+                                                    BTM_BLE_MULTI_ADV_ENB_EVT);
+                }
+
+                if (rt == BTM_CMD_STARTED)
                 {
                     p_inst->p_cback = p_cback;
                     p_inst->p_ref   = p_ref;
@@ -639,10 +757,11 @@ tBTM_STATUS BTM_BleUpdateAdvInstParam (UINT8 inst_id, tBTM_BLE_ADV_PARAMS *p_par
 {
     tBTM_STATUS rt = BTM_ILLEGAL_VALUE;
     tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[inst_id - 1];
+    UINT8 cb_evt = BTM_BLE_MULTI_ADV_PARAM_EVT;
 
     BTM_TRACE_EVENT("BTM_BleUpdateAdvInstParam called with inst_id:%d", inst_id);
 
-    if (0 == btm_cb.cmn_ble_vsc_cb.adv_inst_max)
+    if (0 == BTM_BleMaxMultiAdvInstanceCount())
     {
         BTM_TRACE_ERROR("Controller does not support Multi ADV");
         return BTM_ERR_PROCESSING;
@@ -657,11 +776,39 @@ tBTM_STATUS BTM_BleUpdateAdvInstParam (UINT8 inst_id, tBTM_BLE_ADV_PARAMS *p_par
             BTM_TRACE_DEBUG("adv instance %d is not active", inst_id);
             return BTM_WRONG_MODE;
         }
+        else {
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+            if (controller_get_interface()->supports_ble_extended_advertisements())
+                btm_ble_enable_extended_adv(FALSE, inst_id, 0, 0/*p_params->max_ext_adv_evts*/, 0);
+            else
+#endif
+            {
+                btm_ble_enable_multi_adv(FALSE, inst_id, 0);
+            }
+        }
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        if (controller_get_interface()->supports_ble_extended_advertisements())
+        {
+            rt = btm_ble_extended_adv_set_params(p_inst, p_params, 0);
+            cb_evt = BTM_BLE_EXTENDED_ADV_PARAM_EVT;
+        }
         else
-            btm_ble_enable_multi_adv(FALSE, inst_id, 0);
+#endif
+        {
+            rt = btm_ble_multi_adv_set_params(p_inst, p_params, 0);
+        }
 
-        if (BTM_CMD_STARTED == btm_ble_multi_adv_set_params(p_inst, p_params, 0))
-            rt = btm_ble_enable_multi_adv(TRUE, inst_id, BTM_BLE_MULTI_ADV_PARAM_EVT);
+        if (BTM_CMD_STARTED == rt) {
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+            if (controller_get_interface()->supports_ble_extended_advertisements())
+                rt = btm_ble_enable_extended_adv(TRUE, inst_id, p_inst->duration, p_params->max_ext_adv_evts, cb_evt);
+            else
+#endif
+            {
+                rt = btm_ble_enable_multi_adv(TRUE, inst_id, cb_evt);
+            }
+        }
     }
     return rt;
 }
@@ -682,7 +829,7 @@ tBTM_STATUS BTM_BleUpdateAdvInstParam (UINT8 inst_id, tBTM_BLE_ADV_PARAMS *p_par
 **
 *******************************************************************************/
 tBTM_STATUS BTM_BleCfgAdvInstData (UINT8 inst_id, BOOLEAN is_scan_rsp,
-                                    tBTM_BLE_AD_MASK data_mask,
+                                    tBTM_BLE_AD_MASK data_mask, UINT8 frag_pref,
                                     tBTM_BLE_ADV_DATA *p_data)
 {
     UINT8       param[BTM_BLE_MULTI_ADV_WRITE_DATA_LEN], *pp = param;
@@ -693,8 +840,16 @@ tBTM_STATUS BTM_BleCfgAdvInstData (UINT8 inst_id, BOOLEAN is_scan_rsp,
     UINT8 *pp_temp = (UINT8*)(param + BTM_BLE_MULTI_ADV_WRITE_DATA_LEN -1);
     tBTM_BLE_VSC_CB cmn_ble_vsc_cb;
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
+    {
+        return BTM_BleWriteExtendedAdvData (inst_id, is_scan_rsp, data_mask,
+                                            BTM_BLE_EXT_ADV_COMPLETE ,frag_pref, p_data);
+    }
+#endif
+
     BTM_BleGetVendorCapabilities(&cmn_ble_vsc_cb);
-    if (0 == cmn_ble_vsc_cb.adv_inst_max)
+    if (0 == BTM_BleMaxMultiAdvInstanceCount())
     {
         BTM_TRACE_ERROR("Controller does not support Multi ADV");
         return BTM_ERR_PROCESSING;
@@ -711,9 +866,16 @@ tBTM_STATUS BTM_BleCfgAdvInstData (UINT8 inst_id, BOOLEAN is_scan_rsp,
 
     UINT8_TO_STREAM(pp, sub_code);
     p_len = pp ++;
-    btm_ble_build_adv_data(&data_mask, &pp, p_data);
+    btm_ble_build_adv_data(&data_mask, &pp, p_data, BTM_BLE_AD_DATA_LEN);
     *p_len = (UINT8)(pp - param - 2);
     UINT8_TO_STREAM(pp_temp, inst_id);
+#ifdef WIPOWER_SUPPORTED
+    if (param[7] == WIPOWER_16_UUID_LSB && param[8] == WIPOWER_16_UUID_MSB)
+    {
+        is_wipower_adv = true;
+        wipower_inst_id = inst_id;
+    }
+#endif
 
     if ((rt = BTM_VendorSpecificCommand (HCI_BLE_MULTI_ADV_OCF,
                                     (UINT8)BTM_BLE_MULTI_ADV_WRITE_DATA_LEN,
@@ -739,29 +901,45 @@ tBTM_STATUS BTM_BleCfgAdvInstData (UINT8 inst_id, BOOLEAN is_scan_rsp,
 *******************************************************************************/
 tBTM_STATUS BTM_BleDisableAdvInstance (UINT8 inst_id)
 {
-     tBTM_STATUS rt = BTM_ILLEGAL_VALUE;
-     tBTM_BLE_VSC_CB cmn_ble_vsc_cb;
+    tBTM_STATUS rt = BTM_ILLEGAL_VALUE;
+    tBTM_BLE_VSC_CB cmn_ble_vsc_cb;
 
-     BTM_TRACE_EVENT("BTM_BleDisableAdvInstance with inst_id:%d", inst_id);
+    BTM_TRACE_EVENT("BTM_BleDisableAdvInstance with inst_id:%d", inst_id);
 
-     BTM_BleGetVendorCapabilities(&cmn_ble_vsc_cb);
+    BTM_BleGetVendorCapabilities(&cmn_ble_vsc_cb);
 
-     if (0 == cmn_ble_vsc_cb.adv_inst_max)
-     {
-         BTM_TRACE_ERROR("Controller does not support Multi ADV");
-         return BTM_ERR_PROCESSING;
-     }
+    if (0 == BTM_BleMaxMultiAdvInstanceCount())
+    {
+        BTM_TRACE_ERROR("Controller does not support Multi ADV");
+        return BTM_ERR_PROCESSING;
+    }
 
-     if (inst_id < BTM_BleMaxMultiAdvInstanceCount() &&
-         inst_id != BTM_BLE_MULTI_ADV_DEFAULT_STD)
-     {
-         if ((rt = btm_ble_enable_multi_adv(FALSE, inst_id, BTM_BLE_MULTI_ADV_DISABLE_EVT))
-            == BTM_CMD_STARTED)
-         {
+    if (inst_id < BTM_BleMaxMultiAdvInstanceCount() &&
+        inst_id != BTM_BLE_MULTI_ADV_DEFAULT_STD)
+    {
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+        tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[inst_id - 1];
+        if (controller_get_interface()->supports_ble_extended_advertisements()) {
+            rt = btm_ble_enable_extended_adv (FALSE, inst_id,
+                                                     p_inst->duration, 0/*p_params->max_ext_adv_evts*/,
+                                                     BTM_BLE_MULTI_ADV_DISABLE_EVT);
+        }
+        else
+#endif
+        {
+            rt = btm_ble_enable_multi_adv(FALSE, inst_id, BTM_BLE_MULTI_ADV_DISABLE_EVT);
+        }
+
+        if (rt == BTM_CMD_STARTED
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+            && !controller_get_interface()->supports_ble_extended_advertisements()
+#endif
+           )
+        {
             btm_ble_multi_adv_configure_rpa(&btm_multi_adv_cb.p_adv_inst[inst_id - 1]);
             alarm_cancel(btm_multi_adv_cb.p_adv_inst[inst_id - 1].adv_raddr_timer);
-            btm_multi_adv_cb.p_adv_inst[inst_id - 1].in_use = FALSE;
-         }
+        }
+        btm_multi_adv_cb.p_adv_inst[inst_id - 1].in_use = FALSE;
      }
     return rt;
 }
@@ -807,7 +985,13 @@ void btm_ble_multi_adv_vse_cback(UINT8 len, UINT8 *p)
             adv_inst !=  BTM_BLE_MULTI_ADV_DEFAULT_STD)
         {
             BTM_TRACE_EVENT("btm_ble_multi_adv_reenable called");
-            btm_ble_multi_adv_reenable(adv_inst);
+#ifdef WIPOWER_SUPPORTED
+            if (!(is_wipower_adv && (adv_inst == wipower_inst_id))) {
+                btm_ble_multi_adv_reenable(adv_inst);
+            }
+#else
+                btm_ble_multi_adv_reenable(adv_inst);
+#endif
         }
         /* re-enable connectibility */
         else if (adv_inst == BTM_BLE_MULTI_ADV_DEFAULT_STD)
@@ -827,39 +1011,54 @@ void btm_ble_multi_adv_vse_cback(UINT8 len, UINT8 *p)
 **
 ** Description      This function initialize the multi adv control block.
 **
-** Parameters       None
+** Parameters       UINT8 max_adv_inst
 **
 ** Returns          void
 **
 *******************************************************************************/
-void btm_ble_multi_adv_init()
+void btm_ble_multi_adv_init(UINT8 max_adv_inst)
 {
+    BTM_TRACE_ERROR("%s: max adv instances: %d", __func__, max_adv_inst);
     UINT8 i = 0;
     memset(&btm_multi_adv_cb, 0, sizeof(tBTM_BLE_MULTI_ADV_CB));
     memset (&btm_multi_adv_idx_q,0, sizeof (tBTM_BLE_MULTI_ADV_INST_IDX_Q));
+
     btm_multi_adv_idx_q.front = -1;
     btm_multi_adv_idx_q.rear = -1;
 
-    if (btm_cb.cmn_ble_vsc_cb.adv_inst_max > 0) {
+    if (max_adv_inst > 0)
+    {
         btm_multi_adv_cb.p_adv_inst = osi_calloc(sizeof(tBTM_BLE_MULTI_ADV_INST) *
-                                                 (btm_cb.cmn_ble_vsc_cb.adv_inst_max));
+                                                 (max_adv_inst));
 
         btm_multi_adv_cb.op_q.p_sub_code = osi_calloc(sizeof(UINT8) *
-                                                      (btm_cb.cmn_ble_vsc_cb.adv_inst_max));
+                                                      (max_adv_inst));
 
         btm_multi_adv_cb.op_q.p_inst_id = osi_calloc(sizeof(UINT8) *
-                                                     (btm_cb.cmn_ble_vsc_cb.adv_inst_max));
+                                                     (max_adv_inst));
+
+        btm_ble_ext_enable_cb.set_ids = osi_calloc(sizeof(UINT8) * max_adv_inst);
+
+        btm_ble_ext_enable_cb.durations = osi_calloc(sizeof(UINT16) * max_adv_inst);
+
+        btm_ble_ext_enable_cb.max_adv_events = osi_calloc(sizeof(UINT8) * max_adv_inst);
     }
 
     /* Initialize adv instance indices and IDs. */
-    for (i = 0; i < btm_cb.cmn_ble_vsc_cb.adv_inst_max; i++) {
+    for (i = 0; i < max_adv_inst; i++) {
         btm_multi_adv_cb.p_adv_inst[i].index = i;
         btm_multi_adv_cb.p_adv_inst[i].inst_id = i + 1;
         btm_multi_adv_cb.p_adv_inst[i].adv_raddr_timer =
             alarm_new("btm_ble.adv_raddr_timer");
     }
+    controller_get_interface()->set_ble_adv_ext_size(max_adv_inst);
 
-    BTM_RegisterForVSEvents(btm_ble_multi_adv_vse_cback, TRUE);
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if(!controller_get_interface()->supports_ble_extended_advertisements())
+#endif
+    {
+        BTM_RegisterForVSEvents(btm_ble_multi_adv_vse_cback, TRUE);
+    }
 }
 
 /*******************************************************************************
@@ -874,6 +1073,11 @@ void btm_ble_multi_adv_init()
 *******************************************************************************/
 void btm_ble_multi_adv_cleanup(void)
 {
+#ifdef WIPOWER_SUPPORTED
+    is_wipower_adv = false;
+    wipower_inst_id = BTM_BLE_MULTI_ADV_DEFAULT_STD;
+#endif
+
     pthread_mutex_lock(&btm_multi_adv_lock);
     if (btm_multi_adv_cb.p_adv_inst) {
         for (size_t i = 0; i < btm_cb.cmn_ble_vsc_cb.adv_inst_max; i++) {
@@ -884,6 +1088,10 @@ void btm_ble_multi_adv_cleanup(void)
 
     osi_free_and_reset((void **)&btm_multi_adv_cb.op_q.p_sub_code);
     osi_free_and_reset((void **)&btm_multi_adv_cb.op_q.p_inst_id);
+    osi_free_and_reset((void **)&btm_multi_adv_cb.op_q.p_inst_id);
+    osi_free_and_reset((void **)&btm_ble_ext_enable_cb.set_ids);
+    osi_free_and_reset((void **)&btm_ble_ext_enable_cb.durations);
+    osi_free_and_reset((void **)&btm_ble_ext_enable_cb.max_adv_events);
     pthread_mutex_unlock(&btm_multi_adv_lock);
 }
 
@@ -911,5 +1119,690 @@ void* btm_ble_multi_adv_get_ref(UINT8 inst_id)
 
     return NULL;
 }
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+
+/*******************************************************************************
+**
+** Function         btm_ble_enable_extended_adv
+**
+** Description      This function enables the extended adv
+**
+** Parameters       enable: enable or disable
+**                  inst_id:  adv instance ID, can not be 0
+**                  duration: duration of the adv
+**
+** Returns          status
+**
+*******************************************************************************/
+tBTM_STATUS btm_ble_enable_extended_adv (BOOLEAN enable, UINT8 inst_id, UINT16 duration, UINT8 max_ext_adv_evts, UINT8 cb_evt)
+{
+    UINT8           enb = enable ? 1: 0;
+    tBTM_STATUS     rt;
+
+    BTM_TRACE_EVENT ("%s: enb %d, Inst ID %d, dur = %d(s)",__func__, enb,inst_id, duration);
+    inst_id = inst_id - 1;
+    duration = duration * 100; //duration is interpreted as t*10msec
+
+    if ((rt = btsnd_hcic_ble_set_extended_adv_enable (enb,
+                                    1, //Num of sets
+                                    &inst_id,
+                                    &duration,
+                                    &max_ext_adv_evts))
+                                    == BTM_CMD_STARTED)
+    {
+        btm_ble_multi_adv_enq_op_q(BTM_BLE_MULTI_ADV_ENB, inst_id + 1, cb_evt);
+    }
+    return rt;
+}
+
+/*******************************************************************************
+**
+** Function         btm_ble_save_extended_adv_params
+**
+** Description      This function sets the extended adv params
+**
+** Parameters       p_inst: pointer to instance variable
+**                  p_params: adv parameters
+**                  cb_evt: callback event
+**
+** Returns          status
+**
+*******************************************************************************/
+void btm_ble_save_extended_adv_params (tBTM_BLE_MULTI_ADV_INST *p_inst,UINT32 adv_int_min, UINT32 adv_int_max,
+        UINT8 own_addr_type, UINT8 pri_phy, UINT8 adv_sid ,UINT8 sec_adv_max_skip, UINT8 sec_adv_phy,
+        UINT8 scan_req_notf_enb, UINT8 channel_map, UINT8 adv_filter_policy, UINT8 tx_power)
+{
+    if(p_inst != NULL)
+    {
+        p_inst->adv_int_min = adv_int_min;
+        p_inst->adv_int_max = adv_int_max;
+        p_inst->own_addr_type = own_addr_type;
+        p_inst->pri_phy = pri_phy;
+        p_inst->adv_sid = adv_sid;
+        p_inst->sec_adv_max_skip = sec_adv_max_skip;
+        p_inst->sec_adv_phy = sec_adv_phy;
+        p_inst->scan_req_notf_enb = scan_req_notf_enb;
+        p_inst->channel_map = channel_map;
+        p_inst->adv_filter_policy = adv_filter_policy;
+        p_inst->tx_power = tx_power;
+    }
+}
+
+
+/*******************************************************************************
+**
+** Function         btm_ble_extended_adv_set_params
+**
+** Description      This function sets the extended adv params
+**
+** Parameters       p_inst: pointer to instance variable
+**                  p_params: adv parameters
+**                  cb_evt: callback event
+**
+** Returns          status
+**
+*******************************************************************************/
+tBTM_STATUS btm_ble_extended_adv_set_params (tBTM_BLE_MULTI_ADV_INST *p_inst,
+                                             tBTM_BLE_ADV_PARAMS *p_params,
+                                             UINT8 cb_evt)
+{
+    UINT8             set_id;
+    tBTM_BLE_EXT_EVT  evt_prop = BTM_BLE_EXT_CONNECT_EVT;
+    tBTM_STATUS       rt;
+    tBLE_ADDR_TYPE    own_addr_type;
+    tBLE_ADDR_TYPE    dir_addr_type = BLE_ADDR_RANDOM;
+    UINT32            adv_int_min = 0, adv_int_max =0;
+    UINT8             adv_filter_policy = 0, tx_power =0, channel_map = 0;
+    UINT8             pri_phy = 0,sec_adv_max_skip=0, sec_adv_phy=0, adv_sid=1, scan_req_notf_enb=0;
+
+    if (!p_inst)
+    {
+        BTM_TRACE_ERROR ("%s: instance variable is null", __func__);
+        return BTM_ERR_PROCESSING;
+    }
+
+    if (0 == BTM_BleMaxMultiAdvInstanceCount())
+    {
+        BTM_TRACE_ERROR ("%s: Controller does not support extended Multi ADV", __func__);
+        return BTM_ERR_PROCESSING;
+    }
+
+    set_id = p_inst->inst_id;
+#if (defined BLE_PRIVACY_SPT && BLE_PRIVACY_SPT == TRUE)
+        if (btm_cb.ble_ctr_cb.privacy_mode != BTM_PRIVACY_NONE)
+        {
+            own_addr_type = BLE_ADDR_RANDOM_ID;
+        }
+        else
+#endif
+        {
+            own_addr_type = BLE_ADDR_PUBLIC;
+        }
+
+    if(p_params != NULL)
+    {
+        p_inst->duration = p_params->duration;
+        p_inst->adv_evt = p_params->adv_type;
+
+        adv_int_min = p_params->adv_int_min;
+        adv_int_max = p_params->adv_int_max;
+        //To identify that event type(adv type) parameter was read from bt_stack.conf and not sent from fwks
+        if(p_params->sec_adv_phy > 0)
+        {
+            evt_prop = p_params->adv_type;
+            pri_phy = p_params->pri_phy;
+            adv_sid = p_params->adv_sid;
+            scan_req_notf_enb =p_params->scan_req_notf_enb;
+            sec_adv_phy = p_params->sec_adv_phy;
+            sec_adv_max_skip = p_params->sec_adv_max_skip;
+        }
+        else
+        {
+            switch (p_params->adv_type)
+            {
+                case BTM_BLE_CONNECT_EVT:
+                    evt_prop = BTM_BLE_EXT_CONNECT_EVT;
+                    break;
+                case BTM_BLE_CONNECT_DIR_EVT:
+                    evt_prop = BTM_BLE_EXT_CONNECT_DIR_EVT;
+                    break;
+                case BTM_BLE_DISCOVER_EVT:
+                    evt_prop = BTM_BLE_EXT_DISCOVER_EVT;
+                    break;
+                case BTM_BLE_NON_CONNECT_EVT:
+                    evt_prop = BTM_BLE_EXT_NON_CONNECT_EVT;
+                    break;
+                case BTM_BLE_CONNECT_LO_DUTY_DIR_EVT:
+                    evt_prop = BTM_BLE_EXT_CONNECT_LO_DUTY_DIR_EVT;
+                    break;
+            }
+            pri_phy = BTM_DATA_RATE_ONE;
+            adv_sid = 0x01;
+
+        }
+        p_inst->evt_prop = evt_prop;
+
+        if (p_params->channel_map == 0 || p_params->channel_map > BTM_BLE_DEFAULT_ADV_CHNL_MAP)
+            channel_map = BTM_BLE_DEFAULT_ADV_CHNL_MAP;
+        else
+            channel_map = p_params->channel_map;
+
+        if (p_params->adv_filter_policy >= AP_SCAN_CONN_POLICY_MAX)
+            adv_filter_policy = AP_SCAN_CONN_ALL;
+        else
+            adv_filter_policy = p_params->adv_filter_policy;
+
+        if (p_params->tx_power > BTM_BLE_ADV_TX_POWER_MAX)
+            tx_power = BTM_BLE_ADV_TX_POWER_MAX;
+        else
+            tx_power = p_params->tx_power;
+
+        //save ext adv params in p_inst for reenabling adv for chained ext advs
+        btm_ble_save_extended_adv_params(p_inst, adv_int_min, adv_int_max, own_addr_type, pri_phy, adv_sid ,sec_adv_max_skip,
+                                         sec_adv_phy, scan_req_notf_enb, channel_map, adv_filter_policy,tx_power);
+    }
+    //else case is reached when adv is disabled and re enabled again for chained advs
+    else
+    {
+        evt_prop = p_inst->evt_prop;
+        adv_int_min = p_inst->adv_int_min;
+        adv_int_max =p_inst->adv_int_max;
+        channel_map =p_inst->channel_map;
+        adv_filter_policy =p_inst->adv_filter_policy;
+        tx_power=p_inst->tx_power;
+        pri_phy=p_inst->pri_phy;
+        sec_adv_max_skip=p_inst->sec_adv_max_skip;
+        sec_adv_phy =p_inst->sec_adv_phy;
+        adv_sid =p_inst->adv_sid;
+        scan_req_notf_enb=p_inst->scan_req_notf_enb;
+    }
+
+    BTM_TRACE_ERROR ("%s: evt_prop::%d, primary_phy=%d,p_params->sec_adv_max_skip=%d, p_params->sec_adv_phy=%d, p_params->adv_sid=%d, p_params->scan_req_notf_enb=%d", __func__,
+                    evt_prop, pri_phy, sec_adv_max_skip, sec_adv_phy, adv_sid, scan_req_notf_enb);
+
+    rt = btsnd_hcic_ble_set_extended_adv_params (set_id - 1, evt_prop,
+                                                 adv_int_min, adv_int_max,
+                                                 channel_map, own_addr_type,
+                                                 dir_addr_type, p_inst->rpa,
+                                                 adv_filter_policy, btm_ble_map_adv_tx_power(tx_power),
+                                                 pri_phy, sec_adv_max_skip,
+                                                 sec_adv_phy, adv_sid, scan_req_notf_enb);
+
+    if (rt == BTM_CMD_STARTED)
+    {
+        btm_ble_multi_adv_enq_op_q(BTM_BLE_MULTI_ADV_SET_PARAM, set_id, cb_evt);
+    }
+
+    return rt;
+}
+
+/*******************************************************************************
+**
+** Function         btm_ble_send_ext_adv_data
+**
+** Description      This function configure a Multi-ADV instance with the specified
+**                  adv data or scan response data.
+**
+** Parameters       inst_id: adv instance ID
+**                  is_scan_rsp: is this scan response. if no, set as adv data.
+**                  data_mask: adv data mask.
+**                  p_data: pointer to the adv data structure.
+**                  operation:
+**                  0x00: Intermediate fragment
+**                  0x01: first fragment
+**                  0x02: Last fragment
+**                  0x03: complete data, ctrlr fragmentation permitted
+**                  0x04: complete data, ctrlr fragmentation not permitted
+**
+** Returns          status
+**
+*******************************************************************************/
+tBTM_STATUS btm_ble_send_ext_adv_data (BOOLEAN is_scan_rsp, UINT8 inst_id, UINT8 operation, UINT8 frag_pref, UINT8 data_len, UINT8 *param)
+{
+    tBTM_STATUS rt;
+    UINT8 sub_code;
+    if (!is_scan_rsp)
+    {
+        rt = btsnd_hcic_ble_set_extended_adv_data(inst_id - 1,
+                                    operation,
+                                    frag_pref,
+                                    data_len,
+                                    param);
+        sub_code = BTM_BLE_MULTI_ADV_WRITE_ADV_DATA;
+    }
+    else
+    {
+        rt = btsnd_hcic_ble_set_extended_scan_rsp_data(inst_id - 1,
+                                    operation,
+                                    frag_pref,
+                                    data_len,
+                                    param);
+        sub_code = BTM_BLE_MULTI_ADV_WRITE_SCAN_RSP_DATA;
+    }
+
+    if (rt == BTM_CMD_STARTED)
+    {
+        btm_ble_multi_adv_enq_op_q(sub_code, inst_id, BTM_BLE_MULTI_ADV_DATA_EVT);
+    }
+    return rt;
+}
+
+
+/*******************************************************************************
+**
+** Function         btm_ble_compute_frag_lens
+**
+** Description      This function configure a Multi-ADV instance with the specified
+**                  adv data or scan response data.
+**
+** Parameters       inst_id: adv instance ID
+**                  is_scan_rsp: is this scan response. if no, set as adv data.
+**                  data_mask: adv data mask.
+**                  p_data: pointer to the adv data structure.
+**                  operation:
+**                  0x00: Intermediate fragment
+**                  0x01: first fragment
+**                  0x02: Last fragment
+**                  0x03: complete data, ctrlr fragmentation permitted
+**                  0x04: complete data, ctrlr fragmentation not permitted
+**
+** Returns          status
+**
+*******************************************************************************/
+void btm_ble_compute_frag_lens (UINT16 data_len, UINT8* num_hci_cmds, UINT8 *pp_data_len)
+{
+    UINT8 index = 0;
+    *num_hci_cmds = (data_len/(HCI_COMMAND_SIZE-4));
+    for(index=0; index < *num_hci_cmds; index++)
+        pp_data_len[index] = (HCI_COMMAND_SIZE -4);
+
+    if(data_len % (HCI_COMMAND_SIZE-4))
+    {
+        pp_data_len[index] = (data_len % (HCI_COMMAND_SIZE-4));
+        (*num_hci_cmds)++;
+    }
+    BTM_TRACE_EVENT("btm_ble_compute_frag_lens::Final num_hci_cmds=%d",*num_hci_cmds);
+}
+
+/*******************************************************************************
+**
+** Function         btm_ble_get_operation
+**
+** Description      This function configure a Multi-ADV instance with the specified
+**                  adv data or scan response data.
+**
+** Parameters       inst_id: adv instance ID
+**                  is_scan_rsp: is this scan response. if no, set as adv data.
+**                  data_mask: adv data mask.
+**                  p_data: pointer to the adv data structure.
+**                  operation:
+**                  0x00: Intermediate fragment
+**                  0x01: first fragment
+**                  0x02: Last fragment
+**                  0x03: complete data, ctrlr fragmentation permitted
+**                  0x04: complete data, ctrlr fragmentation not permitted
+**
+** Returns          status
+**
+*******************************************************************************/
+UINT8 btm_ble_get_operation (UINT8 num_hci_cmds_copy, UINT8 num_hci_cmds)
+{
+    UINT8 op = 0;
+    if(num_hci_cmds_copy == num_hci_cmds)
+        op = BTM_BLE_EXT_ADV_FIRST_FRAG;
+    else if(num_hci_cmds != 1)
+        op = BTM_BLE_EXT_ADV_INT_FRAG;
+    else
+        op = BTM_BLE_EXT_ADV_LAST_FRAG;
+    return op;
+}
+
+
+/*******************************************************************************
+**
+** Function         BTM_BleWriteExtendedAdvData
+**
+** Description      This function configure a Multi-ADV instance with the specified
+**                  adv data or scan response data.
+**
+** Parameters       inst_id: adv instance ID
+**                  is_scan_rsp: is this scan response. if no, set as adv data.
+**                  data_mask: adv data mask.
+**                  p_data: pointer to the adv data structure.
+**                  operation:
+**                  0x00: Intermediate fragment
+**                  0x01: first fragment
+**                  0x02: Last fragment
+**                  0x03: complete data, ctrlr fragmentation permitted
+**                  0x04: complete data, ctrlr fragmentation not permitted
+**
+** Returns          status
+**
+*******************************************************************************/
+tBTM_STATUS BTM_BleWriteExtendedAdvData (UINT8 inst_id, BOOLEAN is_scan_rsp,
+                                    tBTM_BLE_AD_MASK data_mask,
+                                    UINT8 operation, UINT8 frag_pref,
+                                    tBTM_BLE_ADV_DATA *p_data)
+{
+    UINT8       param[BTM_BLE_EXTENDED_AD_DATA_LEN], *pp = param, frag_data[HCI_COMMAND_SIZE-4];
+    UINT8       frag_data_len[BTM_BLE_EXT_ADV_MAX_FRAG_NUM], index=0;
+    UINT16      data_len, offset =0, j=0;
+    tBTM_STATUS rt;
+    UINT8       num_hci_cmds = 0, num_hci_cmds_copy = 0;
+    tBTM_BLE_MULTI_ADV_INST *p_inst;
+    tBTM_BLE_LOCAL_ADV_DATA *p_adv_data = &btm_cb.ble_ctr_cb.inq_var.adv_data;
+
+    if (0 == BTM_BleMaxMultiAdvInstanceCount())
+    {
+        BTM_TRACE_ERROR ("%s: Controller does not support extended Multi ADV", __func__);
+        return BTM_ERR_PROCESSING;
+    }
+    BTM_TRACE_EVENT("BTM_BleWriteExtendedAdvData");
+    if (stack_config_get_interface()->get_pts_le_nonconn_adv_enabled())
+    {
+        if (p_adv_data->p_flags != NULL)
+        {
+            p_data->flag = *(p_adv_data->p_flags);
+        }
+    }
+
+    btm_ble_update_dmt_flag_bits(&p_data->flag, btm_cb.btm_inq_vars.connectable_mode,
+                                        btm_cb.btm_inq_vars.discoverable_mode);
+
+    BTM_TRACE_EVENT("%s called with inst_id:%d", __func__, inst_id);
+    // inst_id will range from 1 to 16 max, so the below should ideally fail
+    if (inst_id > BTM_BLE_MULTI_ADV_MAX || inst_id == BTM_BLE_MULTI_ADV_DEFAULT_STD)
+        return BTM_ILLEGAL_VALUE;
+
+    p_inst = &btm_multi_adv_cb.p_adv_inst[inst_id - 1];
+
+    /* check if adv is not enabled for operations 0 to 3 */
+    if (p_inst->in_use && (operation < BTM_BLE_EXT_ADV_COMPLETE))
+    {
+        BTM_TRACE_ERROR ("%s: Illegal operation: %d while adv is enabled", __func__, operation);
+        return BTM_ILLEGAL_VALUE;
+    }
+
+    memset(param, 0, BTM_BLE_EXTENDED_AD_DATA_LEN);
+
+    if (p_inst->len == 0 || (p_inst->evt_prop & BTM_BLE_EXTENDED_LEGACY_MASK)) {
+        BTM_TRACE_ERROR("%s: using default length 31 bytes", __func__);
+        p_inst->len = BTM_BLE_AD_DATA_LEN;
+    }
+
+    btm_ble_build_adv_data(&data_mask, &pp, p_data, p_inst->len);
+    data_len = (UINT16) (pp - param);
+    BTM_TRACE_ERROR("%s: data len is %d", __func__, data_len);
+
+    if(data_len > HCI_COMMAND_SIZE)
+        btm_ble_compute_frag_lens(data_len, &num_hci_cmds, frag_data_len);
+
+    num_hci_cmds_copy = num_hci_cmds;
+
+    if(num_hci_cmds > 0)
+    {
+        //Disable advertisement
+        rt = btm_ble_enable_extended_adv (FALSE, inst_id,
+                                         p_inst->duration, 0/*p_params->max_ext_adv_evts*/,
+                                         0/*instead of BTM_BLE_MULTI_ADV_DISABLE_EVT*/);
+        p_inst->in_use = FALSE;
+
+        //set ext adv params
+        if (rt == BTM_CMD_STARTED)
+        {
+            p_inst->in_use = TRUE;
+            rt = btm_ble_extended_adv_set_params(p_inst, NULL, 0);
+        }
+
+        //set ext adv data
+        if (rt == BTM_CMD_STARTED)
+        {
+            while(num_hci_cmds)
+            {
+                memset(frag_data, 0, frag_data_len[index]);
+                BTM_TRACE_ERROR("offset =%d , index =%d ,frag_data_len[index] ::%d",offset, index, frag_data_len[index]);
+                for(j=0; j< frag_data_len[index]; j++)
+                {
+                    BTM_TRACE_ERROR("Adv data ::%02x",param[offset+j]);
+                }
+                memcpy(frag_data, (param+offset), frag_data_len[index]);
+                operation = btm_ble_get_operation(num_hci_cmds_copy, num_hci_cmds);
+                offset += frag_data_len[index];
+                rt = btm_ble_send_ext_adv_data(is_scan_rsp, inst_id, operation, frag_pref, frag_data_len[index++], frag_data);
+                num_hci_cmds--;
+            }
+        }
+        //enable ext adv
+        if (rt == BTM_CMD_STARTED)
+        {
+            rt = btm_ble_enable_extended_adv (TRUE, p_inst->inst_id, p_inst->duration, 0, 0/*instead of BTM_BLE_EXTENDED_ADV_ENB_EVT*/);
+        }
+    }
+    else
+        rt = btm_ble_send_ext_adv_data(is_scan_rsp, inst_id, operation, frag_pref, data_len, param);
+
+    return rt;
+}
+
+/*******************************************************************************
+**
+** Function         btm_ble_ext_adv_reenable
+**
+** Description      This function re-enable adv instance upon a connection establishment.
+**
+** Parameters       instance id
+**
+** Returns          none.
+**
+*******************************************************************************/
+void btm_ble_ext_adv_reenable(UINT8 inst_id)
+{
+    BTM_TRACE_DEBUG("%s, instance id: %d", __func__, inst_id);
+    tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[inst_id - 1];
+    //TODO: Use expired ticks instead. GKI_get_os_tick_count
+    // provides time in msec. Diff between current and start time
+    // to figure out remaining duration
+    UINT16 duration = p_inst->duration;
+
+    if (TRUE == p_inst->in_use)
+    {
+        // Verify the evt prop directed adv bit is 0
+        if (!(p_inst->evt_prop & 0x04))
+            btm_ble_enable_extended_adv (TRUE, p_inst->inst_id, duration, 0, 0);
+        else
+        {
+            //mark directed adv as disabled if adv has been stopped
+            (p_inst->p_cback)(BTM_BLE_MULTI_ADV_DISABLE_EVT,p_inst->inst_id,p_inst->p_ref,0);
+             p_inst->in_use = FALSE;
+        }
+     }
+}
+
+/*******************************************************************************
+**
+** Function         btm_ble_multi_adv_enable_all
+**
+** Description      This function enables/disables all adv instances at once
+**
+** Parameters       enable/disable
+**
+** Returns          none.
+**
+*******************************************************************************/
+void btm_ble_multi_adv_enable_all(UINT8 enable)
+{
+    BTM_TRACE_DEBUG("%s, enable = %d", __func__, enable);
+    int i;
+    tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[0];
+    UINT8 enb = enable? 1:0;
+    UINT8 num_instances = 0;
+
+    for (i = 0; i <  BTM_BleMaxMultiAdvInstanceCount() - 1; i++, p_inst++)
+    {
+        if (p_inst->in_use) {
+            btm_ble_ext_enable_cb.set_ids[num_instances] = p_inst->inst_id - 1;
+            btm_ble_ext_enable_cb.durations[num_instances] = p_inst->duration * 100;
+            btm_ble_ext_enable_cb.max_adv_events[num_instances] = 0x00;
+            num_instances++;
+        }
+    }
+
+    if (num_instances == 0) return;
+
+    if (!enable)
+    {
+       if (btsnd_hcic_ble_set_extended_adv_enable(enb, 0, NULL, NULL, NULL)
+                                                   == BTM_CMD_STARTED)
+       {
+           btm_ble_multi_adv_enq_op_q(BTM_BLE_MULTI_ADV_ENB, 1, 0);
+       }
+    }
+    else
+    {
+        if ((btsnd_hcic_ble_set_extended_adv_enable (enb,
+                                    num_instances,
+                                    btm_ble_ext_enable_cb.set_ids,
+                                    btm_ble_ext_enable_cb.durations,
+                                    btm_ble_ext_enable_cb.max_adv_events))
+                                    == BTM_CMD_STARTED)
+        {
+            btm_ble_multi_adv_enq_op_q(BTM_BLE_MULTI_ADV_ENB, 1, 0);
+        }
+    }
+}
+
+/*******************************************************************************
+**
+** Function         btm_ble_adv_set_terminated_evt
+**
+** Description      This function is a callback event when an adv set is
+**                  terminiated due to connection complete or due to duration
+**                  timeout
+**
+** Returns          void
+**
+*******************************************************************************/
+
+void btm_ble_adv_set_terminated_evt (UINT8* p)
+{
+    BTM_TRACE_EVENT("%s", __func__);
+    UINT8 status;
+    UINT8 inst_id;
+    UINT16 handle;
+    tBTM_BLE_MULTI_ADV_INST *p_inst;
+
+    STREAM_TO_UINT8(status,p);
+    STREAM_TO_UINT8(inst_id, p);
+
+    //Adjust inst_id to base 1
+    inst_id++;
+
+    STREAM_TO_UINT16(handle, p);
+    BTM_TRACE_DEBUG("%s, status = %d, inst_id = %d, handle = %x",
+                     __func__, status, inst_id, handle);
+
+    if (inst_id > BTM_BleMaxMultiAdvInstanceCount() ||
+        inst_id == BTM_BLE_MULTI_ADV_DEFAULT_STD)
+    {
+        BTM_TRACE_ERROR("%s:Invalid instance received", __func__);
+        return;
+    }
+
+    p_inst = &btm_multi_adv_cb.p_adv_inst[inst_id - 1];
+
+    if (status == BTM_BLE_EXTENDED_ADV_TIMEOUT)
+    {
+        p_inst->in_use = FALSE;
+        if (p_inst->p_cback)
+            (p_inst->p_cback)(BTM_BLE_MULTI_ADV_DISABLE_EVT,p_inst->inst_id, p_inst->p_ref, 0);
+    }
+
+    else if (status == HCI_SUCCESS)
+    {
+        btm_ble_ext_adv_reenable(inst_id);
+    }
+}
+
+
+/*******************************************************************************
+**
+** Function         btm_ble_adv_extension_operation_complete
+**
+** Description      This function is a callback event of adv extension operation
+**                  including write rpa, set adv data/scan rsp data
+**
+** Returns          void
+**
+*******************************************************************************/
+
+void btm_ble_adv_extension_operation_complete(UINT8* p, UINT16 hcicmd)
+{
+    UINT8 status;
+    UINT8 cb_evt = 0, opcode;
+    UINT8 subcode = 0;
+    UINT8 inst_id;
+    tBTM_BLE_MULTI_ADV_INST *p_inst ;
+    STREAM_TO_UINT8 (status, p);
+
+    BTM_TRACE_EVENT ("%s, status: %d, opcode = %d", __func__, status, hcicmd);
+
+    if (status != HCI_SUCCESS)
+    {
+        BTM_TRACE_ERROR ("%s, HCI command failure", __func__);
+        return;
+    }
+
+    btm_ble_multi_adv_deq_op_q(&opcode, &inst_id, &cb_evt);
+
+    switch (hcicmd)
+    {
+        case HCI_BLE_WRITE_EXTENDED_ADV_RPA:
+            subcode = BTM_BLE_MULTI_ADV_SET_RANDOM_ADDR;
+            break;
+        case HCI_BLE_WRITE_EXTENDED_ADV_DATA:
+            subcode = BTM_BLE_MULTI_ADV_WRITE_ADV_DATA;
+            break;
+        case HCI_BLE_WRITE_EXTENDED_SCAN_RSP_DATA:
+            subcode = BTM_BLE_MULTI_ADV_WRITE_SCAN_RSP_DATA;
+            break;
+        case HCI_BLE_WRITE_EXTENDED_ADV_PARAMS:
+            subcode = BTM_BLE_MULTI_ADV_SET_PARAM;
+            break;
+        case HCI_BLE_WRITE_EXTENDED_ADV_ENABLE:
+            subcode = BTM_BLE_MULTI_ADV_ENB;
+            break;
+    }
+
+    if (opcode != subcode)
+    {
+        BTM_TRACE_ERROR("got unexpected Event, expected: %d got: %d", opcode, subcode);
+        return;
+    }
+    p_inst = &btm_multi_adv_cb.p_adv_inst[inst_id - 1];
+
+    if (cb_evt != 0 && p_inst->p_cback != NULL)
+    {
+        (p_inst->p_cback)(cb_evt, inst_id, p_inst->p_ref, status);
+    }
+    return;
+}
+
+UINT8 BTM_BleGetAvailableMAInstance ()
+{
+    int index = 0;
+    tBTM_BLE_MULTI_ADV_INST *p_inst = &btm_multi_adv_cb.p_adv_inst[0];
+
+    BTM_TRACE_EVENT("BTM_BleGetAvailableMAInstance");
+
+    for (index = 0; index <  BTM_BleMaxMultiAdvInstanceCount() - 1; index++, p_inst++)
+    {
+        if (FALSE == p_inst->in_use)
+            break;
+    }
+    return index;
+}
+
+#endif
 #endif
 
diff --git a/stack/btm/btm_ble_privacy.c b/stack/btm/btm_ble_privacy.c
index c8fe541..0805d34 100644
--- a/stack/btm/btm_ble_privacy.c
+++ b/stack/btm/btm_ble_privacy.c
@@ -610,6 +610,15 @@ BOOLEAN btm_ble_suspend_resolving_list_activity(void)
     if (btm_ble_suspend_bg_conn())
         p_ble_cb->suspended_rl_state |= BTM_BLE_RL_INIT;
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
+    {
+      /* Disable extended adv sets if any is enabled*/
+      p_ble_cb->suspended_rl_state |= BTM_BLE_RL_EXT_ADV;
+      btm_ble_multi_adv_enable_all(FALSE);
+    }
+#endif
+
     return TRUE;
 }
 
@@ -628,6 +637,8 @@ void btm_ble_resume_resolving_list_activity(void)
 {
     tBTM_BLE_CB *p_ble_cb = &btm_cb.ble_ctr_cb;
 
+    p_ble_cb->inq_var.scan_duration = 0;
+    p_ble_cb->inq_var.scan_period = 0;
     if (p_ble_cb->suspended_rl_state & BTM_BLE_RL_ADV)
         btm_ble_start_adv();
 
@@ -637,6 +648,14 @@ void btm_ble_resume_resolving_list_activity(void)
     if  (p_ble_cb->suspended_rl_state & BTM_BLE_RL_INIT)
         btm_ble_resume_bg_conn();
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
+    {
+      if  (p_ble_cb->suspended_rl_state & BTM_BLE_RL_EXT_ADV)
+          btm_ble_multi_adv_enable_all(TRUE);
+    }
+#endif
+
     p_ble_cb->suspended_rl_state = BTM_BLE_RL_IDLE;
 }
 
@@ -747,6 +766,61 @@ BOOLEAN btm_ble_disable_resolving_list(UINT8 rl_mask, BOOLEAN to_resume )
     return TRUE;
 }
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+/*******************************************************************************
+**
+** Function         btm_ble_add_multi_adv_rpa
+**
+** Description      This function adds a dummy rpa to the resolving list for
+**                  auto generating the mutli adv set rpa
+**
+** Parameters       peer rpa to be added, addr_type
+**
+** Returns          TRUE if device added, otherwise false
+**
+*******************************************************************************/
+BOOLEAN btm_ble_add_multi_adv_rpa(BD_ADDR bda, tBLE_ADDR_TYPE addr_type)
+{
+    BOOLEAN rt = FALSE;
+    UINT8 rl_mask = btm_cb.ble_ctr_cb.rl_state;
+    BTM_TRACE_DEBUG("%s, mask = %d", __func__, rl_mask);
+    /* if controller does not support RPA offloading or privacy 1.2, skip */
+    if (controller_get_interface()->get_ble_resolving_list_max_size() == 0) {
+        BTM_TRACE_ERROR("%s, resolving list not available", __func__);
+        return rt;
+    }
+
+    if (!controller_get_interface()->supports_ble_privacy()) {
+        BTM_TRACE_ERROR("%s, privacy not supported", __func__);
+        return rt;
+    }
+
+    if (btm_cb.ble_ctr_cb.resolving_list_avail_size == 0) {
+        BTM_TRACE_ERROR("%s, resolving list already full", __func__);
+        return rt;
+    }
+
+    if (rl_mask)
+    {
+        if (!btm_ble_disable_resolving_list (rl_mask, FALSE)) {
+            return rt;
+        }
+    }
+
+    UINT8 *local_irk = btm_cb.devcb.id_keys.irk;
+    BT_OCTET16 peer_irk = {0};
+    BTM_TRACE_DEBUG("%s:adding device to controller resolving list", __func__);
+    rt = btsnd_hcic_ble_add_device_resolving_list(addr_type, bda, peer_irk, local_irk);
+
+    if (rt)
+        btm_ble_enq_resolving_list_pending(bda, BTM_BLE_META_ADD_IRK_ENTRY);
+
+    if (rl_mask)
+        btm_ble_enable_resolving_list(rl_mask);
+    return rt;
+}
+#endif
+
 /*******************************************************************************
 **
 ** Function         btm_ble_resolving_list_load_dev
@@ -807,6 +881,12 @@ BOOLEAN btm_ble_resolving_list_load_dev(tBTM_SEC_DEV_REC *p_dev_rec)
                     // use identical IRK for now
                     rt = btsnd_hcic_ble_add_device_resolving_list(p_dev_rec->ble.static_addr_type,
                               p_dev_rec->ble.static_addr, peer_irk, local_irk);
+                    if (rt && controller_get_interface()->supports_set_le_privacy_mode()) {
+                        BTM_TRACE_DEBUG("%s:adding device privacy mode", __func__);
+                        rt = btsnd_hcic_ble_set_privacy_mode(p_dev_rec->ble.static_addr_type,
+                                                             p_dev_rec->ble.static_addr,
+                                                             0x01);
+                    }
                 }
                 else
                 {
diff --git a/stack/btm/btm_dev.c b/stack/btm/btm_dev.c
index 8e0510b..5db85f5 100644
--- a/stack/btm/btm_dev.c
+++ b/stack/btm/btm_dev.c
@@ -37,8 +37,6 @@
 #include "hcidefs.h"
 #include "l2c_api.h"
 
-static tBTM_SEC_DEV_REC *btm_find_oldest_dev (void);
-
 /*******************************************************************************
 **
 ** Function         BTM_SecAddDevice
@@ -63,22 +61,12 @@ BOOLEAN BTM_SecAddDevice (BD_ADDR bd_addr, DEV_CLASS dev_class, BD_NAME bd_name,
                           LINK_KEY link_key, UINT8 key_type, tBTM_IO_CAP io_cap,
                           UINT8 pin_length)
 {
-    tBTM_SEC_DEV_REC  *p_dev_rec;
-    int               i, j;
-    BOOLEAN           found = FALSE;
-
     BTM_TRACE_API("%s: link key type:%x", __func__, key_type);
-    p_dev_rec = btm_find_dev (bd_addr);
+
+    tBTM_SEC_DEV_REC *p_dev_rec = btm_find_dev (bd_addr);
     if (!p_dev_rec)
     {
-        if (list_length(btm_cb.sec_dev_rec) > BTM_SEC_MAX_DEVICE_RECORDS) {
-            BTM_TRACE_DEBUG("%s: Max devices reached!", __func__);
-            return FALSE;
-        }
-
-        BTM_TRACE_DEBUG ("%s: allocate a new dev rec", __func__);
-        p_dev_rec = osi_calloc(sizeof(tBTM_SEC_DEV_REC));
-        list_append(btm_cb.sec_dev_rec, p_dev_rec);
+        p_dev_rec = btm_sec_allocate_dev_rec();
 
         memcpy (p_dev_rec->bd_addr, bd_addr, BD_ADDR_LEN);
         p_dev_rec->hci_handle = BTM_GetHCIConnHandle (bd_addr, BT_TRANSPORT_BR_EDR);
@@ -88,11 +76,19 @@ BOOLEAN BTM_SecAddDevice (BD_ADDR bd_addr, DEV_CLASS dev_class, BD_NAME bd_name,
         /* update conn params, use default value for background connection params */
         memset(&p_dev_rec->conn_params, 0xff, sizeof(tBTM_LE_CONN_PRAMS));
 #endif
+    } else {
+        /* "Bump" timestamp for existing record */
+        p_dev_rec->timestamp = btm_cb.dev_rec_count++;
+
+        /* TODO(eisenbach):
+         * Small refactor, but leaving original logic for now.
+         * On the surface, this does not make any sense at all. Why change the
+         * bond state for an existing device here? This logic should be verified
+         * as part of a larger refactor.
+         */
+        p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
     }
 
-    p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;           /* Default value */
-    p_dev_rec->timestamp = btm_cb.dev_rec_count++;
-
     if (dev_class)
         memcpy (p_dev_rec->dev_class, dev_class, DEV_CLASS_LEN);
 
@@ -108,26 +104,23 @@ BOOLEAN BTM_SecAddDevice (BD_ADDR bd_addr, DEV_CLASS dev_class, BD_NAME bd_name,
     p_dev_rec->num_read_pages = 0;
     if (features)
     {
+        BOOLEAN found = FALSE;
         memcpy (p_dev_rec->features, features, sizeof (p_dev_rec->features));
-        for (i = HCI_EXT_FEATURES_PAGE_MAX; i >= 0; i--)
+        for (int i = HCI_EXT_FEATURES_PAGE_MAX; !found && i >= 0; i--)
         {
-            for (j = 0; j < HCI_FEATURE_BYTES_PER_PAGE; j++)
+            for (int j = 0; j < HCI_FEATURE_BYTES_PER_PAGE; j++)
             {
                 if (p_dev_rec->features[i][j] != 0)
                 {
                     found = TRUE;
+                    p_dev_rec->num_read_pages = i + 1;
                     break;
                 }
             }
-            if (found)
-            {
-                p_dev_rec->num_read_pages = i + 1;
-                break;
-            }
         }
-    }
-    else
+    } else {
         memset (p_dev_rec->features, 0, sizeof (p_dev_rec->features));
+    }
 
     BTM_SEC_COPY_TRUSTED_DEVICE(trusted_mask, p_dev_rec->trusted_mask);
 
@@ -177,8 +170,6 @@ BOOLEAN BTM_SecAddDevice (BD_ADDR bd_addr, DEV_CLASS dev_class, BD_NAME bd_name,
 *******************************************************************************/
 BOOLEAN BTM_SecDeleteDevice (BD_ADDR bd_addr)
 {
-    tBTM_SEC_DEV_REC *p_dev_rec;
-
     if (BTM_IsAclConnectionUp(bd_addr, BT_TRANSPORT_LE) ||
         BTM_IsAclConnectionUp(bd_addr, BT_TRANSPORT_BR_EDR))
     {
@@ -186,7 +177,8 @@ BOOLEAN BTM_SecDeleteDevice (BD_ADDR bd_addr)
         return FALSE;
     }
 
-    if ((p_dev_rec = btm_find_dev(bd_addr)) != NULL)
+    tBTM_SEC_DEV_REC *p_dev_rec = btm_find_dev(bd_addr);
+    if (p_dev_rec != NULL)
     {
         btm_sec_free_dev(p_dev_rec);
         /* Tell controller to get rid of the link key, if it has one stored */
@@ -198,6 +190,25 @@ BOOLEAN BTM_SecDeleteDevice (BD_ADDR bd_addr)
 
 /*******************************************************************************
 **
+** Function         BTM_SecClearSecurityFlags
+**
+** Description      Reset the security flags (mark as not-paired) for a given
+**                  remove device.
+**
+*******************************************************************************/
+extern void BTM_SecClearSecurityFlags (BD_ADDR bd_addr)
+{
+    tBTM_SEC_DEV_REC *p_dev_rec = btm_find_dev(bd_addr);
+    if (p_dev_rec == NULL)
+        return;
+
+    p_dev_rec->sec_flags = 0;
+    p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
+    p_dev_rec->sm4 = BTM_SM4_UNKNOWN;
+}
+
+/*******************************************************************************
+**
 ** Function         BTM_SecReadDevName
 **
 ** Description      Looks for the device name in the security database for the
@@ -240,20 +251,10 @@ bool is_bd_addr_equal(void *data, void *context)
 *******************************************************************************/
 tBTM_SEC_DEV_REC *btm_sec_alloc_dev (BD_ADDR bd_addr)
 {
-    tBTM_SEC_DEV_REC *p_dev_rec = NULL;
     tBTM_INQ_INFO    *p_inq_info;
     BTM_TRACE_EVENT ("btm_sec_alloc_dev");
 
-    if (list_length(btm_cb.sec_dev_rec) > BTM_SEC_MAX_DEVICE_RECORDS) {
-        p_dev_rec = btm_find_oldest_dev();
-    } else {
-        BTM_TRACE_DEBUG ("allocate a new dev rec");
-        p_dev_rec = osi_calloc(sizeof(tBTM_SEC_DEV_REC));
-        list_append(btm_cb.sec_dev_rec, p_dev_rec);
-    }
-
-    p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;           /* Default value */
-    p_dev_rec->sec_flags = BTM_SEC_IN_USE;
+    tBTM_SEC_DEV_REC *p_dev_rec = btm_sec_allocate_dev_rec();
 
     /* Check with the BT manager if details about remote device are known */
     /* outgoing connection */
@@ -280,7 +281,6 @@ tBTM_SEC_DEV_REC *btm_sec_alloc_dev (BD_ADDR bd_addr)
     p_dev_rec->ble_hci_handle = BTM_GetHCIConnHandle (bd_addr, BT_TRANSPORT_LE);
 #endif
     p_dev_rec->hci_handle = BTM_GetHCIConnHandle (bd_addr, BT_TRANSPORT_BR_EDR);
-    p_dev_rec->timestamp = btm_cb.dev_rec_count++;
 
     return(p_dev_rec);
 }
@@ -298,15 +298,13 @@ void btm_sec_free_dev (tBTM_SEC_DEV_REC *p_dev_rec)
     p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
     p_dev_rec->sec_flags = 0;
     p_dev_rec->sm4 = BTM_SM4_UNKNOWN;
+    p_dev_rec->p_callback = NULL;
 
 #if BLE_INCLUDED == TRUE
     /* Clear out any saved BLE keys */
     btm_sec_clear_ble_keys (p_dev_rec);
-    /* clear the ble block */
-    memset(&p_dev_rec->ble, 0, sizeof(tBTM_SEC_BLE));
 #endif
-
-
+    list_remove(btm_cb.sec_dev_rec, p_dev_rec);
 }
 
 /*******************************************************************************
@@ -425,12 +423,12 @@ bool is_address_equal(void *data, void *context)
 ** Returns          Pointer to the record or NULL
 **
 *******************************************************************************/
-tBTM_SEC_DEV_REC *btm_find_dev(BD_ADDR bd_addr)
+tBTM_SEC_DEV_REC *btm_find_dev(const BD_ADDR bd_addr)
 {
     if (!bd_addr)
         return NULL;
 
-    list_node_t *n = list_foreach(btm_cb.sec_dev_rec, is_address_equal, bd_addr);
+    list_node_t *n = list_foreach(btm_cb.sec_dev_rec, is_address_equal, (void*)bd_addr);
     if (n)
         return list_node(n);
 
@@ -490,8 +488,6 @@ void btm_consolidate_dev(tBTM_SEC_DEV_REC *p_target_rec)
 
                 /* remove the combined record */
                 list_remove(btm_cb.sec_dev_rec, p_dev_rec);
-
-                p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
             }
         }
     }
@@ -523,48 +519,79 @@ tBTM_SEC_DEV_REC *btm_find_or_alloc_dev (BD_ADDR bd_addr)
 
 /*******************************************************************************
 **
-** Function         btm_find_oldest_dev
+** Function         btm_find_oldest_dev_rec
 **
 ** Description      Locates the oldest device in use. It first looks for
 **                  the oldest non-paired device.  If all devices are paired it
-**                  deletes the oldest paired device.
+**                  returns the oldest paired device.
 **
 ** Returns          Pointer to the record or NULL
 **
 *******************************************************************************/
-tBTM_SEC_DEV_REC *btm_find_oldest_dev (void)
+static tBTM_SEC_DEV_REC* btm_find_oldest_dev_rec (void)
 {
     tBTM_SEC_DEV_REC *p_oldest = NULL;
-    UINT32       ot = 0xFFFFFFFF;
+    UINT32       ts_oldest = 0xFFFFFFFF;
     tBTM_SEC_DEV_REC *p_oldest_paired = NULL;
-    UINT32       ot_paired = 0xFFFFFFFF;
+    UINT32       ts_oldest_paired = 0xFFFFFFFF;
 
-    /* First look for the non-paired devices for the oldest entry */
     list_node_t *end = list_end(btm_cb.sec_dev_rec);
     for (list_node_t *node = list_begin(btm_cb.sec_dev_rec); node != end; node = list_next(node)) {
         tBTM_SEC_DEV_REC *p_dev_rec = list_node(node);
-        /* Device is not paired */
-        if ((p_dev_rec->sec_flags & (BTM_SEC_LINK_KEY_KNOWN |BTM_SEC_LE_LINK_KEY_KNOWN)) == 0) {
-            if (p_dev_rec->timestamp < ot) {
+
+        if ((p_dev_rec->sec_flags & (BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LE_LINK_KEY_KNOWN)) == 0) {
+            // Device is not paired
+            if (p_dev_rec->timestamp < ts_oldest) {
                 p_oldest = p_dev_rec;
-                ot       = p_dev_rec->timestamp;
+                ts_oldest = p_dev_rec->timestamp;
+            }
+        } else {
+            // Paired device
+            if (p_dev_rec->timestamp < ts_oldest_paired) {
+                p_oldest_paired = p_dev_rec;
+                ts_oldest_paired = p_dev_rec->timestamp;
             }
-            continue;
         }
+    }
 
-        if (p_dev_rec->timestamp < ot_paired) {
-            p_oldest_paired = p_dev_rec;
-            ot_paired       = p_dev_rec->timestamp;
-        }
+    // If we did not find any non-paired devices, use the oldest paired one...
+    if (ts_oldest == 0xFFFFFFFF)
+        p_oldest = p_oldest_paired;
 
+    return p_oldest;
+}
+
+/*******************************************************************************
+**
+** Function         btm_sec_allocate_dev_rec
+**
+** Description      Attempts to allocate a new device record. If we have
+**                  exceeded the maximum number of allowable records to
+**                  allocate, the oldest record will be deleted to make room
+**                  for the new record.
+**
+** Returns          Pointer to the newly allocated record
+**
+*******************************************************************************/
+tBTM_SEC_DEV_REC* btm_sec_allocate_dev_rec(void)
+{
+    tBTM_SEC_DEV_REC *p_dev_rec = NULL;
+
+    if (list_length(btm_cb.sec_dev_rec) > BTM_SEC_MAX_DEVICE_RECORDS)
+    {
+        p_dev_rec = btm_find_oldest_dev_rec();
+        list_remove(btm_cb.sec_dev_rec, p_dev_rec);
     }
 
-    /* if non-paired device return oldest */
-    if (ot != 0xFFFFFFFF)
-        return(p_oldest);
+    p_dev_rec = osi_calloc(sizeof(tBTM_SEC_DEV_REC));
+    list_append(btm_cb.sec_dev_rec, p_dev_rec);
+
+    // Initialize defaults
+    p_dev_rec->sec_flags = BTM_SEC_IN_USE;
+    p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
+    p_dev_rec->timestamp = btm_cb.dev_rec_count++;
 
-    /* only paired devices present, return oldest */
-    return p_oldest_paired;
+    return p_dev_rec;
 }
 
 /*******************************************************************************
diff --git a/stack/btm/btm_devctl.c b/stack/btm/btm_devctl.c
index 2f35a66..8105298 100644
--- a/stack/btm/btm_devctl.c
+++ b/stack/btm/btm_devctl.c
@@ -178,7 +178,15 @@ static void reset_complete(void *result) {
   btm_cb.ble_ctr_cb.bg_conn_type = BTM_BLE_CONN_NONE;
   btm_cb.ble_ctr_cb.p_select_cback = NULL;
   gatt_reset_bgdev_list();
-  btm_ble_multi_adv_init();
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+  if (controller->supports_ble() && controller->supports_ble_extended_advertisements() &&
+      controller->get_ble_adv_ext_size() > 0) {
+    // provide an extra instance to accomodate for the 0th instance
+    btm_ble_multi_adv_init(controller->get_ble_adv_ext_size() + 1);
+  }
+#endif
+
 #endif
 
   btm_pm_reset();
@@ -200,6 +208,12 @@ static void reset_complete(void *result) {
     btm_ble_white_list_init(controller->get_ble_white_list_size());
     l2c_link_processs_ble_num_bufs(controller->get_acl_buffer_count_ble());
   }
+
+  if(controller->supports_ble_two_mbps_rate()) {
+      /* set 2mbps Tx and Rx if supported*/
+      btsnd_hcic_ble_set_default_data_rate(0, BTM_DATA_RATE_TWO|BTM_DATA_RATE_ONE,
+                                           BTM_DATA_RATE_TWO|BTM_DATA_RATE_ONE);
+  }
 #endif
 
   BTM_SetPinType (btm_cb.cfg.pin_type, btm_cb.cfg.pin_code, btm_cb.cfg.pin_code_len);
@@ -437,6 +451,11 @@ static void btm_decode_ext_features_page (UINT8 page_number, const UINT8 *p_feat
         /* Nothing to do for page 2 */
         break;
 
+    /* Extended Page 3 */
+    case HCI_EXT_FEATURES_PAGE_3:
+        /* Nothing to do for page 3 */
+        break;
+
     default:
         BTM_TRACE_ERROR("btm_decode_ext_features_page page=%d unknown", page_number);
         break;
diff --git a/stack/btm/btm_inq.c b/stack/btm/btm_inq.c
index 93954d8..9d9a213 100644
--- a/stack/btm/btm_inq.c
+++ b/stack/btm/btm_inq.c
@@ -171,6 +171,11 @@ tBTM_STATUS BTM_SetDiscoverability (UINT16 inq_mode, UINT16 window, UINT16 inter
     BOOLEAN      cod_limited;
 
     BTM_TRACE_API ("BTM_SetDiscoverability");
+
+    /* Make sure the controller is active */
+    if (!controller_get_interface()->get_is_ready())
+        return (BTM_DEV_RESET);
+
 #if (BLE_INCLUDED == TRUE && BLE_INCLUDED == TRUE)
     if (controller_get_interface()->supports_ble())
     {
@@ -188,10 +193,6 @@ tBTM_STATUS BTM_SetDiscoverability (UINT16 inq_mode, UINT16 window, UINT16 inter
     if (inq_mode > BTM_MAX_DISCOVERABLE)
         return (BTM_ILLEGAL_VALUE);
 
-    /* Make sure the controller is active */
-    if (!controller_get_interface()->get_is_ready())
-        return (BTM_DEV_RESET);
-
     /* If the window and/or interval is '0', set to default values */
     if (!window)
         window = BTM_DEFAULT_DISC_WINDOW;
@@ -844,7 +845,17 @@ tBTM_STATUS BTM_StartInquiry (tBTM_INQ_PARMS *p_inqparms, tBTM_INQ_RESULTS_CB *p
             p_inq->scan_type = INQ_GENERAL;
             p_inq->inq_active = BTM_INQUIRY_INACTIVE;
             btm_cb.ble_ctr_cb.inq_var.scan_type = BTM_BLE_SCAN_MODE_NONE;
-            btsnd_hcic_ble_set_scan_enable (BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE);
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+            if (controller_get_interface()->supports_ble_extended_advertisements())
+            {
+                btsnd_hcic_ble_set_extended_scan_enable(BTM_BLE_SCAN_DISABLE,BTM_BLE_DUPLICATE_ENABLE, 0, 0);
+            }
+            else
+#endif
+            {
+                btsnd_hcic_ble_set_scan_enable (BTM_BLE_SCAN_DISABLE, BTM_BLE_DUPLICATE_ENABLE);
+            }
         }
         else
 #endif
@@ -1131,7 +1142,7 @@ tBTM_STATUS  BTM_CancelRemoteDeviceName (void)
 ** Returns          pointer to entry, or NULL if not found
 **
 *******************************************************************************/
-tBTM_INQ_INFO *BTM_InqDbRead (BD_ADDR p_bda)
+tBTM_INQ_INFO *BTM_InqDbRead (const BD_ADDR p_bda)
 {
     BTM_TRACE_API ("BTM_InqDbRead: bd addr [%02x%02x%02x%02x%02x%02x]",
                p_bda[0], p_bda[1], p_bda[2], p_bda[3], p_bda[4], p_bda[5]);
@@ -1538,7 +1549,7 @@ BOOLEAN btm_inq_find_bdaddr (BD_ADDR p_bda)
 ** Returns          pointer to entry, or NULL if not found
 **
 *******************************************************************************/
-tINQ_DB_ENT *btm_inq_db_find (BD_ADDR p_bda)
+tINQ_DB_ENT *btm_inq_db_find (const BD_ADDR p_bda)
 {
     UINT16       xx;
     tINQ_DB_ENT  *p_ent = btm_cb.btm_inq_vars.inq_db;
@@ -2052,6 +2063,8 @@ void btm_process_inq_results (UINT8 *p, UINT8 inq_res_mode)
             else
                 p_eir_data = NULL;
 
+            /* Set EIR data length */
+            p_cur->adv_data_len = HCI_EXT_INQ_RESPONSE_LEN;
             /* If a callback is registered, call it with the results */
             if (p_inq_results_cb)
                 (p_inq_results_cb)((tBTM_INQ_RESULTS *) p_cur, p_eir_data);
@@ -2198,7 +2211,7 @@ void btm_process_inq_complete (UINT8 status, UINT8 mode)
         if(p_inq->p_inq_ble_results_cb != NULL)
         {
             BTM_TRACE_DEBUG("BTM Inq Compl: resuming a pending LE scan");
-            BTM_BleObserve(1,0, p_inq->p_inq_ble_results_cb, p_inq->p_inq_ble_cmpl_cb);
+            BTM_BleObserve(1,0/*duration*/, 0 /*period*/, p_inq->p_inq_ble_results_cb, p_inq->p_inq_ble_cmpl_cb);
         }
 #endif
     }
@@ -2525,7 +2538,7 @@ tBTM_STATUS BTM_WriteEIR( BT_HDR *p_buff )
 ** Returns          pointer of EIR data
 **
 *******************************************************************************/
-UINT8 *BTM_CheckEirData( UINT8 *p_eir, UINT8 type, UINT8 *p_length )
+UINT8 *BTM_CheckEirData( UINT8 *p_eir, UINT8 type, UINT8 *p_length, UINT16 adv_data_len )
 {
     UINT8 *p = p_eir;
     UINT8 length;
@@ -2533,7 +2546,7 @@ UINT8 *BTM_CheckEirData( UINT8 *p_eir, UINT8 type, UINT8 *p_length )
     BTM_TRACE_API("BTM_CheckEirData type=0x%02X", type);
 
     STREAM_TO_UINT8(length, p);
-    while( length && (p - p_eir <= HCI_EXT_INQ_RESPONSE_LEN))
+    while( length && (p - p_eir <= adv_data_len))
     {
         STREAM_TO_UINT8(eir_type, p);
         if( eir_type == type )
@@ -2830,10 +2843,10 @@ static UINT8 *btm_eir_get_uuid_list( UINT8 *p_eir, UINT8 uuid_size,
         break;
     }
 
-    p_uuid_data = BTM_CheckEirData( p_eir, complete_type, &uuid_len );
+    p_uuid_data = BTM_CheckEirData( p_eir, complete_type, &uuid_len, HCI_EXT_INQ_RESPONSE_LEN);
     if(p_uuid_data == NULL)
     {
-        p_uuid_data = BTM_CheckEirData( p_eir, more_type, &uuid_len );
+        p_uuid_data = BTM_CheckEirData( p_eir, more_type, &uuid_len, HCI_EXT_INQ_RESPONSE_LEN);
         *p_uuid_list_type = more_type;
     }
     else
diff --git a/stack/btm/btm_int.h b/stack/btm/btm_int.h
index cfcc30a..d633c33 100644
--- a/stack/btm/btm_int.h
+++ b/stack/btm/btm_int.h
@@ -831,6 +831,7 @@ typedef struct
     UINT16                  ediv;       /* received ediv value from LTK request */
     UINT8                   key_size;
     tBTM_BLE_VSC_CB         cmn_ble_vsc_cb;
+    tBTM_BLE_ADV_EXT_CB     ble_adv_ext_cb;
 #endif
 
                                             /* Packet types supported by the local device */
@@ -949,7 +950,7 @@ extern void         btm_process_cancel_complete(UINT8 status, UINT8 mode);
 extern void         btm_event_filter_complete (UINT8 *p);
 extern void         btm_inq_stop_on_ssp(void);
 extern void         btm_inq_clear_ssp(void);
-extern tINQ_DB_ENT *btm_inq_db_find (BD_ADDR p_bda);
+extern tINQ_DB_ENT *btm_inq_db_find (const BD_ADDR p_bda);
 extern BOOLEAN      btm_inq_find_bdaddr (BD_ADDR p_bda);
 
 extern BOOLEAN btm_lookup_eir(BD_ADDR_PTR p_rem_addr);
@@ -996,7 +997,7 @@ extern void         btm_establish_continue (tACL_CONN *p_acl_cb);
 extern void         btm_acl_chk_peer_pkt_type_support (tACL_CONN *p, UINT16 *p_pkt_type);
 /* Read maximum data packet that can be sent over current connection */
 extern UINT16 btm_get_max_packet_size (BD_ADDR addr);
-extern tACL_CONN *btm_bda_to_acl (BD_ADDR bda, tBT_TRANSPORT transport);
+extern tACL_CONN *btm_bda_to_acl (const BD_ADDR bda, tBT_TRANSPORT transport);
 extern BOOLEAN    btm_acl_notif_conn_collision (BD_ADDR bda);
 
 extern void btm_pm_reset(void);
@@ -1054,6 +1055,9 @@ extern BOOLEAN btm_ble_addr_resolvable(BD_ADDR rpa, tBTM_SEC_DEV_REC *p_dev_rec)
 extern tBTM_STATUS btm_ble_read_resolving_list_entry(tBTM_SEC_DEV_REC *p_dev_rec);
 extern BOOLEAN btm_ble_resolving_list_load_dev(tBTM_SEC_DEV_REC *p_dev_rec);
 extern void btm_ble_resolving_list_remove_dev(tBTM_SEC_DEV_REC *p_dev_rec);
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+extern BOOLEAN btm_ble_add_multi_adv_rpa(BD_ADDR bda, tBLE_ADDR_TYPE addr_type);
+#endif
 #endif  /* BLE_INCLUDED */
 
 /* HCI event handler */
@@ -1074,9 +1078,10 @@ extern void btm_report_device_status (tBTM_DEV_STATUS status);
 */
 extern BOOLEAN btm_dev_support_switch (BD_ADDR bd_addr);
 
+extern tBTM_SEC_DEV_REC  *btm_sec_allocate_dev_rec(void);
 extern tBTM_SEC_DEV_REC  *btm_sec_alloc_dev (BD_ADDR bd_addr);
 extern void               btm_sec_free_dev (tBTM_SEC_DEV_REC *p_dev_rec);
-extern tBTM_SEC_DEV_REC  *btm_find_dev (BD_ADDR bd_addr);
+extern tBTM_SEC_DEV_REC  *btm_find_dev (const BD_ADDR bd_addr);
 extern tBTM_SEC_DEV_REC  *btm_find_or_alloc_dev (BD_ADDR bd_addr);
 extern tBTM_SEC_DEV_REC  *btm_find_dev_by_handle (UINT16 handle);
 extern tBTM_BOND_TYPE     btm_get_bond_type_dev(BD_ADDR bd_addr);
diff --git a/stack/btm/btm_pm.c b/stack/btm/btm_pm.c
index 38b7935..986c60d 100644
--- a/stack/btm/btm_pm.c
+++ b/stack/btm/btm_pm.c
@@ -777,6 +777,7 @@ void btm_pm_proc_cmd_status(UINT8 status)
     else /* the command was not successfull. Stay in the same state */
     {
         pm_status = BTM_PM_STS_ERROR;
+        GENERATE_VENDOR_LOGS();
     }
 
     /* notify the caller is appropriate */
diff --git a/stack/btm/btm_sco.c b/stack/btm/btm_sco.c
index 399d3d3..0cc96ef 100644
--- a/stack/btm/btm_sco.c
+++ b/stack/btm/btm_sco.c
@@ -34,6 +34,9 @@
 #include "btm_int.h"
 #include "hcidefs.h"
 #include "bt_utils.h"
+#include "device/include/controller.h"
+#include "device/include/interop.h"
+extern void bta_dm_pm_set_sniff_policy_toggle(BD_ADDR peer_addr, BOOLEAN bDisable);
 
 #if BTM_SCO_INCLUDED == TRUE
 
@@ -59,7 +62,7 @@ static const tBTM_ESCO_PARAMS btm_esco_defaults =
 {
     BTM_64KBITS_RATE,               /* TX Bandwidth (64 kbits/sec)              */
     BTM_64KBITS_RATE,               /* RX Bandwidth (64 kbits/sec)              */
-    0x000a,                         /* 10 ms (HS/HF can use EV3, 2-EV3, 3-EV3)  */
+    0x000c,                         /* 12 ms (HS/HF can use EV3, 2-EV3, 3-EV3)  */
     0x0060,                         /* Inp Linear, Air CVSD, 2s Comp, 16bit     */
     (BTM_SCO_PKT_TYPES_MASK_HV1 +   /* Packet Types                             */
      BTM_SCO_PKT_TYPES_MASK_HV2 +
@@ -67,7 +70,7 @@ static const tBTM_ESCO_PARAMS btm_esco_defaults =
      BTM_SCO_PKT_TYPES_MASK_EV3 +
      BTM_SCO_PKT_TYPES_MASK_EV4 +
      BTM_SCO_PKT_TYPES_MASK_EV5),
-     BTM_ESCO_RETRANS_POWER        /* Retransmission Effort (Power)   */
+   BTM_ESCO_RETRANS_QUALITY         /* Retransmission Effort */
 };
 
 /*******************************************************************************
@@ -639,6 +642,10 @@ tBTM_STATUS BTM_CreateSco (BD_ADDR remote_bda, BOOLEAN is_orig, UINT16 pkt_types
                         {
                             BTM_TRACE_DEBUG("%s In sniff, park or pend mode: %d", __func__, state);
                             memset( (void*)&pm, 0, sizeof(pm));
+                            if (interop_match_addr(INTEROP_DISABLE_SNIFF_POLICY_DURING_SCO,
+                                             (const bt_bdaddr_t *)&remote_bda)) {
+                                bta_dm_pm_set_sniff_policy_toggle(remote_bda, true);
+                            }
                             pm.mode = BTM_PM_MD_ACTIVE;
                             BTM_SetPowerMode(BTM_PM_SET_ONLY_ID, remote_bda, &pm);
                             p->state = SCO_ST_PEND_UNPARK;
@@ -668,7 +675,7 @@ tBTM_STATUS BTM_CreateSco (BD_ADDR remote_bda, BOOLEAN is_orig, UINT16 pkt_types
                              btm_cb.btm_sco_pkt_types_supported);
 
             /* OR in any exception packet types */
-            if (btm_cb.sco_cb.desired_sco_mode == HCI_LINK_TYPE_ESCO)
+            if (controller_get_interface()->get_bt_version()->hci_version >= HCI_PROTO_VERSION_2_0)
             {
                 temp_pkt_types |= ((p_setup->packet_types & BTM_SCO_EXCEPTION_PKTS_MASK) |
                     (btm_cb.btm_sco_pkt_types_supported & BTM_SCO_EXCEPTION_PKTS_MASK));
@@ -706,7 +713,10 @@ tBTM_STATUS BTM_CreateSco (BD_ADDR remote_bda, BOOLEAN is_orig, UINT16 pkt_types
                 {
                     BTM_TRACE_API("BTM_CreateSco -> (e)SCO Link for ACL handle 0x%04x, Desired Type %d",
                                     acl_handle, btm_cb.sco_cb.desired_sco_mode);
-
+                    if (interop_match_addr(INTEROP_DISABLE_SNIFF_POLICY_DURING_SCO,
+                                               (const bt_bdaddr_t *)&remote_bda)) {
+                        bta_dm_pm_set_sniff_policy_toggle(remote_bda, true);
+                    }
                     if ((btm_send_connect_request(acl_handle, p_setup)) != BTM_CMD_STARTED)
                         return (BTM_NO_RESOURCES);
 
@@ -1067,14 +1077,21 @@ UINT16  btm_find_scb_by_handle (UINT16 handle)
 tBTM_STATUS BTM_RemoveSco (UINT16 sco_inx)
 {
 #if (BTM_MAX_SCO_LINKS>0)
-    tSCO_CONN   *p = &btm_cb.sco_cb.sco_db[sco_inx];
+    tSCO_CONN   *p;
     UINT16       tempstate;
     tBTM_PM_STATE   state = BTM_PM_ST_INVALID;
 
     BTM_TRACE_DEBUG("%s", __func__);
 
     /* Validity check */
-    if ((sco_inx >= BTM_MAX_SCO_LINKS) || (p->state == SCO_ST_UNUSED))
+    if (sco_inx >= BTM_MAX_SCO_LINKS)
+        return (BTM_UNKNOWN_ADDR);
+
+    /* Fix for below Klockwork Issue
+     * Array 'btm_cb.sco_cb.sco_db' of size 3 may use index value(s) 0..USHRT_MAX-1 */
+    p = &btm_cb.sco_cb.sco_db[sco_inx];
+
+    if ((p == NULL) || (p->state == SCO_ST_UNUSED))
         return (BTM_UNKNOWN_ADDR);
 
     /* If no HCI handle, simply drop the connection and return */
diff --git a/stack/btm/btm_sec.c b/stack/btm/btm_sec.c
index aa5dbe5..ceb46ab 100644
--- a/stack/btm/btm_sec.c
+++ b/stack/btm/btm_sec.c
@@ -1004,18 +1004,20 @@ tBTM_STATUS btm_sec_bond_by_transport (BD_ADDR bd_addr, tBT_TRANSPORT transport,
     BTM_TRACE_DEBUG ("before update sec_flags=0x%x", p_dev_rec->sec_flags);
 
     /* Finished if connection is active and already paired */
-    if ( ((p_dev_rec->hci_handle != BTM_SEC_INVALID_HANDLE) && transport == BT_TRANSPORT_BR_EDR
+    if ((p_dev_rec->hci_handle != BTM_SEC_INVALID_HANDLE) && transport == BT_TRANSPORT_BR_EDR
          &&  (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED))
-#if (BLE_INCLUDED == TRUE)
-        ||((p_dev_rec->ble_hci_handle != BTM_SEC_INVALID_HANDLE) && transport == BT_TRANSPORT_LE
-         &&  (p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED))
-#endif
-
-         )
     {
         BTM_TRACE_WARNING("BTM_SecBond -> Already Paired");
         return(BTM_SUCCESS);
     }
+#if (BLE_INCLUDED == TRUE)
+    if ((p_dev_rec->ble_hci_handle != BTM_SEC_INVALID_HANDLE) && transport == BT_TRANSPORT_LE
+         &&  (p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED))
+    {
+        BTM_TRACE_WARNING("BTM_SecBond. Last Pairing still in progress. Wait!");
+        return(BTM_CMD_STARTED);
+    }
+#endif
 
     /* Tell controller to get rid of the link key if it has one stored */
     if ((BTM_DeleteStoredLinkKey (bd_addr, NULL)) != BTM_SUCCESS)
@@ -2422,7 +2424,7 @@ tBTM_STATUS btm_sec_l2cap_access_req (BD_ADDR bd_addr, UINT16 psm, UINT16 handle
             p_dev_rec->sec_state         = BTM_SEC_STATE_DELAY_FOR_ENC;
             (*p_callback) (bd_addr, transport, p_ref_data, rc);
 
-            return BTM_SUCCESS;
+            return BTM_CMD_STARTED;
         }
     }
 
@@ -3190,7 +3192,12 @@ void btm_sec_rmt_name_request_complete (UINT8 *p_bd_addr, UINT8 *p_bd_name, UINT
                 return;
             }
 
-            if (status != HCI_SUCCESS)
+            if (status == HCI_ERR_CONTROLLER_BUSY)
+            {
+                BTM_TRACE_WARNING ("btm_sec_rmt_name_request_complete() Wait for incoming connection");
+                return;
+            }
+            else if (status != HCI_SUCCESS)
             {
                 btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);
 
@@ -4096,8 +4103,13 @@ void btm_sec_auth_complete (UINT16 handle, UINT8 status)
     /* User probably Disabled the keyboard while it was asleap.  Let her try */
     if (btm_cb.api.p_auth_complete_callback)
     {
-        /* report the suthentication status */
-        if ((old_state != BTM_PAIR_STATE_IDLE) || (status != HCI_SUCCESS))
+
+        /* don't post auth status key missing,peer user disc and connection timeout cases */
+        if ((old_state != BTM_PAIR_STATE_IDLE) ||
+            ((status != HCI_SUCCESS) &&
+             (status != HCI_ERR_PEER_USER) &&
+             (status != HCI_ERR_CONNECTION_TOUT) &&
+             (status != HCI_ERR_LMP_RESPONSE_TIMEOUT)))
             (*btm_cb.api.p_auth_complete_callback) (p_dev_rec->bd_addr,
                                                     p_dev_rec->dev_class,
                                                     p_dev_rec->sec_bd_name, status);
@@ -4127,12 +4139,10 @@ void btm_sec_auth_complete (UINT16 handle, UINT8 status)
             {
                 BTM_TRACE_DEBUG ("link encrypted afer dedic bonding can use SMP_BR_CHNL");
 
-                if (btm_sec_is_master(p_dev_rec))
-                {
-                    // Encryption is required to start SM over BR/EDR
-                    // indicate that this is encryption after authentication
-                    BTM_SetEncryption(p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR, NULL, NULL, 0);
-                }
+                // Encryption is required to start SM over BR/EDR
+                // from DD bonding initiator.
+                // indicate that this is encryption after authentication
+                BTM_SetEncryption(p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR, NULL, NULL, 0);
             }
             l2cu_start_post_bond_timer (p_dev_rec->hci_handle);
         }
@@ -4173,6 +4183,11 @@ void btm_sec_auth_complete (UINT16 handle, UINT8 status)
             }
         }
 
+        if (btm_cb.api.p_auth_complete_callback && (status == HCI_ERR_KEY_MISSING))
+            (*btm_cb.api.p_auth_complete_callback) (p_dev_rec->bd_addr,
+                                                    p_dev_rec->dev_class,
+                                                    p_dev_rec->sec_bd_name, status);
+
         btm_sec_dev_rec_cback_event (p_dev_rec, BTM_ERR_PROCESSING, FALSE);
 
         if (btm_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)
@@ -4271,11 +4286,16 @@ void btm_sec_encrypt_change (UINT16 handle, UINT8 status, UINT8 encr_enable)
 
     if (p_acl && p_acl->transport == BT_TRANSPORT_LE)
     {
-        if (status == HCI_ERR_KEY_MISSING || status == HCI_ERR_AUTH_FAILURE ||
+        if (status == HCI_ERR_AUTH_FAILURE ||
             status == HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE)
         {
             p_dev_rec->sec_flags &= ~ (BTM_SEC_LE_LINK_KEY_KNOWN);
             p_dev_rec->ble.key_type = BTM_LE_KEY_NONE;
+            GENERATE_VENDOR_LOGS();
+        }
+        else if (status == HCI_ERR_KEY_MISSING)
+        {
+            btm_sec_disconnect(handle, status);
         }
         btm_ble_link_encrypted(p_dev_rec->ble.pseudo_addr, encr_enable);
         return;
@@ -4331,6 +4351,7 @@ void btm_sec_encrypt_change (UINT16 handle, UINT8 status, UINT8 encr_enable)
 
                 BTM_TRACE_DEBUG("updated link key type to %d", p_dev_rec->link_key_type);
                 btm_send_link_key_notif(p_dev_rec);
+                GENERATE_VENDOR_LOGS();
             }
         }
     }
@@ -4381,6 +4402,7 @@ static void btm_sec_connect_after_reject_timeout(UNUSED_ATTR void *data)
 
     BTM_TRACE_EVENT("%s", __func__);
     btm_cb.p_collided_dev_rec = 0;
+    btm_cb.collision_start_time = 0;
 
     if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED)
     {
@@ -4412,6 +4434,7 @@ void btm_sec_connected (UINT8 *bda, UINT16 handle, UINT8 status, UINT8 enc_mode)
     BOOLEAN          is_pairing_device = FALSE;
     tACL_CONN        *p_acl_cb;
     UINT8            bit_shift = 0;
+    BTM_TRACE_DEBUG ("%s",__func__);
 
     btm_acl_resubmit_page();
 
@@ -4420,10 +4443,10 @@ void btm_sec_connected (UINT8 *bda, UINT16 handle, UINT8 status, UINT8 enc_mode)
 #if (BT_USE_TRACES == TRUE)
     if (p_dev_rec)
     {
-        BTM_TRACE_EVENT ("Security Manager: btm_sec_connected in state: %s  handle:%d status:%d enc_mode:%d  bda:%x RName:%s",
+        BTM_TRACE_EVENT ("Security Manager: btm_sec_connected in state: %s  handle:%d status:%d enc_mode:%d  bda:%x RName:%s,new_encr_key_256 to %d",
                           btm_pair_state_descr(btm_cb.pairing_state), handle, status, enc_mode,
                           (bda[2]<<24)+(bda[3]<<16)+(bda[4]<<8)+bda[5],
-                          p_dev_rec->sec_bd_name);
+                          p_dev_rec->sec_bd_name,p_dev_rec->new_encryption_key_is_p256);
     }
     else
     {
@@ -4548,7 +4571,7 @@ void btm_sec_connected (UINT8 *bda, UINT16 handle, UINT8 status, UINT8 enc_mode)
             return;
         }
         /* wait for incoming connection without resetting pairing state */
-        else if (status == HCI_ERR_CONNECTION_EXISTS)
+        else if ((status == HCI_ERR_CONNECTION_EXISTS) || (status ==  HCI_ERR_CONTROLLER_BUSY))
         {
             BTM_TRACE_WARNING ("Security Manager: btm_sec_connected: Wait for incoming connection");
             return;
@@ -4614,6 +4637,14 @@ void btm_sec_connected (UINT8 *bda, UINT16 handle, UINT8 status, UINT8 enc_mode)
                                                         p_dev_rec->sec_bd_name, status);
             }
         }
+        /*as p_auth_complete_callback may remove p_de_rec from list, so we
+         * need find it again */
+        p_dev_rec = btm_find_dev_by_handle (handle);
+        if(p_dev_rec == NULL)
+        {
+            BTM_TRACE_ERROR("%s p_dev_rec have been removed, return", __func__);
+            return;
+        }
 
         if (status == HCI_ERR_CONNECTION_TOUT || status == HCI_ERR_LMP_RESPONSE_TIMEOUT  ||
             status == HCI_ERR_UNSPECIFIED     || status == HCI_ERR_PAGE_TIMEOUT)
@@ -4703,7 +4734,7 @@ void btm_sec_connected (UINT8 *bda, UINT16 handle, UINT8 status, UINT8 enc_mode)
     /* After connection is established we perform security if we do not know */
     /* the name, or if we are originator because some procedure can have */
     /* been scheduled while connection was down */
-    BTM_TRACE_DEBUG ("is_originator:%d ", p_dev_rec->is_originator);
+    BTM_TRACE_DEBUG ("is_originator:%d ,new_encr_key_256 to %d", p_dev_rec->is_originator,p_dev_rec->new_encryption_key_is_p256);
     return;
 }
 
@@ -4783,7 +4814,7 @@ void btm_sec_disconnected (UINT16 handle, UINT8 reason)
             "  remote_name:%s", __func__, p_dev_rec->security_required, btm_pair_state_descr(btm_cb.pairing_state),
             reason, bd_addr[0], bd_addr[1], bd_addr[2], bd_addr[3], bd_addr[4], bd_addr[5], p_dev_rec->sec_bd_name);
 
-    BTM_TRACE_EVENT("%s before update sec_flags=0x%x", __func__, p_dev_rec->sec_flags);
+    BTM_TRACE_EVENT("%s before update sec_flags=0x%x, new_encr_key_256 to %d ", __func__, p_dev_rec->sec_flags,p_dev_rec->new_encryption_key_is_p256);
 
     /* If we are in the process of bonding we need to tell client that auth failed */
     if ( (btm_cb.pairing_state != BTM_PAIR_STATE_IDLE)
@@ -4840,7 +4871,7 @@ void btm_sec_disconnected (UINT16 handle, UINT8 reason)
     p_dev_rec->security_required = BTM_SEC_NONE;
 
     p_callback = p_dev_rec->p_callback;
-
+    p_dev_rec->new_encryption_key_is_p256 = FALSE;
     /* if security is pending, send callback to clean up the security state */
     if(p_callback)
     {
@@ -4849,7 +4880,7 @@ void btm_sec_disconnected (UINT16 handle, UINT8 reason)
         (*p_callback) (p_dev_rec->bd_addr, transport, p_dev_rec->p_ref_data, BTM_ERR_PROCESSING);
     }
 
-    BTM_TRACE_EVENT("%s after update sec_flags=0x%x", __func__, p_dev_rec->sec_flags);
+    BTM_TRACE_EVENT("%s after update sec_flags=0x%x,new_encr_key_256 to %d", __func__, p_dev_rec->sec_flags,p_dev_rec->new_encryption_key_is_p256);
 }
 
 /*******************************************************************************
@@ -5136,6 +5167,23 @@ static void btm_sec_pairing_timeout(UNUSED_ATTR void *data)
         case BTM_PAIR_STATE_GET_REM_NAME:
             /* We need to notify the UI that timeout has happened while waiting for authentication*/
             btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);
+            tL2C_LCB *p_lcb = l2cu_find_lcb_by_bd_addr (p_cb->pairing_bda, BT_TRANSPORT_BR_EDR);
+            /* If no channels on the connection, start idle timeout */
+            if ((p_lcb) && p_lcb->in_use && (p_lcb->link_state == LST_CONNECTED))
+            {
+                if (!p_lcb->ccb_queue.p_first_ccb)
+                {
+                    BTM_TRACE_WARNING("%s start idle timeout if no ccbs", __func__ );
+                    l2cu_no_dynamic_ccbs (p_lcb);
+                }
+                else
+                {
+                    BTM_TRACE_ERROR("%s hci disc triggered when last channel disconnects BDA: %08x%04x",
+                                __func__,
+                                (p_cb->pairing_bda[0]<<24) + (p_cb->pairing_bda[1]<<16) + (p_cb->pairing_bda[2]<<8) + p_cb->pairing_bda[3],
+                                (p_cb->pairing_bda[4] << 8) + p_cb->pairing_bda[5]);
+                }
+            }
             if (btm_cb.api.p_auth_complete_callback)
             {
                 if (p_dev_rec == NULL)
@@ -5973,6 +6021,7 @@ void btm_sec_dev_rec_cback_event (tBTM_SEC_DEV_REC *p_dev_rec, UINT8 res, BOOLEA
 {
     tBTM_SEC_CALLBACK   *p_callback = p_dev_rec->p_callback;
 
+    BTM_TRACE_DEBUG ("%s ",__func__);
     if (p_dev_rec->p_callback)
     {
         p_dev_rec->p_callback = NULL;
diff --git a/stack/btu/btu_hcif.c b/stack/btu/btu_hcif.c
index 3806a1e..28ea831 100644
--- a/stack/btu/btu_hcif.c
+++ b/stack/btu/btu_hcif.c
@@ -125,7 +125,13 @@ static void btu_ble_rc_param_req_evt(UINT8 *p);
 #if (defined BLE_PRIVACY_SPT && BLE_PRIVACY_SPT == TRUE)
 static void btu_ble_proc_enhanced_conn_cmpl (UINT8 *p, UINT16 evt_len);
 #endif
+static void btu_ble_data_rate_update_evt(UINT8 *p, UINT16 evt_len);
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && BLE_EXTENDED_ADV_SUPPORT == TRUE)
+static void btu_ble_adv_terminated_evt (UINT8* p);
+static void btu_ble_process_ext_adv_pkt (UINT8 *p);
+static void btu_ble_scan_timeout_evt (void);
+#endif
     #endif
 
 /*******************************************************************************
@@ -333,6 +339,23 @@ void btu_hcif_process_event (UNUSED_ATTR UINT8 controller_id, BT_HDR *p_msg)
                case HCI_BLE_DATA_LENGTH_CHANGE_EVT:
                     btu_ble_data_length_change_evt(p, hci_evt_len);
                     break;
+
+               case HCI_BLE_PHY_UPDATE_EVT:
+                    btu_ble_data_rate_update_evt(p, hci_evt_len);
+                    break;
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && BLE_EXTENDED_ADV_SUPPORT == TRUE)
+               case HCI_BLE_EXT_ADV_TERMINATED_EVT:
+                    btu_ble_adv_terminated_evt(p);
+                    break;
+
+               case HCI_BLE_EXT_ADV_PKT_RPT_EVT:
+                    btu_ble_process_ext_adv_pkt(p);
+                    break;
+               case HCI_BLE_SCAN_TIMEOUT_EVT:
+                    btu_ble_scan_timeout_evt();
+                    break;
+#endif
             }
             break;
 #endif /* BLE_INCLUDED */
@@ -861,6 +884,8 @@ static void btu_hcif_hdl_command_complete (UINT16 opcode, UINT8 *p, UINT16 evt_l
 
         case HCI_BLE_TRANSMITTER_TEST:
         case HCI_BLE_RECEIVER_TEST:
+        case HCI_BLE_ENH_TRANSMITTER_TEST:
+        case HCI_BLE_ENH_RECEIVER_TEST:
         case HCI_BLE_TEST_END:
             btm_ble_test_command_complete(p);
             break;
@@ -885,8 +910,23 @@ static void btu_hcif_hdl_command_complete (UINT16 opcode, UINT8 *p, UINT16 evt_l
         case HCI_BLE_READ_RESOLVABLE_ADDR_LOCAL:
         case HCI_BLE_SET_ADDR_RESOLUTION_ENABLE:
         case HCI_BLE_SET_RAND_PRIV_ADDR_TIMOUT:
+             break;
+#endif
+        /* adv extension complete events*/
+#if (defined BLE_EXTENDED_ADV_SUPPORT && BLE_EXTENDED_ADV_SUPPORT == TRUE)
+        case HCI_BLE_WRITE_EXTENDED_ADV_RPA:
+        case HCI_BLE_WRITE_EXTENDED_ADV_DATA:
+        case HCI_BLE_WRITE_EXTENDED_SCAN_RSP_DATA:
+        case HCI_BLE_WRITE_EXTENDED_ADV_PARAMS:
+        case HCI_BLE_WRITE_EXTENDED_ADV_ENABLE:
+            btm_ble_adv_extension_operation_complete(p, opcode);
             break;
+        case HCI_BLE_READ_MAX_ADV_LENGTH:
+            btm_ble_read_inst_length_complete (p, evt_len);
+            break;
+
 #endif
+
 #endif /* (BLE_INCLUDED == TRUE) */
 
         default:
@@ -1635,13 +1675,33 @@ static void btu_ble_process_adv_pkt (UINT8 *p)
 {
     HCI_TRACE_EVENT("btu_ble_process_adv_pkt");
 
-    btm_ble_process_adv_pkt(p);
+    btm_ble_process_adv_pkt(p, FALSE);
 }
 
+
+
 static void btu_ble_ll_conn_complete_evt ( UINT8 *p, UINT16 evt_len)
 {
     btm_ble_conn_complete(p, evt_len, FALSE);
 }
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && BLE_EXTENDED_ADV_SUPPORT == TRUE)
+static void btu_ble_adv_terminated_evt (UINT8 *p)
+{
+    btm_ble_adv_set_terminated_evt(p);
+}
+
+static void btu_ble_process_ext_adv_pkt (UINT8 *p)
+{
+    btm_ble_process_adv_pkt(p, TRUE);
+}
+
+static void btu_ble_scan_timeout_evt (void)
+{
+    btm_ble_scan_timeout_evt();
+}
+#endif
+
 #if (defined BLE_PRIVACY_SPT && BLE_PRIVACY_SPT == TRUE)
 static void btu_ble_proc_enhanced_conn_cmpl( UINT8 *p, UINT16 evt_len)
 {
@@ -1655,10 +1715,17 @@ static void btu_ble_ll_conn_param_upd_evt (UINT8 *p, UINT16 evt_len)
     /* extract the HCI handle first */
     UINT8   status;
     UINT16  handle;
+    UINT16  interval;
+    UINT16  latency;
+    UINT16  timeout;
 
-    STREAM_TO_UINT8  (status, p);
-    STREAM_TO_UINT16 (handle, p);
-    l2cble_process_conn_update_evt(handle, status);
+    STREAM_TO_UINT8(status, p);
+    STREAM_TO_UINT16(handle, p);
+    STREAM_TO_UINT16(interval, p);
+    STREAM_TO_UINT16(latency, p);
+    STREAM_TO_UINT16(timeout, p);
+
+    l2cble_process_conn_update_evt(handle, status, interval, latency, timeout);
 }
 
 static void btu_ble_read_remote_feat_evt (UINT8 *p)
@@ -1719,5 +1786,25 @@ static void btu_ble_rc_param_req_evt(UINT8 *p)
 }
 #endif /* BLE_LLT_INCLUDED */
 
+static void btu_ble_data_rate_update_evt(UINT8 *p, UINT16 evt_len)
+{
+    UINT8 status;
+    UINT16 handle;
+    UINT8 tx_phy;
+    UINT8 rx_phy;
+
+    if(!controller_get_interface()->supports_ble_two_mbps_rate())
+    {
+        HCI_TRACE_WARNING("%s, request not supported", __func__);
+        return;
+    }
+    STREAM_TO_UINT8(status, p);
+    STREAM_TO_UINT16(handle, p);
+    STREAM_TO_UINT8(tx_phy, p);
+    STREAM_TO_UINT8(rx_phy, p);
+    HCI_TRACE_DEBUG("%s Phy update evt, status=%d, handle = 0x%0x, tx_phy=%d, rx_phy=%d",
+                     __func__, status, handle, tx_phy, rx_phy);
+}
+
 #endif /* BLE_INCLUDED */
 
diff --git a/stack/gap/gap_ble.c b/stack/gap/gap_ble.c
index d92665a..e14b13e 100644
--- a/stack/gap/gap_ble.c
+++ b/stack/gap/gap_ble.c
@@ -708,7 +708,7 @@ BOOLEAN gap_ble_accept_cl_operation(BD_ADDR peer_bda, UINT16 uuid, tGAP_BLE_CMPL
         p_clcb->connected = TRUE;
 
     /* hold the link here */
-    if (!GATT_Connect(gap_cb.gatt_if, p_clcb->bda, TRUE, BT_TRANSPORT_LE))
+    if (!GATT_Connect(gap_cb.gatt_if, p_clcb->bda, TRUE, BT_TRANSPORT_LE, false))
         return started;
 
     /* enqueue the request */
diff --git a/stack/gap/gap_conn.c b/stack/gap/gap_conn.c
index 04bba78..55df7cf 100644
--- a/stack/gap/gap_conn.c
+++ b/stack/gap/gap_conn.c
@@ -137,8 +137,9 @@ UINT16 GAP_ConnOpen (char *p_serv_name, UINT8 service_id, BOOLEAN is_server,
     if ((p_ccb = gap_allocate_ccb()) == NULL)
         return (GAP_INVALID_HANDLE);
 
-    /* update the transport */
+    /* update the transport ,service_id */
     p_ccb->transport = transport;
+    p_ccb->service_id = service_id;
 
     /* If caller specified a BD address, save it */
     if (p_rem_bda)
@@ -216,7 +217,6 @@ UINT16 GAP_ConnOpen (char *p_serv_name, UINT8 service_id, BOOLEAN is_server,
     }
 
     /* Register with Security Manager for the specific security level */
-    p_ccb->service_id = service_id;
     if (!BTM_SetSecurityLevel ((UINT8)!is_server, p_serv_name,
                 p_ccb->service_id, security, p_ccb->psm, 0, 0))
     {
@@ -690,7 +690,7 @@ UINT16 GAP_ConnGetL2CAPCid (UINT16 gap_handle)
 
 /*******************************************************************************
 **
-** Function         gap_tx_connect_ind
+** Function         gap_tx_complete_ind
 **
 ** Description      Sends out GAP_EVT_TX_EMPTY when transmission has been
 **                  completed.
@@ -709,6 +709,11 @@ void gap_tx_complete_ind (UINT16 l2cap_cid, UINT16 sdu_sent)
         GAP_TRACE_EVENT("%s: GAP_EVT_TX_EMPTY", __func__);
         p_ccb->p_callback (p_ccb->gap_handle, GAP_EVT_TX_EMPTY);
     }
+    else if ((p_ccb->con_state == GAP_CCB_STATE_CONNECTED) && (sdu_sent >= 1))
+    {
+        GAP_TRACE_EVENT("%s: GAP_EVT_TX_DONE", __func__);
+        p_ccb->p_callback (p_ccb->gap_handle, GAP_EVT_TX_DONE);
+    }
 }
 
 /*******************************************************************************
diff --git a/stack/gatt/gatt_api.c b/stack/gatt/gatt_api.c
index b8c45d3..e343d18 100644
--- a/stack/gatt/gatt_api.c
+++ b/stack/gatt/gatt_api.c
@@ -34,6 +34,8 @@
 #include "l2c_api.h"
 #include "btm_int.h"
 
+#define SYSTEM_APP_GATT_IF  3
+
 /*******************************************************************************
 **
 ** Function         GATT_SetTraceLevel
@@ -1277,6 +1279,11 @@ void GATT_Deregister (tGATT_IF gatt_if)
             if (gatt_get_ch_state(p_tcb) != GATT_CH_CLOSE)
             {
                 gatt_update_app_use_link_flag(gatt_if, p_tcb,  FALSE, TRUE);
+                if ((gatt_if > SYSTEM_APP_GATT_IF) && (!gatt_num_apps_hold_link(p_tcb)))
+                {
+                    /* this will disconnect the link or cancel the pending connect request at lower layer*/
+                    gatt_disconnect(p_tcb);
+                }
             }
 
             for (j = 0, p_clcb= &gatt_cb.clcb[j]; j < GATT_CL_MAX_LCB; j++, p_clcb++)
@@ -1357,7 +1364,8 @@ void GATT_StartIf (tGATT_IF gatt_if)
 ** Returns          TRUE if connection started; FALSE if connection start failure.
 **
 *******************************************************************************/
-BOOLEAN GATT_Connect (tGATT_IF gatt_if, BD_ADDR bd_addr, BOOLEAN is_direct, tBT_TRANSPORT transport)
+BOOLEAN GATT_Connect (tGATT_IF gatt_if, BD_ADDR bd_addr, BOOLEAN is_direct,
+                      tBT_TRANSPORT transport, BOOLEAN opportunistic)
 {
     tGATT_REG    *p_reg;
     BOOLEAN status = FALSE;
@@ -1372,7 +1380,7 @@ BOOLEAN GATT_Connect (tGATT_IF gatt_if, BD_ADDR bd_addr, BOOLEAN is_direct, tBT_
     }
 
     if (is_direct)
-        status = gatt_act_connect (p_reg, bd_addr, transport);
+        status = gatt_act_connect (p_reg, bd_addr, transport, opportunistic);
     else
     {
         if (transport == BT_TRANSPORT_LE)
diff --git a/stack/gatt/gatt_attr.c b/stack/gatt/gatt_attr.c
index 9a2c6fa..74f0f35 100644
--- a/stack/gatt/gatt_attr.c
+++ b/stack/gatt/gatt_attr.c
@@ -235,24 +235,26 @@ static void gatt_connect_cback (tGATT_IF gatt_if, BD_ADDR bda, UINT16 conn_id,
 {
     UNUSED(gatt_if);
 
-    GATT_TRACE_EVENT("%s: from %08x%04x connected:%d conn_id=%d reason = 0x%04x", __func__,
-                      (bda[0]<<24)+(bda[1]<<16)+(bda[2]<<8)+bda[3],
-                      (bda[4]<<8)+bda[5], connected, conn_id, reason);
+    GATT_TRACE_EVENT ("%s: from %08x%04x connected:%d conn_id=%d reason = 0x%04x", __FUNCTION__,
+                       (bda[0]<<24)+(bda[1]<<16)+(bda[2]<<8)+bda[3],
+                       (bda[4]<<8)+bda[5], connected, conn_id, reason);
 
     tGATT_PROFILE_CLCB *p_clcb = gatt_profile_find_clcb_by_bd_addr(bda, transport);
-    if (connected) {
-        if (p_clcb == NULL)
-            p_clcb = gatt_profile_clcb_alloc(conn_id, bda, transport);
-
-        if (p_clcb == NULL)
-            return;
+    if (p_clcb == NULL)
+        return;
 
+    if (connected)
+    {
+        p_clcb->conn_id = conn_id;
         p_clcb->connected = TRUE;
-        p_clcb->ccc_stage = GATT_SVC_CHANGED_SERVICE;
-        gatt_cl_start_config_ccc(p_clcb);
+
+        if (p_clcb->ccc_stage == GATT_SVC_CHANGED_CONNECTING)
+        {
+            p_clcb->ccc_stage ++;
+            gatt_cl_start_config_ccc(p_clcb);
+        }
     } else {
-        if (p_clcb != NULL)
-            gatt_profile_clcb_dealloc(p_clcb);
+        gatt_profile_clcb_dealloc(p_clcb);
     }
 }
 
@@ -455,7 +457,7 @@ void GATT_ConfigServiceChangeCCC (BD_ADDR remote_bda, BOOLEAN enable, tBT_TRANSP
         p_clcb->connected = TRUE;
     }
     /* hold the link here */
-    GATT_Connect(gatt_cb.gatt_if, remote_bda, TRUE, transport);
+    GATT_Connect(gatt_cb.gatt_if, remote_bda, TRUE, transport, true);
     p_clcb->ccc_stage = GATT_SVC_CHANGED_CONNECTING;
 
     if (!p_clcb->connected)
diff --git a/stack/gatt/gatt_db.c b/stack/gatt/gatt_db.c
index cffcc70..3be01a1 100644
--- a/stack/gatt/gatt_db.c
+++ b/stack/gatt/gatt_db.c
@@ -62,7 +62,8 @@ static tGATT_STATUS gatts_send_app_read_request(tGATT_TCB *p_tcb, UINT8 op_code,
 BOOLEAN gatts_init_service_db (tGATT_SVC_DB *p_db, tBT_UUID *p_service,  BOOLEAN is_pri,
                                UINT16 s_hdl, UINT16 num_handle)
 {
-    p_db->svc_buffer = fixed_queue_new(SIZE_MAX);
+    if(!p_db->svc_buffer)
+       p_db->svc_buffer = fixed_queue_new(SIZE_MAX);
 
     if (!allocate_svc_db_buf(p_db))
     {
@@ -990,14 +991,16 @@ static void *allocate_attr_in_db(tGATT_SVC_DB *p_db, tBT_UUID *p_uuid, tGATT_PER
     }
     else if (p_attr16->uuid_type == GATT_ATTR_UUID_TYPE_32)
     {
-        GATT_TRACE_DEBUG("=====> handle = [0x%04x] uuid32 = [0x%08x] perm=0x%02x ",
-                          p_attr32->handle, p_attr32->uuid, p_attr32->permission);
+        if (p_attr32)
+           GATT_TRACE_DEBUG("=====> handle = [0x%04x] uuid32 = [0x%08x] perm=0x%02x ",
+                             p_attr32->handle, p_attr32->uuid, p_attr32->permission);
     }
     else
     {
-        GATT_TRACE_DEBUG("=====> handle = [0x%04x] uuid128 = [0x%02x:0x%02x] perm=0x%02x ",
-                          p_attr128->handle, p_attr128->uuid[0],p_attr128->uuid[1],
-                          p_attr128->permission);
+        if (p_attr128)
+           GATT_TRACE_DEBUG("=====> handle = [0x%04x] uuid128 = [0x%02x:0x%02x] perm=0x%02x ",
+                             p_attr128->handle, p_attr128->uuid[0],p_attr128->uuid[1],
+                             p_attr128->permission);
     }
     return(void *)p_attr16;
 }
diff --git a/stack/gatt/gatt_int.h b/stack/gatt/gatt_int.h
index 56760e9..1f97cb7 100644
--- a/stack/gatt/gatt_int.h
+++ b/stack/gatt/gatt_int.h
@@ -532,7 +532,7 @@ extern void gatt_free(void);
 
 /* from gatt_main.c */
 extern BOOLEAN gatt_disconnect (tGATT_TCB *p_tcb);
-extern BOOLEAN gatt_act_connect (tGATT_REG *p_reg, BD_ADDR bd_addr, tBT_TRANSPORT transport);
+extern BOOLEAN gatt_act_connect (tGATT_REG *p_reg, BD_ADDR bd_addr, tBT_TRANSPORT transport, bool opportunistic);
 extern BOOLEAN gatt_connect (BD_ADDR rem_bda,  tGATT_TCB *p_tcb, tBT_TRANSPORT transport);
 extern void gatt_data_process (tGATT_TCB *p_tcb, BT_HDR *p_buf);
 extern void gatt_update_app_use_link_flag ( tGATT_IF gatt_if, tGATT_TCB *p_tcb, BOOLEAN is_add, BOOLEAN check_acl_link);
diff --git a/stack/gatt/gatt_main.c b/stack/gatt/gatt_main.c
index 489b672..72d56a3 100644
--- a/stack/gatt/gatt_main.c
+++ b/stack/gatt/gatt_main.c
@@ -29,6 +29,7 @@
 #include "bt_common.h"
 #include "gatt_int.h"
 #include "l2c_api.h"
+#include "l2c_int.h"
 #include "btm_int.h"
 #include "btm_ble_int.h"
 #include "bt_utils.h"
@@ -240,7 +241,12 @@ BOOLEAN gatt_disconnect (tGATT_TCB *p_tcb)
         {
             if (p_tcb->att_lcid == L2CAP_ATT_CID)
             {
-                if (ch_state == GATT_CH_OPEN)
+                tL2C_LCB *p_lcb = l2cu_find_lcb_by_bd_addr(p_tcb->peer_bda, p_tcb->transport);
+                tL2C_LINK_STATE link_state = p_lcb != NULL ? p_lcb->link_state : LST_DISCONNECTED;
+                GATT_TRACE_WARNING("%s, ch_state=%d, link_state=%d", __func__, ch_state, link_state);
+
+                if ((ch_state == GATT_CH_OPEN) ||
+                        ((ch_state == GATT_CH_CONN) && (link_state == LST_CONNECTED)))
                 {
                     /* only LCB exist between remote device and local */
                     ret = L2CA_RemoveFixedChnl (L2CAP_ATT_CID, p_tcb->peer_bda);
@@ -276,49 +282,32 @@ BOOLEAN gatt_disconnect (tGATT_TCB *p_tcb)
 **
 ** Description      Update the application use link status
 **
-** Returns          void.
+** Returns          true if any modifications are made, false otherwise.
 **
 *******************************************************************************/
-void gatt_update_app_hold_link_status (tGATT_IF gatt_if, tGATT_TCB *p_tcb, BOOLEAN is_add)
+BOOLEAN gatt_update_app_hold_link_status(tGATT_IF gatt_if, tGATT_TCB *p_tcb, BOOLEAN is_add)
 {
-    UINT8 i;
-    BOOLEAN found=FALSE;
-
-    if (p_tcb == NULL)
-    {
-        GATT_TRACE_ERROR("gatt_update_app_hold_link_status p_tcb=NULL");
-        return;
-    }
-
-
-    for (i=0; i<GATT_MAX_APPS; i++)
-    {
-        if (p_tcb->app_hold_link[i] ==  gatt_if)
-        {
-            found = TRUE;
-            if (!is_add)
-            {
-                p_tcb->app_hold_link[i] = 0;
-                break;
-            }
+    for (int i = 0; i < GATT_MAX_APPS; i++) {
+        if (p_tcb->app_hold_link[i] == gatt_if && is_add) {
+            GATT_TRACE_DEBUG("%s: gatt_if %d already exists at idx %d", __func__, gatt_if, i);
+            return true;
         }
     }
 
-    if (!found && is_add)
-    {
-        for (i=0; i<GATT_MAX_APPS; i++)
-        {
-            if (p_tcb->app_hold_link[i] ==  0)
-            {
-                p_tcb->app_hold_link[i] = gatt_if;
-                found = TRUE;
-                break;
-            }
+    for (int i=0; i<GATT_MAX_APPS; i++) {
+        if (p_tcb->app_hold_link[i] == 0 && is_add) {
+            p_tcb->app_hold_link[i] = gatt_if;
+            GATT_TRACE_DEBUG("%s: added gatt_if=%d idx=%d ", __func__, gatt_if, i);
+            return TRUE;
+        } else if (p_tcb->app_hold_link[i] == gatt_if && !is_add) {
+            p_tcb->app_hold_link[i] = 0;
+            GATT_TRACE_DEBUG("%s: removed gatt_if=%d idx=%d", __func__, gatt_if, i);
+            return TRUE;
         }
     }
 
-    GATT_TRACE_DEBUG("gatt_update_app_hold_link_status found=%d[1-found] idx=%d gatt_if=%d is_add=%d", found, i, gatt_if, is_add);
-
+    GATT_TRACE_DEBUG("%s: gatt_if=%d not found; is_add=%d", __func__, gatt_if, is_add);
+    return FALSE;
 }
 
 /*******************************************************************************
@@ -331,34 +320,37 @@ void gatt_update_app_hold_link_status (tGATT_IF gatt_if, tGATT_TCB *p_tcb, BOOLE
 ** Returns          void.
 **
 *******************************************************************************/
-void gatt_update_app_use_link_flag (tGATT_IF gatt_if, tGATT_TCB *p_tcb, BOOLEAN is_add, BOOLEAN check_acl_link)
+void gatt_update_app_use_link_flag(tGATT_IF gatt_if, tGATT_TCB *p_tcb, BOOLEAN is_add,
+                                   BOOLEAN check_acl_link)
 {
-    GATT_TRACE_DEBUG("gatt_update_app_use_link_flag  is_add=%d chk_link=%d",
-                      is_add, check_acl_link);
+    GATT_TRACE_DEBUG("%s: is_add=%d chk_link=%d", __func__, is_add, check_acl_link);
 
-    gatt_update_app_hold_link_status(gatt_if, p_tcb, is_add);
+    if (!p_tcb)
+        return;
 
-    if (check_acl_link &&
-        p_tcb &&
-         p_tcb->att_lcid == L2CAP_ATT_CID && /* only update link idle timer for fixed channel */
-        (BTM_GetHCIConnHandle(p_tcb->peer_bda, p_tcb->transport) != GATT_INVALID_ACL_HANDLE))
-    {
-        if (is_add)
-        {
-            GATT_TRACE_DEBUG("GATT disables link idle timer");
-            /* acl link is connected disable the idle timeout */
-            GATT_SetIdleTimeout(p_tcb->peer_bda, GATT_LINK_NO_IDLE_TIMEOUT, p_tcb->transport);
-        }
-        else
-        {
-            if (!gatt_num_apps_hold_link(p_tcb))
-            {
-                /* acl link is connected but no application needs to use the link
-                   so set the timeout value to GATT_LINK_IDLE_TIMEOUT_WHEN_NO_APP seconds */
-                GATT_TRACE_DEBUG("GATT starts link idle timer =%d sec", GATT_LINK_IDLE_TIMEOUT_WHEN_NO_APP);
-                GATT_SetIdleTimeout(p_tcb->peer_bda, GATT_LINK_IDLE_TIMEOUT_WHEN_NO_APP, p_tcb->transport);
-            }
+    // If we make no modification, i.e. kill app that was never connected to a device,
+    // skip updating the device state.
+    if (!gatt_update_app_hold_link_status(gatt_if, p_tcb, is_add))
+        return;
+
+    if (!check_acl_link ||
+            p_tcb->att_lcid != L2CAP_ATT_CID || /* only update link idle timer for fixed channel */
+            (BTM_GetHCIConnHandle(p_tcb->peer_bda, p_tcb->transport) == GATT_INVALID_ACL_HANDLE)) {
+        return;
+    }
 
+    if (is_add) {
+        GATT_TRACE_DEBUG("%s: disable link idle timer", __func__);
+        /* acl link is connected disable the idle timeout */
+        GATT_SetIdleTimeout(p_tcb->peer_bda, GATT_LINK_NO_IDLE_TIMEOUT, p_tcb->transport);
+    } else {
+        if (!gatt_num_apps_hold_link(p_tcb)) {
+            /* acl link is connected but no application needs to use the link
+               so set the timeout value to GATT_LINK_IDLE_TIMEOUT_WHEN_NO_APP seconds */
+            GATT_TRACE_DEBUG("%s: start link idle timer =%d sec", __func__,
+                             GATT_LINK_IDLE_TIMEOUT_WHEN_NO_APP);
+            GATT_SetIdleTimeout(p_tcb->peer_bda, GATT_LINK_IDLE_TIMEOUT_WHEN_NO_APP,
+                                p_tcb->transport);
         }
     }
 }
@@ -372,7 +364,8 @@ void gatt_update_app_use_link_flag (tGATT_IF gatt_if, tGATT_TCB *p_tcb, BOOLEAN
 ** Returns          void.
 **
 *******************************************************************************/
-BOOLEAN gatt_act_connect (tGATT_REG *p_reg, BD_ADDR bd_addr, tBT_TRANSPORT transport)
+BOOLEAN gatt_act_connect (tGATT_REG *p_reg, BD_ADDR bd_addr,
+                          tBT_TRANSPORT transport, BOOLEAN opportunistic)
 {
     BOOLEAN     ret = FALSE;
     tGATT_TCB   *p_tcb;
@@ -419,7 +412,11 @@ BOOLEAN gatt_act_connect (tGATT_REG *p_reg, BD_ADDR bd_addr, tBT_TRANSPORT trans
 
     if (ret)
     {
-        gatt_update_app_use_link_flag(p_reg->gatt_if, p_tcb, TRUE, TRUE);
+        if (!opportunistic)
+            gatt_update_app_use_link_flag(p_reg->gatt_if, p_tcb, TRUE, TRUE);
+        else
+            GATT_TRACE_DEBUG("%s: connection is opportunistic, not updating app usage",
+                            __func__);
     }
 
     return ret;
@@ -450,6 +447,8 @@ static void gatt_le_connect_cback (UINT16 chan, BD_ADDR bd_addr, BOOLEAN connect
                        (bd_addr[0]<<24)+(bd_addr[1]<<16)+(bd_addr[2]<<8)+bd_addr[3],
                        (bd_addr[4]<<8)+bd_addr[5], (connected) ? "connected" : "disconnected");
 
+    if (reason == GATT_CONN_TIMEOUT || reason == GATT_CONN_LMP_TIMEOUT)
+        GENERATE_VENDOR_LOGS();
     if ((p_srv_chg_clt = gatt_is_bda_in_the_srv_chg_clt_list(bd_addr)) != NULL)
     {
         check_srv_chg = TRUE;
diff --git a/stack/gatt/gatt_sr.c b/stack/gatt/gatt_sr.c
index 11ef79c..911989a 100644
--- a/stack/gatt/gatt_sr.c
+++ b/stack/gatt/gatt_sr.c
@@ -329,6 +329,7 @@ void gatt_process_exec_write_req (tGATT_TCB *p_tcb, UINT8 op_code, UINT16 len, U
     UINT32  trans_id = 0;
     tGATT_IF gatt_if;
     UINT16  conn_id;
+    BT_HDR  *p_buf;
 
     UNUSED(len);
 
@@ -373,7 +374,8 @@ void gatt_process_exec_write_req (tGATT_TCB *p_tcb, UINT8 op_code, UINT16 len, U
     else /* nothing needs to be executed , send response now */
     {
         GATT_TRACE_ERROR("gatt_process_exec_write_req: no prepare write pending");
-        gatt_send_error_rsp(p_tcb, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, FALSE);
+        if ((p_buf = attp_build_sr_msg(p_tcb, GATT_RSP_EXEC_WRITE, NULL)) != NULL)
+            attp_send_sr_msg (p_tcb, p_buf);
     }
 }
 
diff --git a/stack/gatt/gatt_utils.c b/stack/gatt/gatt_utils.c
index 4582b5a..a899110 100644
--- a/stack/gatt/gatt_utils.c
+++ b/stack/gatt/gatt_utils.c
@@ -1288,6 +1288,7 @@ void gatt_rsp_timeout(void *data)
 
     GATT_TRACE_WARNING("%s disconnecting...", __func__);
     gatt_disconnect (p_clcb->p_tcb);
+    GENERATE_VENDOR_LOGS();
 }
 
 /*******************************************************************************
diff --git a/stack/hcic/hciblecmds.c b/stack/hcic/hciblecmds.c
index 5d58449..08d077e 100644
--- a/stack/hcic/hciblecmds.c
+++ b/stack/hcic/hciblecmds.c
@@ -221,6 +221,72 @@ BOOLEAN btsnd_hcic_ble_set_scan_enable (UINT8 scan_enable, UINT8 duplicate)
     return (TRUE);
 }
 
+BOOLEAN btsnd_hcic_ble_set_extended_scan_params (UINT8 scan_phys,
+                                          UINT8 scan_type,
+                                          UINT16 scan_int, UINT16 scan_win,
+                                          UINT16 scan_int_coded, UINT16 scan_win_coded,
+                                          UINT8 addr_type_own, UINT8 scan_filter_policy)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);
+
+    if(scan_phys == 0)
+        scan_phys = HCIC_SCAN_PHY_LE_1M;
+
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_WRITE_EXT_SCAN_PARAMS);
+
+    if((scan_phys == HCIC_SCAN_PHY_LE_1M) || (scan_phys == HCIC_SCAN_PHY_LE_CODED))
+    {
+        p->len = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_PARAM;
+        UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_PARAM);
+    }
+    else if(scan_phys == HCIC_SCAN_PHY_LE_1M_CODED)
+    {
+        p->len = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_PARAM + 5;
+        UINT8_TO_STREAM (pp, (HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_PARAM + 5));
+    }
+    UINT8_TO_STREAM (pp, addr_type_own);
+    UINT8_TO_STREAM (pp, scan_filter_policy);
+    UINT8_TO_STREAM (pp, scan_phys);
+    UINT8_TO_STREAM (pp, scan_type);
+    UINT16_TO_STREAM (pp, scan_int);
+    UINT16_TO_STREAM (pp, scan_win);
+
+
+    if(scan_phys == HCIC_SCAN_PHY_LE_1M_CODED)
+    {
+        UINT8_TO_STREAM (pp, scan_type);
+        UINT16_TO_STREAM (pp, scan_int_coded);
+        UINT16_TO_STREAM (pp, scan_win_coded);
+    }
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_ble_set_extended_scan_enable (UINT8 scan_enable, UINT8 duplicate,
+                                                 UINT16 duraton, UINT16 period)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_ENABLE;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_WRITE_EXT_SCAN_ENABLE);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_ENABLE);
+
+    UINT8_TO_STREAM (pp, scan_enable);
+    UINT8_TO_STREAM (pp, duplicate);
+    UINT16_TO_STREAM (pp, duraton);
+    UINT16_TO_STREAM (pp, period);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
 /* link layer connection management commands */
 BOOLEAN btsnd_hcic_ble_create_ll_conn (UINT16 scan_int, UINT16 scan_win,
                                        UINT8 init_filter_policy,
@@ -259,6 +325,63 @@ BOOLEAN btsnd_hcic_ble_create_ll_conn (UINT16 scan_int, UINT16 scan_win,
     return (TRUE);
 }
 
+BOOLEAN btsnd_hcic_ble_ext_create_ll_conn (UINT8 ini_phy, UINT16 scan_int, UINT16 scan_win,
+                                       UINT8 init_filter_policy,
+                                       UINT8 addr_type_peer, BD_ADDR bda_peer,
+                                       UINT8 addr_type_own,
+                                       UINT16 conn_int_min, UINT16 conn_int_max,
+                                       UINT16 conn_latency, UINT16 conn_timeout,
+                                       UINT16 min_ce_len, UINT16 max_ce_len)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_EXT_CREATE_LL_CONN;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_EXT_CREATE_LL_CONN);
+    if(ini_phy == HCIC_SCAN_PHY_LE_1M || ini_phy == HCIC_SCAN_PHY_LE_CODED)
+    {
+        p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_EXT_CREATE_LL_CONN;
+        UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_BLE_EXT_CREATE_LL_CONN);
+    }
+    else if(ini_phy == HCIC_SCAN_PHY_LE_1M_CODED)
+    {
+        p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_EXT_CREATE_LL_CONN + 16;
+        UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_BLE_EXT_CREATE_LL_CONN + 16);
+    }
+
+    UINT8_TO_STREAM (pp, init_filter_policy);
+    UINT8_TO_STREAM (pp, addr_type_own);
+    UINT8_TO_STREAM (pp, addr_type_peer);
+    BDADDR_TO_STREAM (pp, bda_peer);
+    UINT8_TO_STREAM (pp, ini_phy);
+
+    UINT16_TO_STREAM (pp, scan_int);
+    UINT16_TO_STREAM (pp, scan_win);
+    UINT16_TO_STREAM (pp, conn_int_min);
+    UINT16_TO_STREAM (pp, conn_int_max);
+    UINT16_TO_STREAM (pp, conn_latency);
+    UINT16_TO_STREAM (pp, conn_timeout);
+    UINT16_TO_STREAM (pp, min_ce_len);
+    UINT16_TO_STREAM (pp, max_ce_len);
+
+    if(ini_phy == HCIC_SCAN_PHY_LE_1M_CODED)
+    {
+        UINT16_TO_STREAM (pp, scan_int);
+        UINT16_TO_STREAM (pp, scan_win);
+        UINT16_TO_STREAM (pp, conn_int_min);
+        UINT16_TO_STREAM (pp, conn_int_max);
+        UINT16_TO_STREAM (pp, conn_latency);
+        UINT16_TO_STREAM (pp, conn_timeout);
+        UINT16_TO_STREAM (pp, min_ce_len);
+        UINT16_TO_STREAM (pp, max_ce_len);
+    }
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
 BOOLEAN btsnd_hcic_ble_create_conn_cancel (void)
 {
     BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
@@ -525,6 +648,25 @@ BOOLEAN btsnd_hcic_ble_receiver_test(UINT8 rx_freq)
     return (TRUE);
 }
 
+BOOLEAN btsnd_hcic_ble_enh_receiver_test(UINT8 rx_freq, UINT8 phy, UINT8 mod_index)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_WRITE_PARAM3;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_ENH_RECEIVER_TEST);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_WRITE_PARAM3);
+
+    UINT8_TO_STREAM (pp, rx_freq);
+    UINT8_TO_STREAM (pp, phy);
+    UINT8_TO_STREAM (pp, mod_index);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
 BOOLEAN btsnd_hcic_ble_transmitter_test(UINT8 tx_freq, UINT8 test_data_len, UINT8 payload)
 {
     BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
@@ -544,6 +686,26 @@ BOOLEAN btsnd_hcic_ble_transmitter_test(UINT8 tx_freq, UINT8 test_data_len, UINT
     return (TRUE);
 }
 
+BOOLEAN btsnd_hcic_ble_enh_transmitter_test(UINT8 tx_freq, UINT8 test_data_len, UINT8 payload, UINT8 phy)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_WRITE_PARAM4;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_ENH_TRANSMITTER_TEST);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_WRITE_PARAM4);
+
+    UINT8_TO_STREAM (pp, tx_freq);
+    UINT8_TO_STREAM (pp, test_data_len);
+    UINT8_TO_STREAM (pp, payload);
+    UINT8_TO_STREAM (pp, phy);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
 BOOLEAN btsnd_hcic_ble_test_end(void)
 {
     BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
@@ -661,6 +823,26 @@ BOOLEAN btsnd_hcic_ble_rm_device_resolving_list (UINT8 addr_type_peer, BD_ADDR b
     return (TRUE);
 }
 
+BOOLEAN btsnd_hcic_ble_set_privacy_mode (UINT8 addr_type_peer, BD_ADDR bda_peer, UINT8 privacy_type)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);
+
+    p->len = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_SET_PRIVACY_MODE;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_SET_PRIVACY_MODE);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_BLE_SET_PRIVACY_MODE);
+    UINT8_TO_STREAM (pp, addr_type_peer);
+    BDADDR_TO_STREAM (pp, bda_peer);
+    UINT8_TO_STREAM (pp, privacy_type);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID, p);
+
+    return (TRUE);
+}
+
+
 BOOLEAN btsnd_hcic_ble_clear_resolving_list (void)
 {
     BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
@@ -766,5 +948,217 @@ BOOLEAN btsnd_hcic_ble_set_data_length(UINT16 conn_handle, UINT16 tx_octets, UIN
     return TRUE;
 }
 
-#endif
+BOOLEAN btsnd_hcic_ble_set_default_data_rate(UINT8 all_phy, UINT8 tx_phy, UINT8 rx_phy)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_WRITE_DEFAULT_PHY;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_BLE_SET_DEFAULT_PHY_RATE);
+    UINT8_TO_STREAM(pp, HCIC_PARAM_SIZE_BLE_WRITE_DEFAULT_PHY);
+
+    UINT8_TO_STREAM(pp, all_phy);
+    UINT8_TO_STREAM(pp, tx_phy);
+    UINT8_TO_STREAM(pp, rx_phy);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID, p);
+    return TRUE;
+}
+
+BOOLEAN btsnd_hcic_ble_set_data_rate(UINT16 handle, UINT8 all_phy, UINT8 tx_phy,
+                                     UINT8 rx_phy, UINT16 phy_options)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_WRITE_PHY;
+    p->offset = 0;
+
+    UINT16_TO_STREAM(pp, HCI_BLE_SET_PHY_RATE);
+    UINT8_TO_STREAM(pp, HCIC_PARAM_SIZE_BLE_WRITE_PHY);
+
+    UINT16_TO_STREAM(pp, handle);
+    UINT8_TO_STREAM(pp, all_phy);
+    UINT8_TO_STREAM(pp, tx_phy);
+    UINT8_TO_STREAM(pp, rx_phy);
+    UINT16_TO_STREAM(pp, phy_options);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID, p);
+    return TRUE;
+}
+
+BOOLEAN btsnd_hcic_ble_set_extended_adv_params (UINT8 set_id, UINT16 event_properties,
+                                              UINT32 adv_int_min, UINT32 adv_int_max,
+                                              UINT8 channel_map, UINT8 addr_type_own,
+                                              UINT8 addr_type_dir, BD_ADDR direct_bda,
+                                              UINT8 adv_filter_policy, UINT8 adv_tx_power,
+                                              UINT8 primary_adv_phy, UINT8 secondary_max_skip,
+                                              UINT8 secondary_adv_phy, UINT8 advertising_sid,
+                                              UINT8 scan_req_not_enb)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_ADV_PARAMS ;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_WRITE_EXTENDED_ADV_PARAMS);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_ADV_PARAMS);
+    UINT8_TO_STREAM (pp, set_id);
+    UINT16_TO_STREAM (pp, event_properties);
+    UINT24_TO_STREAM (pp, adv_int_min);
+    UINT24_TO_STREAM (pp, adv_int_max);
+    UINT8_TO_STREAM (pp, channel_map);
+    UINT8_TO_STREAM (pp, addr_type_own);
+    UINT8_TO_STREAM (pp, addr_type_dir);
+    BDADDR_TO_STREAM (pp, direct_bda);
+    UINT8_TO_STREAM (pp, adv_filter_policy);
+    UINT8_TO_STREAM (pp, adv_tx_power);
+    UINT8_TO_STREAM (pp, primary_adv_phy);
+    UINT8_TO_STREAM (pp, secondary_max_skip);
+    UINT8_TO_STREAM (pp, secondary_adv_phy);
+    UINT8_TO_STREAM (pp, advertising_sid);
+    UINT8_TO_STREAM (pp, scan_req_not_enb);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_ble_set_extended_adv_data (UINT8 set_id, UINT8 operation, UINT8 fragment_pref,
+                                              UINT8 data_len, UINT8 *p_data)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len    = HCIC_PREAMBLE_SIZE + data_len + 4;
+    p->offset = 0;
+
+    if (data_len > HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_ADV_DATA)
+        data_len = HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_ADV_DATA;
+
+
+    UINT16_TO_STREAM (pp, HCI_BLE_WRITE_EXTENDED_ADV_DATA);
+    UINT8_TO_STREAM  (pp, data_len + 4);
+    UINT8_TO_STREAM  (pp, set_id);
+    UINT8_TO_STREAM  (pp, operation);
+    UINT8_TO_STREAM  (pp, fragment_pref);
+
+    memset(pp, 0, data_len + 1);
+
+    if (p_data != NULL && data_len > 0)
+    {
+        UINT8_TO_STREAM (pp, data_len);
+        ARRAY_TO_STREAM (pp, p_data, data_len);
+    }
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_ble_set_extended_scan_rsp_data (UINT8 set_id, UINT8 operation, UINT8 fragment_pref,
+                                                   UINT8 data_len, UINT8 *p_scan_rsp)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len    = HCIC_PREAMBLE_SIZE + data_len + 4;
+    p->offset = 0;
 
+    if (data_len > HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_SCAN_RSP )
+            data_len = HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_SCAN_RSP;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_WRITE_EXTENDED_SCAN_RSP_DATA);
+    UINT8_TO_STREAM  (pp, data_len + 4);
+    UINT8_TO_STREAM  (pp, set_id);
+    UINT8_TO_STREAM  (pp, operation);
+    UINT8_TO_STREAM  (pp, fragment_pref);
+
+    memset(pp, 0, data_len + 1);
+
+    if (p_scan_rsp != NULL && data_len > 0)
+    {
+        UINT8_TO_STREAM (pp, data_len);
+        ARRAY_TO_STREAM (pp, p_scan_rsp, data_len);
+    }
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_ble_set_extended_adv_enable (UINT8 adv_enable, UINT8 num_sets, UINT8* handles,
+                                            UINT16* durations, UINT8* max_adv_events)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_WRITE_EXTENDED_ADV_ENABLE + num_sets*4;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_WRITE_EXTENDED_ADV_ENABLE);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_WRITE_EXTENDED_ADV_ENABLE + 4*num_sets);
+
+    UINT8_TO_STREAM (pp, adv_enable);
+    UINT8_TO_STREAM (pp, num_sets);
+
+    if (num_sets > 0) {
+        for (UINT8 count = 0; count < num_sets; count++) {
+            UINT8_TO_STREAM(pp, handles[count]);
+            UINT16_TO_STREAM (pp, durations[count]);
+            UINT8_TO_STREAM(pp, max_adv_events[count]);
+        }
+    }
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_ble_read_num_adv_sets (void)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_READ_CMD;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_READ_NUM_ADV_SETS);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_READ_CMD);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_ble_write_extended_rpa (UINT8 set_id, BD_ADDR rpa)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_WRITE_EXTENDED_ADV_RPA;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_WRITE_EXTENDED_ADV_RPA);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_WRITE_EXTENDED_ADV_RPA);
+    UINT8_TO_STREAM  (pp, set_id);
+    BDADDR_TO_STREAM (pp, rpa);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_ble_read_extended_max_adv_len (void)
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);;
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_READ_CMD;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BLE_READ_MAX_ADV_LENGTH);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_READ_CMD);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+#endif
diff --git a/stack/hid/hidh_conn.c b/stack/hid/hidh_conn.c
index 96fc5bd..29074bd 100644
--- a/stack/hid/hidh_conn.c
+++ b/stack/hid/hidh_conn.c
@@ -274,13 +274,16 @@ static void hidh_l2cif_connect_ind (BD_ADDR  bd_addr, UINT16 l2cap_cid, UINT16 p
 
     if (psm == HID_PSM_CONTROL)
     {
+        bt_bdaddr_t remote_bdaddr;
         p_hcon->conn_flags = 0;
         p_hcon->ctrl_cid   = l2cap_cid;
         p_hcon->ctrl_id    = l2cap_id;
         p_hcon->disc_reason = HID_L2CAP_CONN_FAIL;  /* In case disconnection occurs before security is completed, then set CLOSE_EVT reason code to 'connection failure' */
 
         p_hcon->conn_state = HID_CONN_STATE_SECURITY;
-        if (!interop_match_addr(INTEROP_DISABLE_AUTH_FOR_HID_POINTING, (bt_bdaddr_t*)p_dev->addr))
+        bdcpy(remote_bdaddr.address, p_dev->addr);
+
+        if (!interop_match_addr(INTEROP_DISABLE_AUTH_FOR_HID_POINTING, (bt_bdaddr_t *)&remote_bdaddr))
         {
             if(btm_sec_mx_access_request (p_dev->addr, HID_PSM_CONTROL,
                 FALSE, BTM_SEC_PROTO_HID,
@@ -318,6 +321,7 @@ static void hidh_l2cif_connect_ind (BD_ADDR  bd_addr, UINT16 l2cap_cid, UINT16 p
 void hidh_process_repage_timer_timeout(void *data)
 {
   uint8_t dhandle = PTR_TO_UINT(data);
+  GENERATE_VENDOR_LOGS();
   hidh_try_repage(dhandle);
 }
 
@@ -389,6 +393,7 @@ void hidh_sec_check_complete_orig (BD_ADDR bd_addr, tBT_TRANSPORT transport, voi
             }
         }
 #endif
+        GENERATE_VENDOR_LOGS();
         p_dev->conn.disc_reason = HID_ERR_AUTH_FAILED;      /* Save reason for disconnecting */
         hidh_conn_disconnect(dhandle);
     }
@@ -452,17 +457,21 @@ static void hidh_l2cif_connect_cfm (UINT16 l2cap_cid, UINT16 result)
             reason = HID_L2CAP_CONN_FAIL | (UINT32) result ;
             HIDH_TRACE_WARNING ("HID-Host: l2cap connect failed, reason = %d", reason);
             hh_cb.callback( dhandle, hh_cb.devices[dhandle].addr, HID_HDEV_EVT_CLOSE, reason, NULL ) ;
+            GENERATE_VENDOR_LOGS();
         }
         return;
     }
     /* receive Control Channel connect confirmation */
     if (l2cap_cid == p_hcon->ctrl_cid)
     {
+        bt_bdaddr_t remote_address;
+
         /* check security requirement */
         p_hcon->conn_state = HID_CONN_STATE_SECURITY;
         p_hcon->disc_reason = HID_L2CAP_CONN_FAIL;  /* In case disconnection occurs before security is completed, then set CLOSE_EVT reason code to "connection failure" */
+        bdcpy(remote_address.address, p_dev->addr);
 
-        if (!interop_match_addr(INTEROP_DISABLE_AUTH_FOR_HID_POINTING, (bt_bdaddr_t *)p_dev->addr))
+        if (!interop_match_addr(INTEROP_DISABLE_AUTH_FOR_HID_POINTING, (bt_bdaddr_t *)&remote_address))
         {
             btm_sec_mx_access_request (p_dev->addr, HID_PSM_CONTROL,
                 TRUE, BTM_SEC_PROTO_HID,
@@ -546,6 +555,7 @@ static void hidh_l2cif_config_ind (UINT16 l2cap_cid, tL2CAP_CFG_INFO *p_cfg)
                 hidh_conn_disconnect (dhandle);
                 HIDH_TRACE_WARNING ("HID-Host: l2cap config failed, reason = %d", reason);
                 hh_cb.callback( dhandle, hh_cb.devices[dhandle].addr, HID_HDEV_EVT_CLOSE, reason, NULL ) ;
+                GENERATE_VENDOR_LOGS();
                 return;
             }
             else
@@ -607,6 +617,7 @@ static void hidh_l2cif_config_cfm (UINT16 l2cap_cid, tL2CAP_CFG_INFO *p_cfg)
         reason = HID_L2CAP_CFG_FAIL | (UINT32) p_cfg->result ;
         HIDH_TRACE_WARNING ("HID-Host: l2cap config ind failed, reason = %d", reason);
         hh_cb.callback( dhandle, hh_cb.devices[dhandle].addr, HID_HDEV_EVT_CLOSE, reason, NULL ) ;
+        GENERATE_VENDOR_LOGS();
         return;
     }
 
@@ -626,6 +637,7 @@ static void hidh_l2cif_config_cfm (UINT16 l2cap_cid, tL2CAP_CFG_INFO *p_cfg)
                 hidh_conn_disconnect (dhandle);
                 HIDH_TRACE_WARNING ("HID-Host: l2cap config ind failed 2, reason = %d", reason);
                 hh_cb.callback( dhandle, hh_cb.devices[dhandle].addr, HID_HDEV_EVT_CLOSE, reason, NULL ) ;
+                GENERATE_VENDOR_LOGS();
                 return;
             }
             else
@@ -713,6 +725,7 @@ static void hidh_l2cif_disconnect_ind (UINT16 l2cap_cid, BOOLEAN ack_needed)
                                interval_ms, hidh_process_repage_timer_timeout,
                                UINT_TO_PTR(dhandle), btu_general_alarm_queue);
             hh_cb.callback( dhandle,  hh_cb.devices[dhandle].addr, HID_HDEV_EVT_CLOSE, disc_res, NULL);
+            GENERATE_VENDOR_LOGS();
         }
         else
 #endif
@@ -1088,6 +1101,7 @@ tHID_STATUS hidh_conn_initiate (UINT8 dhandle)
         HIDH_TRACE_WARNING ("HID-Host Originate failed");
         hh_cb.callback( dhandle,  hh_cb.devices[dhandle].addr, HID_HDEV_EVT_CLOSE,
                                 HID_ERR_L2CAP_FAILED, NULL ) ;
+        GENERATE_VENDOR_LOGS();
         return HID_ERR_L2CAP_FAILED;
     }
     else
diff --git a/stack/include/a2d_aac.h b/stack/include/a2d_aac.h
index 102de67..413d486 100644
--- a/stack/include/a2d_aac.h
+++ b/stack/include/a2d_aac.h
@@ -75,7 +75,8 @@
 #define A2D_AAC_IE_BIT_RATE                    0x007FFFFF
 
 
-#define BTIF_AAC_DEFAULT_BIT_RATE 0x000409B6
+#define BTIF_AAC_DEFAULT_BIT_RATE 0x00028488 //165kbps
+#define BTIF_AAC_MIN_BITRATE 0x0000FA00
 
 typedef struct  {
     INT16 s16SamplingFreq;  /* 16k, 32k, 44.1k or 48k*/
diff --git a/stack/include/a2d_aptx.h b/stack/include/a2d_aptx.h
index 3e52013..2fb9613 100644
--- a/stack/include/a2d_aptx.h
+++ b/stack/include/a2d_aptx.h
@@ -120,7 +120,15 @@ extern BOOLEAN (*A2D_aptx_sched_stop)(void);
 extern void (*A2D_aptx_encoder_deinit)(void);
 extern UINT8 a2d_av_aptx_cfg_in_cap(UINT8 *p_cfg, tA2D_APTX_CIE *p_cap);
 extern BOOLEAN A2D_check_and_init_aptX();
+extern void A2D_start_aptX(void *encoder, A2D_AptXCodecType aptX_codec_type,
+                        BOOLEAN use_SCMS_T, BOOLEAN is_24bit_audio,
+                        UINT16 sample_rate, UINT8 format_bits,
+                        UINT8 channel, UINT16 MTU, A2D_AptXReadFn read_fn,
+                        A2D_AptXBufferSendFn send_fn,
+                        A2D_AptXSetPriorityFn set_priority_fn,
+                        BOOLEAN test, BOOLEAN trace);
 extern void A2D_deinit_aptX();
+extern void A2D_stop_aptX (void);
 extern void A2D_close_aptX();
 
 #ifdef __cplusplus
diff --git a/stack/include/avct_api.h b/stack/include/avct_api.h
index f8441e8..350afdd 100644
--- a/stack/include/avct_api.h
+++ b/stack/include/avct_api.h
@@ -326,6 +326,18 @@ UINT8 AVCT_SetTraceLevel (UINT8 new_level);
 *******************************************************************************/
 extern BOOLEAN avct_get_peer_addr_by_ccb (UINT8 idx, BD_ADDR addr);
 
+/*******************************************************************************
+**
+** Function         AVCT_CheckIncomingConn
+**
+**
+** Description      Check if remote AVCTP incoming connection in progress
+**
+** Returns          TRUE if icoming connection is in progress,
+**
+*******************************************************************************/
+extern BOOLEAN AVCT_CheckIncomingConn(BD_ADDR peer_addr);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/stack/include/avdt_api.h b/stack/include/avdt_api.h
index 6bb1a58..f52420f 100644
--- a/stack/include/avdt_api.h
+++ b/stack/include/avdt_api.h
@@ -412,6 +412,7 @@ typedef struct {
     UINT8               tsep;           /* SEP type */
     UINT8               media_type;     /* Media type */
     UINT16              nsc_mask;       /* Nonsupported protocol command messages */
+    UINT8               registration_id;/* All SCBs created during single registration will have same value.*/
 } tAVDT_CS;
 
 /* AVDT data option mask is used in the write request */
diff --git a/stack/include/avrc_api.h b/stack/include/avrc_api.h
index 15354b5..7245b6b 100644
--- a/stack/include/avrc_api.h
+++ b/stack/include/avrc_api.h
@@ -679,6 +679,18 @@ extern BOOLEAN AVRC_IsValidAvcType(UINT8 pdu_id, UINT8 avc_type);
 *******************************************************************************/
 extern BOOLEAN AVRC_IsValidPlayerAttr(UINT8 attr);
 
+/*******************************************************************************
+**
+** Function         AVRC_CheckIncomingConn
+**
+** Description      Check if AVRC incoming connection in progress
+**
+**
+** Returns          returns TRUE if incoming connection in progress
+**
+*******************************************************************************/
+extern BOOLEAN AVRC_CheckIncomingConn(BD_ADDR peer_addr);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/stack/include/btm_api.h b/stack/include/btm_api.h
index 04c8d0d..80e4022 100644
--- a/stack/include/btm_api.h
+++ b/stack/include/btm_api.h
@@ -30,6 +30,7 @@
 #include "hcidefs.h"
 
 #include "smp_api.h"
+
 /*****************************************************************************
 **  DEVICE CONTROL and COMMON
 *****************************************************************************/
@@ -118,6 +119,13 @@ typedef struct
     UINT8   *p_param_buf;
 } tBTM_RAW_CMPL;
 
+typedef struct
+{
+    UINT16 adv_len;
+    UINT8 *adv_data_cache;
+} tBTM_BLE_INQ_DATA_CB;
+
+
 #define  BTM_VSC_CMPL_DATA_SIZE  (BTM_MAX_VENDOR_SPECIFIC_LEN + sizeof(tBTM_VSC_CMPL))
 /**************************************************
 **  Device Control and General Callback Functions
@@ -604,7 +612,7 @@ typedef struct              /* contains the parameters passed to the inquiry fun
 #define BTM_BLE_EVT_DISC_ADV        0x02
 #define BTM_BLE_EVT_NON_CONN_ADV    0x03
 #define BTM_BLE_EVT_SCAN_RSP        0x04
-typedef UINT8 tBTM_BLE_EVT_TYPE;
+typedef UINT16 tBTM_BLE_EVT_TYPE;
 #endif
 
 /* These are the fields returned in each device's response to the inquiry.  It
@@ -621,12 +629,20 @@ typedef struct
     INT8        rssi;       /* Set to BTM_INQ_RES_IGNORE_RSSI if  not valid */
     UINT32      eir_uuid[BTM_EIR_SERVICE_ARRAY_SIZE];
     BOOLEAN     eir_complete_list;
+    UINT16      adv_data_len;
 #if (BLE_INCLUDED == TRUE)
     tBT_DEVICE_TYPE         device_type;
     UINT8       inq_result_type;
     UINT8       ble_addr_type;
     tBTM_BLE_EVT_TYPE       ble_evt_type;
     UINT8                   flag;
+    tBTM_BLE_INQ_DATA_CB    inq_data;
+    UINT8       pri_phy;
+    UINT8       sec_phy;
+    UINT8       adv_sid;
+    UINT16      periodic_adv_int;
+    UINT8       direct_addr_type;
+    BD_ADDR     direct_bda;
 #endif
 } tBTM_INQ_RESULTS;
 
@@ -1609,13 +1625,14 @@ typedef UINT8 tBTM_LE_KEY_TYPE;
 #define BTM_LE_AUTH_REQ_MITM    SMP_AUTH_YN_BIT    /* 1 << 2 */
 typedef UINT8 tBTM_LE_AUTH_REQ;
 #define BTM_LE_SC_SUPPORT_BIT           SMP_SC_SUPPORT_BIT     /* (1 << 3) */
-#define BTM_LE_KP_SUPPORT_BIT           SMP_KP_SUPPORT_BIT     /* (1 << 4) */
+#define BTM_LE_KP_SUPPORT_BIT           SMP_KP_SUPPORT_BIT     /* (1 << 4) */`
+#define BTM_LE_H7_SUPPORT_BIT           SMP_H7_SUPPORT_BIT     /* (1 << 5) */`
 
-#define BTM_LE_AUTH_REQ_SC_ONLY         SMP_AUTH_SC_ENC_ONLY    /* 1 << 3 */
-#define BTM_LE_AUTH_REQ_SC_BOND         SMP_AUTH_SC_GB          /* 1001 */
-#define BTM_LE_AUTH_REQ_SC_MITM         SMP_AUTH_SC_MITM_NB     /* 1100 */
-#define BTM_LE_AUTH_REQ_SC_MITM_BOND    SMP_AUTH_SC_MITM_GB     /* 1101 */
-#define BTM_LE_AUTH_REQ_MASK            SMP_AUTH_MASK           /* 0x1D */
+#define BTM_LE_AUTH_REQ_SC_ONLY         SMP_AUTH_SC_ENC_ONLY    /* 00101000 */
+#define BTM_LE_AUTH_REQ_SC_BOND         SMP_AUTH_SC_GB          /* 00101001 */
+#define BTM_LE_AUTH_REQ_SC_MITM         SMP_AUTH_SC_MITM_NB     /* 00101100 */
+#define BTM_LE_AUTH_REQ_SC_MITM_BOND    SMP_AUTH_SC_MITM_GB     /* 00101101 */
+#define BTM_LE_AUTH_REQ_MASK            SMP_AUTH_MASK           /* 0x3D */
 
 /* LE security level */
 #define BTM_LE_SEC_NONE             SMP_SEC_NONE
@@ -2555,7 +2572,7 @@ extern UINT8 *BTM_ReadAllRemoteFeatures (BD_ADDR addr);
 ** Returns          pointer to entry, or NULL if not found
 **
 *******************************************************************************/
-extern tBTM_INQ_INFO *BTM_InqDbRead (BD_ADDR p_bda);
+extern tBTM_INQ_INFO *BTM_InqDbRead (const BD_ADDR p_bda);
 
 
 /*******************************************************************************
@@ -3362,6 +3379,15 @@ extern BOOLEAN BTM_SecAddDevice (BD_ADDR bd_addr, DEV_CLASS dev_class,
 *******************************************************************************/
 extern BOOLEAN BTM_SecDeleteDevice (BD_ADDR bd_addr);
 
+/*******************************************************************************
+**
+** Function         BTM_SecClearSecurityFlags
+**
+** Description      Reset the security flags (mark as not-paired) for a given
+**                  remove device.
+**
+*******************************************************************************/
+extern void BTM_SecClearSecurityFlags (BD_ADDR bd_addr);
 
 /*******************************************************************************
 **
@@ -3752,7 +3778,7 @@ extern tBTM_STATUS BTM_SetSsrParams (BD_ADDR remote_bda, UINT16 max_lat,
 ** Returns          the handle of the connection, or 0xFFFF if none.
 **
 *******************************************************************************/
-extern UINT16 BTM_GetHCIConnHandle (BD_ADDR remote_bda, tBT_TRANSPORT transport);
+extern UINT16 BTM_GetHCIConnHandle (const BD_ADDR remote_bda, tBT_TRANSPORT transport);
 
 /*******************************************************************************
 **
@@ -3797,7 +3823,7 @@ extern tBTM_STATUS BTM_WriteEIR( BT_HDR * p_buff );
 ** Returns          pointer of EIR data
 **
 *******************************************************************************/
-extern UINT8 *BTM_CheckEirData( UINT8 *p_eir, UINT8 type, UINT8 *p_length );
+extern UINT8 *BTM_CheckEirData( UINT8 *p_eir, UINT8 type, UINT8 *p_length, UINT16 adv_data_len );
 
 /*******************************************************************************
 **
diff --git a/stack/include/btm_ble_api.h b/stack/include/btm_ble_api.h
index 43a015d..4a9517c 100644
--- a/stack/include/btm_ble_api.h
+++ b/stack/include/btm_ble_api.h
@@ -48,7 +48,25 @@ typedef UINT8 tBTM_BLE_CHNL_MAP[CHNL_MAP_LEN];
 
 #define BTM_BLE_UNKNOWN_EVT     0xff
 
+#define BTM_BLE_EXT_SCAN_RSP_EVT_MASK   0x08
+#define BTM_BLE_EXT_CONNECT_DIR_EVT_MASK   0x04
+#define BTM_BLE_EXT_LEGACY_ADV_MASK   0x10
+#define BTM_BLE_EXT_CONN_ADV_MASK   0x01
+#define BTM_BLE_EXT_ADV_EVT_DATA_MASK   0x60
+
+#define BTM_BLE_EXT_ADV_EVT_DATA_CMPL_MASK   0x00
+#define BTM_BLE_EXT_ADV_EVT_DATA_INCMPL_MASK   0x20
+#define BTM_BLE_EXT_ADV_EVT_DATA_INCMPL_TRUNC_MASK   0x40
+
 typedef UINT8 tBTM_BLE_EVT;
+
+#define BTM_BLE_EXT_CONNECT_EVT        0x0013
+#define BTM_BLE_EXT_CONNECT_DIR_EVT    0x001D
+#define BTM_BLE_EXT_DISCOVER_EVT       0x0012
+#define BTM_BLE_EXT_NON_CONNECT_EVT    0x0010
+#define BTM_BLE_EXT_CONNECT_LO_DUTY_DIR_EVT   0x0015
+typedef UINT16 tBTM_BLE_EXT_EVT;
+
 typedef UINT8 tBTM_BLE_CONN_MODE;
 
 typedef UINT32 tBTM_BLE_REF_VALUE;
@@ -357,7 +375,8 @@ typedef UINT8   tBTM_BLE_AD_TYPE;
 /*  Preferred maximum number of microseconds that the local Controller
     should use to transmit a single Link Layer Data Channel PDU. */
 #define BTM_BLE_DATA_TX_TIME_MIN     0x0148
-#define BTM_BLE_DATA_TX_TIME_MAX     0x0848
+#define BTM_BLE_DATA_TX_TIME_MAX_LEGACY     0x0848
+#define BTM_BLE_DATA_TX_TIME_MAX            0x4290
 
 /* adv tx power level */
 #define BTM_BLE_ADV_TX_POWER_MIN        0           /* minimum tx power */
@@ -367,6 +386,11 @@ typedef UINT8   tBTM_BLE_AD_TYPE;
 #define BTM_BLE_ADV_TX_POWER_MAX        4           /* maximum tx power */
 typedef UINT8 tBTM_BLE_ADV_TX_POWER;
 
+/* Subevent code for LE Connection Complete event */
+#if (BLE_PRIVACY_SPT == TRUE )
+#define BTM_BLE_ENHC_CONN_SUB_CODE 0x0A
+#endif
+
 /* adv tx power in dBm */
 typedef struct
 {
@@ -384,6 +408,12 @@ typedef struct
     UINT8 debug_logging_supported;
 }tBTM_BLE_VSC_CB;
 
+typedef struct
+{
+    UINT8 adv_inst_max;         /* max adv instance supported in controller */
+    UINT16 adv_data_len_max;
+}tBTM_BLE_ADV_EXT_CB;
+
 /* slave preferred connection interval range */
 typedef struct
 {
@@ -466,28 +496,48 @@ typedef struct
 }tBTM_BLE_ADV_DATA;
 
 #ifndef BTM_BLE_MULTI_ADV_MAX
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+#define BTM_BLE_MULTI_ADV_MAX   17 /* An extra instance for Extended adv in order to use the 0 inst_id*/
+#else
 #define BTM_BLE_MULTI_ADV_MAX   16 /* controller returned adv_inst_max should be less
                                       than this number */
 #endif
 
+#endif
+
 #define BTM_BLE_MULTI_ADV_INVALID   0
 
 #define BTM_BLE_MULTI_ADV_ENB_EVT           1
 #define BTM_BLE_MULTI_ADV_DISABLE_EVT       2
 #define BTM_BLE_MULTI_ADV_PARAM_EVT         3
 #define BTM_BLE_MULTI_ADV_DATA_EVT          4
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+#define BTM_BLE_EXTENDED_ADV_ENB_EVT        5
+#define BTM_BLE_EXTENDED_ADV_PARAM_EVT      6
+#endif
 typedef UINT8 tBTM_BLE_MULTI_ADV_EVT;
 
 #define BTM_BLE_MULTI_ADV_DEFAULT_STD 0
 
 typedef struct
 {
-    UINT16          adv_int_min;
-    UINT16          adv_int_max;
-    UINT8           adv_type;
+    UINT32          adv_int_min;
+    UINT32          adv_int_max;
+    UINT16           adv_type;
     tBTM_BLE_ADV_CHNL_MAP channel_map;
     tBTM_BLE_AFP    adv_filter_policy;
     tBTM_BLE_ADV_TX_POWER tx_power;
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    UINT8           pri_phy;
+    UINT8           sec_adv_max_skip;
+    UINT8           sec_adv_phy;
+    UINT8           adv_sid;
+    UINT8           scan_req_notf_enb;
+    UINT16          duration;
+    UINT8           max_ext_adv_evts;
+    UINT8           frag_pref;
+#endif
 }tBTM_BLE_ADV_PARAMS;
 
 typedef struct
@@ -511,6 +561,24 @@ typedef struct
     tBTM_BLE_MULTI_ADV_CBACK    *p_cback;
     void                        *p_ref;
     UINT8                       index;
+    UINT16                      len;
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    UINT16                      duration;
+    tBTM_BLE_EXT_EVT            evt_prop;
+
+    //for chained ext advs
+    UINT32                      adv_int_min;
+    UINT32                      adv_int_max;
+    UINT8                       channel_map;
+    UINT8                       adv_filter_policy;
+    UINT8                       tx_power;
+    UINT8                       pri_phy;
+    UINT8                       sec_adv_max_skip;
+    UINT8                       sec_adv_phy;
+    UINT8                       adv_sid;
+    UINT8                       scan_req_notf_enb;
+    UINT8                       own_addr_type;
+#endif
 }tBTM_BLE_MULTI_ADV_INST;
 
 typedef struct
@@ -526,6 +594,15 @@ typedef struct
     tBTM_BLE_MULTI_ADV_OPQ  op_q;
 }tBTM_BLE_MULTI_ADV_CB;
 
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+typedef struct
+{
+    UINT8     *set_ids;
+    UINT16    *durations;
+    UINT8     *max_adv_events;
+}tBTM_BLE_EXT_ADV_ENABLE_CB;
+#endif
+
 typedef UINT8 tGATT_IF;
 
 typedef void (tBTM_BLE_SCAN_THRESHOLD_CBACK)(tBTM_BLE_REF_VALUE ref_value);
@@ -912,7 +989,7 @@ extern "C" {
 ** Returns          TRUE if added OK, else FALSE
 **
 *******************************************************************************/
-extern BOOLEAN BTM_SecAddBleDevice (BD_ADDR bd_addr, BD_NAME bd_name,
+extern BOOLEAN BTM_SecAddBleDevice (const BD_ADDR bd_addr, BD_NAME bd_name,
                                            tBT_DEVICE_TYPE dev_type, tBLE_ADDR_TYPE addr_type);
 
 /*******************************************************************************
@@ -1006,8 +1083,9 @@ extern void BTM_BleObtainVendorCapabilities(tBTM_BLE_VSC_CB *p_cmn_vsc_cb);
 ** Returns          void
 **
 *******************************************************************************/
-extern void BTM_BleSetScanParams(tGATT_IF client_if, UINT32 scan_interval,
-                                 UINT32 scan_window, tBLE_SCAN_MODE scan_type,
+extern void BTM_BleSetScanParams(tGATT_IF client_if, UINT8 scan_phys, UINT32 scan_interval,
+                                 UINT32 scan_window, UINT16 scan_interval_coded,
+                                 UINT16 scan_window_coded, tBLE_SCAN_MODE scan_type,
                                  tBLE_SCAN_PARAM_SETUP_CBACK scan_setup_status_cback);
 
 /*******************************************************************************
@@ -1022,6 +1100,19 @@ extern void BTM_BleSetScanParams(tGATT_IF client_if, UINT32 scan_interval,
 **
 *******************************************************************************/
 extern void BTM_BleGetVendorCapabilities(tBTM_BLE_VSC_CB *p_cmn_vsc_cb);
+
+/*******************************************************************************
+**
+** Function         BTM_BleGetAdvExtCapabilities
+**
+** Description      This function reads local LE features
+**
+** Parameters       p_cmn_vsc_cb : Locala LE capability structure
+**
+** Returns          void
+**
+*******************************************************************************/
+extern void BTM_BleGetAdvExtCapabilities(tBTM_BLE_ADV_EXT_CB *p_ble_adv_ext_cb);
 /*******************************************************************************
 **
 ** Function         BTM_BleSetStorageConfig
@@ -1136,7 +1227,7 @@ extern tBTM_STATUS BTM_BleWriteScanRsp(tBTM_BLE_AD_MASK data_mask,
 ** Returns          void
 **
 *******************************************************************************/
-extern tBTM_STATUS BTM_BleObserve(BOOLEAN start, UINT8 duration,
+extern tBTM_STATUS BTM_BleObserve(BOOLEAN start, UINT16 duration, UINT16 period,
                                   tBTM_INQ_RESULTS_CB *p_results_cb, tBTM_CMPL_CB *p_cmpl_cb);
 
 
@@ -1236,6 +1327,22 @@ extern void BTM_BleConfirmReply (BD_ADDR bd_addr, UINT8 res);
 *******************************************************************************/
 extern void BTM_BleOobDataReply(BD_ADDR bd_addr, UINT8 res, UINT8 len, UINT8 *p_data);
 
+/*******************************************************************************
+**
+** Function         BTM_BleSecureConnectionOobDataReply
+**
+** Description      This function is called to provide the OOB data for
+**                  SMP in response to BTM_LE_OOB_REQ_EVT when secure connection
+**                  data is available
+**
+** Parameters:      bd_addr     - Address of the peer device
+**                  p_c         - pointer to Confirmation
+**                  p_r         - pointer to Randomizer.
+**
+*******************************************************************************/
+extern void BTM_BleSecureConnectionOobDataReply(BD_ADDR bd_addr,
+                                                uint8_t *p_c, uint8_t *p_r);
+
 
 /*******************************************************************************
 **
@@ -1418,6 +1525,32 @@ extern  void BTM_BleSetConnScanParams (UINT32 scan_interval, UINT32 scan_window)
 *******************************************************************************/
 extern void BTM_BleReadControllerFeatures(tBTM_BLE_CTRL_FEATURES_CBACK  *p_vsc_cback);
 
+/******************************************************************************
+**
+** Function         BTM_BleReadExtAdvControllerFeatures
+**
+** Description      Reads BLE specific controller features
+**
+** Parameters:      tBTM_BLE_CTRL_FEATURES_CBACK : Callback to notify when features are read
+**
+** Returns          void
+**
+*******************************************************************************/
+extern void BTM_BleReadExtAdvControllerFeatures(tBTM_BLE_CTRL_FEATURES_CBACK  *p_vsc_cback);
+
+/******************************************************************************
+**
+** Function         BTM_BleGetAvailableMAInstance
+**
+** Description      Gets Available Multi Adv instance
+**
+** Parameters:      void
+**
+** Returns          Multi advertisement instance id
+**
+*******************************************************************************/
+extern UINT8 BTM_BleGetAvailableMAInstance(void);
+
 /*******************************************************************************
 **
 ** Function         BTM_CheckAdvData
@@ -1431,7 +1564,7 @@ extern void BTM_BleReadControllerFeatures(tBTM_BLE_CTRL_FEATURES_CBACK  *p_vsc_c
 ** Returns          pointer of ADV data
 **
 *******************************************************************************/
-extern  UINT8 *BTM_CheckAdvData( UINT8 *p_adv, UINT8 type, UINT8 *p_length);
+extern  UINT8 *BTM_CheckAdvData( UINT8 *p_adv, UINT8 type, UINT8 *p_length, UINT16 adv_data_len);
 
 /*******************************************************************************
 **
@@ -1621,6 +1754,21 @@ extern void BTM_BleUpdateAdvFilterPolicy(tBTM_BLE_AFP adv_policy);
 *******************************************************************************/
 void BTM_BleReceiverTest(UINT8 rx_freq, tBTM_CMPL_CB *p_cmd_cmpl_cback);
 
+/*******************************************************************************
+**
+** Function         BTM_BleEnhReceiverTest
+**
+** Description      This function is called to start the LE Enhanced Receiver
+**                  test
+**
+** Parameter        rx_freq - Frequency Range
+**                  phy - Phy to be used
+**                  mod_index - Modulation index
+**                  p_cmd_cmpl_cback - Command Complete callback
+**
+*******************************************************************************/
+void BTM_BleEnhReceiverTest(UINT8 rx_freq, UINT8 phy, UINT8 mod_index,
+                              tBTM_CMPL_CB *p_cmd_cmpl_cback);
 
 /*******************************************************************************
 **
@@ -1639,6 +1787,23 @@ void BTM_BleTransmitterTest(UINT8 tx_freq, UINT8 test_data_len,
 
 /*******************************************************************************
 **
+** Function         BTM_BleEnhTransmitterTest
+**
+** Description      This function is called to start the LE Enhanced Transmitter test
+**
+** Parameter        tx_freq - Frequency Range
+**                  test_data_len - Length in bytes of payload data in each packet
+**                  packet_payload - Pattern to use in the payload
+**                  phy - Phy to be used
+**                  p_cmd_cmpl_cback - Command Complete callback
+**
+*******************************************************************************/
+void BTM_BleEnhTransmitterTest(UINT8 tx_freq, UINT8 test_data_len,
+                                 UINT8 packet_payload, UINT8 phy,
+                                 tBTM_CMPL_CB *p_cmd_cmpl_cback);
+
+/*******************************************************************************
+**
 ** Function         BTM_BleTestEnd
 **
 ** Description      This function is called to stop the in-progress TX or RX test
@@ -1764,7 +1929,7 @@ extern tBTM_STATUS BTM_BleUpdateAdvInstParam (UINT8 inst_id, tBTM_BLE_ADV_PARAMS
 **
 *******************************************************************************/
 extern tBTM_STATUS BTM_BleCfgAdvInstData (UINT8 inst_id, BOOLEAN is_scan_rsp,
-                                    tBTM_BLE_AD_MASK data_mask,
+                                    tBTM_BLE_AD_MASK data_mask, UINT8 frag_pref,
                                     tBTM_BLE_ADV_DATA *p_data);
 
 /*******************************************************************************
@@ -1874,7 +2039,55 @@ extern tBTM_STATUS BTM_SetBleDataLength(BD_ADDR bd_addr, UINT16 tx_pdu_length);
 **
 *******************************************************************************/
 extern BOOLEAN BTM_GetRemoteDeviceName(BD_ADDR bda, BD_NAME bdname);
+/*******************************************************************************
+**
+** Function         BTM_SetBlePhy
+**
+** Description      This function is called to set BLE Tx and Rx Phy
+**
+** Returns          BTM_SUCCESS if success; otherwise failed.
+**
+*******************************************************************************/
+extern tBTM_STATUS BTM_SetBlePhy(BD_ADDR bd_addr, UINT8 all_phy, UINT8 tx_phy,
+                                 UINT8 rx_phy, UINT16 phy_options);
 
+/*******************************************************************************
+**
+** Function         BTM_SetDefaultBlePhy
+**
+** Description      This function is to set default BLE tx and rx PHY
+**
+** Returns          BTM_SUCCESS if success; otherwise failed.
+**
+*******************************************************************************/
+tBTM_STATUS BTM_SetDefaultBlePhy(UINT8 all_phy, UINT8 tx_phy, UINT8 rx_phy);
+
+
+/*******************************************************************************
+**
+** Function         BTM_BleWriteExtendedAdvData
+**
+** Description      This function configure a Multi-ADV instance with the specified
+**                  adv data or scan response data.
+**
+** Parameters       inst_id: adv instance ID
+**                  is_scan_rsp: is this scan response. if no, set as adv data.
+**                  data_mask: adv data mask.
+**                  p_data: pointer to the adv data structure.
+**                  operation:
+**                  0x00: Intermediate fragment
+**                  0x01: first fragment
+**                  0x02: Last fragment
+**                  0x03: complete data, ctrlr fragmentation permitted
+**                  0x04: complete data, ctrlr fragmentation not permitted
+**
+** Returns          status
+**
+*******************************************************************************/
+tBTM_STATUS BTM_BleWriteExtendedAdvData (UINT8 inst_id, BOOLEAN is_scan_rsp,
+                                    tBTM_BLE_AD_MASK data_mask,
+                                    UINT8 operation, UINT8 frag_pref,
+                                    tBTM_BLE_ADV_DATA *p_data);
 #ifdef __cplusplus
 }
 #endif
diff --git a/stack/include/gap_api.h b/stack/include/gap_api.h
index e1be352..394fbd3 100644
--- a/stack/include/gap_api.h
+++ b/stack/include/gap_api.h
@@ -56,6 +56,7 @@
 #define GAP_EVT_CONN_CONGESTED      0x0103
 #define GAP_EVT_CONN_UNCONGESTED    0x0104
 #define GAP_EVT_TX_EMPTY            0x0105
+#define GAP_EVT_TX_DONE             0x0106
 
 /* Values for 'chan_mode_mask' field */
 /* GAP_ConnOpen() - optional channels to negotiate */
diff --git a/stack/include/gatt_api.h b/stack/include/gatt_api.h
index a042bb9..182b5ba 100644
--- a/stack/include/gatt_api.h
+++ b/stack/include/gatt_api.h
@@ -1070,14 +1070,18 @@ extern  void GATT_StartIf (tGATT_IF gatt_if);
 **
 ** Parameters       gatt_if: applicaiton interface
 **                  bd_addr: peer device address.
-**                  is_direct: is a direct conenection or a background auto connection
+**                  is_direct: is a direct connection or a background auto connection
 **                  transport : Physical transport for GATT connection (BR/EDR or LE)
+**                  opportunistic: will not keep device connected if other apps
+**                      disconnect, will not update connected apps counter, when
+**                      disconnected won't cause physical disconnection.
 **
 ** Returns          TRUE if connection started; FALSE if connection start failure.
 **
 *******************************************************************************/
 extern BOOLEAN GATT_Connect (tGATT_IF gatt_if, BD_ADDR bd_addr,
-                             BOOLEAN is_direct, tBT_TRANSPORT transport);
+                             BOOLEAN is_direct, tBT_TRANSPORT transport,
+                             BOOLEAN opportunistic);
 
 
 /*******************************************************************************
diff --git a/stack/include/hcidefs.h b/stack/include/hcidefs.h
index ad98867..59771e8 100644
--- a/stack/include/hcidefs.h
+++ b/stack/include/hcidefs.h
@@ -27,6 +27,7 @@
 #define HCI_PROTO_VERSION_4_0 0x06      /* Version for BT spec 4.0          */
 #define HCI_PROTO_VERSION_4_1 0x07      /* Version for BT spec 4.1          */
 #define HCI_PROTO_VERSION_4_2 0x08      /* Version for BT spec 4.2          */
+#define HCI_PROTO_VERSION_5_0 0x09      /* Version for BT spec 5.0          */
 
 /*
 **  Definitions for HCI groups
@@ -312,6 +313,7 @@
 #define HCI_BLE_WRITE_ADV_ENABLE        (0x000A | HCI_GRP_BLE_CMDS)
 #define HCI_BLE_WRITE_SCAN_PARAMS       (0x000B | HCI_GRP_BLE_CMDS)
 #define HCI_BLE_WRITE_SCAN_ENABLE       (0x000C | HCI_GRP_BLE_CMDS)
+
 #define HCI_BLE_CREATE_LL_CONN          (0x000D | HCI_GRP_BLE_CMDS)
 #define HCI_BLE_CREATE_CONN_CANCEL      (0x000E | HCI_GRP_BLE_CMDS)
 #define HCI_BLE_READ_WHITE_LIST_SIZE    (0x000F | HCI_GRP_BLE_CMDS)
@@ -348,6 +350,30 @@
 #define HCI_BLE_READ_RESOLVABLE_ADDR_LOCAL  (0x002C | HCI_GRP_BLE_CMDS)
 #define HCI_BLE_SET_ADDR_RESOLUTION_ENABLE  (0x002D | HCI_GRP_BLE_CMDS)
 #define HCI_BLE_SET_RAND_PRIV_ADDR_TIMOUT   (0x002E | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_SET_PRIVACY_MODE            (0x004E | HCI_GRP_BLE_CMDS)
+
+#define HCI_BLE_SET_DEFAULT_PHY_RATE        (0x0031 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_SET_PHY_RATE                (0x0032 | HCI_GRP_BLE_CMDS)
+
+#define HCI_BLE_ENH_RECEIVER_TEST           (0x0033 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_ENH_TRANSMITTER_TEST        (0x0034 | HCI_GRP_BLE_CMDS)
+
+/* BLE ADV EXTENSION COMMANDS */
+#define HCI_BLE_WRITE_EXTENDED_ADV_RPA      (0x0035 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_WRITE_EXTENDED_ADV_PARAMS   (0x0036 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_WRITE_EXTENDED_ADV_DATA     (0x0037 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_WRITE_EXTENDED_SCAN_RSP_DATA (0x0038 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_WRITE_EXTENDED_ADV_ENABLE   (0x0039 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_READ_NUM_ADV_SETS           (0x003B | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_READ_MAX_ADV_LENGTH         (0x003A | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_WRITE_EXT_SCAN_PARAMS       (0x0041 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_WRITE_EXT_SCAN_ENABLE       (0x0042 | HCI_GRP_BLE_CMDS)
+#define HCI_BLE_EXT_CREATE_LL_CONN          (0x0043 | HCI_GRP_BLE_CMDS)
+
+#define BTM_BLE_EXT_ADV_INT_FRAG            0x00
+#define BTM_BLE_EXT_ADV_FIRST_FRAG          0x01
+#define BTM_BLE_EXT_ADV_LAST_FRAG           0x02
+#define BTM_BLE_EXT_ADV_COMPLETE           0x03
 
 /* LE Get Vendor Capabilities Command OCF */
 #define HCI_BLE_VENDOR_CAP_OCF    (0x0153 | HCI_GRP_VENDOR_SPECIFIC)
@@ -713,6 +739,14 @@
 #define HCI_BLE_DATA_LENGTH_CHANGE_EVT      0x07
 #define HCI_BLE_ENHANCED_CONN_COMPLETE_EVT  0x0a
 #define HCI_BLE_DIRECT_ADV_EVT              0x0b
+#define HCI_BLE_PHY_UPDATE_EVT              0x0c
+#if (defined BLE_EXTENDED_ADV_SUPPORT && BLE_EXTENDED_ADV_SUPPORT == TRUE)
+#define HCI_BLE_EXT_ADV_PKT_RPT_EVT         0x0d
+#define HCI_BLE_SCAN_TIMEOUT_EVT            0x11
+#define HCI_BLE_EXT_ADV_TERMINATED_EVT      0x12
+#endif
+
+
 
 /* Definitions for LE Channel Map */
 #define HCI_BLE_CHNL_MAP_SIZE               5
@@ -1450,7 +1484,8 @@ typedef struct
 #define HCI_EXT_FEATURES_PAGE_0     0       /* Extended Feature Page 0 (regular features) */
 #define HCI_EXT_FEATURES_PAGE_1     1       /* Extended Feature Page 1 */
 #define HCI_EXT_FEATURES_PAGE_2     2       /* Extended Feature Page 2 */
-#define HCI_EXT_FEATURES_PAGE_MAX   HCI_EXT_FEATURES_PAGE_2
+#define HCI_EXT_FEATURES_PAGE_3     3       /* Extended Feature Page 3 */
+#define HCI_EXT_FEATURES_PAGE_MAX   HCI_EXT_FEATURES_PAGE_3
 
 #define HCI_FEATURE_BYTES_PER_PAGE      8
 
@@ -1791,6 +1826,17 @@ typedef struct
 #define HCI_LE_FEATURE_DATA_LEN_EXT_OFF        0
 #define HCI_LE_DATA_LEN_EXT_SUPPORTED(x) ((x)[HCI_LE_FEATURE_DATA_LEN_EXT_OFF] & HCI_LE_FEATURE_DATA_LEN_EXT_MASK)
 
+/* 2Mbps support */
+#define HCI_LE_FEATURE_TWO_MBPS_MASK           0x01
+#define HCI_LE_FEATURE_TWO_MBPS                1
+#define HCI_LE_TWO_MBPS_SUPPORTED(x) ((x)[HCI_LE_FEATURE_TWO_MBPS] & HCI_LE_FEATURE_TWO_MBPS_MASK)
+
+/* Advertisement Length Extensions  */
+#define HCI_LE_FEATURE_ADV_EXT_MASK            0x10
+#define HCI_LE_FEATURE_ADV_EXT_OFF             1
+#define HCI_LE_ADV_EXTENSION_SUPPORTED(x) ((x)[HCI_LE_FEATURE_ADV_EXT_OFF] & HCI_LE_FEATURE_ADV_EXT_MASK)
+
+
 /*
 **   Local Supported Commands encoding
 */
@@ -2613,5 +2659,11 @@ typedef struct
 #define HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_NEG_RPY_OFF           33
 #define HCI_LE_RC_CONN_PARAM_UPD_NEG_RPY_SUPPORTED(x)      ((x)[HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_NEG_RPY_OFF] & HCI_SUPP_COMMANDS_RLE_RC_CONN_PARAM_UPD_NEG_RPY_MASK)
 
+/* support for LE privacy mode command (byte 39 bit 2)*/
+#define HCI_SUPP_COMMANDS_LE_SET_PRIVACY_MODE_MASK          0x04
+#define HCI_SUPP_COMMANDS_LE_SET_PRIVACY_MODE_OFF           39
+#define HCI_LE_SET_PRIVACY_MODE_SUPPORTED(x)      ((x)[HCI_SUPP_COMMANDS_LE_SET_PRIVACY_MODE_OFF] & HCI_SUPP_COMMANDS_LE_SET_PRIVACY_MODE_MASK)
+
+
 #endif
 
diff --git a/stack/include/hcimsgs.h b/stack/include/hcimsgs.h
index e77c80c..26d1f5f 100644
--- a/stack/include/hcimsgs.h
+++ b/stack/include/hcimsgs.h
@@ -521,6 +521,8 @@ extern BOOLEAN btsnd_hcic_change_name(BD_NAME name);
 
 #define HCIC_WRITE_PARAM3_PARAM_OFF      0
 
+#define HCIC_PARAM_SIZE_WRITE_PARAM4     4
+
 #define HCIC_PARAM_SIZE_SET_AFH_CHANNELS    10
 
 extern BOOLEAN btsnd_hcic_write_pin_type(UINT8 type);                   /* Write PIN Type */
@@ -656,8 +658,13 @@ extern void btsnd_hcic_vendor_spec_cmd (void *buffer, UINT16 opcode,
 #define HCIC_PARAM_SIZE_WRITE_ADV_ENABLE        1
 #define HCIC_PARAM_SIZE_BLE_WRITE_SCAN_PARAM    7
 #define HCIC_PARAM_SIZE_BLE_WRITE_SCAN_ENABLE   2
+
+#define HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_PARAM    8
+#define HCIC_PARAM_SIZE_BLE_WRITE_EXT_SCAN_ENABLE   6
+
 #define HCIC_PARAM_SIZE_BLE_CREATE_LL_CONN      25
 #define HCIC_PARAM_SIZE_BLE_CREATE_CONN_CANCEL  0
+#define HCIC_PARAM_SIZE_BLE_EXT_CREATE_LL_CONN  26
 #define HCIC_PARAM_SIZE_CLEAR_WHITE_LIST        0
 #define HCIC_PARAM_SIZE_ADD_WHITE_LIST          7
 #define HCIC_PARAM_SIZE_REMOVE_WHITE_LIST       7
@@ -679,6 +686,7 @@ extern void btsnd_hcic_vendor_spec_cmd (void *buffer, UINT16 opcode,
 
 #define HCIC_PARAM_SIZE_BLE_ADD_DEV_RESOLVING_LIST      (7 + HCIC_BLE_IRK_SIZE * 2)
 #define HCIC_PARAM_SIZE_BLE_RM_DEV_RESOLVING_LIST       7
+#define HCIC_PARAM_SIZE_BLE_SET_PRIVACY_MODE            8
 #define HCIC_PARAM_SIZE_BLE_CLEAR_RESOLVING_LIST        0
 #define HCIC_PARAM_SIZE_BLE_READ_RESOLVING_LIST_SIZE    0
 #define HCIC_PARAM_SIZE_BLE_READ_RESOLVABLE_ADDR_PEER   7
@@ -687,6 +695,18 @@ extern void btsnd_hcic_vendor_spec_cmd (void *buffer, UINT16 opcode,
 #define HCIC_PARAM_SIZE_BLE_SET_RAND_PRIV_ADDR_TIMOUT   2
 #define HCIC_PARAM_SIZE_BLE_SET_DATA_LENGTH             6
 #define HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_SCAN_PARAM  11
+#define HCIC_PARAM_SIZE_BLE_WRITE_DEFAULT_PHY          3
+#define HCIC_PARAM_SIZE_BLE_WRITE_PHY                  7
+
+#define HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_ADV_PARAMS  25
+#define HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_ADV_DATA    251
+#define HCIC_PARAM_SIZE_BLE_WRITE_EXTENDED_SCAN_RSP    251
+#define HCIC_PARAM_SIZE_WRITE_EXTENDED_ADV_ENABLE      2
+#define HCIC_PARAM_SIZE_WRITE_EXTENDED_ADV_RPA         7
+
+#define HCIC_SCAN_PHY_LE_1M         1
+#define HCIC_SCAN_PHY_LE_CODED      4
+#define HCIC_SCAN_PHY_LE_1M_CODED   5
 
 /* ULP HCI command */
 extern BOOLEAN btsnd_hcic_ble_set_evt_mask (BT_EVENT_MASK event_mask);
@@ -762,8 +782,14 @@ extern BOOLEAN btsnd_hcic_ble_read_host_supported (void);
 
 extern BOOLEAN btsnd_hcic_ble_receiver_test(UINT8 rx_freq);
 
+extern BOOLEAN btsnd_hcic_ble_enh_receiver_test(UINT8 rx_freq, UINT8 phy, UINT8 mod_index);
+
 extern BOOLEAN btsnd_hcic_ble_transmitter_test(UINT8 tx_freq, UINT8 test_data_len,
                                                UINT8 payload);
+
+extern BOOLEAN btsnd_hcic_ble_enh_transmitter_test(UINT8 tx_freq, UINT8 test_data_len,
+                                               UINT8 payload, UINT8 phy);
+
 extern BOOLEAN btsnd_hcic_ble_test_end(void);
 
 #if (defined BLE_LLT_INCLUDED) && (BLE_LLT_INCLUDED == TRUE)
@@ -790,6 +816,8 @@ extern BOOLEAN btsnd_hcic_ble_add_device_resolving_list (UINT8 addr_type_peer,
 extern BOOLEAN btsnd_hcic_ble_rm_device_resolving_list (UINT8 addr_type_peer,
                                                                 BD_ADDR bda_peer);
 
+extern BOOLEAN btsnd_hcic_ble_set_privacy_mode (UINT8 addr_type_peer, BD_ADDR bda_peer, UINT8 privacy_type);
+
 extern BOOLEAN btsnd_hcic_ble_clear_resolving_list (void);
 
 extern BOOLEAN btsnd_hcic_ble_read_resolvable_addr_peer (UINT8 addr_type_peer,
@@ -802,6 +830,54 @@ extern BOOLEAN btsnd_hcic_ble_set_addr_resolution_enable (UINT8 addr_resolution_
 
 extern BOOLEAN btsnd_hcic_ble_set_rand_priv_addr_timeout (UINT16 rpa_timout);
 
+extern BOOLEAN btsnd_hcic_ble_set_default_data_rate(UINT8 all_phy, UINT8 tx_phy, UINT8 rx_phy);
+
+extern BOOLEAN btsnd_hcic_ble_set_data_rate(UINT16 handle, UINT8 all_phy, UINT8 tx_phy,
+                                            UINT8 rx_phy, UINT16 phy_options);
+
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+extern BOOLEAN btsnd_hcic_ble_set_extended_adv_params (UINT8 set_id, UINT16 event_properties,
+                                              UINT32 adv_int_min, UINT32 adv_int_max,
+                                              UINT8 channel_map, UINT8 addr_type_own,
+                                              UINT8 addr_type_dir, BD_ADDR direct_bda,
+                                              UINT8 adv_filter_policy, UINT8 adv_tx_power,
+                                              UINT8 primary_adv_phy, UINT8 secondary_max_skip,
+                                              UINT8 secondary_adv_phy, UINT8 advertising_sid,
+                                              UINT8 scan_req_not_enb);
+
+extern BOOLEAN btsnd_hcic_ble_set_extended_adv_data (UINT8 set_id, UINT8 operation, UINT8 fragment_pref,
+                                                     UINT8 data_len, UINT8 *p_data);
+
+extern BOOLEAN btsnd_hcic_ble_set_extended_scan_rsp_data (UINT8 set_id, UINT8 operation, UINT8 fragement_pref,
+                                                          UINT8 data_len, UINT8 *p_scan_rsp);
+
+extern BOOLEAN btsnd_hcic_ble_set_extended_adv_enable (UINT8 adv_enable, UINT8 num_sets, UINT8* handles,
+                                            UINT16* durations, UINT8* max_adv_events);
+
+extern BOOLEAN btsnd_hcic_ble_read_num_adv_sets (void);
+
+extern BOOLEAN btsnd_hcic_ble_read_extended_max_adv_len (void);
+
+extern BOOLEAN btsnd_hcic_ble_write_extended_rpa (UINT8 set_id, BD_ADDR rpa);
+
+extern BOOLEAN btsnd_hcic_ble_set_extended_scan_params (UINT8 scan_phys,
+                                                        UINT8 scan_type,
+                                                        UINT16 scan_int, UINT16 scan_win,
+                                                        UINT16 scan_int_coded, UINT16 scan_win_coded,
+                                                        UINT8 addr_type_own, UINT8 scan_filter_policy);
+
+extern BOOLEAN btsnd_hcic_ble_set_extended_scan_enable (UINT8 scan_enable, UINT8 duplicate,
+                                                        UINT16 duraton, UINT16 period);
+
+extern BOOLEAN btsnd_hcic_ble_ext_create_ll_conn (UINT8 ini_phy, UINT16 scan_int, UINT16 scan_win,
+                                                  UINT8 init_filter_policy,
+                                                  UINT8 addr_type_peer, BD_ADDR bda_peer,
+                                                  UINT8 addr_type_own,
+                                                  UINT16 conn_int_min, UINT16 conn_int_max,
+                                                  UINT16 conn_latency, UINT16 conn_timeout,
+                                                  UINT16 min_ce_len, UINT16 max_ce_len);
+#endif
+
 #endif /* BLE_INCLUDED */
 
 extern BOOLEAN btsnd_hcic_read_authenticated_payload_tout(UINT16 handle);
diff --git a/stack/include/l2c_api.h b/stack/include/l2c_api.h
index 82aa211..518af3a 100644
--- a/stack/include/l2c_api.h
+++ b/stack/include/l2c_api.h
@@ -178,6 +178,7 @@ typedef struct
     UINT16  credits;
 } tL2CAP_LE_CFG_INFO;
 
+
 /* L2CAP channel configured field bitmap */
 #define L2CAP_CH_CFG_MASK_MTU           0x0001
 #define L2CAP_CH_CFG_MASK_QOS           0x0002
@@ -894,6 +895,21 @@ extern BOOLEAN L2CA_GetBDAddrbyHandle (UINT16 handle, BD_ADDR bd_addr);
 *******************************************************************************/
 extern UINT8 L2CA_GetChnlFcrMode (UINT16 lcid);
 
+#if (defined(LE_L2CAP_CFC_INCLUDED) && (LE_L2CAP_CFC_INCLUDED == TRUE))
+/*******************************************************************************
+**
+**  Function         L2CA_LE_SetFlowControlCredits
+**
+**  Description      Set flow control credits
+**
+**  Parameters:      Local CID,Credits to set
+**
+**  Return value:    TRUE if flow control set,FALSE otherwise
+**
+*******************************************************************************/
+
+extern BOOLEAN L2CA_LE_SetFlowControlCredits (UINT16 cid, UINT16 credits);
+#endif
 
 /*******************************************************************************
 **
diff --git a/stack/include/port_api.h b/stack/include/port_api.h
index f24887b..66c6202 100644
--- a/stack/include/port_api.h
+++ b/stack/include/port_api.h
@@ -301,6 +301,19 @@ extern int PORT_SetDataCOCallback (UINT16 port_handle, tPORT_DATA_CO_CALLBACK *p
 *******************************************************************************/
 extern int PORT_SetEventMask (UINT16 port_handle, UINT32 mask);
 
+/*******************************************************************************
+**
+** Function         PORT_GetRemoteMtu
+**
+** Description      This function feteches remote mtu from port
+**
+** Parameters:      handle     - Handle returned in the RFCOMM_CreateConnection
+**
+** Returns:         UINT16     - Maximum rfcomm frame size that can be
+**                               transmitted to the peer
+**
+*******************************************************************************/
+extern UINT16 PORT_GetRemoteMtu (UINT16 handle);
 
 /*******************************************************************************
 **
diff --git a/stack/include/smp_api.h b/stack/include/smp_api.h
index 62ef1db..6d77d7f 100644
--- a/stack/include/smp_api.h
+++ b/stack/include/smp_api.h
@@ -85,23 +85,23 @@ typedef UINT8   tSMP_EVT;
 #define SMP_MAX_FAIL_RSN_PER_SPEC   SMP_XTRANS_DERIVE_NOT_ALLOW
 
 /* self defined error code */
-#define SMP_PAIR_INTERNAL_ERR       (SMP_MAX_FAIL_RSN_PER_SPEC + 0x01) /* 0x0E */
+#define SMP_PAIR_INTERNAL_ERR       (SMP_MAX_FAIL_RSN_PER_SPEC + 0x01) /* 0x0F */
 
-/* 0x0F unknown IO capability, unable to decide association model */
-#define SMP_UNKNOWN_IO_CAP          (SMP_MAX_FAIL_RSN_PER_SPEC + 0x02) /* 0x0F */
+/* Unknown IO capability, unable to decide association model */
+#define SMP_UNKNOWN_IO_CAP          (SMP_MAX_FAIL_RSN_PER_SPEC + 0x02) /* 0x10 */
 
-#define SMP_INIT_FAIL               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x03) /* 0x10 */
-#define SMP_CONFIRM_FAIL            (SMP_MAX_FAIL_RSN_PER_SPEC + 0x04) /* 0x11 */
-#define SMP_BUSY                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x05) /* 0x12 */
-#define SMP_ENC_FAIL                (SMP_MAX_FAIL_RSN_PER_SPEC + 0x06) /* 0x13 */
-#define SMP_STARTED                 (SMP_MAX_FAIL_RSN_PER_SPEC + 0x07) /* 0x14 */
-#define SMP_RSP_TIMEOUT             (SMP_MAX_FAIL_RSN_PER_SPEC + 0x08) /* 0x15 */
-#define SMP_DIV_NOT_AVAIL           (SMP_MAX_FAIL_RSN_PER_SPEC + 0x09) /* 0x16 */
+#define SMP_INIT_FAIL               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x03) /* 0x11 */
+#define SMP_CONFIRM_FAIL            (SMP_MAX_FAIL_RSN_PER_SPEC + 0x04) /* 0x12 */
+#define SMP_BUSY                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x05) /* 0x13 */
+#define SMP_ENC_FAIL                (SMP_MAX_FAIL_RSN_PER_SPEC + 0x06) /* 0x14 */
+#define SMP_STARTED                 (SMP_MAX_FAIL_RSN_PER_SPEC + 0x07) /* 0x15 */
+#define SMP_RSP_TIMEOUT             (SMP_MAX_FAIL_RSN_PER_SPEC + 0x08) /* 0x16 */
+#define SMP_DIV_NOT_AVAIL           (SMP_MAX_FAIL_RSN_PER_SPEC + 0x09) /* 0x17 */
 
-/* 0x17 unspecified failed reason */
-#define SMP_FAIL                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0A) /* 0x17 */
+/* Unspecified failure reason */
+#define SMP_FAIL                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0A) /* 0x18 */
 
-#define SMP_CONN_TOUT               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0B)
+#define SMP_CONN_TOUT               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0B) /* 0x19 */
 #define SMP_SUCCESS                 0
 
 typedef UINT8 tSMP_STATUS;
@@ -146,8 +146,9 @@ typedef UINT8   tSMP_OOB_DATA_TYPE;
 #define SMP_AUTH_YN_BIT         (1 << 2)
 #define SMP_SC_SUPPORT_BIT      (1 << 3)
 #define SMP_KP_SUPPORT_BIT      (1 << 4)
+#define SMP_H7_SUPPORT_BIT      (1 << 5)
 
-#define SMP_AUTH_MASK    (SMP_AUTH_GEN_BOND|SMP_AUTH_YN_BIT|SMP_SC_SUPPORT_BIT|SMP_KP_SUPPORT_BIT)
+#define SMP_AUTH_MASK    (SMP_AUTH_GEN_BOND|SMP_AUTH_YN_BIT|SMP_SC_SUPPORT_BIT|SMP_KP_SUPPORT_BIT|SMP_H7_SUPPORT_BIT)
 
 #define SMP_AUTH_BOND           SMP_AUTH_GEN_BOND
 
@@ -164,16 +165,16 @@ typedef UINT8   tSMP_OOB_DATA_TYPE;
 #define SMP_AUTH_GB_IOCAP       (SMP_AUTH_GEN_BOND | SMP_AUTH_YN_BIT)
 
 /* Secure Connections, no MITM, no Bonding */
-#define SMP_AUTH_SC_ENC_ONLY    (SMP_SC_SUPPORT_BIT)
+#define SMP_AUTH_SC_ENC_ONLY    (SMP_SC_SUPPORT_BIT | SMP_H7_SUPPORT_BIT)
 
 /* Secure Connections, no MITM, Bonding */
-#define SMP_AUTH_SC_GB          (SMP_SC_SUPPORT_BIT | SMP_AUTH_GEN_BOND)
+#define SMP_AUTH_SC_GB          (SMP_SC_SUPPORT_BIT | SMP_AUTH_GEN_BOND | SMP_H7_SUPPORT_BIT)
 
 /* Secure Connections, MITM, no Bonding */
-#define SMP_AUTH_SC_MITM_NB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_NO_BOND)
+#define SMP_AUTH_SC_MITM_NB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_NO_BOND | SMP_H7_SUPPORT_BIT)
 
 /* Secure Connections, MITM, Bonding */
-#define SMP_AUTH_SC_MITM_GB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_GEN_BOND)
+#define SMP_AUTH_SC_MITM_GB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_GEN_BOND | SMP_H7_SUPPORT_BIT)
 
  /* All AuthReq RFU bits are set to 1 - NOTE: reserved bit in Bonding_Flags is not set */
 #define SMP_AUTH_ALL_RFU_SET    0xF8
diff --git a/stack/l2cap/l2c_ble.c b/stack/l2cap/l2c_ble.c
index 3315815..747e424 100644
--- a/stack/l2cap/l2c_ble.c
+++ b/stack/l2cap/l2c_ble.c
@@ -33,6 +33,7 @@
 #include "device/include/controller.h"
 #include "device/include/interop.h"
 #include "stack_config.h"
+#include "btif_debug_l2c.h"
 
 #if (BLE_INCLUDED == TRUE)
 
@@ -77,7 +78,7 @@ BOOLEAN L2CA_CancelBleConnectReq (BD_ADDR rem_bda)
         p_lcb = l2cu_find_lcb_by_bd_addr(rem_bda, BT_TRANSPORT_LE);
         /* Do not remove lcb if an LE link is already up as a peripheral */
         if (p_lcb != NULL &&
-            !(p_lcb->link_role == HCI_ROLE_SLAVE && btm_bda_to_acl(rem_bda, BT_TRANSPORT_LE)))
+            !(p_lcb->link_role == HCI_ROLE_SLAVE && btm_bda_to_acl(rem_bda, BT_TRANSPORT_LE) != NULL))
         {
             p_lcb->disc_reason = L2CAP_CONN_CANCEL;
             l2cu_release_lcb (p_lcb);
@@ -234,42 +235,6 @@ UINT16 L2CA_GetDisconnectReason (BD_ADDR remote_bda, tBT_TRANSPORT transport)
     return reason;
 }
 
-void l2cble_use_preferred_conn_params(BD_ADDR bda) {
-    tL2C_LCB *p_lcb = l2cu_find_lcb_by_bd_addr (bda, BT_TRANSPORT_LE);
-    tBTM_SEC_DEV_REC    *p_dev_rec = btm_find_or_alloc_dev (bda);
-
-    /* If there are any preferred connection parameters, set them now */
-    if ( (p_dev_rec->conn_params.min_conn_int     >= BTM_BLE_CONN_INT_MIN ) &&
-         (p_dev_rec->conn_params.min_conn_int     <= BTM_BLE_CONN_INT_MAX ) &&
-         (p_dev_rec->conn_params.max_conn_int     >= BTM_BLE_CONN_INT_MIN ) &&
-         (p_dev_rec->conn_params.max_conn_int     <= BTM_BLE_CONN_INT_MAX ) &&
-         (p_dev_rec->conn_params.slave_latency    <= BTM_BLE_CONN_LATENCY_MAX ) &&
-         (p_dev_rec->conn_params.supervision_tout >= BTM_BLE_CONN_SUP_TOUT_MIN) &&
-         (p_dev_rec->conn_params.supervision_tout <= BTM_BLE_CONN_SUP_TOUT_MAX) &&
-         ((p_lcb->min_interval < p_dev_rec->conn_params.min_conn_int &&
-          p_dev_rec->conn_params.min_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ||
-          (p_lcb->min_interval > p_dev_rec->conn_params.max_conn_int) ||
-          (p_lcb->latency > p_dev_rec->conn_params.slave_latency) ||
-          (p_lcb->timeout > p_dev_rec->conn_params.supervision_tout)))
-    {
-        L2CAP_TRACE_DEBUG ("%s: HANDLE=%d min_conn_int=%d max_conn_int=%d slave_latency=%d supervision_tout=%d", __func__,
-                            p_lcb->handle, p_dev_rec->conn_params.min_conn_int, p_dev_rec->conn_params.max_conn_int,
-                            p_dev_rec->conn_params.slave_latency, p_dev_rec->conn_params.supervision_tout);
-
-        p_lcb->min_interval = p_dev_rec->conn_params.min_conn_int;
-        p_lcb->max_interval = p_dev_rec->conn_params.max_conn_int;
-        p_lcb->timeout      = p_dev_rec->conn_params.supervision_tout;
-        p_lcb->latency      = p_dev_rec->conn_params.slave_latency;
-
-        btsnd_hcic_ble_upd_ll_conn_params (p_lcb->handle,
-                                           p_dev_rec->conn_params.min_conn_int,
-                                           p_dev_rec->conn_params.max_conn_int,
-                                           p_dev_rec->conn_params.slave_latency,
-                                           p_dev_rec->conn_params.supervision_tout,
-                                           0, 0);
-    }
-}
-
 /*******************************************************************************
 **
 ** Function l2cble_notify_le_connection
@@ -284,7 +249,7 @@ void l2cble_notify_le_connection (BD_ADDR bda)
     tL2C_LCB *p_lcb = l2cu_find_lcb_by_bd_addr (bda, BT_TRANSPORT_LE);
     tACL_CONN *p_acl = btm_bda_to_acl(bda, BT_TRANSPORT_LE) ;
     tL2C_CCB *p_ccb;
-    BD_NAME bdname;
+    /*BD_NAME bdname;*/
 
     if (p_lcb != NULL && p_acl != NULL && p_lcb->link_state != LST_CONNECTED)
     {
@@ -295,24 +260,21 @@ void l2cble_notify_le_connection (BD_ADDR bda)
         l2cu_process_fixed_chnl_resp (p_lcb);
     }
 
-    if (p_lcb == NULL) {
-        L2CAP_TRACE_ERROR("%s, link control block is null", __func__);
-        return;
-    }
-
-    /* For all channels, send the event through their FSMs */
-    for (p_ccb = p_lcb->ccb_queue.p_first_ccb; p_ccb; p_ccb = p_ccb->p_next_ccb)
-    {
-        if (p_ccb->chnl_state == CST_CLOSED)
-            l2c_csm_execute (p_ccb, L2CEVT_LP_CONNECT_CFM, NULL);
+    if (p_lcb != NULL) {
+        /* For all channels, send the event through their FSMs */
+        for (p_ccb = p_lcb->ccb_queue.p_first_ccb; p_ccb; p_ccb = p_ccb->p_next_ccb)
+        {
+            if (p_ccb->chnl_state == CST_CLOSED)
+                l2c_csm_execute (p_ccb, L2CEVT_LP_CONNECT_CFM, NULL);
+        }
     }
 
 
-    if (!BTM_GetRemoteDeviceName(bda, bdname) || !*bdname ||
+    /*if (!BTM_GetRemoteDeviceName(bda, bdname) || !*bdname ||
         (!interop_match_name(INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS, (const char*) bdname)))
     {
         l2cble_use_preferred_conn_params(bda);
-    }
+    }*/
 }
 
 /*******************************************************************************
@@ -581,6 +543,14 @@ static void l2cble_start_conn_update (tL2C_LCB *p_lcb)
             p_lcb->conn_update_mask |= L2C_BLE_NOT_DEFAULT_PARAM;
         }
     }
+
+    /* Record the BLE connection update request. */
+    if (p_lcb->conn_update_mask & L2C_BLE_UPDATE_PENDING) {
+      bt_bdaddr_t bd_addr;
+      bdcpy(bd_addr.address, p_lcb->remote_bd_addr);
+      btif_debug_ble_connection_update_request(bd_addr, min_conn_int, max_conn_int, slave_latency,
+          supervision_tout);
+    }
 }
 
 /*******************************************************************************
@@ -593,17 +563,16 @@ static void l2cble_start_conn_update (tL2C_LCB *p_lcb)
 ** Returns          void
 **
 *******************************************************************************/
-void l2cble_process_conn_update_evt (UINT16 handle, UINT8 status)
+void l2cble_process_conn_update_evt (UINT16 handle, UINT8 status,
+                  UINT16 interval, UINT16 latency, UINT16 timeout)
 {
-    tL2C_LCB *p_lcb;
-
-    L2CAP_TRACE_DEBUG("l2cble_process_conn_update_evt");
+    L2CAP_TRACE_DEBUG("%s", __func__);
 
     /* See if we have a link control block for the remote device */
-    p_lcb = l2cu_find_lcb_by_handle(handle);
+    tL2C_LCB *p_lcb = l2cu_find_lcb_by_handle(handle);
     if (!p_lcb)
     {
-        L2CAP_TRACE_WARNING("l2cble_process_conn_update_evt: Invalid handle: %d", handle);
+        L2CAP_TRACE_WARNING("%s: Invalid handle: %d", __func__, handle);
         return;
     }
 
@@ -611,13 +580,20 @@ void l2cble_process_conn_update_evt (UINT16 handle, UINT8 status)
 
     if (status != HCI_SUCCESS)
     {
-        L2CAP_TRACE_WARNING("l2cble_process_conn_update_evt: Error status: %d", status);
+        L2CAP_TRACE_WARNING("%s: Error status: %d", __func__, status);
     }
 
     l2cble_start_conn_update(p_lcb);
 
-    L2CAP_TRACE_DEBUG("l2cble_process_conn_update_evt: conn_update_mask=%d", p_lcb->conn_update_mask);
+    /* Record the BLE connection update response. */
+    bt_bdaddr_t bd_addr;
+    bdcpy(bd_addr.address, p_lcb->remote_bd_addr);
+    btif_debug_ble_connection_update_response(bd_addr, status, interval,
+        latency, timeout);
+
+    L2CAP_TRACE_DEBUG("%s: conn_update_mask=%d", __func__, p_lcb->conn_update_mask);
 }
+
 /*******************************************************************************
 **
 ** Function         l2cble_process_sig_cmd
@@ -676,6 +652,9 @@ void l2cble_process_sig_cmd (tL2C_LCB *p_lcb, UINT8 *p, UINT16 pkt_len)
                 if (min_interval < BTM_BLE_CONN_INT_MIN_LIMIT)
                     min_interval = BTM_BLE_CONN_INT_MIN_LIMIT;
 
+                if (max_interval < BTM_BLE_CONN_INT_MIN_LIMIT)
+                    max_interval = BTM_BLE_CONN_INT_MIN_LIMIT;
+
                 if (min_interval < BTM_BLE_CONN_INT_MIN || min_interval > BTM_BLE_CONN_INT_MAX ||
                     max_interval < BTM_BLE_CONN_INT_MIN || max_interval > BTM_BLE_CONN_INT_MAX ||
                     latency  > BTM_BLE_CONN_LATENCY_MAX ||
@@ -894,6 +873,7 @@ BOOLEAN l2cble_init_direct_conn (tL2C_LCB *p_lcb)
     UINT8 peer_addr_type = BLE_ADDR_PUBLIC;
     UINT8 own_addr_type = BLE_ADDR_PUBLIC;
 
+    L2CAP_TRACE_WARNING ("l2cble_init_direct_conn");
     /* There can be only one BLE connection request outstanding at a time */
     if (p_dev_rec == NULL)
     {
@@ -933,40 +913,68 @@ BOOLEAN l2cble_init_direct_conn (tL2C_LCB *p_lcb)
         return FALSE;
     }
 
-    if (!btsnd_hcic_ble_create_ll_conn (scan_int,/* UINT16 scan_int      */
-                                        scan_win, /* UINT16 scan_win      */
-                                        FALSE,                   /* UINT8 white_list     */
-                                        peer_addr_type,          /* UINT8 addr_type_peer */
-                                        peer_addr,               /* BD_ADDR bda_peer     */
-                                        own_addr_type,         /* UINT8 addr_type_own  */
-        (UINT16) ((p_dev_rec->conn_params.min_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ?
-        p_dev_rec->conn_params.min_conn_int : BTM_BLE_CONN_INT_MIN_DEF),  /* UINT16 conn_int_min  */
-        (UINT16) ((p_dev_rec->conn_params.max_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ?
-        p_dev_rec->conn_params.max_conn_int : BTM_BLE_CONN_INT_MAX_DEF),  /* UINT16 conn_int_max  */
-        (UINT16) ((p_dev_rec->conn_params.slave_latency != BTM_BLE_CONN_PARAM_UNDEF) ?
-        p_dev_rec->conn_params.slave_latency : BTM_BLE_CONN_SLAVE_LATENCY_DEF), /* UINT16 conn_latency  */
-        (UINT16) ((p_dev_rec->conn_params.supervision_tout != BTM_BLE_CONN_PARAM_UNDEF) ?
-        p_dev_rec->conn_params.supervision_tout : BTM_BLE_CONN_TIMEOUT_DEF), /* conn_timeout */
-                                        0,                       /* UINT16 min_len       */
-                                        0))                      /* UINT16 max_len       */
+#if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+    if (controller_get_interface()->supports_ble_extended_advertisements())
     {
-        l2cu_release_lcb (p_lcb);
-        L2CAP_TRACE_ERROR("initate direct connection fail, no resources");
-        return (FALSE);
+        L2CAP_TRACE_WARNING ("l2cble_init_direct_conn::Calling btsnd_hcic_ble_ext_create_ll_conn");
+        if (!btsnd_hcic_ble_ext_create_ll_conn (1 /*LE 1M PHY*/, scan_int,/* UINT16 scan_int      */
+                                            scan_win, /* UINT16 scan_win      */
+                                            FALSE,                   /* UINT8 white_list     */
+                                            peer_addr_type,          /* UINT8 addr_type_peer */
+                                            peer_addr,               /* BD_ADDR bda_peer     */
+                                            own_addr_type,         /* UINT8 addr_type_own  */
+                    (UINT16) ((p_dev_rec->conn_params.min_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ?
+                    p_dev_rec->conn_params.min_conn_int : BTM_BLE_CONN_INT_MIN_DEF),  /* UINT16 conn_int_min  */
+                    (UINT16) ((p_dev_rec->conn_params.max_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ?
+                    p_dev_rec->conn_params.max_conn_int : BTM_BLE_CONN_INT_MAX_DEF),  /* UINT16 conn_int_max  */
+                    (UINT16) ((p_dev_rec->conn_params.slave_latency != BTM_BLE_CONN_PARAM_UNDEF) ?
+                    p_dev_rec->conn_params.slave_latency : BTM_BLE_CONN_SLAVE_LATENCY_DEF), /* UINT16 conn_latency  */
+                    (UINT16) ((p_dev_rec->conn_params.supervision_tout != BTM_BLE_CONN_PARAM_UNDEF) ?
+                    p_dev_rec->conn_params.supervision_tout : BTM_BLE_CONN_TIMEOUT_DEF), /* conn_timeout */
+                                                    0,                       /* UINT16 min_len       */
+                                                    0))                      /* UINT16 max_len       */
+        {
+            l2cu_release_lcb (p_lcb);
+            L2CAP_TRACE_ERROR("initate direct connection fail, no resources");
+            return (FALSE);
+        }
     }
     else
+#endif
     {
-        p_lcb->link_state = LST_CONNECTING;
-        l2cb.is_ble_connecting = TRUE;
-        memcpy (l2cb.ble_connecting_bda, p_lcb->remote_bd_addr, BD_ADDR_LEN);
-        alarm_set_on_queue(p_lcb->l2c_lcb_timer,
-                           L2CAP_BLE_LINK_CONNECT_TIMEOUT_MS,
-                           l2c_lcb_timer_timeout, p_lcb,
-                           btu_general_alarm_queue);
-        btm_ble_set_conn_st (BLE_DIR_CONN);
-
-        return (TRUE);
+        if (!btsnd_hcic_ble_create_ll_conn (scan_int,/* UINT16 scan_int      */
+                                            scan_win, /* UINT16 scan_win      */
+                                            FALSE,                   /* UINT8 white_list     */
+                                            peer_addr_type,          /* UINT8 addr_type_peer */
+                                            peer_addr,               /* BD_ADDR bda_peer     */
+                                            own_addr_type,         /* UINT8 addr_type_own  */
+            (UINT16) ((p_dev_rec->conn_params.min_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ?
+            p_dev_rec->conn_params.min_conn_int : BTM_BLE_CONN_INT_MIN_DEF),  /* UINT16 conn_int_min  */
+            (UINT16) ((p_dev_rec->conn_params.max_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ?
+            p_dev_rec->conn_params.max_conn_int : BTM_BLE_CONN_INT_MAX_DEF),  /* UINT16 conn_int_max  */
+            (UINT16) ((p_dev_rec->conn_params.slave_latency != BTM_BLE_CONN_PARAM_UNDEF) ?
+            p_dev_rec->conn_params.slave_latency : BTM_BLE_CONN_SLAVE_LATENCY_DEF), /* UINT16 conn_latency  */
+            (UINT16) ((p_dev_rec->conn_params.supervision_tout != BTM_BLE_CONN_PARAM_UNDEF) ?
+            p_dev_rec->conn_params.supervision_tout : BTM_BLE_CONN_TIMEOUT_DEF), /* conn_timeout */
+                                            0,                       /* UINT16 min_len       */
+                                            0))                      /* UINT16 max_len       */
+        {
+            l2cu_release_lcb (p_lcb);
+            L2CAP_TRACE_ERROR("initate direct connection fail, no resources");
+            return (FALSE);
+        }
     }
+
+    p_lcb->link_state = LST_CONNECTING;
+    l2cb.is_ble_connecting = TRUE;
+    memcpy (l2cb.ble_connecting_bda, p_lcb->remote_bd_addr, BD_ADDR_LEN);
+    alarm_set_on_queue(p_lcb->l2c_lcb_timer,
+                       L2CAP_BLE_LINK_CONNECT_TIMEOUT_MS,
+                       l2c_lcb_timer_timeout, p_lcb,
+                       btu_general_alarm_queue);
+    btm_ble_set_conn_st (BLE_DIR_CONN);
+
+    return (TRUE);
 }
 
 /*******************************************************************************
@@ -1479,6 +1487,33 @@ void  l2cble_sec_comp(BD_ADDR p_bda, tBT_TRANSPORT transport, void *p_ref_data,
     }
 }
 
+#if (defined(LE_L2CAP_CFC_INCLUDED) && (LE_L2CAP_CFC_INCLUDED == TRUE))
+/*******************************************************************************
+**
+** Function         L2CA_LE_SetFlowControlCredits
+**
+** Description      This function sets the credits for LE incase credits did
+**                  not set during the LE connection establishment.
+**
+** Returns          TRUE if flow control set,false otherwise
+**
+*******************************************************************************/
+BOOLEAN L2CA_LE_SetFlowControlCredits (UINT16 cid, UINT16 credits)
+{
+    tL2C_CCB  *p_ccb;
+    L2CAP_TRACE_WARNING ("LE-L2CAP: %s credits: %d  CID: 0x%04x", __FUNCTION__,
+                                                                credits, cid);
+    /* Find the channel control block. We don't know the link it is on. */
+    if ((p_ccb = l2cu_find_ccb_by_cid (NULL, cid)) == NULL)
+    {
+        L2CAP_TRACE_WARNING ("LE-L2CAP: no CCB found");
+        return (FALSE);
+    }
+	l2cble_send_flow_control_credit(p_ccb, credits);
+        return (TRUE);
+}
+
+#endif //LE_L2CAP_CFC_INCLUDED
 /*******************************************************************************
 **
 ** Function         l2ble_sec_access_req
diff --git a/stack/l2cap/l2c_int.h b/stack/l2cap/l2c_int.h
index ce32651..bbf2409 100644
--- a/stack/l2cap/l2c_int.h
+++ b/stack/l2cap/l2c_int.h
@@ -768,7 +768,8 @@ extern void l2cble_conn_comp (UINT16 handle, UINT8 role, BD_ADDR bda, tBLE_ADDR_
 extern BOOLEAN l2cble_init_direct_conn (tL2C_LCB *p_lcb);
 extern void l2cble_notify_le_connection (BD_ADDR bda);
 extern void l2c_ble_link_adjust_allocation (void);
-extern void l2cble_process_conn_update_evt (UINT16 handle, UINT8 status);
+extern void l2cble_process_conn_update_evt (UINT16 handle, UINT8 status,
+                        UINT16 interval, UINT16 latency, UINT16 timeout);
 
 extern void l2cble_credit_based_conn_req (tL2C_CCB *p_ccb);
 extern void l2cble_credit_based_conn_res (tL2C_CCB *p_ccb, UINT16 result);
diff --git a/stack/l2cap/l2c_link.c b/stack/l2cap/l2c_link.c
index becd9ca..dcf1362 100644
--- a/stack/l2cap/l2c_link.c
+++ b/stack/l2cap/l2c_link.c
@@ -41,54 +41,12 @@
 #include "btm_api.h"
 #include "btm_int.h"
 #include "btcore/include/bdaddr.h"
-
+#include "device/include/interop_config.h"
 
 extern fixed_queue_t *btu_general_alarm_queue;
 
 static BOOLEAN l2c_link_send_to_lower (tL2C_LCB *p_lcb, BT_HDR *p_buf);
 
-/* Black listed car kits/headsets for role switch */
-static const UINT8 hci_role_switch_black_list_prefix[][3] = {{0x00, 0x26, 0xb4}  /* NAC FORD,2013 Lincoln */
-                                                             ,{0x00, 0x26, 0xe8} /* Nissan Murano */
-                                                             ,{0x00, 0x37, 0x6d} /* Lexus ES300h */
-                                                             ,{0x9c, 0x3a, 0xaf} /* SAMSUNG HM1900 */
-                                                             ,{0x00, 0x18, 0x91} /* WOOWI HERO */
-                                                             ,{0x0c, 0xe0, 0xe4} /* PLT_M70 */
-                                                             ,{0x00, 0x07, 0x04} /* Infiniti G37 2011 */
-                                                             ,{0x00, 0x23, 0x01} /* Roman R9020 */
-                                                             ,{0xa4, 0x15, 0x66} /* Motorola Boom */
-                                                             ,{0xd0, 0x13, 0x1e} /* Samsung keyboard */
-                                                             ,{0x1c, 0x48, 0xf9} /* Jabra Storm */
-                                                             ,{0x8f, 0x20, 0xb4} /* BT1719 */
-                                                             ,{0xa8, 0xb9, 0xb3} /* Sonata CarKit */
-                                                            };
-
-/*******************************************************************************
-**
-** Function         hci_blacklistted_for_role_switch
-**
-** Description      This function is called to find the blacklisted carkits
-**                  for role switch.
-**
-** Returns          TRUE, if black listed
-**
-*******************************************************************************/
-BOOLEAN hci_blacklistted_for_role_switch (BD_ADDR addr)
-{
-    int blacklistsize = 0;
-    int i =0;
-
-    blacklistsize = sizeof(hci_role_switch_black_list_prefix)/sizeof(hci_role_switch_black_list_prefix[0]);
-    for (i=0; i < blacklistsize; i++)
-    {
-        if (0 == memcmp(hci_role_switch_black_list_prefix[i], addr, 3))
-        {
-            return TRUE;
-        }
-    }
-    return FALSE;
-}
-
 #define HI_PRI_LINK_QUOTA 2 //Mininum ACL buffer quota for high priority link
 /*******************************************************************************
 **
@@ -106,6 +64,7 @@ BOOLEAN l2c_link_hci_conn_req (BD_ADDR bd_addr)
     tL2C_LCB        *p_lcb_cur;
     int             xx;
     BOOLEAN         no_links;
+    bt_bdaddr_t     remote_bdaddr;
 
     /* See if we have a link control block for the remote device */
     p_lcb = l2cu_find_lcb_by_bd_addr (bd_addr, BT_TRANSPORT_BR_EDR);
@@ -118,6 +77,7 @@ BOOLEAN l2c_link_hci_conn_req (BD_ADDR bd_addr)
         {
             btsnd_hcic_reject_conn (bd_addr, HCI_ERR_HOST_REJECT_RESOURCES);
             L2CAP_TRACE_ERROR ("L2CAP failed to allocate LCB");
+            GENERATE_VENDOR_LOGS();
             return FALSE;
         }
 
@@ -144,8 +104,8 @@ BOOLEAN l2c_link_hci_conn_req (BD_ADDR bd_addr)
             else
                 p_lcb->link_role = l2cu_get_conn_role(p_lcb);
         }
-
-        if ((p_lcb->link_role == BTM_ROLE_MASTER)&&(hci_blacklistted_for_role_switch(bd_addr))) {
+        bdcpy(remote_bdaddr.address, bd_addr);
+        if ((p_lcb->link_role == BTM_ROLE_MASTER)&&(interop_database_match_addr(INTEROP_DISABLE_ROLE_SWITCH, (bt_bdaddr_t *)&remote_bdaddr))) {
             p_lcb->link_role = BTM_ROLE_SLAVE;
             L2CAP_TRACE_WARNING ("l2c_link_hci_conn_req:set link_role= %d",p_lcb->link_role);
         }
@@ -330,6 +290,7 @@ BOOLEAN l2c_link_hci_conn_comp (UINT8 status, UINT16 handle, BD_ADDR p_bda)
             {
                 /* we are in collision situation, wait for connecttion request from controller */
                 p_lcb->link_state = LST_CONNECTING;
+                GENERATE_VENDOR_LOGS();
             }
             else
             {
@@ -663,6 +624,9 @@ void l2c_link_timeout (tL2C_LCB *p_lcb)
 #endif
         /* Release the LCB */
         l2cu_release_lcb (p_lcb);
+
+        /*Generate logs for link timeout while connecting/disconnecting*/
+        GENERATE_VENDOR_LOGS();
     }
 
     /* If link is connected, check for inactivity timeout */
@@ -728,6 +692,9 @@ void l2c_link_timeout (tL2C_LCB *p_lcb)
                 l2cu_process_fixed_disc_cback(p_lcb);
                 p_lcb->link_state = LST_DISCONNECTING;
                 timeout_ms = L2CAP_LINK_DISCONNECT_TIMEOUT_MS;
+
+                /*Link timeout must not occur while bonding*/
+                GENERATE_VENDOR_LOGS();
             }
             else
             {
diff --git a/stack/l2cap/l2c_main.c b/stack/l2cap/l2c_main.c
index d549c21..911ee50 100644
--- a/stack/l2cap/l2c_main.c
+++ b/stack/l2cap/l2c_main.c
@@ -28,6 +28,8 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <log/log.h>
+
 #include "bt_target.h"
 #include "btm_int.h"
 #include "btu.h"
@@ -112,7 +114,7 @@ void l2c_rcv_acl_data (BT_HDR *p_msg)
                 }
 
                 return;
-            } else {
+            } else if (handle != 0xedc) {    /* Handle 0xedc used for SOC Logging */
                 L2CAP_TRACE_ERROR ("L2CAP - rcvd ACL for unknown handle:%d ls:%d cid:%d"
                         " opcode:%d cur count:%d", handle, p_msg->layer_specific, rcv_cid,
                         cmd_code, list_length(l2cb.rcv_pending_q));
@@ -132,6 +134,14 @@ void l2c_rcv_acl_data (BT_HDR *p_msg)
     STREAM_TO_UINT16 (hci_len, p);
     p_msg->offset += 4;
 
+    if (hci_len < L2CAP_PKT_OVERHEAD) {
+        /* Must receive at least the L2CAP length and CID */
+        L2CAP_TRACE_WARNING ("L2CAP - got incorrect hci header");
+        android_errorWriteLog(0x534e4554, "34946955");
+        osi_free(p_msg);
+        return;
+    }
+
     /* Extract the length and CID */
     STREAM_TO_UINT16 (l2cap_len, p);
     STREAM_TO_UINT16 (rcv_cid, p);
@@ -154,17 +164,8 @@ void l2c_rcv_acl_data (BT_HDR *p_msg)
         }
     }
 
-    if (hci_len >= L2CAP_PKT_OVERHEAD)  /* Must receive at least the L2CAP length and CID.*/
-    {
-        p_msg->len    = hci_len - L2CAP_PKT_OVERHEAD;
-        p_msg->offset += L2CAP_PKT_OVERHEAD;
-    }
-    else
-    {
-        L2CAP_TRACE_WARNING ("L2CAP - got incorrect hci header" );
-        osi_free(p_msg);
-        return;
-    }
+    p_msg->len    = hci_len - L2CAP_PKT_OVERHEAD;
+    p_msg->offset += L2CAP_PKT_OVERHEAD;
 
     if (l2cap_len != p_msg->len)
     {
diff --git a/stack/pan/pan_api.c b/stack/pan/pan_api.c
index a20ed57..d56bf1f 100644
--- a/stack/pan/pan_api.c
+++ b/stack/pan/pan_api.c
@@ -407,6 +407,7 @@ tPAN_RESULT PAN_Connect (BD_ADDR rem_bda, UINT8 src_role, UINT8 dst_role, UINT16
     result = BNEP_Connect (rem_bda, &src_uuid, &dst_uuid, &(pcb->handle));
     if (result != BNEP_SUCCESS)
     {
+        pan_cb.num_conns--;
         pan_release_pcb (pcb);
         return result;
     }
diff --git a/stack/rfcomm/port_api.c b/stack/rfcomm/port_api.c
index 13457f9..0c90866 100644
--- a/stack/rfcomm/port_api.c
+++ b/stack/rfcomm/port_api.c
@@ -527,6 +527,51 @@ int PORT_CheckConnection (UINT16 handle, BD_ADDR bd_addr, UINT16 *p_lcid)
 
 /*******************************************************************************
 **
+** Function         PORT_GetRemoteMtu
+**
+** Description      This function feteches remote mtu from port
+**
+** Parameters:      handle     - Handle returned in the RFCOMM_CreateConnection
+**
+** Returns:         UINT16     - Maximum rfcomm frame size that can be
+**                               transmitted to the peer
+**
+*******************************************************************************/
+UINT16 PORT_GetRemoteMtu (UINT16 handle)
+{
+    tPORT      *p_port;
+
+    RFCOMM_TRACE_API ("PORT_GetRemoteMtu() handle:%d", handle);
+
+    /* Check if handle is valid to avoid crashing */
+    if ((handle == 0) || (handle > MAX_RFC_PORTS))
+    {
+        return (0);
+    }
+
+    p_port = &rfc_cb.port.port[handle - 1];
+
+    if (!p_port->in_use || (p_port->state == PORT_STATE_CLOSED))
+    {
+        RFCOMM_TRACE_ERROR ("PORT_GetRemoteMtu() p_port->in_use = %d, p_port->state = %d",
+               p_port->in_use, p_port->state);
+        return (0);
+    }
+
+    if (!p_port->rfc.p_mcb
+     || !p_port->rfc.p_mcb->peer_ready
+     || (p_port->rfc.state != RFC_STATE_OPENED))
+    {
+        RFCOMM_TRACE_ERROR ("PORT_GetRemoteMtu() peer not ready or p_port->rfc.state = %d",
+                p_port->rfc.state );
+        return (0);
+    }
+
+    return (p_port->peer_mtu);
+}
+
+/*******************************************************************************
+**
 ** Function         PORT_IsOpening
 **
 ** Description      This function returns TRUE if there is any RFCOMM connection
diff --git a/stack/rfcomm/port_rfc.c b/stack/rfcomm/port_rfc.c
index aaad62a..374b191 100644
--- a/stack/rfcomm/port_rfc.c
+++ b/stack/rfcomm/port_rfc.c
@@ -312,6 +312,7 @@ void PORT_ParNegInd (tRFC_MCB *p_mcb, UINT8 dlci, UINT16 mtu, UINT8 cl, UINT8 k)
             problem, they don't disconnect if we send DM */
             rfc_check_mcb_active( p_mcb );
             RFCOMM_TRACE_EVENT( "PORT_ParNegInd: port not found" );
+            GENERATE_VENDOR_LOGS();
             return;
         }
         p_mcb->port_inx[dlci] = p_port->inx;
diff --git a/stack/rfcomm/rfc_l2cap_if.c b/stack/rfcomm/rfc_l2cap_if.c
index 05f4994..6ae3863 100644
--- a/stack/rfcomm/rfc_l2cap_if.c
+++ b/stack/rfcomm/rfc_l2cap_if.c
@@ -35,7 +35,9 @@
 #include "l2cdefs.h"
 #include "rfc_int.h"
 #include "bt_utils.h"
+#include "port_ext.h"
 
+extern fixed_queue_t *btu_general_alarm_queue;
 
 /*
 ** Define Callback functions to be called by L2CAP
@@ -104,10 +106,13 @@ void RFCOMM_ConnectInd (BD_ADDR bd_addr, UINT16 lcid, UINT16 psm, UINT8 id)
             /* wait random timeout (2 - 12) to resolve collision */
             /* if peer gives up then local device rejects incoming connection and continues as initiator */
             /* if timeout, local device disconnects outgoing connection and continues as acceptor */
-            RFCOMM_TRACE_DEBUG ("RFCOMM_ConnectInd start timer for collision, initiator's LCID(0x%x), acceptor's LCID(0x%x)",
-                                  p_mcb->lcid, p_mcb->pending_lcid);
-
-            rfc_timer_start(p_mcb, (UINT16)(time_get_os_boottime_ms() % 10 + 2));
+            period_ms_t interval_ms = (((time_get_os_boottime_ms() % 20) * 500) + 2000);
+            RFCOMM_TRACE_DEBUG ("RFCOMM_ConnectInd start collision timer = %d ms , initiator's LCID(0x%x), acceptor's LCID(0x%x)",
+                                  interval_ms, p_mcb->lcid, p_mcb->pending_lcid);
+            alarm_set_on_queue(p_mcb->mcb_timer, interval_ms,
+                       rfcomm_mcb_timer_timeout, p_mcb,
+                       btu_general_alarm_queue);
+            GENERATE_VENDOR_LOGS();
             return;
         }
         else
diff --git a/stack/rfcomm/rfc_mx_fsm.c b/stack/rfcomm/rfc_mx_fsm.c
index e99be11..0d80b26 100644
--- a/stack/rfcomm/rfc_mx_fsm.c
+++ b/stack/rfcomm/rfc_mx_fsm.c
@@ -375,6 +375,8 @@ void rfc_mx_sm_sabme_wait_ua (tRFC_MCB *p_mcb, UINT16 event, void *p_data)
 *******************************************************************************/
 void rfc_mx_sm_state_wait_sabme (tRFC_MCB *p_mcb, UINT16 event, void *p_data)
 {
+    tPORT   *p_port;
+    int     i;
     RFCOMM_TRACE_EVENT ("rfc_mx_sm_state_wait_sabme - evt:%d", event);
     switch (event)
     {
@@ -414,7 +416,15 @@ void rfc_mx_sm_state_wait_sabme (tRFC_MCB *p_mcb, UINT16 event, void *p_data)
 
             p_mcb->state      = RFC_MX_STATE_CONNECTED;
             p_mcb->peer_ready = TRUE;
-            PORT_StartCnf (p_mcb, RFCOMM_SUCCESS);
+            p_port = &rfc_cb.port.port[0];
+            for (i = 0; i < MAX_RFC_PORTS; i++, p_port++)
+            {
+                if (p_port->rfc.p_mcb == p_mcb)
+                {
+                    PORT_StartCnf (p_mcb, RFCOMM_SUCCESS);
+                    break;
+                }
+            }
         }
         return;
 
diff --git a/stack/rfcomm/rfc_utils.c b/stack/rfcomm/rfc_utils.c
index 17923b0..692d985 100644
--- a/stack/rfcomm/rfc_utils.c
+++ b/stack/rfcomm/rfc_utils.c
@@ -325,6 +325,7 @@ void rfcomm_port_timer_timeout(void *data)
     tPORT *p_port = (tPORT *)data;
 
     rfc_port_sm_execute(p_port, RFC_EVENT_TIMEOUT, NULL);
+    GENERATE_VENDOR_LOGS();
 }
 
 void rfcomm_mcb_timer_timeout(void *data)
@@ -332,6 +333,8 @@ void rfcomm_mcb_timer_timeout(void *data)
     tRFC_MCB *p_mcb = (tRFC_MCB *)data;
 
     rfc_mx_sm_execute(p_mcb, RFC_EVENT_TIMEOUT, NULL);
+
+    GENERATE_VENDOR_LOGS();
 }
 
 /*******************************************************************************
diff --git a/stack/sdp/sdp_db.c b/stack/sdp/sdp_db.c
index 82e7784..e24cde9 100644
--- a/stack/sdp/sdp_db.c
+++ b/stack/sdp/sdp_db.c
@@ -398,7 +398,7 @@ BOOLEAN SDP_AddAttribute (UINT32 handle, UINT16 attr_id, UINT8 attr_type,
                           UINT32 attr_len, UINT8 *p_val)
 {
 #if SDP_SERVER_ENABLED == TRUE
-    UINT16          xx, yy, zz;
+    UINT16          xx;
     tSDP_RECORD     *p_rec = &sdp_cb.server_db.record[0];
 
 #if (BT_TRACE_VERBOSE == TRUE)
@@ -436,81 +436,84 @@ BOOLEAN SDP_AddAttribute (UINT32 handle, UINT16 attr_id, UINT8 attr_type,
 #endif
 
     /* Find the record in the database */
-    for (zz = 0; zz < sdp_cb.server_db.num_records; zz++, p_rec++)
+    for (xx = 0; xx < sdp_cb.server_db.num_records; xx++, p_rec++)
     {
         if (p_rec->record_handle == handle)
-        {
-            tSDP_ATTRIBUTE  *p_attr = &p_rec->attribute[0];
+            return SDP_AddAttributetoRecord (p_rec, attr_id, attr_type, attr_len, p_val);
+    }
+#endif
+    return (FALSE);
+}
 
-            /* Found the record. Now, see if the attribute already exists */
-            for (xx = 0; xx < p_rec->num_attributes; xx++, p_attr++)
-            {
-                /* The attribute exists. replace it */
-                if (p_attr->id == attr_id)
-                {
-                    SDP_DeleteAttribute (handle, attr_id);
-                    break;
-                }
-                if (p_attr->id > attr_id)
-                    break;
-            }
+BOOLEAN SDP_AddAttributetoRecord (tSDP_RECORD *p_rec, UINT16 attr_id, UINT8 attr_type,
+                                  UINT32 attr_len, UINT8 *p_val)
+{
+    UINT16 xx, yy;
+    tSDP_ATTRIBUTE  *p_attr = &p_rec->attribute[0];
+    /* Found the record. Now, see if the attribute already exists */
+    for (xx = 0; xx < p_rec->num_attributes; xx++, p_attr++)
+    {
+        /* The attribute exists. replace it */
+        if (p_attr->id == attr_id)
+        {
+            SDP_DeleteAttributefromRecord (p_rec, attr_id);
+            break;
+        }
+        if (p_attr->id > attr_id)
+            break;
+    }
 
-            if (p_rec->num_attributes == SDP_MAX_REC_ATTR)
-                return (FALSE);
+    if (p_rec->num_attributes == SDP_MAX_REC_ATTR)
+        return (FALSE);
 
-            /* If not found, see if we can allocate a new entry */
-            if (xx == p_rec->num_attributes)
-                p_attr = &p_rec->attribute[p_rec->num_attributes];
-            else
-            {
-                /* Since the attributes are kept in sorted order, insert ours here */
-                for (yy = p_rec->num_attributes; yy > xx; yy--)
-                    p_rec->attribute[yy] = p_rec->attribute[yy - 1];
-            }
+    /* If not found, see if we can allocate a new entry */
+    if (xx == p_rec->num_attributes)
+        p_attr = &p_rec->attribute[p_rec->num_attributes];
+    else
+    {
+        /* Since the attributes are kept in sorted order, insert ours here */
+        for (yy = p_rec->num_attributes; yy > xx; yy--)
+            p_rec->attribute[yy] = p_rec->attribute[yy - 1];
+    }
 
-            p_attr->id   = attr_id;
-            p_attr->type = attr_type;
-            p_attr->len  = attr_len;
+    p_attr->id   = attr_id;
+    p_attr->type = attr_type;
+    p_attr->len  = attr_len;
 
-            if (p_rec->free_pad_ptr + attr_len >= SDP_MAX_PAD_LEN)
-            {
-                /* do truncate only for text string type descriptor */
-                if (attr_type == TEXT_STR_DESC_TYPE)
-                {
-                    SDP_TRACE_WARNING("SDP_AddAttribute: attr_len:%d too long. truncate to (%d)",
-                        attr_len, SDP_MAX_PAD_LEN - p_rec->free_pad_ptr );
-
-                    attr_len = SDP_MAX_PAD_LEN - p_rec->free_pad_ptr;
-                    p_val[SDP_MAX_PAD_LEN - p_rec->free_pad_ptr] = '\0';
-                    p_val[SDP_MAX_PAD_LEN - p_rec->free_pad_ptr+1] = '\0';
-                }
-                else
-                    attr_len = 0;
-            }
+    if (p_rec->free_pad_ptr + attr_len >= SDP_MAX_PAD_LEN)
+    {
+        /* do truncate only for text string type descriptor */
+        if (attr_type == TEXT_STR_DESC_TYPE)
+        {
+            SDP_TRACE_WARNING("SDP_AddAttributetoRecord: attr_len:%d too long. truncate to (%d)",
+                attr_len, SDP_MAX_PAD_LEN - p_rec->free_pad_ptr );
 
-            if ((attr_len > 0) && (p_val != 0))
-            {
-                p_attr->len  = attr_len;
-                memcpy (&p_rec->attr_pad[p_rec->free_pad_ptr], p_val, (size_t)attr_len);
-                p_attr->value_ptr = &p_rec->attr_pad[p_rec->free_pad_ptr];
-                p_rec->free_pad_ptr += attr_len;
-            }
-            else if ((attr_len == 0 && p_attr->len != 0) || /* if truncate to 0 length, simply don't add */
-                      p_val == 0)
-            {
-                SDP_TRACE_ERROR("SDP_AddAttribute fail, length exceed maximum: ID %d: attr_len:%d ",
-                    attr_id, attr_len );
-                p_attr->id   = p_attr->type = p_attr->len  = 0;
-                return (FALSE);
-            }
-            p_rec->num_attributes++;
-            return (TRUE);
+            attr_len = SDP_MAX_PAD_LEN - p_rec->free_pad_ptr;
+            p_val[SDP_MAX_PAD_LEN - p_rec->free_pad_ptr] = '\0';
+            p_val[SDP_MAX_PAD_LEN - p_rec->free_pad_ptr+1] = '\0';
         }
+        else
+            attr_len = 0;
     }
-#endif
-    return (FALSE);
-}
 
+    if ((attr_len > 0) && (p_val != 0))
+    {
+        p_attr->len  = attr_len;
+        memcpy (&p_rec->attr_pad[p_rec->free_pad_ptr], p_val, (size_t)attr_len);
+        p_attr->value_ptr = &p_rec->attr_pad[p_rec->free_pad_ptr];
+        p_rec->free_pad_ptr += attr_len;
+    }
+    else if ((attr_len == 0 && p_attr->len != 0) || /* if truncate to 0 length, simply don't add */
+              p_val == 0)
+    {
+        SDP_TRACE_ERROR("SDP_AddAttributetoRecord fail, length exceed maximum: ID %d: attr_len:%d ",
+            attr_id, attr_len );
+        p_attr->id   = p_attr->type = p_attr->len  = 0;
+        return (FALSE);
+    }
+    p_rec->num_attributes++;
+    return (TRUE);
+}
 
 /*******************************************************************************
 **
@@ -757,6 +760,36 @@ BOOLEAN SDP_AddProfileDescriptorList (UINT32 handle, UINT16 profile_uuid,
 #endif
 }
 
+BOOLEAN SDP_AddProfileDescriptorListtoRecord (tSDP_RECORD *prec, UINT16 profile_uuid,
+                                      UINT16 version)
+{
+#if SDP_SERVER_ENABLED == TRUE
+    UINT8 *p;
+    BOOLEAN result;
+    UINT8 *p_buff = (UINT8 *)osi_malloc(sizeof(UINT8) * SDP_MAX_ATTR_LEN);
+
+    p = p_buff + 2;
+
+    /* First, build the profile descriptor list. This consists of a data element sequence. */
+    /* The sequence consists of profile's UUID and version number  */
+    UINT8_TO_BE_STREAM  (p, (UUID_DESC_TYPE << 3) | SIZE_TWO_BYTES);
+    UINT16_TO_BE_STREAM (p, profile_uuid);
+
+    UINT8_TO_BE_STREAM  (p, (UINT_DESC_TYPE << 3) | SIZE_TWO_BYTES);
+    UINT16_TO_BE_STREAM (p, version);
+
+    /* Add in type and length fields */
+    *p_buff = (UINT8) ((DATA_ELE_SEQ_DESC_TYPE << 3) | SIZE_IN_NEXT_BYTE);
+    *(p_buff+1) = (UINT8) (p - (p_buff+2));
+
+    result = SDP_AddAttributetoRecord (prec, ATTR_ID_BT_PROFILE_DESC_LIST,DATA_ELE_SEQ_DESC_TYPE, (UINT32) (p - p_buff), p_buff);
+    osi_free(p_buff);
+    return result;
+
+#else   /* SDP_SERVER_ENABLED == FALSE */
+    return (FALSE);
+#endif
+}
 
 /*******************************************************************************
 **
@@ -853,67 +886,75 @@ BOOLEAN SDP_AddServiceClassIdList (UINT32 handle, UINT16 num_services,
 BOOLEAN SDP_DeleteAttribute (UINT32 handle, UINT16 attr_id)
 {
 #if SDP_SERVER_ENABLED == TRUE
-    UINT16          xx, yy;
+    UINT16          xx;
     tSDP_RECORD     *p_rec = &sdp_cb.server_db.record[0];
-    UINT8           *pad_ptr;
-    UINT32  len;                        /* Number of bytes in the entry */
 
     /* Find the record in the database */
     for (xx = 0; xx < sdp_cb.server_db.num_records; xx++, p_rec++)
     {
         if (p_rec->record_handle == handle)
         {
-            tSDP_ATTRIBUTE  *p_attr = &p_rec->attribute[0];
-
             SDP_TRACE_API("Deleting attr_id 0x%04x for handle 0x%x", attr_id, handle);
-            /* Found it. Now, find the attribute */
-            for (xx = 0; xx < p_rec->num_attributes; xx++, p_attr++)
+            if (SDP_DeleteAttributefromRecord (p_rec, attr_id))
+                return (TRUE);
+        }
+    }
+#endif
+    /* If here, not found */
+    return (FALSE);
+}
+
+BOOLEAN SDP_DeleteAttributefromRecord (tSDP_RECORD *p_rec, UINT16 attr_id)
+{
+    UINT16          xx, yy;
+    tSDP_ATTRIBUTE  *p_attr = &p_rec->attribute[0];
+    UINT8           *pad_ptr;
+    UINT32  len;                        /* Number of bytes in the entry */
+
+    /* Found it. Now, find the attribute */
+    for (xx = 0; xx < p_rec->num_attributes; xx++, p_attr++)
+    {
+        if (p_attr->id == attr_id)
+        {
+            pad_ptr = p_attr->value_ptr;
+            len = p_attr->len;
+            if (p_rec->free_pad_ptr + p_attr->len >= SDP_MAX_PAD_LEN)
+            {
+                SDP_TRACE_ERROR("Deleting attr_id 0x%04x len %d exceeds 600", attr_id, len);
+                if (p_attr->type == TEXT_STR_DESC_TYPE)
+                    len = SDP_MAX_PAD_LEN - p_rec->free_pad_ptr;
+                else
+                    len = 0;
+            }
+            if (len)
             {
-                if (p_attr->id == attr_id)
+                for (yy = 0; yy < p_rec->num_attributes; yy++)
                 {
-                    pad_ptr = p_attr->value_ptr;
-                    len = p_attr->len;
-                    if (p_rec->free_pad_ptr + p_attr->len >= SDP_MAX_PAD_LEN)
-                    {
-                        SDP_TRACE_ERROR("Deleting attr_id 0x%04x len %d exceeds 600", attr_id, len);
-                        if (p_attr->type == TEXT_STR_DESC_TYPE)
-                            len = SDP_MAX_PAD_LEN - p_rec->free_pad_ptr;
-                        else
-                            len = 0;
-                    }
-                    if (len)
-                    {
-                        for (yy = 0; yy < p_rec->num_attributes; yy++)
-                        {
-                            if( p_rec->attribute[yy].value_ptr > pad_ptr )
-                                p_rec->attribute[yy].value_ptr -= len;
-                        }
-                    }
-
-                    /* Found it. Shift everything up one */
-                    p_rec->num_attributes--;
-
-                    for (yy = xx; yy < p_rec->num_attributes; yy++, p_attr++)
-                    {
-                        *p_attr = *(p_attr + 1);
-                    }
-
-                    /* adjust attribute values if needed */
-                    if (len)
-                    {
-                        xx = (p_rec->free_pad_ptr - ((pad_ptr+len) -
-                                                  &p_rec->attr_pad[0]));
-                        for( yy=0; yy<xx; yy++, pad_ptr++)
-                            *pad_ptr = *(pad_ptr+len);
-                        p_rec->free_pad_ptr -= len;
-                    }
-                    return (TRUE);
+                    if( p_rec->attribute[yy].value_ptr > pad_ptr )
+                        p_rec->attribute[yy].value_ptr -= len;
                 }
             }
+
+            /* Found it. Shift everything up one */
+            p_rec->num_attributes--;
+
+            for (yy = xx; yy < p_rec->num_attributes; yy++, p_attr++)
+            {
+                *p_attr = *(p_attr + 1);
+            }
+
+            /* adjust attribute values if needed */
+            if (len)
+            {
+                xx = (p_rec->free_pad_ptr - ((pad_ptr+len) -
+                                          &p_rec->attr_pad[0]));
+                for( yy=0; yy<xx; yy++, pad_ptr++)
+                    *pad_ptr = *(pad_ptr+len);
+                p_rec->free_pad_ptr -= len;
+            }
+            return (TRUE);
         }
     }
-#endif
-    /* If here, not found */
     return (FALSE);
 }
 
diff --git a/stack/sdp/sdp_discovery.c b/stack/sdp/sdp_discovery.c
index 1377af5..99e116a 100644
--- a/stack/sdp/sdp_discovery.c
+++ b/stack/sdp/sdp_discovery.c
@@ -353,13 +353,14 @@ static void sdp_copy_raw_data (tCONN_CB *p_ccb, BOOLEAN offset)
     UINT8           type;
 
 #if (SDP_DEBUG_RAW == TRUE)
-    UINT8 num_array[SDP_MAX_LIST_BYTE_COUNT];
+    UINT8 num_array[2 * SDP_MAX_LIST_BYTE_COUNT + 1]; // Need double the space to store hex data
     UINT32 i;
 
     for (i = 0; i < p_ccb->list_len; i++)
     {
         sprintf((char *)&num_array[i*2],"%02X",(UINT8)(p_ccb->rsp_list[i]));
     }
+    (char)num_array[2*i] = '\0';
     SDP_TRACE_WARNING("result :%s",num_array);
 #endif
 
@@ -384,10 +385,11 @@ static void sdp_copy_raw_data (tCONN_CB *p_ccb, BOOLEAN offset)
             SDP_TRACE_WARNING("rem_len :%d less than cpy_len:%d", rem_len, cpy_len);
             cpy_len = rem_len;
         }
-#if (SDP_DEBUG_RAW == TRUE)
-        SDP_TRACE_WARNING("list_len :%d cpy_len:%d raw_size:%d raw_used:%d",
-            list_len, cpy_len, p_ccb->p_db->raw_size, p_ccb->p_db->raw_used);
-#endif
+        SDP_TRACE_WARNING(
+          "%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d "
+          "raw_used:%d raw_data:%p",
+          __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,
+          p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);
         memcpy (&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);
         p_ccb->p_db->raw_used += cpy_len;
     }
diff --git a/stack/sdp/sdp_server.c b/stack/sdp/sdp_server.c
index 3b36677..15c2a77 100644
--- a/stack/sdp/sdp_server.c
+++ b/stack/sdp/sdp_server.c
@@ -40,8 +40,12 @@
 
 #include "sdp_api.h"
 #include "sdpint.h"
+#include "device/include/interop.h"
+#include "btif/include/btif_storage.h"
+#include "device/include/interop_config.h"
 #include <errno.h>
 #include <cutils/properties.h>
+#include <hardware/bluetooth.h>
 
 #if SDP_SERVER_ENABLED == TRUE
 
@@ -56,12 +60,8 @@ extern fixed_queue_t *btu_general_alarm_queue;
 #define AVRCP_SUPPORTED_FEATURES_POSITION 1
 #define AVRCP_BROWSE_SUPPORT_BITMASK    0x40
 #define AVRCP_CA_SUPPORT_BITMASK        0x01
-
-/* Few remote device does not understand AVRCP version greater
- * than 1.3 and falls back to 1.0, we would like to blacklist
- * and send AVRCP versio as 1.3.
- */
-static const UINT8 sdp_black_list_prefix[][3] = {};
+#define PBAP_SKIP_GOEP_L2CAP_PSM_LEN    0x06
+#define PBAP_SKIP_SUPP_FEA_LEN          0x08
 
 /********************************************************************************/
 /*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
@@ -78,6 +78,10 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
                                              UINT16 param_len, UINT8 *p_req,
                                              UINT8 *p_req_end);
 
+static BOOLEAN is_pbap_record_blacklisted (tSDP_ATTRIBUTE attr, BD_ADDR remote_address);
+
+static tSDP_RECORD *sdp_update_pbap_record_if_blacklisted(tSDP_RECORD *p_rec,
+                                      BD_ADDR remote_address);
 
 /********************************************************************************/
 /*                  E R R O R   T E X T   S T R I N G S                         */
@@ -166,24 +170,30 @@ int sdp_get_stored_avrc_tg_version(BD_ADDR addr)
 *******************************************************************************/
 BOOLEAN sdp_dev_blacklisted_for_avrcp15 (BD_ADDR addr)
 {
-    int blacklistsize = 0;
-    int i =0;
+    bt_bdaddr_t remote_bdaddr;
+    bdcpy(remote_bdaddr.address, addr);
 
-    if(sizeof(sdp_black_list_prefix) == 0)
-    {
-        SDP_TRACE_ERROR("No AVRCP Black Listed Device");
-        return FALSE;
-    }
+    if (interop_match_addr(INTEROP_ADV_AVRCP_VER_1_3, &remote_bdaddr)) {
+        bt_property_t prop_name;
+        bt_bdname_t bdname;
 
-    blacklistsize = sizeof(sdp_black_list_prefix)/sizeof(sdp_black_list_prefix[0]);
-    for (i=0; i < blacklistsize; i++)
-    {
-        if (0 == memcmp(sdp_black_list_prefix[i], addr, 3))
+        BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_BDNAME,
+                               sizeof(bt_bdname_t), &bdname);
+        if (btif_storage_get_remote_device_property(&remote_bdaddr,
+                                              &prop_name) != BT_STATUS_SUCCESS)
+        {
+            SDP_TRACE_ERROR("%s: BT_PROPERTY_BDNAME failed, returning false", __func__);
+            return FALSE;
+        }
+
+        if (strlen((const char *)bdname.name) != 0 &&
+            interop_match_name(INTEROP_ADV_AVRCP_VER_1_3, (const char *)bdname.name))
         {
-            SDP_TRACE_ERROR("SDP Avrcp Version Black List Device");
+            SDP_TRACE_DEBUG("%s: advertise AVRCP version 1.3 for device", __func__);
             return TRUE;
         }
     }
+
     return FALSE;
 }
 
@@ -307,7 +317,9 @@ BOOLEAN sdp_change_hfp_version (tSDP_ATTRIBUTE *p_attr, BD_ADDR remote_address)
         if (((p_attr->value_ptr[3] << 8) | (p_attr->value_ptr[4])) ==
                 UUID_SERVCLASS_HF_HANDSFREE)
         {
-            is_blacklisted = is_device_present(IOT_HFP_1_7_BLACKLIST, remote_address);
+            bt_bdaddr_t remote_bdaddr;
+            bdcpy(remote_bdaddr.address, remote_address);
+            is_blacklisted = interop_database_match_addr(INTEROP_HFP_1_7_BLACKLIST, (bt_bdaddr_t *)&remote_bdaddr);
             SDP_TRACE_DEBUG("%s: HF version is 1.7 for BD addr: %x:%x:%x",\
                            __func__, remote_address[0], remote_address[1], remote_address[2]);
             /* For PTS we should show AG's HFP version as 1.7 */
@@ -629,6 +641,8 @@ static void process_service_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
         return;
     }
 
+    p_rec = sdp_update_pbap_record_if_blacklisted(p_rec, p_ccb->device_address);
+
     /* Free and reallocate buffer */
     osi_free(p_ccb->rsp_list);
     p_ccb->rsp_list = (UINT8 *)osi_malloc(max_list_len);
@@ -686,8 +700,10 @@ static void process_service_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
         (defined(SDP_AVRCP_1_5) && (SDP_AVRCP_1_5 == TRUE)))
             /* Check for UUID Remote Control and Remote BD address  */
             is_avrcp_fallback = sdp_fallback_avrcp_version (p_attr, p_ccb->device_address);
+#if (defined(AVCT_BROWSE_INCLUDED)&&(AVCT_BROWSE_INCLUDED == TRUE))
             is_avrcp_browse_bit_reset = sdp_reset_avrcp_browsing_bit(
                         p_rec->attribute[1], p_attr, p_ccb->device_address);
+#endif
 #if (defined(SDP_AVRCP_1_6) && (SDP_AVRCP_1_6 == TRUE))
             is_avrcp_ca_bit_reset = sdp_reset_avrcp_cover_art_bit(
                         p_rec->attribute[1], p_attr, p_ccb->device_address);
@@ -917,6 +933,7 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
     UINT8           *p_rsp, *p_rsp_start, *p_rsp_param_len;
     UINT16          rsp_param_len, xx;
     tSDP_RECORD    *p_rec;
+    tSDP_RECORD    *p_prev_rec;
     tSDP_ATTR_SEQ   attr_seq, attr_seq_sav;
     tSDP_ATTRIBUTE *p_attr;
     BT_HDR         *p_buf;
@@ -927,6 +944,7 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
     BOOLEAN         is_avrcp_ca_bit_reset = FALSE;
     UINT8           *p_seq_start = NULL;
     UINT16          seq_len, attr_len;
+    UINT16          blacklist_skip_len = 0;
     UNUSED(p_req_end);
 
     /* Extract the UUID sequence to search for */
@@ -953,7 +971,6 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
     }
 
     memcpy(&attr_seq_sav, &attr_seq, sizeof(tSDP_ATTR_SEQ)) ;
-
     /* Free and reallocate buffer */
     osi_free(p_ccb->rsp_list);
     p_ccb->rsp_list = (UINT8 *)osi_malloc(max_list_len);
@@ -1005,6 +1022,34 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
     for (p_rec = sdp_db_service_search (p_ccb->cont_info.prev_sdp_rec, &uid_seq); p_rec; p_rec = sdp_db_service_search (p_rec, &uid_seq))
     {
         p_ccb->cont_info.curr_sdp_rec = p_rec;
+        /* Store the actual record pointer which would be reused later */
+        p_prev_rec = p_rec;
+        p_rec = sdp_update_pbap_record_if_blacklisted(p_rec, p_ccb->device_address);
+        if (p_rec != p_prev_rec) {
+            /* Remote device is blacklisted for PBAP, calculate the reduction in length */
+            for (xx = p_ccb->cont_info.next_attr_index; xx < attr_seq_sav.num_attr; xx++) {
+                if (attr_seq_sav.attr_entry[xx].start == attr_seq_sav.attr_entry[xx].end) {
+                    if (attr_seq_sav.attr_entry[xx].start == ATTR_ID_GOEP_L2CAP_PSM) {
+                        blacklist_skip_len += PBAP_SKIP_GOEP_L2CAP_PSM_LEN;
+                        SDP_TRACE_ERROR("%s: ATTR_ID_GOEP_L2CAP_PSM requested,"
+                            " need to reduce length by %d", __func__,
+                            blacklist_skip_len);
+                    } else if (attr_seq_sav.attr_entry[xx].start ==
+                        ATTR_ID_PBAP_SUPPORTED_FEATURES) {
+                        blacklist_skip_len += PBAP_SKIP_SUPP_FEA_LEN;
+                        SDP_TRACE_DEBUG("%s: ATTR_ID_PBAP_SUPPORTED_FEATURES requested,"
+                            " need to reduce length by %d", __func__,
+                            blacklist_skip_len);
+                    }
+                } else {
+                    blacklist_skip_len = PBAP_SKIP_GOEP_L2CAP_PSM_LEN +
+                        PBAP_SKIP_SUPP_FEA_LEN;
+                    SDP_TRACE_DEBUG("%s: All attributes requested"
+                        " need to reduce length by %d", __func__,
+                        blacklist_skip_len);
+                }
+            }
+        }
         /* Allow space for attribute sequence type and length */
         p_seq_start = p_rsp;
         if (p_ccb->cont_info.last_attr_seq_desc_sent == FALSE)
@@ -1032,8 +1077,10 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
         (defined(SDP_AVRCP_1_5) && (SDP_AVRCP_1_5 == TRUE)))
                 /* Check for UUID Remote Control and Remote BD address  */
                 is_avrcp_fallback = sdp_fallback_avrcp_version (p_attr, p_ccb->device_address);
+#if (defined(AVCT_BROWSE_INCLUDED)&&(AVCT_BROWSE_INCLUDED == TRUE))
                 is_avrcp_browse_bit_reset = sdp_reset_avrcp_browsing_bit(
                             p_rec->attribute[1], p_attr, p_ccb->device_address);
+#endif
 #if (defined(SDP_AVRCP_1_6) && (SDP_AVRCP_1_6 == TRUE))
                 is_avrcp_ca_bit_reset = sdp_reset_avrcp_cover_art_bit(
                             p_rec->attribute[1], p_attr, p_ccb->device_address);
@@ -1203,6 +1250,8 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
 
         /* Reset the next attr index */
         p_ccb->cont_info.next_attr_index = 0;
+        /* restore the record pointer.*/
+        p_rec = p_prev_rec;
         p_ccb->cont_info.prev_sdp_rec = p_rec;
         p_ccb->cont_info.last_attr_seq_desc_sent = FALSE;
     }
@@ -1237,6 +1286,13 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
     {
         /* Get the total list length for requested uid and attribute sequence */
         p_ccb->list_len = sdpu_get_list_len(&uid_seq, &attr_seq_sav) + 3;
+        if (blacklist_skip_len &&
+            p_ccb->list_len > blacklist_skip_len) {
+            p_ccb->list_len -= blacklist_skip_len;
+            SDP_TRACE_DEBUG("%s: reducing list_len by %d for blacklisted device",
+                __func__, blacklist_skip_len);
+            blacklist_skip_len = 0;
+        }
         /* Put in the sequence header (2 or 3 bytes) */
         if (p_ccb->list_len > 255)
         {
@@ -1278,6 +1334,14 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
 
     p_ccb->cont_offset += len_to_send;
 
+    if (blacklist_skip_len &&
+        p_ccb->list_len > blacklist_skip_len) {
+        p_ccb->list_len -= blacklist_skip_len;
+        SDP_TRACE_DEBUG("%s: reducing list_len by %d for blacklisted device",
+            __func__, blacklist_skip_len);
+        blacklist_skip_len = 0;
+    }
+
     /* If anything left to send, continuation needed */
     if (p_ccb->cont_offset < p_ccb->list_len)
     {
@@ -1301,4 +1365,97 @@ static void process_service_search_attr_req (tCONN_CB *p_ccb, UINT16 trans_num,
     L2CA_DataWrite (p_ccb->connection_id, p_buf);
 }
 
+/*************************************************************************************
+**
+** Function        is_pbap_record_blacklisted
+**
+** Description     Checks if given PBAP record is for PBAP PSE and blacklisted
+**
+** Returns         BOOLEAN
+**
+***************************************************************************************/
+static BOOLEAN is_pbap_record_blacklisted (tSDP_ATTRIBUTE attr,
+                                      BD_ADDR remote_address)
+{
+    if ((attr.id == ATTR_ID_SERVICE_CLASS_ID_LIST) &&
+        (((attr.value_ptr[1] << 8) | (attr.value_ptr[2])) ==
+        UUID_SERVCLASS_PBAP_PSE))
+    {
+        bt_bdaddr_t remote_bdaddr;
+        bdcpy(remote_bdaddr.address, remote_address);
+
+        bt_property_t prop_name;
+        bt_bdname_t bdname;
+
+        memset(&bdname, 0, sizeof(bt_bdname_t));
+        BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_BDNAME,
+                               sizeof(bt_bdname_t), &bdname);
+        if (btif_storage_get_remote_device_property(&remote_bdaddr,
+                                              &prop_name) != BT_STATUS_SUCCESS) {
+            SDP_TRACE_DEBUG("%s: BT_PROPERTY_BDNAME failed", __func__);
+        }
+        if (interop_match_addr(INTEROP_ADV_PBAP_VER_1_1, &remote_bdaddr) ||
+           (strlen((const char *)bdname.name) != 0 &&
+            interop_match_name(INTEROP_ADV_PBAP_VER_1_1,
+            (const char *)bdname.name))) {
+            SDP_TRACE_DEBUG("%s: device is blacklisted for pbap version downgrade", __func__);
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/*************************************************************************************
+**
+** Function        sdp_update_pbap_record_if_blacklisted
+**
+** Description     updates pbap record after checking if blacklisted
+**
+** Returns         the address of updated record
+**
+***************************************************************************************/
+static tSDP_RECORD *sdp_update_pbap_record_if_blacklisted(tSDP_RECORD *p_rec,
+                                      BD_ADDR remote_address)
+{
+    static tSDP_RECORD pbap_temp_sdp_rec;
+    static BOOLEAN is_blacklisted_rec_created = FALSE;
+
+    /* Check if the given SDP record is blacklisted and requires updatiion */
+    if (is_pbap_record_blacklisted(p_rec->attribute[1], remote_address)) {
+        if (is_blacklisted_rec_created)
+            return &pbap_temp_sdp_rec;
+
+        bool status = TRUE;
+        int xx;
+        UINT8 supported_repositories = 0x03;
+        UINT16 legacy_version = 0x0101;
+        memset(&pbap_temp_sdp_rec, 0, sizeof(tSDP_RECORD));
+
+        tSDP_ATTRIBUTE  *p_attr = &p_rec->attribute[0];
+
+        /* Copying contents of the PBAP PSE record to a temporary record */
+        for (xx = 0; xx < p_rec->num_attributes; xx++, p_attr++)
+            SDP_AddAttributetoRecord (&pbap_temp_sdp_rec, p_attr->id,
+            p_attr->type, p_attr->len, p_attr->value_ptr);
+
+        status &= SDP_DeleteAttributefromRecord (&pbap_temp_sdp_rec,
+            ATTR_ID_PBAP_SUPPORTED_FEATURES);
+        status &= SDP_DeleteAttributefromRecord (&pbap_temp_sdp_rec,
+            ATTR_ID_GOEP_L2CAP_PSM);
+        status &= SDP_AddAttributetoRecord (&pbap_temp_sdp_rec,
+            ATTR_ID_SUPPORTED_REPOSITORIES, UINT_DESC_TYPE, (UINT32)1,
+            (UINT8*)&supported_repositories);
+        status &= SDP_AddProfileDescriptorListtoRecord(&pbap_temp_sdp_rec,
+            UUID_SERVCLASS_PHONE_ACCESS, legacy_version);
+        if (!status) {
+            SDP_TRACE_ERROR("%s() FAILED", __func__);
+            return p_rec;
+        }
+        is_blacklisted_rec_created = TRUE;
+        return &pbap_temp_sdp_rec;
+    }
+    return p_rec;
+}
+
 #endif  /* SDP_SERVER_ENABLED == TRUE */
diff --git a/stack/sdp/sdpint.h b/stack/sdp/sdpint.h
index f4a3493..a42ac21 100644
--- a/stack/sdp/sdpint.h
+++ b/stack/sdp/sdpint.h
@@ -301,6 +301,11 @@ extern void sdpu_uuid16_to_uuid128(UINT16 uuid16, UINT8* p_uuid128);
 extern tSDP_RECORD    *sdp_db_service_search (tSDP_RECORD *p_rec, tSDP_UUID_SEQ *p_seq);
 extern tSDP_RECORD    *sdp_db_find_record (UINT32 handle);
 extern tSDP_ATTRIBUTE *sdp_db_find_attr_in_rec (tSDP_RECORD *p_rec, UINT16 start_attr, UINT16 end_attr);
+extern BOOLEAN SDP_AddAttributetoRecord (tSDP_RECORD *p_rec, UINT16 attr_id, UINT8 attr_type,
+                                  UINT32 attr_len, UINT8 *p_val);
+extern BOOLEAN SDP_AddProfileDescriptorListtoRecord (tSDP_RECORD *p_rec, UINT16 profile_uuid,
+                                      UINT16 version);
+extern BOOLEAN SDP_DeleteAttributefromRecord (tSDP_RECORD *p_rec, UINT16 attr_id);
 
 
 /* Functions provided by sdp_server.c
diff --git a/stack/smp/smp_act.c b/stack/smp/smp_act.c
index 1e3effe..c772550 100644
--- a/stack/smp/smp_act.c
+++ b/stack/smp/smp_act.c
@@ -24,6 +24,8 @@
 #include "stack/smp/smp_int.h"
 #include "utils/include/bt_utils.h"
 
+extern fixed_queue_t *btu_general_alarm_queue;
+
 #if SMP_INCLUDED == TRUE
 const UINT8 smp_association_table[2][SMP_IO_CAP_MAX][SMP_IO_CAP_MAX] =
 {
@@ -189,6 +191,8 @@ void smp_send_app_cback(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
 
         if (callback_rc == SMP_SUCCESS)
         {
+            bt_bdaddr_t remote_bdaddr;
+            bdcpy(remote_bdaddr.address, p_cb->pairing_bda);
             switch (p_cb->cb_evt)
             {
                 case SMP_IO_CAP_REQ_EVT:
@@ -223,7 +227,7 @@ void smp_send_app_cback(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
                     if (!(p_cb->loc_auth_req & SMP_SC_SUPPORT_BIT)
                         || lmp_version_below(p_cb->pairing_bda, HCI_PROTO_VERSION_4_2)
                         || interop_match_addr(INTEROP_DISABLE_LE_SECURE_CONNECTIONS,
-                            (const bt_bdaddr_t *)&p_cb->pairing_bda))
+                            (const bt_bdaddr_t *)&remote_bdaddr))
                     {
                         p_cb->loc_auth_req &= ~SMP_KP_SUPPORT_BIT;
                         p_cb->local_i_key &= ~SMP_SEC_KEY_TYPE_LK;
@@ -240,13 +244,15 @@ void smp_send_app_cback(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
                     p_cb->loc_enc_size = cb_data.io_req.max_key_size;
                     p_cb->local_i_key = cb_data.io_req.init_keys;
                     p_cb->local_r_key = cb_data.io_req.resp_keys;
+                    p_cb->loc_auth_req |= SMP_H7_SUPPORT_BIT;
 
                     p_cb->local_i_key &= ~SMP_SEC_KEY_TYPE_LK;
                     p_cb->local_r_key &= ~SMP_SEC_KEY_TYPE_LK;
 
                     SMP_TRACE_WARNING ( "for SMP over BR max_key_size: 0x%02x,\
-                        local_i_key: 0x%02x, local_r_key: 0x%02x",
-                        p_cb->loc_enc_size, p_cb->local_i_key, p_cb->local_r_key);
+                        local_i_key: 0x%02x, local_r_key: 0x%02x, auth_req = %d",
+                        p_cb->loc_enc_size, p_cb->local_i_key, p_cb->local_r_key, p_cb->loc_auth_req);
+
 
                     smp_br_state_machine_event(p_cb, SMP_BR_KEYS_RSP_EVT, NULL);
                     break;
@@ -553,6 +559,9 @@ void smp_proc_pair_fail(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
 {
     SMP_TRACE_DEBUG("%s", __func__);
     p_cb->status = *(UINT8 *)p_data;
+
+    /* Cancel pending auth complete timer if set */
+    alarm_cancel(p_cb->delayed_auth_timer_ent);
 }
 
 /*******************************************************************************
@@ -935,6 +944,13 @@ void smp_br_check_authorization_request(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
         p_cb->local_r_key &= (SMP_SEC_KEY_TYPE_ID | SMP_SEC_KEY_TYPE_CSRK);
     }
 
+    /* Check if H7 function needs to be used for key derivation*/
+    if ((p_cb->loc_auth_req & SMP_H7_SUPPORT_BIT) && (p_cb->peer_auth_req & SMP_H7_SUPPORT_BIT))
+    {
+        p_cb->key_derivation_h7_used = TRUE;
+    }
+    SMP_TRACE_DEBUG("%s use h7 = %d", __func__, p_cb->key_derivation_h7_used);
+
     SMP_TRACE_DEBUG("%s rcvs upgrades: i_keys=0x%x r_keys=0x%x "
                       "(i-initiator r-responder)", __FUNCTION__, p_cb->local_i_key,
                       p_cb->local_r_key);
@@ -1287,7 +1303,6 @@ void smp_key_pick_key(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
 *******************************************************************************/
 void smp_key_distribution(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
 {
-    UINT8   reason = SMP_SUCCESS;
     SMP_TRACE_DEBUG("%s role=%d (0-master) r_keys=0x%x i_keys=0x%x",
                       __func__, p_cb->role, p_cb->local_r_key, p_cb->local_i_key);
 
@@ -1309,9 +1324,22 @@ void smp_key_distribution(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
             }
 
             if (p_cb->total_tx_unacked == 0)
-                smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);
-            else
+            {
+                /*
+                 * Instead of declaring authorization complete immediately,
+                 * delay the event from being sent by SMP_DELAYED_AUTH_TIMEOUT_MS.
+                 * This allows the slave to send over Pairing Failed if the
+                 * last key is rejected.  During this waiting window, the
+                 * state should remain in SMP_STATE_BOND_PENDING.
+                 */
+                if (!alarm_is_scheduled(p_cb->delayed_auth_timer_ent)) {
+                    SMP_TRACE_DEBUG("%s delaying auth complete.", __func__);
+                    alarm_set_on_queue(p_cb->delayed_auth_timer_ent, SMP_DELAYED_AUTH_TIMEOUT_MS,
+                                       smp_delayed_auth_complete_timeout, NULL, btu_general_alarm_queue);
+                }
+            } else {
                 p_cb->wait_for_authorization_complete = TRUE;
+            }
         }
     }
 }
@@ -1485,8 +1513,6 @@ void smp_pairing_cmpl(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
 {
     if (p_cb->total_tx_unacked == 0)
     {
-        /* update connection parameter to remote preferred */
-        L2CA_EnableUpdateBleConnParams(p_cb->pairing_bda, TRUE);
         /* process the pairing complete */
         smp_proc_pairing_cmpl(p_cb);
     }
@@ -1525,8 +1551,11 @@ void smp_idle_terminate(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
 *******************************************************************************/
 void smp_fast_conn_param(tSMP_CB *p_cb, tSMP_INT_DATA *p_data)
 {
-    /* disable connection parameter update */
-    L2CA_EnableUpdateBleConnParams(p_cb->pairing_bda, FALSE);
+    /* Disable L2CAP connection parameter updates while bonding since
+       some peripherals are not able to revert to fast connection parameters
+       during the start of service discovery. Connection paramter updates
+       get enabled again once service discovery completes. */
+    L2CA_EnableUpdateBleConnParams(p_cb->pairing_bda, false);
 }
 
 /*******************************************************************************
diff --git a/stack/smp/smp_api.c b/stack/smp/smp_api.c
index b3373b5..ddf9ba4 100644
--- a/stack/smp/smp_api.c
+++ b/stack/smp/smp_api.c
@@ -52,6 +52,7 @@ void SMP_Init(void)
 {
     memset(&smp_cb, 0, sizeof(tSMP_CB));
     smp_cb.smp_rsp_timer_ent = alarm_new("smp.smp_rsp_timer_ent");
+    smp_cb.delayed_auth_timer_ent = alarm_new("smp.delayed_auth_timer_ent");
 
 #if defined(SMP_INITIAL_TRACE_LEVEL)
     smp_cb.trace_level = SMP_INITIAL_TRACE_LEVEL;
diff --git a/stack/smp/smp_int.h b/stack/smp/smp_int.h
index fbb4289..f11fe49 100644
--- a/stack/smp/smp_int.h
+++ b/stack/smp/smp_int.h
@@ -51,6 +51,7 @@ typedef UINT8   tSMP_ASSO_MODEL;
 #endif
 
 #define SMP_WAIT_FOR_RSP_TIMEOUT_MS      (30 * 1000)
+#define SMP_DELAYED_AUTH_TIMEOUT_MS      500
 
 #define SMP_OPCODE_INIT                   0x04
 
@@ -311,6 +312,7 @@ typedef struct
                                             /* either in Secure Connections mode or not at all */
     tSMP_ASSO_MODEL selected_association_model;
     BOOLEAN         le_secure_connections_mode_is_used;
+    BOOLEAN         key_derivation_h7_used;
     BOOLEAN le_sc_kp_notif_is_used;
     tSMP_SC_KEY_TYPE local_keypress_notification;
     tSMP_SC_KEY_TYPE peer_keypress_notification;
@@ -340,7 +342,8 @@ typedef struct
     UINT16          total_tx_unacked;
     BOOLEAN         wait_for_authorization_complete;
     UINT8           cert_failure; /*failure case for certification */
-} tSMP_CB;
+    alarm_t         *delayed_auth_timer_ent;
+}tSMP_CB;
 
 /* Server Action functions are of this type */
 typedef void (*tSMP_ACT)(tSMP_CB *p_cb, tSMP_INT_DATA *p_data);
@@ -481,6 +484,7 @@ extern void smp_proc_pairing_cmpl(tSMP_CB *p_cb);
 extern void smp_convert_string_to_tk(BT_OCTET16 tk, UINT32 passkey);
 extern void smp_mask_enc_key(UINT8 loc_enc_size, UINT8 * p_data);
 extern void smp_rsp_timeout(void *data);
+extern void smp_delayed_auth_complete_timeout(void *data);
 extern void smp_xor_128(BT_OCTET16 a, BT_OCTET16 b);
 extern BOOLEAN smp_encrypt_data (UINT8 *key, UINT8 key_len,
                                  UINT8 *plain_text, UINT8 pt_len,
@@ -529,6 +533,7 @@ extern BOOLEAN smp_calculate_f5_key(UINT8 *w, UINT8 *t);
 extern BOOLEAN smp_calculate_f6(UINT8 *w, UINT8 *n1, UINT8 *n2, UINT8 *r, UINT8 *iocap,
                                UINT8 *a1, UINT8 *a2, UINT8 *f3);
 extern BOOLEAN smp_calculate_h6(UINT8 *w, UINT8 *keyid, UINT8 *h2);
+extern BOOLEAN smp_calculate_h7(UINT8 *salt, UINT8 *w, UINT8 *h2);
 #if SMP_DEBUG == TRUE
 extern void smp_debug_print_nbyte_little_endian (UINT8 *p, const UINT8 *key_name,
                                                  UINT8 len);
diff --git a/stack/smp/smp_keys.c b/stack/smp/smp_keys.c
index a985f97..6860f95 100644
--- a/stack/smp/smp_keys.c
+++ b/stack/smp/smp_keys.c
@@ -1909,6 +1909,11 @@ BOOLEAN smp_calculate_link_key_from_long_term_key(tSMP_CB *p_cb)
     tBTM_SEC_DEV_REC *p_dev_rec;
     BD_ADDR bda_for_lk;
     tBLE_ADDR_TYPE conn_addr_type;
+    BT_OCTET16  salt = {
+        0x31, 0x70, 0x6D, 0x74, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+    };
+
 
     SMP_TRACE_DEBUG ("%s", __func__);
 
@@ -1937,7 +1942,11 @@ BOOLEAN smp_calculate_link_key_from_long_term_key(tSMP_CB *p_cb)
     BT_OCTET16 intermediate_link_key;
     BOOLEAN ret = TRUE;
 
-    ret = smp_calculate_h6(p_cb->ltk, (UINT8 *)"1pmt" /* reversed "tmp1" */,intermediate_link_key);
+    if (p_cb->key_derivation_h7_used)
+        ret = smp_calculate_h7((UINT8*)salt, p_cb->ltk, intermediate_link_key);
+    else
+        ret = smp_calculate_h6(p_cb->ltk, (UINT8 *)"1pmt" /* reversed "tmp1" */,intermediate_link_key);
+
     if (!ret)
     {
         SMP_TRACE_ERROR("%s failed to derive intermediate_link_key", __func__);
@@ -2011,6 +2020,10 @@ BOOLEAN smp_calculate_long_term_key_from_link_key(tSMP_CB *p_cb)
     BOOLEAN ret = TRUE;
     tBTM_SEC_DEV_REC *p_dev_rec;
     UINT8 rev_link_key[16];
+    BT_OCTET16  salt = {
+        0x32, 0x70, 0x6D, 0x74, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+    };
 
     SMP_TRACE_DEBUG ("%s", __FUNCTION__);
 
@@ -2043,9 +2056,17 @@ BOOLEAN smp_calculate_long_term_key_from_link_key(tSMP_CB *p_cb)
     REVERSE_ARRAY_TO_STREAM(p1, p2, 16);
 
     BT_OCTET16 intermediate_long_term_key;
-    /* "tmp2" obtained from the spec */
-    ret = smp_calculate_h6(rev_link_key, (UINT8 *) "2pmt" /* reversed "tmp2" */,
-                           intermediate_long_term_key);
+
+    if (p_cb->key_derivation_h7_used)
+    {
+        ret = smp_calculate_h7((UINT8*)salt, rev_link_key, intermediate_long_term_key);
+    }
+    else
+    {
+        /* "tmp2" obtained from the spec */
+        ret = smp_calculate_h6(rev_link_key, (UINT8 *) "2pmt" /* reversed "tmp2" */,
+                               intermediate_long_term_key);
+    }
 
     if (!ret)
     {
@@ -2145,6 +2166,78 @@ BOOLEAN smp_calculate_h6(UINT8 *w, UINT8 *keyid, UINT8 *c)
 
 /*******************************************************************************
 **
+** Function         smp_calculate_h7
+**
+** Description      The function calculates
+**                  C = h7(SALT, W) = AES-CMAC   (W)
+**                                            SALT
+**                  where
+**                  input:  W is 128 bit,
+**                          SALT is 128 bit,
+**                  output: C is 128 bit.
+**
+** Returns          FALSE if out of resources, TRUE in other cases.
+**
+** Note             The LSB is the first octet, the MSB is the last octet of
+**                  the AES-CMAC input/output stream.
+**
+*******************************************************************************/
+BOOLEAN smp_calculate_h7(UINT8 *salt, UINT8 *w, UINT8 *c)
+{
+#if SMP_DEBUG == TRUE
+    UINT8   *p_print = NULL;
+#endif
+
+    SMP_TRACE_DEBUG ("%s",__FUNCTION__);
+#if SMP_DEBUG == TRUE
+    p_print = w;
+    smp_debug_print_nbyte_little_endian (p_print, (const UINT8 *)"W", BT_OCTET16_LEN);
+    p_print = salt;
+    smp_debug_print_nbyte_little_endian (p_print, (const UINT8 *)"SALT", BT_OCTET16_LEN);
+#endif
+
+    UINT8 *p = NULL;
+    UINT8 key[BT_OCTET16_LEN];
+
+    p = key;
+    ARRAY_TO_STREAM(p, salt, BT_OCTET16_LEN);
+
+#if SMP_DEBUG == TRUE
+    p_print = key;
+    smp_debug_print_nbyte_little_endian (p_print, (const UINT8 *)"K", BT_OCTET16_LEN);
+#endif
+
+    UINT8 msg_len = BT_OCTET16_LEN /* msg size */;
+    UINT8 msg[BT_OCTET16_LEN];
+
+    p = msg;
+    ARRAY_TO_STREAM(p, w, BT_OCTET16_LEN);
+
+#if SMP_DEBUG == TRUE
+    p_print = msg;
+    smp_debug_print_nbyte_little_endian (p_print,(const UINT8 *) "M", msg_len);
+#endif
+
+    BOOLEAN ret = TRUE;
+    UINT8 cmac[BT_OCTET16_LEN];
+    if (!aes_cipher_msg_auth_code(key, msg, msg_len, BT_OCTET16_LEN, cmac))
+    {
+        SMP_TRACE_ERROR("%s failed",__FUNCTION__);
+        ret = FALSE;
+    }
+
+#if SMP_DEBUG == TRUE
+    p_print = cmac;
+    smp_debug_print_nbyte_little_endian (p_print, (const UINT8 *)"AES-CMAC", BT_OCTET16_LEN);
+#endif
+
+    p = c;
+    ARRAY_TO_STREAM(p, cmac, BT_OCTET16_LEN);
+    return ret;
+}
+
+/*******************************************************************************
+**
 ** Function         smp_start_nonce_generation
 **
 ** Description      This function starts nonce generation.
diff --git a/stack/smp/smp_main.c b/stack/smp/smp_main.c
index e05f934..4f02146 100644
--- a/stack/smp/smp_main.c
+++ b/stack/smp/smp_main.c
@@ -240,7 +240,7 @@ static const UINT8 smp_master_entry_map[][SMP_STATE_MAX] =
 /* PAIR_RSP             */{ 0,    0,     0,      1,     0,   0,    0,   0,      0,      0,    0,    0,      0,     0,     0,    0,     0   },
 /* CONFIRM              */{ 0,    0,     0,      0,     0,   1,    0,   0,      0,      0,    0,    0,      0,     0,     0,    0,     0   },
 /* RAND                 */{ 0,    0,     0,      0,     0,   0,    1,   0,      0,      0,    1,    0,      0,     0,     0,    0,     0   },
-/* PAIR_FAIL            */{ 0,    0x81,  0,      0x81,  0x81,0x81, 0x81,0x81,   0x81,   0x81, 0x81, 0x81,   0x81,  0x81,  0,    0,     0   },
+/* PAIR_FAIL            */{ 0,    0x81,  0,      0x81,  0x81,0x81, 0x81,0x81,   0x81,   0x81, 0x81, 0x81,   0x81,  0x81,  0,    0x81,  0   },
 /* ENC_INFO             */{ 0,    0,     0,      0,     0,   0,    0,   0,      0,      0,    0,    0,      0,     0,     0,    1,     0   },
 /* MASTER_ID            */{ 0,    0,     0,      0,     0,   0,    0,   0,      0,      0,    0,    0,      0,     0,     0,    4,     0   },
 /* ID_INFO              */{ 0,    0,     0,      0,     0,   0,    0,   0,      0,      0,    0,    0,      0,     0,     0,    2,     0   },
diff --git a/stack/smp/smp_utils.c b/stack/smp/smp_utils.c
index 0be94c4..04e4713 100644
--- a/stack/smp/smp_utils.c
+++ b/stack/smp/smp_utils.c
@@ -375,6 +375,30 @@ void smp_rsp_timeout(UNUSED_ATTR void *data)
 
 /*******************************************************************************
 **
+** Function         smp_delayed_auth_complete_timeout
+**
+** Description      Called when no pairing failed command received within timeout
+**                  period.
+**
+** Returns          void
+**
+*******************************************************************************/
+void smp_delayed_auth_complete_timeout(UNUSED_ATTR void *data)
+{
+    /*
+     * Waited for potential pair failure. Send SMP_AUTH_CMPL_EVT if
+     * the state is still in bond pending.
+     */
+    if (smp_get_state() == SMP_STATE_BOND_PENDING)
+    {
+        UINT8 reason = SMP_SUCCESS;
+        SMP_TRACE_EVENT("%s sending delayed auth complete.", __func__);
+        smp_sm_event(&smp_cb, SMP_AUTH_CMPL_EVT, &reason);
+    }
+}
+
+/*******************************************************************************
+**
 ** Function         smp_build_pairing_req_cmd
 **
 ** Description      Build pairing request command.
@@ -842,10 +866,12 @@ void smp_cb_cleanup(tSMP_CB   *p_cb)
     SMP_TRACE_EVENT("smp_cb_cleanup");
 
     alarm_free(p_cb->smp_rsp_timer_ent);
+    alarm_free(p_cb->delayed_auth_timer_ent);
     memset(p_cb, 0, sizeof(tSMP_CB));
     p_cb->p_callback = p_callback;
     p_cb->trace_level = trace_level;
     p_cb->smp_rsp_timer_ent = alarm_new("smp.smp_rsp_timer_ent");
+    p_cb->delayed_auth_timer_ent = alarm_new("smp.delayed_auth_timer_ent");
 }
 
 /*******************************************************************************
@@ -1172,7 +1198,13 @@ tSMP_ASSO_MODEL smp_select_association_model(tSMP_CB *p_cb)
         p_cb->le_secure_connections_mode_is_used = TRUE;
     }
 
-    SMP_TRACE_DEBUG("use_sc_process = %d", p_cb->le_secure_connections_mode_is_used);
+    if ((p_cb->peer_auth_req & SMP_H7_SUPPORT_BIT) && (p_cb->loc_auth_req & SMP_H7_SUPPORT_BIT))
+    {
+        p_cb->key_derivation_h7_used = TRUE;
+    }
+
+    SMP_TRACE_DEBUG("use_sc_process = %d, h7 use = %d", p_cb->le_secure_connections_mode_is_used,
+                     p_cb->key_derivation_h7_used);
 
     if (p_cb->le_secure_connections_mode_is_used)
     {
diff --git a/stack/srvc/srvc_dis.c b/stack/srvc/srvc_dis.c
index c17c660..12ae5a5 100644
--- a/stack/srvc/srvc_dis.c
+++ b/stack/srvc/srvc_dis.c
@@ -472,7 +472,7 @@ BOOLEAN DIS_ReadDISInfo(BD_ADDR peer_bda, tDIS_READ_CBACK *p_cback, tDIS_ATTR_MA
 
     if (conn_id == GATT_INVALID_CONN_ID)
     {
-        return GATT_Connect(srvc_eng_cb.gatt_if, peer_bda, TRUE, BT_TRANSPORT_LE);
+        return GATT_Connect(srvc_eng_cb.gatt_if, peer_bda, TRUE, BT_TRANSPORT_LE, false);
     }
 
     return dis_gatt_c_read_dis_req(conn_id);
diff --git a/test/blegatt_test/README.txt b/test/blegatt_test/README.txt
index ef2d8e4..1b4f478 100644
--- a/test/blegatt_test/README.txt
+++ b/test/blegatt_test/README.txt
@@ -79,3 +79,113 @@ specific HCI test mode commands to be added.
 
 
 
+
+proceduredure to create LE-L2CAP Connection Oriented Channal
+============================================================
+Step 1:
+        --> Run the gatt_testtool executable on both side (i.e, peripheral & central)
+
+Step 2:
+        Start Advertisement
+        ===================
+
+        > start_adv <uuid> <flag> ( peripheral side )
+
+        Where,
+                flag     -->    1 (start advertisement)
+                                 0 (stop advertisement)
+
+                option    -->    1 (Doing registration with only Gatt_cb which is required for LE-L2CAP)
+                                 0 (Doing the existing s_registration for gatt_testtool)
+
+        This will start the advertisement and listen for the incoming LE connection.
+
+Step 3:
+        Start&Stop scanning
+        ===================
+
+        > c_scan_start  ( central side )
+        > c_scan_stop ( stop it as and when we find the remote device) ( Central side)
+
+Step 4:
+       listen for incoming LE COC
+       ==========================
+
+        > le_l2cap_listen  <le_psm> <mtu> <mps> <init_credits> <sec_level> ( peripheral side )
+
+        Where,
+                le_psm          -->     1 to 127 (Fixed Range, SIG assigned)
+                                        128 to 255 (Dynamic Range)
+                mtu             -->     23 to 65535
+                mps             -->     23 to 65533
+                init_credits    -->     0 to 65535
+                sec_level       -->     0 for no security
+                                        1 for authentication
+                                -->     2 for encryption
+
+        Example : le_l2cap_listen 128 23 23 100 0
+        Note : MTU value should not be less then MPS
+
+Step 5:
+        Initiate LE COC connection
+        ==========================
+
+        > le_l2cap_coc_connect  <le_psm> <mtu> <mps> <init_credits> <sec_level> <bd_addr> ( central side)
+
+        Where,
+                le_psm          -->     1 to 127 (Fixed Range, SIG assigned)
+                                        128 to 255 (Dynamic Range)
+                mtu             -->     23 to 65535
+                mps             -->     23 to 65533
+                init_credits    -->     0 to 65535
+                bd_addr         -->     remote BD address
+                sec_level       -->     0 for no security
+                                        1 for authentication
+                                -->     2 for encryption
+
+        Example :  le_l2cap_coc_connect 128 23 23 100 0 7e58587530b8
+        Note : MTU value should not be less then MPS
+
+Step 6:
+        Send Credits [LE Credit Based Flow Control Mode]
+        ================================================
+
+        [Initiating the LE credit based flow control with the no.of credits incase of initial credits were
+         not provided i.e set as 0 as part of connection establishment, this command will be ignored
+         if the intial credits were given as part of conneciton establishment.]
+
+        > le_l2cap_coc_flow_ctrl <cid> <credits>
+
+        Where,
+                cid             -->     64 to 127 (Dynamic Range)
+                                        [ Use the allocated CID during LE COC connection initialization]
+                credits         -->     1 to 65535
+
+        Note : When we plan to send this command, the initial credit value has to be set with zero
+               during the initialization LE COC connection.
+
+Step 7:
+        Send file
+        =========
+
+        push the file in to the device "/system" directory which you want to sent.
+
+        > send_file <cid> < file_path >
+
+        Where,
+                cid             -->     64 to 127 (Dynamic Range)
+                                        [ Use the allocated CID during LE COC connection initialization]
+                file_path       -->     give the file path which is going to be sent.
+
+        Example : send_file 65 /system/bt_stack_file.txt
+
+Step 8:
+        Disconnect LE COC
+        =================
+
+        > le_coc_disconnect <cid>
+
+        Where,
+                cid             -->     64 to 127 (Dynamic Range)
+                                        [ Use the allocated CID during LE COC connection initialization]
+
diff --git a/test/blegatt_test/gatt_test.c b/test/blegatt_test/gatt_test.c
index 5820411..982c80c 100644
--- a/test/blegatt_test/gatt_test.c
+++ b/test/blegatt_test/gatt_test.c
@@ -46,7 +46,7 @@
 #include "bt_target.h"
 #include "l2c_api.h"
 #include "bta_api.h"
-
+#include "l2c_int.h"
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <netdb.h>
@@ -102,6 +102,40 @@ static void register_server_cb(int status, int server_if, bt_uuid_t *app_uuid);
 
 static unsigned char main_done = 0;
 static bt_status_t status;
+typedef struct
+{
+    UINT16      result;                 /* Only used in confirm messages */
+    UINT16      credits;                /* used to send the outstanding credits */
+    UINT16      le_psm;
+    UINT16      le_mps;
+    UINT16      le_mtu;
+    UINT16      init_credits;          /* initial credits */
+} tL2CAP_LE_CONN_INFO;
+
+typedef struct
+{
+    BOOLEAN                 in_use;
+    UINT16                  psm;
+    UINT16                  lcid;
+    tL2CAP_LE_CONN_INFO     loc_conn_info;
+    tL2CAP_LE_CONN_INFO     rmt_conn_info;
+    BOOLEAN                 is_server;
+} t_le_chnl_info;
+
+t_le_chnl_info le_chnl_conn_info[MAX_L2CAP_CLIENTS];
+#define LE_ACL_MAX_BUFF_SIZE 4096
+static int num_frames = 1;
+static unsigned long g_delay = 1; /* Default delay before data transfer */
+static int count = 1;
+static UINT16 g_BleEncKeySize = 16;
+//static int g_omps = 0;
+//static int rcv_count = 0;
+static int g_le_coc_if = 0;
+static int rcv_itration = 0;
+static volatile BOOLEAN cong_status = FALSE;
+/* Control channel LE-L2CAP default options */
+static tL2CAP_LE_CONN_INFO le_conn_info;
+static tL2CAP_LE_CFG_INFO local_coc_cfg;
 
 /* Main API */
 static bluetooth_device_t* bt_device;
@@ -157,8 +191,9 @@ L2CAP_CONN_SETUP,
 L2CAP_CONNECTED
 };
 
-static int L2cap_conn_state = L2CAP_NOT_CONNECTED;
+//static int L2cap_conn_state = L2CAP_NOT_CONNECTED;
 static tL2CAP_CFG_INFO tl2cap_cfg_info;
+static long data_size = -1;
 static UINT16           g_PSM           = 0;
 static UINT16           g_lcid          = 0;
 
@@ -208,6 +243,20 @@ static UINT16 do_l2cap_connect(bt_bdaddr_t * bd_addr);
 
 int GetBdAddr(char *p, bt_bdaddr_t *pbd_addr);
 
+/* LE L2CAP functions */
+static t_le_chnl_info *le_allocate_conn_info(UINT16 psm, BOOLEAN is_server);
+static t_le_chnl_info *le_get_conn_info(UINT16 psm, BOOLEAN is_server);
+static t_le_chnl_info *le_get_conn_info_by_lcid(UINT16 lcid);
+static BOOLEAN le_release_conn_info(t_le_chnl_info *le_conn_info);
+UINT8 do_l2cap_DataWrite(UINT16 chnl_id, char *p , UINT32 len);
+static int Send_Data();
+static int send_file(char *p);
+static void le_l2cap_coc_connect(char *svr);
+UINT16 do_le_l2cap_coc_connect(char *p);
+static void le_l2cap_coc_flow_ctrl(char *p);
+UINT16 do_le_l2cap_coc_flow_ctrl(char *p);
+static void do_le_coc_disconnect(char *p);
+int GetFileName(char *p, char *filename);
 
 /************************************************************************************
 **  GATT Client Callbacks
@@ -224,7 +273,7 @@ static void register_client_cb(int status, int client_if, bt_uuid_t *app_uuid)
 
 static void scan_result_cb(bt_bdaddr_t* remote_bd_addr, int rssi, uint8_t* adv_data)
 {
-    printf("%s:: remote_bd_addr=%02x:%02x:%02x:%02x:%02x:%02x, adv_data=0x%x \n",  __FUNCTION__,
+    printf("%s:: remote_bd_addr= %02X%02X%02X%02X%02X%02X , adv_data=0x%x \n",  __FUNCTION__,
     remote_bd_addr->address[0], remote_bd_addr->address[1], remote_bd_addr->address[2],
     remote_bd_addr->address[3], remote_bd_addr->address[4], remote_bd_addr->address[5], *adv_data);
 }
@@ -744,7 +793,7 @@ static int create_cmdjob(char *cmd)
     pthread_t thread_id;
     char *job_cmd;
 
-    job_cmd = malloc(strlen(cmd)+1); /* freed in job handler */
+    job_cmd = (char*)calloc(1, strlen(cmd)+1); /* freed in job handler */
     if (job_cmd) {
        strlcpy(job_cmd, cmd,(strlen(cmd)+1));
       if (pthread_create(&thread_id, NULL,
@@ -964,8 +1013,7 @@ static bool set_wake_alarm(uint64_t delay_millis, bool should_wake, alarm_cb cb,
    new_value.it_interval.tv_sec = 0;
    new_value.it_interval.tv_nsec = 0;
    timer_settime(timer, 0, &new_value, NULL);
-
-  return TRUE;
+   return true;
 }
 
 static int acquire_wake_lock(const char *lock_name)
@@ -1006,7 +1054,35 @@ static bt_os_callouts_t bt_os_callbacks = {
 static void l2test_l2c_connect_ind_cb(BD_ADDR bd_addr, UINT16 lcid, UINT16 psm, UINT8 id)
 {
 
-    if((L2CAP_FCR_ERTM_MODE == g_Fcr_Mode) || (L2CAP_FCR_STREAM_MODE == g_Fcr_Mode)) {
+    UINT16 result;
+
+    local_coc_cfg.credits = L2CAP_LE_DEFAULT_CREDIT;
+    local_coc_cfg.mtu = L2CAP_LE_DEFAULT_MTU;
+    local_coc_cfg.mps = L2CAP_LE_DEFAULT_MPS;
+    /* Verify if LE PSM  */
+   if (L2C_IS_VALID_LE_PSM(psm))
+   {
+       if (psm == 200)
+       {
+           printf("No Resources Available\n");
+           result = L2CAP_LE_NO_RESOURCES;
+           sL2capInterface->LeConnectRsp (bd_addr, id, lcid, result,L2CAP_LE_CONN_OK,&local_coc_cfg);
+       }
+       else if(psm == 201)
+       {
+           printf("L2CAP_LE_CONN_INSUFFI_AUTHORIZATION \n");
+           result = L2CAP_LE_INSUFFICIENT_AUTHORIZATION;
+           sL2capInterface->LeConnectRsp (bd_addr, id, lcid, result,L2CAP_LE_CONN_OK,&local_coc_cfg);
+       }
+       else
+       {
+
+           result = L2CAP_LE_CONN_OK;
+           sL2capInterface->LeConnectRsp (bd_addr, id, lcid, result,L2CAP_LE_CONN_OK,&local_coc_cfg);
+       }
+       return;
+   }
+   if((L2CAP_FCR_ERTM_MODE == g_Fcr_Mode) || (L2CAP_FCR_STREAM_MODE == g_Fcr_Mode)) {
         sL2capInterface->ErtmConnectRsp(bd_addr, id, lcid, L2CAP_CONN_OK, L2CAP_CONN_OK, &t_ertm_info);
     } else {
         sL2capInterface->ConnectRsp(bd_addr, id, lcid, L2CAP_CONN_OK, L2CAP_CONN_OK);
@@ -1027,7 +1103,20 @@ static void l2test_l2c_connect_ind_cb(BD_ADDR bd_addr, UINT16 lcid, UINT16 psm,
 
 static void l2test_l2c_connect_cfm_cb(UINT16 lcid, UINT16 result)
 {
+    t_le_chnl_info *le_conn_info = le_get_conn_info_by_lcid(lcid);
+    if (le_conn_info&&L2C_IS_VALID_LE_PSM(le_conn_info->psm))
+    {
 
+        if (result == L2CAP_LE_CONN_OK) {
+            g_ConnectionState = CONNECT;
+        }
+        else if(le_conn_info && !le_conn_info->is_server)
+        {
+            le_release_conn_info(le_conn_info);
+        }
+        return;
+    }
+#if 0
     if (result == L2CAP_CONN_OK) {
         L2cap_conn_state = L2CAP_CONN_SETUP;
         tL2CAP_CFG_INFO cfg;
@@ -1037,6 +1126,7 @@ static void l2test_l2c_connect_cfm_cb(UINT16 lcid, UINT16 result)
         g_ConnectionState = CONNECT;
         g_lcid = lcid;
     }
+#endif
 }
 
 static void l2test_l2c_connect_pnd_cb(UINT16 lcid)
@@ -1077,6 +1167,13 @@ static void l2test_l2c_config_cfm_cb(UINT16 lcid, tL2CAP_CFG_INFO *p_cfg)
 
 static void l2test_l2c_disconnect_ind_cb(UINT16 lcid, BOOLEAN ack_needed)
 {
+    t_le_chnl_info *le_conn_info = le_get_conn_info_by_lcid(lcid);
+    /* release the conn info entry if it'a  client */
+    if(le_conn_info &&  !le_conn_info->is_server)
+    {
+        le_release_conn_info(le_conn_info);
+    }
+    printf("l2test_le_l2c_disconnect_ind_cb, cid=0x%x, acks=%d\n", lcid, ack_needed);
     if (ack_needed)
     {
         /* send L2CAP disconnect response */
@@ -1087,6 +1184,14 @@ static void l2test_l2c_disconnect_ind_cb(UINT16 lcid, BOOLEAN ack_needed)
 }
 static void l2test_l2c_disconnect_cfm_cb(UINT16 lcid, UINT16 result)
 {
+    t_le_chnl_info *le_conn_info = le_get_conn_info_by_lcid(lcid);
+    /* release the conn info entry if it'a  client */
+    if(le_conn_info &&  !le_conn_info->is_server)
+    {
+        le_release_conn_info(le_conn_info);
+    }
+
+    printf("l2test_le_l2c_disconnect_cfm_cb, cid=0x%x, result=%d\n", lcid, result);
     g_ConnectionState = DISCONNECT;
     g_lcid = 0;
 }
@@ -1096,11 +1201,18 @@ static void l2test_l2c_QoSViolationInd(BD_ADDR bd_addr)
 }
 static void l2test_l2c_data_ind_cb(UINT16 lcid, BT_HDR *p_buf)
 {
-     printf("l2test_l2c_data_ind_cb:: event=%u, len=%u, offset=%u, layer_specific=%u\n", p_buf->event, p_buf->len, p_buf->offset, p_buf->layer_specific);
+    rcv_itration++;
+    printf("l2test_l2c_data_ind_cb:: itration=%d, event=%u, len=%u, "\
+            "offset=%u, layer_specific=%u\n",rcv_itration, p_buf->event,
+            p_buf->len, p_buf->offset, p_buf->layer_specific);
+    sL2capInterface->LeFreeBuf(p_buf);
+    printf("l2test_l2c_data_ind_cb:: event=%u, len=%u, offset=%u, layer_specific=%u\n",
+            p_buf->event, p_buf->len, p_buf->offset, p_buf->layer_specific);
 }
 static void l2test_l2c_congestion_ind_cb(UINT16 lcid, BOOLEAN is_congested)
 {
-    printf("l2test_l2c_congestion_ind_cb\n");
+    cong_status = is_congested;
+    printf("l2test_l2c_congestion_ind_cb is_congested %d\n ", is_congested);
 }
 
 static void l2test_l2c_tx_complete_cb (UINT16 lcid, UINT16 NoOfSDU)
@@ -1114,6 +1226,79 @@ static void l2c_echo_rsp_cb(UINT16 p)
     printf("Ping Response = %s\n", (L2CAP_PING_RESULT_OK==p) ?"Ping Reply OK" :(L2CAP_PING_RESULT_NO_LINK==p) ?"Link Could Not be setup" :"Remote L2cap did not reply");
 }
 */
+/*LE-L2CAP Callback*/
+
+#if 0
+
+static void l2test_le_connect_ind_cb(BD_ADDR bd_addr, UINT16 lcid, UINT8 id,
+                                    tL2CAP_LE_CONN_INFO *conn_info)
+{
+    printf(" l2test_le_connect_ind_cb\n lcid=%u\n id=%u\n ls_psm %d\n "\
+            "le_mtu %d\n le_mps %d\n", lcid, id, conn_info->le_psm,
+            conn_info->le_mtu, conn_info->le_mps);
+    t_le_chnl_info *le_conn_info;
+    if (conn_info->le_psm == 200)
+    {
+        printf("No Resources Available\n");
+        conn_info->result = L2CAP_LE_NO_RESOURCES;
+        sL2capInterface->LeConnectRsp (bd_addr, id, lcid, conn_info);
+        return;
+    }
+    else if(conn_info->le_psm == 201)
+    {
+        printf("L2CAP_LE_CONN_INSUFFI_AUTHORIZATION \n");
+        conn_info->result = L2CAP_LE_INSUFFICIENT_AUTHORIZATION;
+        sL2capInterface->LeConnectRsp (bd_addr, id, lcid, conn_info);
+        return;
+    }
+
+    le_conn_info = le_get_conn_info(conn_info->le_psm, TRUE);
+
+    if(le_conn_info)
+    {
+        le_conn_info->loc_conn_info.result = L2CAP_LE_CONN_OK;
+        le_conn_info->lcid = lcid;
+        sL2capInterface->LeConnectRsp (bd_addr, id, lcid,
+                &le_conn_info->loc_conn_info);
+        memcpy(&le_conn_info->rmt_conn_info, conn_info,
+                sizeof(tL2CAP_LE_CONN_INFO));
+        g_ConnectionState = CONNECT;
+    }
+    else
+    {
+        printf("No PSM registered \n");
+        conn_info->result = L2CAP_LE_NO_PSM;
+        sL2capInterface->LeConnectRsp (bd_addr, id, lcid, conn_info);
+        return;
+    }
+}
+
+static void l2test_le_connect_cfm_cb(UINT16 lcid,
+        tL2CAP_LE_CONN_INFO *conn_info)
+{
+    t_le_chnl_info *le_conn_info;
+
+    printf(" l2test_le_connect_cfm_cb\n lcid=%u\n ls_psm %d\n le_mtu %d\n "\
+            "le_mps %d\n result %d\n",lcid, conn_info->le_psm,
+            conn_info->le_mtu, conn_info->le_mps, conn_info->result);
+
+    le_conn_info = le_get_conn_info(conn_info->le_psm, FALSE);
+
+    if (conn_info->result == L2CAP_LE_CONN_OK) {
+        g_ConnectionState = CONNECT;
+        if(le_conn_info)
+        {
+            memcpy(&le_conn_info->rmt_conn_info, conn_info,
+                    sizeof(tL2CAP_LE_CONN_INFO));
+            le_conn_info->lcid = lcid;
+        }
+    }
+    else if(le_conn_info && !le_conn_info->is_server)
+    {
+        le_release_conn_info(le_conn_info);
+    }
+}
+#endif
 
 /* L2CAP callback function structure */
 static tL2CAP_APPL_INFO l2test_l2c_appl = {
@@ -1944,6 +2129,7 @@ void do_l2cap_init(char *p)
 {
 
     memset(&tl2cap_cfg_info, 0, sizeof(tl2cap_cfg_info));
+    memset(&le_conn_info, 0, sizeof(le_conn_info));
     //Use macros for the constants
     tl2cap_cfg_info.mtu_present = TRUE;
     tl2cap_cfg_info.mtu = g_imtu;
@@ -1954,7 +2140,10 @@ void do_l2cap_init(char *p)
     tl2cap_cfg_info.fcr.mode = g_Fcr_Mode;
     tl2cap_cfg_info.fcs = 0;
     tl2cap_cfg_info.fcs_present = 1;
-
+    le_conn_info.init_credits = L2CAP_LE_MAX_CREDIT;
+    le_conn_info.le_mtu = L2CAP_LE_DEFAULT_MTU;
+    le_conn_info.le_mps = L2CAP_LE_DEFAULT_MPS;
+    le_conn_info.le_psm = 0x80; //dynamic le psm starts from 0x80
     if(L2CAP_FCR_ERTM_MODE == tl2cap_cfg_info.fcr.mode)
     {
         tl2cap_cfg_info.fcr = ertm_fcr_opts_def;
@@ -1963,6 +2152,12 @@ void do_l2cap_init(char *p)
     {
         tl2cap_cfg_info.fcr = stream_fcr_opts_def;
     }
+    //Load L2cap Interface
+    else if(NULL == sL2capInterface)
+    {
+        printf("Get L2cap testapp interfaces\n");
+        sL2capInterface = sBtInterface->get_testapp_interface(TEST_APP_L2CAP);
+    }
     tl2cap_cfg_info.fcr.tx_win_sz = 3;
     //Initialize ERTM Parameters
     t_ertm_info.preferred_mode = g_Fcr_Mode;
@@ -2014,8 +2209,363 @@ BOOLEAN do_l2cap_disconnect(char *p)
     return sL2capInterface->DisconnectReq(g_lcid);
 }
 
+/* LE-L2CAP functionalities */
+static t_le_chnl_info *le_allocate_conn_info(UINT16 psm, BOOLEAN is_server)
+{
+    t_le_chnl_info    *p_le_chnl_info = &le_chnl_conn_info[0];
+    UINT16      i;
+
+    for (i = 0; i < MAX_L2CAP_CLIENTS; i++, p_le_chnl_info++)
+    {
+        if (!p_le_chnl_info->in_use)
+        {
+            p_le_chnl_info->in_use = TRUE;
+            p_le_chnl_info->is_server = is_server;
+            p_le_chnl_info->psm    = psm;
+            return p_le_chnl_info;
+        }
+    }
+    return (NULL);
+
+}
+
+static t_le_chnl_info *le_get_conn_info(UINT16 psm, BOOLEAN is_server)
+{
+    t_le_chnl_info    *p_le_chnl_info = &le_chnl_conn_info[0];
+    UINT16      i;
+
+    for (i = 0; i < MAX_L2CAP_CLIENTS; i++, p_le_chnl_info++)
+    {
+        if ((p_le_chnl_info->in_use) && (p_le_chnl_info->psm == psm)
+                && (is_server == p_le_chnl_info->is_server))
+        {
+            return p_le_chnl_info;
+        }
+    }
+    return NULL;
+
+}
+
+static t_le_chnl_info *le_get_conn_info_by_lcid(UINT16 lcid)
+{
+    t_le_chnl_info    *p_le_chnl_info = &le_chnl_conn_info[0];
+    UINT16      i;
+
+    for (i = 0; i < MAX_L2CAP_CLIENTS; i++, p_le_chnl_info++)
+    {
+        if ((p_le_chnl_info->in_use) && (p_le_chnl_info->lcid == lcid))
+        {
+            return p_le_chnl_info;
+        }
+    }
+    return NULL;
+
+}
+
+static BOOLEAN le_release_conn_info(t_le_chnl_info *le_conn_info)
+{
+    if (le_conn_info && (le_conn_info->in_use))
+    {
+        le_conn_info->in_use = FALSE;
+        le_conn_info->is_server = 0;
+        le_conn_info->psm    = 0;
+        memset(le_conn_info, 0, sizeof(tL2CAP_LE_CONN_INFO));
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static void do_start_advertisment(char *p)
+{
+    tBT_UUID    uuid;
+    int option = get_int(&p, -1);
+    int start = get_int(&p, -1);
+
+    uuid.len = LEN_UUID_128;
+    memcpy(&uuid.uu.uuid128, "\x11\x22\xA0\x0D\x00\x00\x00\x00\x01\x23\x45\x67\x89\xAB\xCD\xEF", 16); //1122A00D-0000-0000-0123-456789ABCDEF
+
+    if ((g_le_coc_if == 0) && option)
+        g_le_coc_if = sGattInterface->Register(&uuid, &sGattCB);
+    printf("Gatt Registration Done\n");
+
+    if( option)
+    {
+        if (start == 1)
+            status = sGattInterface->Listen(g_le_coc_if, start, NULL);
+        else if (start == 0)
+            status = sGattInterface->Listen(g_le_coc_if, start, NULL);
+        else
+        {
+            printf("Unknown parameter\n");
+            return;
+        }
+    }
+    else
+    {
+        if (start == 1)
+            status = sGattInterface->Listen(g_server_if_scan, start, NULL);
+        else if (start == 0)
+            status = sGattInterface->Listen(g_server_if_scan, start, NULL);
+        else
+        {
+            printf("Unknown parameter\n");
+            return;
+        }
+    }
+    printf("Gatt Listen status is %d\n", status);
+}
+
+UINT16 do_le_l2cap_coc_flow_ctrl(char *p)
+{
+    UINT16 lcid = get_int(&p, -1);
+
+    UINT16 credits = get_int(&p, -1);
+
+    printf("\ndo_le_l2cap_coc_flow_ctrl lcid = %d, credits = %d\n", lcid, credits);
+    return sL2capInterface->LeFlowControl(lcid, credits);
+}
+static void le_l2cap_coc_flow_ctrl(char *p)
+{
+    printf("In le_l2cap_coc_flow_ctrl\n");
+    do_le_l2cap_coc_flow_ctrl(p);
+}
+
+UINT16 do_le_l2cap_coc_connect(char *p)
+{
+    int le_initiator_sec_level;
+    UINT16 le_coc_seclevel = 0;
+    bt_bdaddr_t bd_addr = {{0}};
+    UINT16 le_psm = get_int(&p, -1);
 
 
+    t_le_chnl_info *le_conn_info = le_allocate_conn_info(le_psm, FALSE);
+
+    if(le_conn_info)
+    {
+        le_conn_info->loc_conn_info.le_psm = le_psm;
+        le_conn_info->loc_conn_info.le_mtu = get_int(&p, -1);
+        le_conn_info->loc_conn_info.le_mps = get_int(&p, -1);
+        le_conn_info->loc_conn_info.init_credits = get_int(&p, -1);
+        le_initiator_sec_level = get_int(&p, -1);
+        if(FALSE == GetBdAddr(p, &bd_addr))    return FALSE;
+    }
+    else
+        return FALSE;
+
+    if (le_initiator_sec_level == 0)
+    {
+        le_coc_seclevel |= BTM_SEC_NONE;
+    }
+    else if (le_initiator_sec_level == 1)
+    {
+        le_coc_seclevel |= BTM_SEC_OUT_AUTHENTICATE;
+    }
+    else if (le_initiator_sec_level == 2)
+    {
+        le_coc_seclevel |= BTM_SEC_OUT_ENCRYPT;
+        le_coc_seclevel |= BTM_SEC_OUT_AUTHENTICATE;
+    }
+    else
+    {
+        printf("Security level not supported");
+        return FALSE;
+    }
+
+    printf("g_SecLevel = %d \n", le_coc_seclevel);
+    sL2capInterface->RegisterLePsm(le_conn_info->loc_conn_info.le_psm, TRUE,
+            le_coc_seclevel, g_BleEncKeySize);
+    sleep(3);
+    local_coc_cfg.credits = le_conn_info->loc_conn_info.init_credits;
+    local_coc_cfg.mtu = le_conn_info->loc_conn_info.le_mtu;
+    local_coc_cfg.mps = le_conn_info->loc_conn_info.le_mps;
+    printf("\ndo_l2cap_connect:::::::: psm %d mtu %d mps %d init_credit %d \n",
+            le_conn_info->loc_conn_info.le_psm, le_conn_info->loc_conn_info.le_mtu,
+            le_conn_info->loc_conn_info.le_mps, le_conn_info->loc_conn_info.init_credits);
+
+    return sL2capInterface->LeConnect(le_conn_info->loc_conn_info.le_psm, ( UINT8 * )&bd_addr.address, &local_coc_cfg);
+}
+
+static void le_l2cap_coc_connect(char *svr)
+{
+    do_le_l2cap_coc_connect(svr);
+}
+
+static void le_l2cap_listen(char *p)
+{
+    int le_rspndr_sec_level;
+    UINT16 le_coc_seclevel = 0;
+    UINT16 le_psm = get_int(&p, -1);
+    t_le_chnl_info *le_conn_info = le_get_conn_info(le_psm, TRUE);
+
+    if(!le_conn_info)
+    {
+        le_conn_info = le_allocate_conn_info(le_psm, TRUE);
+    }
+    else
+    {
+        printf("ALready listening on same channel");
+        return;
+    }
+
+    if(le_conn_info)
+    {
+        le_conn_info->loc_conn_info.le_psm = le_psm;
+        le_conn_info->loc_conn_info.le_mtu = get_int(&p, -1);
+        le_conn_info->loc_conn_info.le_mps = get_int(&p, -1);
+        le_conn_info->loc_conn_info.init_credits = get_int(&p, -1);
+        le_rspndr_sec_level = get_int(&p, -1);
+    }
+    else
+        return;
+
+    if (le_rspndr_sec_level == 0)
+    {
+        le_coc_seclevel |= BTM_SEC_NONE;
+    }
+    else if (le_rspndr_sec_level == 1)
+    {
+        le_coc_seclevel |= BTM_SEC_IN_AUTHENTICATE;
+    }
+    else if (le_rspndr_sec_level == 2)
+    {
+        le_coc_seclevel |= BTM_SEC_IN_ENCRYPT;
+        le_coc_seclevel |= BTM_SEC_IN_AUTHENTICATE;
+    }
+    else
+    {
+        printf("Security level not supported");
+        return ;
+    }
+    printf("g_SecLevel = %d \n", le_coc_seclevel);
+
+    sL2capInterface->RegisterLePsm(le_conn_info->loc_conn_info.le_psm, FALSE,
+                                           le_coc_seclevel, g_BleEncKeySize);
+
+    printf("Waiting for Incoming connection for LE PSM %d... \n",
+                              le_conn_info->loc_conn_info.le_psm);
+}
+
+UINT8 do_l2cap_DataWrite(UINT16 chnl_id, char *p , UINT32 len)
+{
+    return sL2capInterface->DataWrite(chnl_id, p, len);
+}
+
+static int send_file(char *p)
+{
+    uint32_t seq = 0, itration = 1;
+    int fd, size;
+    char filename[] = {0};
+    char tmpBuf[LE_ACL_MAX_BUFF_SIZE];
+    UINT16 lcid;
+
+    lcid = get_int(&p, -1);
+    t_le_chnl_info *le_conn_info = le_get_conn_info_by_lcid(lcid);
+    GetFileName(p, filename);
+
+    if(!le_conn_info)
+    {
+        printf("No conn info, exit \n");
+        return FALSE;
+    }
+
+    g_omtu =  le_conn_info->rmt_conn_info.le_mtu;
+
+    if(g_omtu < LE_ACL_MAX_BUFF_SIZE)
+        data_size = g_omtu;
+    else
+        data_size = LE_ACL_MAX_BUFF_SIZE;
+
+    printf("data_size(max patload size) = %ld, g_omtu(max ttansmission unit) = %d",
+            data_size, g_omtu);
+
+    printf("Filename for input data = %s \n", filename);
+
+    if ((fd = open(filename, O_RDONLY)) < 0)
+    {
+        printf("Open failed: %s (%d)\n", strerror(errno), errno);
+        exit(1);
+    }
+    while (1)
+    {
+        while(cong_status)
+        {
+            usleep(50 * 1000);
+        }
+        if((size = read(fd, tmpBuf, data_size)) <= 0)
+        {
+            printf("\n File end ");
+            break;
+        }
+        printf("Sending data :: itration %d, omtu %d, writing data size %d\n",
+                itration, g_omtu, size);
+        do_l2cap_DataWrite(lcid, tmpBuf, size);
+        itration++;
+    }
+
+    if (num_frames && g_delay && count && !(seq % count))
+        usleep(g_delay);
+    return TRUE;
+}
+
+static int Send_Data(char *p)
+{
+    //uint32_t seq =0;
+    int send_mode;
+    UINT16 lcid;
+
+    lcid = get_int(&p, -1);
+    send_mode = get_int(&p, -1);
+
+    char tmpBuffer_1[] = {
+        0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
+        0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
+        0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
+        0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
+        0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
+        0x7F
+    };
+    char tmpBuffer_2[] = {
+        0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
+        0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
+        0x7F,0x7F,0x7F
+    };
+
+    if(send_mode == 1)  // segmented
+    {
+        printf("Sending Segmented data...\nData written len %d...\n",
+                sizeof(tmpBuffer_1) );
+        do_l2cap_DataWrite(lcid, tmpBuffer_1, sizeof(tmpBuffer_1));
+    }
+    else if( send_mode == 0) // unsegmented
+    {
+        printf("Sending Unsegmented data...\nData written len %d...\n",
+                sizeof(tmpBuffer_2) );
+        do_l2cap_DataWrite(lcid, tmpBuffer_2, sizeof(tmpBuffer_2));
+    }
+    return TRUE;
+}
+
+static void send_data_on_le_coc(char *svr)
+{
+    printf("Sending data on LE L2CAP CoC...\n");
+    Send_Data(svr);
+}
+static void do_send_file(char *svr)
+{
+    printf("Sending file on LE L2CAP CoC...\n");
+    send_file(svr);
+}
+
+BOOLEAN le_coc_disc(char *p)
+{
+    UINT16 cid = get_int(&p, -1);
+    return sL2capInterface->DisconnectReq(cid);
+}
+
+static void do_le_coc_disconnect(char *p)
+{
+    le_coc_disc(p);
+}
 
 /*******************************************************************************
  ** SMP API commands
@@ -2243,6 +2793,36 @@ const t_cmd console_cmd_list[] =
     { "l2cap_send_data_cid", do_l2cap_send_data_cid, ":: BdAddr<00112233445566>, CID<>", 0 },
 
     { "set_local_name", do_set_localname, ":: setName<name>", 0 },
+    /* LE-L2CAP cmds */
+    { " ", NULL, "\n\t\t\033[0m\033[34mLE L2CAP CoC Commands\033[0m", 0 },
+    { " ", NULL, "\033[0m\033[34mCommands\t\t\tParameters\033[0m", 0 },
+
+    { "start_adv", do_start_advertisment, "\t\t::\tuuid [0 - register"\
+        "none (or) 1 - register uuid] , \n\t\t\t\tflag [0- stop adv (or) "\
+        "1 - start adv] \n  " , 0},
+
+    { "le_l2cap_listen", le_l2cap_listen, "\t::\tle_psm [1 to 255], "\
+        "\n\t\t\t\tle_mtu [23 to 65535], \n\t\t\t\tle_mps [23 to 65533],"\
+        " \n\t\t\t\tinit_credits [0 to 65535], \n\t\t\t\tsec_level "\
+        "[0 - None, 1 - Authentication, 2 - Auth and Encryption]", 0},
+
+    { "le_l2cap_coc_connect", le_l2cap_coc_connect, "\t::\tle_psm [128 to 255],"\
+        "\n\t\t\t\tle_mtu [23 to 65535], \n\t\t\t\tle_mps [23 to 65533], "\
+        "\n\t\t\t\tinit_credits [0 to 65535], \n\t\t\t\tsec_level [0 - None,"\
+        " 1 - Authentication, 2 - Encryption], \n\t\t\t\tbd_addr [001122334455] ", 0},
+
+    { "le_l2cap_coc_flow_ctrl", le_l2cap_coc_flow_ctrl, "\t::\tchnl_id [chnl id"\
+        "info from conn_ind or conn_cnf], \n\t\t\t\tcredits [1 to 65535]", 0},
+
+    { "send_data_on_le_coc", send_data_on_le_coc, "\t::\tchnl_id [chnl id info "\
+        "from conn_ind or conn_cnf] , \n\t\t\t\tdata_type [0 - Unsegmented data ,"\
+        "1 - Segmented data]", 0},
+
+    { "send_file", do_send_file, "\t\t::\tchnl_id [chnl_id info from conn_ind"\
+        "or conn_cnf], \n\t\t\t\tfile_name", 0},
+
+    { "le_coc_disconnect", do_le_coc_disconnect, "\t::\tchnl_id [chnl_id info"\
+        "from conn_ind or conn_cnf]", 0},
     /* add here */
 
     /* last entry */
@@ -2282,9 +2862,12 @@ static void process_cmd(char *p, unsigned char is_job)
         for(i=0; i<6; i++) {
             pincode.pin[i] = cmd[i];
         }
+        pincode.pin[i] = '\0';
         if(BT_STATUS_SUCCESS != sBtInterface->pin_reply(remote_bd_address, TRUE, strlen((const char*)pincode.pin), &pincode)) {
             printf("Pin Reply failed\n");
         }
+        else
+            printf("Pin Reply done and paired\n");
         //flush the char for pinkey
         cmd[6] = 0;
     }
@@ -2363,8 +2946,27 @@ int main (int argc, char * argv[])
 
     return 0;
 }
+int GetFileName(char *p, char *filename)
+{
+//    uint8_t  i;
+    int len;
+
+    skip_blanks(&p);
 
+    printf("Input file name = %s\n", p);
 
+    if (p == NULL)
+    {
+        printf("\nInvalid File Name... Please enter file name\n");
+        return FALSE;
+    }
+    len = strlen(p);
+
+    memcpy(filename, p, len);
+    filename[len] = '\0';
+
+    return TRUE;
+}
 int GetBdAddr(char *p, bt_bdaddr_t *pbd_addr)
 {
     char Arr[13] = {0};
diff --git a/test/bluedroidtest/bluedroidtest.c b/test/bluedroidtest/bluedroidtest.c
index b19e036..114ec0b 100644
--- a/test/bluedroidtest/bluedroidtest.c
+++ b/test/bluedroidtest/bluedroidtest.c
@@ -125,7 +125,7 @@ static void bdt_shutdown(void)
 static void config_permissions(void)
 {
     struct __user_cap_header_struct header;
-    struct __user_cap_data_struct cap;
+    struct __user_cap_data_struct cap[2];
 
     bdt_log("set_aid_and_cap : pid %d, uid %d gid %d", getpid(), getuid(), getgid());
 
@@ -136,17 +136,25 @@ static void config_permissions(void)
     setuid(AID_BLUETOOTH);
     setgid(AID_BLUETOOTH);
 
-    header.version = _LINUX_CAPABILITY_VERSION;
-
-    cap.effective = cap.permitted =  cap.inheritable =
-                    1 << CAP_NET_RAW |
-                    1 << CAP_NET_ADMIN |
-                    1 << CAP_NET_BIND_SERVICE |
-                    1 << CAP_SYS_RAWIO |
-                    1 << CAP_SYS_NICE |
-                    1 << CAP_SETGID;
-
-    capset(&header, &cap);
+    header.version = _LINUX_CAPABILITY_VERSION_3;
+
+    cap[CAP_TO_INDEX(CAP_NET_RAW)].permitted |= CAP_TO_MASK(CAP_NET_RAW);
+    cap[CAP_TO_INDEX(CAP_NET_ADMIN)].permitted |= CAP_TO_MASK(CAP_NET_ADMIN);
+    cap[CAP_TO_INDEX(CAP_NET_BIND_SERVICE)].permitted |= CAP_TO_MASK(CAP_NET_BIND_SERVICE);
+    cap[CAP_TO_INDEX(CAP_SYS_RAWIO)].permitted |= CAP_TO_MASK(CAP_SYS_RAWIO);
+    cap[CAP_TO_INDEX(CAP_SYS_NICE)].permitted |= CAP_TO_MASK(CAP_SYS_NICE);
+    cap[CAP_TO_INDEX(CAP_SETGID)].permitted |= CAP_TO_MASK(CAP_SETGID);
+    cap[CAP_TO_INDEX(CAP_WAKE_ALARM)].permitted |= CAP_TO_MASK(CAP_WAKE_ALARM);
+
+    cap[CAP_TO_INDEX(CAP_NET_RAW)].effective |= CAP_TO_MASK(CAP_NET_RAW);
+    cap[CAP_TO_INDEX(CAP_NET_ADMIN)].effective |= CAP_TO_MASK(CAP_NET_ADMIN);
+    cap[CAP_TO_INDEX(CAP_NET_BIND_SERVICE)].effective |= CAP_TO_MASK(CAP_NET_BIND_SERVICE);
+    cap[CAP_TO_INDEX(CAP_SYS_RAWIO)].effective |= CAP_TO_MASK(CAP_SYS_RAWIO);
+    cap[CAP_TO_INDEX(CAP_SYS_NICE)].effective |= CAP_TO_MASK(CAP_SYS_NICE);
+    cap[CAP_TO_INDEX(CAP_SETGID)].effective |= CAP_TO_MASK(CAP_SETGID);
+    cap[CAP_TO_INDEX(CAP_WAKE_ALARM)].effective |= CAP_TO_MASK(CAP_WAKE_ALARM);
+
+    capset(&header, &cap[0]);
     setgroups(sizeof(groups)/sizeof(groups[0]), groups);
 }
 
diff --git a/test/mcap_tool/mcap_tool.c b/test/mcap_tool/mcap_tool.c
index 736d517..861aaf6 100644
--- a/test/mcap_tool/mcap_tool.c
+++ b/test/mcap_tool/mcap_tool.c
@@ -527,7 +527,7 @@ static int create_cmdjob(char *cmd)
 {
     pthread_t thread_id;
     char *job_cmd;
-    job_cmd = malloc(strlen(cmd)+1); /* freed in job handler */
+    job_cmd = (char*)calloc(1, strlen(cmd)+1); /* freed in job handler */
     if(job_cmd)
     {
         strlcpy(job_cmd, cmd, strlen(job_cmd)+1);
diff --git a/test/rfcommtest/rfcommtest.c b/test/rfcommtest/rfcommtest.c
index 68b9b60..2159daf 100644
--- a/test/rfcommtest/rfcommtest.c
+++ b/test/rfcommtest/rfcommtest.c
@@ -438,7 +438,7 @@ static int create_cmdjob(char *cmd)
     pthread_t thread_id;
     char *job_cmd;
 
-    job_cmd = malloc(strlen(cmd)+1); /* freed in job handler */
+    job_cmd = (char*)calloc(1, strlen(cmd)+1); /* freed in job handler */
     if (job_cmd)
     {
         strlcpy(job_cmd, cmd, sizeof(job_cmd));
diff --git a/udrv/ulinux/uipc.c b/udrv/ulinux/uipc.c
index c64a7ae..c5cf905 100644
--- a/udrv/ulinux/uipc.c
+++ b/udrv/ulinux/uipc.c
@@ -67,6 +67,9 @@
 
 #define UIPC_FLUSH_BUFFER_SIZE 1024
 
+#define CHAN_CREATE_WAIT_TIME_MS 30
+#define CHAN_CREATE_RETRY_COUNT 10
+
 /*****************************************************************************
 **  Local type definitions
 ******************************************************************************/
@@ -143,6 +146,7 @@ const char* dump_uipc_event(tUIPC_EVENT event)
 
 static inline int create_server_socket(const char* name)
 {
+    int ret;
     int s = socket(AF_LOCAL, SOCK_STREAM, 0);
     if (s < 0)
         return -1;
@@ -151,9 +155,10 @@ static inline int create_server_socket(const char* name)
 
     if(osi_socket_local_server_bind(s, name, ANDROID_SOCKET_NAMESPACE_ABSTRACT) < 0)
     {
+        ret = (errno == EADDRINUSE ? -EADDRINUSE : -1);
         BTIF_TRACE_EVENT("socket failed to create (%s)", strerror(errno));
         close(s);
-        return -1;
+        return ret;
     }
 
     if(listen(s, 5) < 0)
@@ -350,6 +355,7 @@ static inline void uipc_wakeup_locked(void)
 static int uipc_setup_server_locked(tUIPC_CH_ID ch_id, char *name, tUIPC_RCV_CBACK *cback)
 {
     int fd;
+    int i;
 
     BTIF_TRACE_EVENT("SETUP CHANNEL SERVER %d", ch_id);
 
@@ -358,7 +364,19 @@ static int uipc_setup_server_locked(tUIPC_CH_ID ch_id, char *name, tUIPC_RCV_CBA
 
     UIPC_LOCK();
 
-    fd = create_server_socket(name);
+    for (i = 0; i < CHAN_CREATE_RETRY_COUNT; i++)
+    {
+        fd = create_server_socket(name);
+        if (fd == -EADDRINUSE)
+        {
+            BTIF_TRACE_ERROR("Address already in use, retry: %d", i);
+            usleep(CHAN_CREATE_WAIT_TIME_MS * 1000);
+        }
+        else
+        {
+            break;
+        }
+    }
 
     if (fd < 0)
     {
diff --git a/vendor_libs/linux/bt_vendor_linux.c b/vendor_libs/linux/bt_vendor_linux.c
index eec3e01..41abc8a 100644
--- a/vendor_libs/linux/bt_vendor_linux.c
+++ b/vendor_libs/linux/bt_vendor_linux.c
@@ -202,10 +202,10 @@ static int bt_vendor_wait_hcidev(void)
     }
 
     if (fds[0].revents & POLLIN) {
-      n = read(fd, &ev, sizeof(struct mgmt_pkt));
+      OSI_NO_INTR(n = read(fd, &ev, sizeof(struct mgmt_pkt)));
       if (n < 0) {
-        LOG_ERROR(LOG_TAG,
-                  "Error reading control channel");
+        LOG_ERROR(LOG_TAG, "Error reading control channel: %s",
+                  strerror(errno));
         ret = -1;
         break;
       }

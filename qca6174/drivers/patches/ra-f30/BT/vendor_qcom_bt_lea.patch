diff --git a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/AvrcpTestActivity.java b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/AvrcpTestActivity.java
new file mode 100644
index 0000000..d925da0
--- /dev/null
+++ b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/AvrcpTestActivity.java
@@ -0,0 +1,993 @@
+/*
+ * Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of The Linux Foundation nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+package org.codeaurora.bluetooth.bttestapp;
+
+import android.app.ActionBar;
+import android.app.DialogFragment;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothAvrcpController;
+import android.bluetooth.BluetoothAvrcpInfo;
+import android.bluetooth.BluetoothProfile;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.SystemProperties;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.widget.Button;
+import android.widget.Toast;
+import android.widget.ToggleButton;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.content.ContentResolver;
+import android.os.Handler;
+import android.os.Process;
+import android.net.Uri;
+import android.widget.TextView;
+import android.app.Activity;
+import java.util.concurrent.TimeUnit;
+
+import org.codeaurora.bluetooth.bttestapp.R;
+import org.codeaurora.bluetooth.bttestapp.util.Logger;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.locks.ReentrantLock;
+import android.database.CursorIndexOutOfBoundsException;
+import android.database.sqlite.SQLiteCantOpenDatabaseException;
+import android.database.sqlite.SQLiteException;
+
+public class AvrcpTestActivity extends MonkeyActivity implements IBluetoothConnectionObserver {
+
+    private final String TAG = "AvrcpTestActivity";
+    private boolean ffPressed = false;
+
+    private ActionBar mActionBar = null;
+    private UpdateThread mUpdateThread;
+    private PressandHoldHandler mPressandHoldHandler;
+    private View appView;
+    private Activity mLocalActivity;
+    private final ReentrantLock mLock = new ReentrantLock();
+    BluetoothAvrcpController mAvrcpController;
+    ProfileService mProfileService = null;
+    BluetoothDevice mDevice;
+    BluetoothAvrcpShareContentObserver mAvrcpDataObserver = null;
+    private class PlayerSettings
+    {
+        public byte attr_Id;
+        public byte attr_val;
+        public byte [] supported_values; // app shld check these values before Setting Player Attributes.
+    };
+    ArrayList<PlayerSettings> plSetting= null;
+    int remoteSupportedFeatures = 0;
+    public static final int KEY_STATE_PRESSED = 0;
+    public static final int KEY_STATE_RELEASED = 1;
+    public static final int AVRC_ID_PLAY = 0x44;
+    public static final int AVRC_ID_PAUSE = 0x46;
+    public static final int AVRC_ID_VOL_UP = 0x41;
+    public static final int AVRC_ID_VOL_DOWN = 0x42;
+    public static final int AVRC_ID_STOP = 0x45;
+    public static final int AVRC_ID_FF = 0x49;
+    public static final int AVRC_ID_REWIND = 0x48;
+    public static final int AVRC_ID_FORWARD = 0x4B;
+    public static final int AVRC_ID_BACKWARD = 0x4C;
+
+    public static final int SEND_PASS_THROUGH_CMD = 1;
+
+    private TextView mRepeatStatus;
+    private TextView mShuffleStatus;
+    private TextView mGenreStatus;
+    private TextView mArtistName;
+    private TextView mAlbumName;
+    private TextView mPlayTime;
+    private TextView mScanStatus;
+    private TextView mPlayStatus;
+    private TextView mEqualizerStatus;
+    private TextView mTrackNumber;
+    private TextView mTitleName;
+    private ToggleButton mCTStartButton;
+    private Button ffButton;
+    private Button rwButton;
+
+    private String repeatText;
+    private String shuffleText;
+    private String genreText;
+    private String artistText;
+    private String albumText;
+    private String playText;
+    private String scanText;
+    private String playStatusText;
+    private String equalizerText;
+    private String trackNumText;
+    private String titleNameText;
+
+    private final BroadcastReceiver mAvrcpControllerReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            BluetoothDevice device = (BluetoothDevice)
+                    intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+
+            if (action.equals(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED)) {
+                int prevState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
+                int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                onReceiveActionConnectionStateChanged(device, prevState, state, intent.getExtras());
+            }
+        }
+
+        private void onReceiveActionConnectionStateChanged(BluetoothDevice device,
+                int prevState, int state, Bundle features) {
+            Logger.v(TAG, "onReceiveActionConnectionStateChanged: AVRCP: " +
+                    device.getAddress() + " (" +
+                    String.valueOf(prevState) + " -> " +
+                    String.valueOf(state) + ")");
+            if (state ==  BluetoothProfile.STATE_DISCONNECTED) {
+                if (device.equals(mDevice))
+                    mDevice = null;
+                if (plSetting != null)
+                    plSetting.clear();
+                remoteSupportedFeatures = 0;
+                unregisterMetaDataObserver();
+                resetDisplay();
+                mCTStartButton.setChecked(false);
+                Toast.makeText(mLocalActivity, "Device " + device + " AVRCP Disconnected", Toast.LENGTH_SHORT).show();
+            }
+            else if(state == BluetoothProfile.STATE_CONNECTED) {
+                mDevice = device;
+                Toast.makeText(mLocalActivity, "Device " + device + " AVRCP Connected", Toast.LENGTH_SHORT).show();
+            }
+        }
+    };
+    private View.OnTouchListener onTouchListenerRW = new View.OnTouchListener() {
+        @Override
+        public boolean onTouch(View v, MotionEvent me) {
+            v.onTouchEvent(me);
+            Log.d(TAG," onTouch for RW " + me.getAction());
+            if (me.getAction() == MotionEvent.ACTION_UP){
+                if ((mAvrcpController != null) && mDevice != null &&
+                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_REWIND, KEY_STATE_RELEASED);
+                    if (mPressandHoldHandler != null)
+                        mPressandHoldHandler.sendMessageAtFrontOfQueue(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_REWIND,KEY_STATE_RELEASED));
+                    } else {
+                        Logger.e(TAG, "passthru command not sent, connection unavailable");
+                    }
+            }
+            else if (me.getAction() == MotionEvent.ACTION_DOWN) {
+                if ((mAvrcpController != null) && mDevice != null &&
+                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_REWIND, KEY_STATE_PRESSED);
+                      if ((mPressandHoldHandler != null)&&(!mPressandHoldHandler.hasMessages(SEND_PASS_THROUGH_CMD)))
+                        mPressandHoldHandler.sendMessage(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_REWIND,KEY_STATE_PRESSED));
+                    } else {
+                        Logger.e(TAG, "passthru command not sent, connection unavailable");
+                    }
+            }
+            return true;
+        }
+    };
+    private View.OnTouchListener onTouchListenerFF = new View.OnTouchListener() {
+        @Override
+        public boolean onTouch(View v, MotionEvent me) {
+            v.onTouchEvent(me);
+            Log.d(TAG," onTouch for FF " + me.getAction());
+            if (me.getAction() == MotionEvent.ACTION_UP){
+                if ((mAvrcpController != null) && mDevice != null &&
+                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FF, KEY_STATE_RELEASED);
+                        if (mPressandHoldHandler != null)
+                            mPressandHoldHandler.sendMessageAtFrontOfQueue(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_FF,KEY_STATE_RELEASED));
+                    } else {
+                        Logger.e(TAG, "passthru command not sent, connection unavailable");
+                    }
+            }
+            else if (me.getAction() == MotionEvent.ACTION_DOWN) {
+                if ((mAvrcpController != null) && mDevice != null &&
+                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+                        if ((mPressandHoldHandler != null)&&(!mPressandHoldHandler.hasMessages(SEND_PASS_THROUGH_CMD)))
+                            mPressandHoldHandler.sendMessage(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_FF,KEY_STATE_PRESSED));
+                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FF, KEY_STATE_PRESSED);
+                    } else {
+                        Logger.e(TAG, "passthru command not sent, connection unavailable");
+                    }
+            }
+            return true;
+        }
+    };
+    private final class PressandHoldHandler extends Handler {
+        private PressandHoldHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            Log.d(TAG," Recvd Msg " + msg.what);
+            int keyState = msg.arg2;
+            int keyCode = msg.arg1;
+            switch(msg.what) {
+            case SEND_PASS_THROUGH_CMD:
+                if (keyState == KEY_STATE_PRESSED) {
+                    Message msgsend = mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD, keyCode, keyState);
+                    mPressandHoldHandler.sendMessageDelayed(msgsend, 1000);
+                    if ((mAvrcpController != null) && mDevice != null &&
+                            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+                            mAvrcpController.sendPassThroughCmd(mDevice, keyCode, keyState);
+                    }
+                }
+                else if(keyState == KEY_STATE_RELEASED) {
+                    if (mPressandHoldHandler.hasMessages(SEND_PASS_THROUGH_CMD))
+                        mPressandHoldHandler.removeMessages(SEND_PASS_THROUGH_CMD);
+                    if ((mAvrcpController != null) && mDevice != null &&
+                            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+                            mAvrcpController.sendPassThroughCmd(mDevice, keyCode, keyState);
+                    }
+                }
+                break;
+            }
+        }
+    }
+    private class BluetoothAvrcpShareContentObserver extends ContentObserver {
+        public BluetoothAvrcpShareContentObserver() {
+            super(new Handler());
+        }
+        @Override
+        public void onChange(boolean selfChange) {
+            updateFromAvrcpContentProvider();
+        }
+    };
+    private void updateFromAvrcpContentProvider() {
+        Logger.e(TAG," AVRCP DB updated");
+        if (mUpdateThread == null)
+        {
+            Logger.e(TAG, "Starting a new Thread ");
+            mUpdateThread = new UpdateThread();
+            mUpdateThread.start();
+        }
+    }
+    private class UpdateThread extends Thread {
+        public UpdateThread() {
+            super(" BT_TESTAPP AVRCP UpdateThread");
+        }
+        @Override
+        public void run() {
+            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+            Uri avrcpDataUri = BluetoothAvrcpInfo.CONTENT_URI;
+            String[] mSelectionArgs = {""}; mSelectionArgs[0] = "";
+            Cursor cursor = getContentResolver().query(avrcpDataUri, null, null, null,
+                    BluetoothAvrcpInfo._ID);
+
+            if (cursor != null) {
+                int num_rows = cursor.getCount();
+                int index;
+                cursor.moveToFirst();
+                int num_colums = cursor.getColumnCount();
+                Logger.e(TAG," number of rows " + num_rows + " num Col " + num_colums);
+                mLock.lock();
+                try {
+                while(num_colums > 0){
+                    switch(num_colums) {
+                    case 1: // Track Num
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TRACK_NUM);
+                        if (index == -1)
+                            break;
+                        int track_num = cursor.getInt(index);
+                        if (track_num == BluetoothAvrcpInfo.TRACK_NUM_INVALID) {
+                            trackNumText = "NOT_SUP";
+                            break;
+                        }
+                        StringBuffer str = new StringBuffer();
+                        str.append(String.valueOf(track_num));
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACKS);
+                        if (index > 0) {
+                            str.append(" | ");
+                            str.append(String.valueOf(cursor.getInt(index)));
+                        }
+                        trackNumText = str.toString();
+                        Logger.e(TAG, " Number of Tracks " + trackNumText);
+                        break;
+                    case 2: // TRACK Title
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TITLE);
+                        if (index == -1)
+                            break;
+                        titleNameText = cursor.getString(index);
+                        Logger.e(TAG, " Track Title " + titleNameText);
+                        break;
+                    case 3: // Artist Name
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.ARTIST_NAME);
+                        if (index == -1)
+                            break;
+                        artistText = cursor.getString(index);
+                        Logger.e(TAG, " Artist Name " + artistText);
+                        break;
+                    case 4: // Album Name
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.ALBUM_NAME);
+                        if (index == -1)
+                            break;
+                        albumText = cursor.getString(index);
+                        Logger.e(TAG, " album_name " + albumText);
+                        break;
+                    case 5: // play time
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAYING_TIME);
+                        if (index == -1)
+                            break;
+                        long playing_time = cursor.getLong(index);
+                        long minutes = TimeUnit.MILLISECONDS.toMinutes(playing_time);
+                        playing_time = playing_time - (60*minutes*1000);
+                        long seconds = TimeUnit.MILLISECONDS.toSeconds(playing_time);
+                        StringBuffer strPlayTime = new StringBuffer();
+                        strPlayTime.append(String.valueOf(minutes));
+                        strPlayTime.append(":");
+                        strPlayTime.append(String.valueOf(seconds));
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACK_TIME);
+                        if (index > 0) {
+                            strPlayTime.append(" | ");
+                            long totalTrackTime = cursor.getLong(index);
+                            minutes = TimeUnit.MILLISECONDS.toMinutes(totalTrackTime);
+                            totalTrackTime = totalTrackTime - (60*minutes*1000);
+                            seconds = TimeUnit.MILLISECONDS.toSeconds(totalTrackTime);
+                            strPlayTime.append(String.valueOf(minutes));
+                            strPlayTime.append(":");
+                            strPlayTime.append(String.valueOf(seconds));
+                        }
+                        playText = strPlayTime.toString();
+                        Logger.e(TAG, " playing_time " + playText);
+                        break;
+                    case 6: //Genre
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.GENRE);
+                        if (index == -1)
+                            break;
+                        genreText = cursor.getString(index);
+                        Logger.e(TAG, " genre  " + genreText);
+                        break;
+                    case 7:// play Status
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAY_STATUS);
+                        if (index == -1)
+                            break;
+                        playStatusText = cursor.getString(index);
+                        Logger.e(TAG, " playStatus  " + playStatusText);
+                        break;
+                    case 8:// Repeat Status
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.REPEAT_STATUS);
+                        if (index == -1)
+                            break;
+                        repeatText = cursor.getString(index);
+                        Logger.e(TAG, " repetStatus  " + repeatText);
+                        break;
+                    case 9:// ShuffleStatus
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.SHUFFLE_STATUS);
+                        if (index == -1)
+                            break;
+                        shuffleText = cursor.getString(index);
+                        Logger.e(TAG, " ShuffleStatus  " + shuffleText);
+                        break;
+                    case 10:// Scan Status
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.SCAN_STATUS);
+                        if (index == -1)
+                            break;
+                        scanText = cursor.getString(index);
+                        Logger.e(TAG, " Scan Status  " + scanText);
+                        break;
+                    case 11:// Eq Status
+                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.EQUALIZER_STATUS);
+                        if (index == -1)
+                            break;
+                        equalizerText = cursor.getString(index);
+                        Logger.e(TAG, " Equalizer Status  " + equalizerText);
+                        break;
+                    }
+                    num_colums --;
+                }
+                } // try end
+                catch(CursorIndexOutOfBoundsException e) {
+                    Log.d(TAG," CursorIndexOutOfBoundsException happended");
+                }
+                catch(SQLiteCantOpenDatabaseException e) {
+                    Log.d(TAG," SQLiteCantOpenDatabaseException happended");
+                }
+                catch(SQLiteException e) {
+                    Log.d(TAG," SQLiteException happended");
+                }
+                finally {
+                    if(cursor != null)
+                        cursor.close();
+                    mLock.unlock();
+                }
+            }
+            else {
+                Logger.v(TAG," Cursor is NULL");
+            }
+            mLocalActivity.runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    mLock.lock();
+                    try {
+                        mTrackNumber.setText(trackNumText);
+                        mTitleName.setText(titleNameText);
+                        mEqualizerStatus.setText(equalizerText);
+                        mArtistName.setText(artistText);
+                        mScanStatus.setText(scanText);
+                        mShuffleStatus.setText(shuffleText);
+                        mRepeatStatus.setText(repeatText);
+                        mPlayStatus.setText(playStatusText);
+                        mGenreStatus.setText(genreText);
+                        mPlayTime.setText(playText);
+                        mAlbumName.setText(albumText);
+                    }
+                    finally {
+                        mLock.unlock();
+                    }
+                }
+            });
+            mUpdateThread =  null;
+        }
+    }
+    private final ServiceConnection mAvrcpControllerServiceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder service) {
+            Logger.v(TAG, "onServiceConnected()");
+            mProfileService = ((ProfileService.LocalBinder) service).getService();
+            mAvrcpController = mProfileService.getAvrcpController();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            Logger.v(TAG, "onServiceDisconnected()");
+            mProfileService = null;
+            mAvrcpController = null;
+            mDevice = null;
+            remoteSupportedFeatures = 0;
+            if (plSetting != null)
+                plSetting.clear();
+            unregisterMetaDataObserver();
+            resetDisplay();
+            mCTStartButton.setChecked(false);
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Logger.v(TAG, "onCreate()");
+
+        ActivityHelper.initialize(this, R.layout.activity_avrcp_test);
+        BluetoothConnectionReceiver.registerObserver(this);
+        ActivityHelper.setActionBarTitle(this, R.string.title_avrcp_test);
+        mLocalActivity = this;
+        initializeViewFragments();
+        // bind to app service
+        HandlerThread thread = new HandlerThread("BT-TestAppPressandHoldHandler");
+        thread.start();
+        Looper looper = thread.getLooper();
+        mPressandHoldHandler = new PressandHoldHandler(looper);
+        Intent intent = new Intent(this, ProfileService.class);
+        bindService(intent, mAvrcpControllerServiceConnection, BIND_AUTO_CREATE);
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
+        registerReceiver(mAvrcpControllerReceiver, filter);
+    }
+
+    @Override
+    protected void onDestroy() {
+        Logger.v(TAG, "onDestroy");
+        mDevice = null;
+        remoteSupportedFeatures = 0;
+        if (plSetting != null)
+            plSetting.clear();
+        unregisterMetaDataObserver();
+        unregisterReceiver(mAvrcpControllerReceiver);
+        unbindService(mAvrcpControllerServiceConnection);
+        BluetoothConnectionReceiver.removeObserver(this);
+        mPressandHoldHandler.removeCallbacksAndMessages(null);
+        Looper looper = mPressandHoldHandler.getLooper();
+        if (looper != null) {
+            looper.quit();
+        }
+        super.onDestroy();
+    }
+
+    @Override
+    protected void onResume() {
+        Logger.v(TAG, "onResume");
+        super.onResume();
+    }
+
+    @Override
+    protected void onPause() {
+        Logger.v(TAG, "onPause");
+        super.onPause();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        mActionBarMenu = menu;
+        return true;
+    }
+
+    @Override
+    public void onDeviceChanged(BluetoothDevice device) {
+        Logger.v(TAG, "onDeviceChanged() BD = "+ device.getAddress());
+        mDevice = device;
+    }
+
+    @Override
+    public void onDeviceDisconected() {
+        Logger.v(TAG, "onDeviceDisconected");
+        mDevice = null;
+        remoteSupportedFeatures = 0;
+    }
+
+    private void prepareActionBar() {
+        Logger.v(TAG, "prepareActionBar()");
+
+        mActionBar = getActionBar();
+        if (mActionBar != null) {
+            mActionBar.setTitle(R.string.title_avrcp_test);
+            mActionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);
+        }
+    }
+    public boolean isDeviceConnected() {
+        return ((mAvrcpController != null) && mDevice != null &&
+                BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice)));
+    }
+    public void registerMetaDataObserver() {
+       if(!isDeviceConnected()) {
+           Logger.e(TAG," Device not Connected");
+           return;
+       }
+       if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA) == 0) {
+           Logger.e(TAG," Device does not support MetaData");
+           return;
+       }
+       /* check if DataObserver is already registered */
+       if (mAvrcpDataObserver != null)
+           return;
+       Uri avrcpDataUri = BluetoothAvrcpInfo.CONTENT_URI;
+       mAvrcpDataObserver = new BluetoothAvrcpShareContentObserver();
+       getContentResolver().registerContentObserver(avrcpDataUri, true, mAvrcpDataObserver);
+       Logger.v(TAG," Registered Content Observer");
+    }
+    public void unregisterMetaDataObserver() {
+        Logger.d(TAG," unregisterMetaDataObserver");
+        if (mAvrcpDataObserver == null)
+            return;
+        getContentResolver().unregisterContentObserver(mAvrcpDataObserver);
+        mAvrcpDataObserver = null;
+    }
+    public void onClickPassthruPlay(View v) {
+        Logger.v(TAG, "onClickPassthruPlay()");
+        if ((mAvrcpController != null) && mDevice != null &&
+            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PLAY, KEY_STATE_PRESSED);
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PLAY, KEY_STATE_RELEASED);
+        } else {
+            Logger.e(TAG, "passthru command not sent, connection unavailable");
+        }
+    }
+    public void onClickPassthruVolUp(View v) {
+        Logger.v(TAG, "onClickPassthruVolUp()");
+/*
+        boolean isA2dpSinkEnabled = SystemProperties.getBoolean("persist.service.bt.a2dp.sink", false);
+        if (isA2dpSinkEnabled) {
+            Logger.v(TAG, "Sink Enabled, not sending VOL UP ");
+            return;
+        }
+*/
+        if ((mAvrcpController != null) && mDevice != null &&
+            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_UP, KEY_STATE_PRESSED);
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_UP, KEY_STATE_RELEASED);
+        } else {
+            Logger.e(TAG, "passthru command not sent, connection unavailable");
+        }
+    }
+    public void onClickPassthruVolDown(View v) {
+        Logger.v(TAG, "onClickPassthruVolDown()");
+/*
+        boolean isA2dpSinkEnabled = SystemProperties.getBoolean("persist.service.bt.a2dp.sink", false);
+        if (isA2dpSinkEnabled) {
+            Logger.v(TAG, "Sink Enabled, not sending VOL DOWN ");
+            return;
+        }
+*/
+        if ((mAvrcpController != null) && mDevice != null &&
+            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_DOWN, KEY_STATE_PRESSED);
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_DOWN, KEY_STATE_RELEASED);
+        } else {
+            Logger.e(TAG, "passthru command not sent, connection unavailable");
+        }
+    }
+    public void onClickPassthruForward(View v) {
+        Logger.v(TAG, "onClickPassthruForward()");
+        if ((mAvrcpController != null) && mDevice != null &&
+            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FORWARD, KEY_STATE_PRESSED);
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FORWARD, KEY_STATE_RELEASED);
+        } else {
+            Logger.e(TAG, "passthru command not sent, connection unavailable");
+        }
+    }
+    public void onClickPassthruBackward(View v) {
+        Logger.v(TAG, "onClickPassthruBackward()");
+        if ((mAvrcpController != null) && mDevice != null &&
+            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_BACKWARD, KEY_STATE_PRESSED);
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_BACKWARD, KEY_STATE_RELEASED);
+        } else {
+            Logger.e(TAG, "passthru command not sent, connection unavailable");
+        }
+    }
+    public void onClickToggleRepeat(View v) {
+        Logger.v(TAG, "onClickToggleRepeat()");
+        if ((mAvrcpController == null) ||
+            (mDevice == null)||
+            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
+               return;
+        }
+        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
+            return;
+        }
+        if ((plSetting == null)||(plSetting.isEmpty())) {
+           /* BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
+            updatePlayerSettings(mMetaData);*/
+        }
+
+        if ((plSetting == null)||(plSetting.isEmpty())||(repeatText == null)) {
+            Log.w(TAG," not supported, return");
+            return;
+        }
+        for (PlayerSettings sett: plSetting) {
+            Log.d(TAG," finding the current value " + sett.attr_Id);
+            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_REPEAT_STATUS) {
+                int repeat_status;
+                mLock.lock();
+                try {
+                    if(repeatText.equals("REPEAT_OFF"))
+                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_OFF;
+                    else if (repeatText.equals("REPEAT_SINGLE_TRACK_REPEAT"))
+                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_SINGLE_TRACK_REPEAT;
+                    else if (repeatText.equals("REPEAT_GROUP_REPEAT"))
+                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_GROUP_REPEAT;
+                    else if (repeatText.equals("REPEAT_ALL_TRACK_REPEAT"))
+                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_ALL_TRACK_REPEAT;
+                    else {
+                        Log.d(TAG," Repeat not supported ");
+                        return;
+                    }
+                }
+                finally {
+                    mLock.unlock();
+                }
+                for (int zz = 0; zz < sett.supported_values.length; zz++) {
+                    if (repeat_status == sett.supported_values[zz]) {
+                        repeat_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
+                        break;
+                    }
+                }
+                /* Needs to be updated for Android-N code base */
+                /* mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, repeat_status);*/
+                break;
+            }
+        }
+    }
+    public void onClickToggleEq(View v) {
+        Logger.v(TAG, "onClickToggleEq()");
+        if ((mAvrcpController == null) ||
+            (mDevice == null)||
+            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
+               return;
+        }
+        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
+            return;
+        }
+        if ((plSetting == null)||(plSetting.isEmpty())) {
+            /*BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
+            updatePlayerSettings(mMetaData);*/
+        }
+        if ((plSetting == null)||(plSetting.isEmpty())||(equalizerText == null)) {
+            Log.w(TAG," not supported, return");
+            return;
+        }
+        for (PlayerSettings sett: plSetting) {
+            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_EQUALIZER_STATUS) {
+                int eq_status;
+                mLock.lock();
+                try {
+                    if(equalizerText.equals("EQUALIZER_OFF"))
+                        eq_status = BluetoothAvrcpInfo.EQUALIZER_STATUS_OFF;
+                    else if (equalizerText.equals("EQUALIZER_ON"))
+                        eq_status = BluetoothAvrcpInfo.EQUALIZER_STATUS_ON;
+                    else {
+                        Log.d(TAG," Equalizer not supported ");
+                        return;
+                    }
+                }
+                finally {
+                    mLock.unlock();
+                }
+                for (int zz = 0; zz < sett.supported_values.length; zz ++) {
+                    if (eq_status == sett.supported_values[zz]) {
+                        eq_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
+                        break;
+                    }
+                }
+                /* Needs to be updated for Android-N code base */
+                /*mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, eq_status);*/
+                break;
+            }
+        }
+    }
+    public void onClickToggleScan(View v) {
+        Logger.v(TAG, "onClickToggleScan()");
+        if ((mAvrcpController == null) ||
+            (mDevice == null)||
+            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
+               return;
+        }
+        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
+            return;
+        }
+        if ((plSetting == null)||(plSetting.isEmpty())) {
+            /*BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
+            updatePlayerSettings(mMetaData);*/
+        }
+        if ((plSetting == null)||(plSetting.isEmpty())||(scanText == null)) {
+            Log.w(TAG," not supported, return");
+            return;
+        }
+        for (PlayerSettings sett: plSetting) {
+            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_SCAN_STATUS) {
+                int scan_status;
+                mLock.lock();
+                try {
+                    if(scanText.equals("SCAN_OFF"))
+                        scan_status = BluetoothAvrcpInfo.SCAN_STATUS_OFF;
+                    else if (scanText.equals("SCAN_GROUP_SCAN"))
+                        scan_status = BluetoothAvrcpInfo.SCAN_STATUS_GROUP_SCAN;
+                    else if (scanText.equals("SCAN_ALL_TRACK_SCAN"))
+                        scan_status = BluetoothAvrcpInfo.SCAN_STATUS_ALL_TRACK_SCAN;
+                    else {
+                        Log.d(TAG," Scan not supported ");
+                        return;
+                    }
+                }
+                finally {
+                    mLock.unlock();
+                }
+                for (int zz = 0; zz < sett.supported_values.length; zz ++) {
+                    if (scan_status == sett.supported_values[zz]) {
+                        scan_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
+                        break;
+                    }
+                }
+                /* Needs to be updated for Android-N code base */
+                /* mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, scan_status); */
+                break;
+            }
+        }
+    }
+    public void onClickToggleShuffle(View v) {
+        Logger.v(TAG, "onClickToggleShuffle()");
+        if ((mAvrcpController == null) ||
+            (mDevice == null)||
+            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
+               return;
+        }
+        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
+            return;
+        }
+        if ((plSetting == null)||(plSetting.isEmpty())) {
+            /*BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
+            updatePlayerSettings(mMetaData);*/
+        }
+        if ((plSetting == null)||(plSetting.isEmpty())||(shuffleText == null)) {
+            Log.w(TAG," not supported, return");
+            return;
+        }
+        for (PlayerSettings sett: plSetting) {
+            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_SHUFFLE_STATUS) {
+                int shuffle_status;
+                mLock.lock();
+                try {
+                    if(shuffleText.equals("SHUFFLE_OFF"))
+                        shuffle_status = BluetoothAvrcpInfo.SHUFFLE_STATUS_OFF;
+                    else if (shuffleText.equals("SHUFFLE_GROUP_SHUFFLE"))
+                        shuffle_status = BluetoothAvrcpInfo.SHUFFLE_STATUS_GROUP_SHUFFLE;
+                    else if (shuffleText.equals("SHUFFLE_ALL_TRACK_SHUFFLE"))
+                        shuffle_status = BluetoothAvrcpInfo.SHUFFLE_STATUS_ALL_TRACK_SHUFFLE;
+                    else {
+                        Log.d(TAG," Shuffle not supported ");
+                        return;
+                    }
+                }
+                finally {
+                    mLock.unlock();
+                }
+                for (int zz = 0; zz < sett.supported_values.length; zz ++) {
+                    if (shuffle_status == sett.supported_values[zz]) {
+                        shuffle_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
+                        break;
+                    }
+                }
+                /* Needs to be updated for Android-N code base */
+                /* mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, shuffle_status);*/
+                break;
+            }
+        }
+    }
+
+    public void onClickPassthruPause(View v) {
+        Logger.v(TAG, "onClickPassthruPause()");
+        if ((mAvrcpController != null) && mDevice != null &&
+            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PAUSE, KEY_STATE_PRESSED);
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PAUSE, KEY_STATE_RELEASED);
+        } else {
+            Logger.e(TAG, "passthru command not sent, connection unavailable");
+        }
+    }
+
+    public void onClickPassthruStop(View v) {
+        Logger.v(TAG, "onClickPassthruStop()");
+        if ((mAvrcpController != null) && mDevice != null &&
+            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_STOP, KEY_STATE_PRESSED);
+            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_STOP, KEY_STATE_RELEASED);
+        } else {
+            Logger.e(TAG, "passthru command not sent, connection unavailable");
+        }
+
+    }
+
+    private void updatePlayerSettings(BluetoothAvrcpInfo mData) {
+        if (plSetting != null) {
+            plSetting.clear();
+        }
+        plSetting = new ArrayList<PlayerSettings>();
+        if (mData == null)
+            return;
+        byte[] plAttributes = mData.getSupportedPlayerAttributes();
+        for (int zz = 0; zz < plAttributes.length; zz++) {
+            PlayerSettings playerSetting = new PlayerSettings();
+            playerSetting.attr_Id = plAttributes[zz];
+            playerSetting.supported_values = new byte[mData.getNumSupportedPlayerAttributeVal(playerSetting.attr_Id)];
+            byte[] plAttribSupportedValues = mData.getSupportedPlayerAttributeVlaues(playerSetting.attr_Id);
+            for (int xx = 0; xx < playerSetting.supported_values.length; xx++) {
+                playerSetting.supported_values[xx] = plAttribSupportedValues[xx];
+            }
+            plSetting.add(playerSetting);
+        }
+    }
+    private void resetDisplay() {
+        mLocalActivity.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                mLock.lock();
+                trackNumText = "NOT_SUPP";
+                titleNameText = BluetoothAvrcpInfo.TITLE_INVALID;
+                equalizerText = BluetoothAvrcpInfo.EQUALIZER_STATUS_INVALID;
+                artistText = BluetoothAvrcpInfo.ARTIST_NAME_INVALID;
+                scanText = BluetoothAvrcpInfo.SCAN_STATUS_INVALID;
+                shuffleText = BluetoothAvrcpInfo.SHUFFLE_STATUS_INVALID;
+                repeatText = BluetoothAvrcpInfo.REPEAT_STATUS_INVALID;
+                playStatusText = BluetoothAvrcpInfo.PLAY_STATUS_INVALID;
+                genreText = BluetoothAvrcpInfo.GENRE_INVALID;
+                playText = BluetoothAvrcpInfo.PLAY_STATUS_INVALID;
+                albumText = BluetoothAvrcpInfo.ALBUM_NAME_INVALID;
+                try {
+                    mTrackNumber.setText(trackNumText);
+                    mTitleName.setText(titleNameText);
+                    mEqualizerStatus.setText(equalizerText);
+                    mArtistName.setText(artistText);
+                    mScanStatus.setText(scanText);
+                    mShuffleStatus.setText(shuffleText);
+                    mRepeatStatus.setText(repeatText);
+                    mPlayStatus.setText(playStatusText);
+                    mGenreStatus.setText(genreText);
+                    mPlayTime.setText(playText);
+                    mAlbumName.setText(albumText);
+                }
+                finally {
+                    mLock.unlock();
+                }
+            }
+        });
+    }
+    private void initializeViewFragments() {
+         Log.v(TAG,"initializeViewFragments");
+         mShuffleStatus = (TextView) findViewById(R.id.shuffle_status);
+         mRepeatStatus = (TextView) findViewById(R.id.repeat_status);
+         mGenreStatus = (TextView) findViewById(R.id.genre_name);
+         mArtistName = (TextView) findViewById(R.id.artist_name);
+         mAlbumName = (TextView) findViewById(R.id.album_name);
+         mPlayTime = (TextView) findViewById(R.id.playing_time);
+         mScanStatus = (TextView) findViewById(R.id.scan_status);
+         mPlayStatus = (TextView) findViewById(R.id.play_status);
+         mEqualizerStatus = (TextView) findViewById(R.id.equalizer_status);
+         mTrackNumber = (TextView) findViewById(R.id.track_number);
+         mTitleName = (TextView) findViewById(R.id.title_name);
+         mCTStartButton = (ToggleButton) findViewById(R.id.toggleButton1);
+         ffButton = (Button) findViewById(R.id.onClickPassthruFF);
+         rwButton = (Button) findViewById(R.id.onClickPassthruRewind);
+         ffButton.setOnTouchListener(onTouchListenerFF);
+         rwButton.setOnTouchListener(onTouchListenerRW);
+    }
+    public void onCTStartToggleClicked(View view) {
+        // Is the toggle on?
+        boolean on = ((ToggleButton) view).isChecked();
+        Log.v(TAG, "onCTStartToggleClicked is_on: " + on);
+        if ((mAvrcpController != null)&&(on)) {
+            List<BluetoothDevice> deviceList = mAvrcpController.getConnectedDevices();
+            if (deviceList.size() > 0) {
+                mDevice = deviceList.get(0);
+                if (mAvrcpController.getConnectionState(mDevice) != BluetoothProfile.STATE_CONNECTED) {
+                    mCTStartButton.setChecked(false);
+                    Toast.makeText(mLocalActivity, "Device Not Connected", Toast.LENGTH_SHORT).show();
+                    return;
+                }
+                remoteSupportedFeatures = mAvrcpController.getSupportedFeatures(mDevice);
+                Log.d(TAG," getSupportedFeatures " + remoteSupportedFeatures);
+                if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)!=0) {
+                 /*   BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
+                    updatePlayerSettings(mMetaData);
+                    registerMetaDataObserver();
+                    int[] elementAttribute = new int[1];
+                    elementAttribute[0] = BluetoothAvrcpInfo.MEDIA_ATTRIBUTE_ALL;
+                    mAvrcpController.getMetaData(elementAttribute);*/
+                }
+                else {
+                    unregisterMetaDataObserver();
+                    resetDisplay();
+                    mCTStartButton.setChecked(false);
+                    Toast.makeText(mLocalActivity, "Device Don't Support MetaData", Toast.LENGTH_SHORT).show();
+                }
+            }
+            else {  // no device connected
+               mCTStartButton.setChecked(false);
+               Toast.makeText(mLocalActivity, "Device Not Connected", Toast.LENGTH_SHORT).show();
+            }
+        } else if(mAvrcpController != null){
+              unregisterMetaDataObserver();
+              resetDisplay();
+        }
+    }
+}
diff --git a/system_bt_ext/device/src/interop.c b/system_bt_ext/device/src/interop.c
index 43b97f8..346ae6b 100644
--- a/system_bt_ext/device/src/interop.c
+++ b/system_bt_ext/device/src/interop.c
@@ -214,7 +214,10 @@ static future_t *interop_clean_up(void)
 
   return future_new_immediate(FUTURE_SUCCESS);
 }
-
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
 EXPORT_SYMBOL module_t interop_module = {
   .name = INTEROP_MODULE,
   .init = interop_init,
diff --git a/vhal/include/hardware/bt_av_vendor.h b/vhal/include/hardware/bt_av_vendor.h
new file mode 100755
index 0000000..5a0b6a0
--- /dev/null
+++ b/vhal/include/hardware/bt_av_vendor.h
@@ -0,0 +1,270 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_INCLUDE_BT_AV_VENDOR_H
+#define ANDROID_INCLUDE_BT_AV_VENDOR_H
+
+#define BT_PROFILE_ADVANCED_AUDIO_VENDOR_ID "a2dp_vendor"
+#define BT_PROFILE_ADVANCED_AUDIO_SINK_VENDOR_ID "a2dp_sink_vendor"
+
+__BEGIN_DECLS
+
+#define A2DP_SINK_ENABLE_SBC_DECODING       0x01
+#define A2DP_SINK_RETREIVE_RTP_HEADER       0x02
+#define A2DP_SINK_ENABLE_DELAY_REPORTING    0X04
+#define A2DP_SRC_ENABLE_DELAY_REPORTING     0x01
+
+#define A2DP_SINK_AUDIO_CODEC_SBC       0x00
+#define A2DP_SINK_AUDIO_CODEC_MP3       0x01
+#define A2DP_SINK_AUDIO_CODEC_AAC       0x02
+#define A2DP_SINK_AUDIO_CODEC_ATRAC     0x04
+#define A2DP_SINK_AUDIO_CODEC_APTX      0x08
+#define A2DP_SINK_AUDIO_CODEC_PCM       0x40
+
+/* SBC Codec Macros */
+#define SBC_SAMP_FREQ_16     0x80    /* 16 Khz */
+#define SBC_SAMP_FREQ_32     0x40    /* 32 Khz */
+#define SBC_SAMP_FREQ_44     0x20    /* 44.1 Khz */
+#define SBC_SAMP_FREQ_48     0x10    /* 48 Khz */
+
+#define SBC_CH_MONO          0x08    /* Channel Mono */
+#define SBC_CH_DUAL          0x04    /* Channel Dual */
+#define SBC_CH_STEREO        0x02    /* Channel STEREO */
+#define SBC_CH_JOINT         0x01    /* Channel DUAL STEREO */
+
+#define SBC_BLOCKS_4         0x80    /* BLOCKS: 4 */
+#define SBC_BLOCKS_8         0x40    /* BLOCKS: 8 */
+#define SBC_BLOCKS_12        0x20    /* BLOCKS: 12 */
+#define SBC_BLOCKS_16        0x10    /* BLOCKS: 16 */
+
+#define SBC_SUBBAND_4        0x08    /* SUBBAND 4 */
+#define SBC_SUBBAND_8        0x04    /* SUBBAND 8 */
+
+#define SBC_ALLOC_SNR        0x02    /* ALLOCATION_MODE: SNR */
+#define SBC_ALLOC_LOUDNESS   0x01    /* ALLOCATION_MODE: LOUDNESS */
+
+/* AAC Codec Macros */
+#define AAC_OBJ_TYPE_MPEG_2_AAC_LC      0x80      /* b7:MPEG-2 AAC LC */
+#define AAC_OBJ_TYPE_MPEG_4_AAC_LC      0x40      /* b7:MPEG-4 AAC LC */
+#define AAC_OBJ_TYPE_MPEG_4_AAC_LTP     0x20      /* b7:MPEG-4 AAC LTP */
+#define AAC_OBJ_TYPE_MPEG_4_AAC_SCA     0x10      /* b7:MPEG-4 AAC SCALABLE */
+
+#define AAC_SAMP_FREQ_8000              0x8000    /* b15: 8000 */
+#define AAC_SAMP_FREQ_11025             0x4000    /* b15: 11025 */
+#define AAC_SAMP_FREQ_12000             0x2000    /* b15: 12000 */
+#define AAC_SAMP_FREQ_16000             0x1000    /* b15: 16000 */
+#define AAC_SAMP_FREQ_22050             0x0800    /* b15: 22050 */
+#define AAC_SAMP_FREQ_24000             0x0400    /* b15: 24000 */
+#define AAC_SAMP_FREQ_32000             0x0200    /* b15: 32000 */
+#define AAC_SAMP_FREQ_44100             0x0100    /* b15: 441000 */
+#define AAC_SAMP_FREQ_48000             0x0080    /* b15: 48000 */
+#define AAC_SAMP_FREQ_64000             0x0040    /* b15: 64000 */
+#define AAC_SAMP_FREQ_88200             0x0020    /* b15: 88200 */
+#define AAC_SAMP_FREQ_96000             0x0010    /* b15: 96000 */
+
+#define AAC_CHANNELS_1                  0x08      /* Channel 1 */
+#define AAC_CHANNELS_2                  0x04      /* Channel 2 */
+
+/* MP3 Codec Macros */
+#define MP3_LAYER_1                     0x80    /* b7:MP1 */
+#define MP3_LAYER_2                     0x40    /* b6:MP2 */
+#define MP3_LAYER_3                     0x20    /* b5:MP3 */
+
+#define MP3_CRC                         0x10    /* b4:SUPPORTED */
+
+#define MP3_CHANNEL_MONO                0x08    /* Channel MONO */
+#define MP3_CHANNEL_DUAL                0x04    /* Channel DUAL */
+#define MP3_CHANNEL_STEREO              0x02    /* Channel STEREO */
+#define MP3_CHANNEL_JOINT_STEREO        0x01    /* Channel JOINT_STEREO */
+
+#define MP3_MPF_2                       0x40    /* b6:MPF2 supported, otwerwise 0 */
+
+#define MP3_SAMP_FREQ_16000             0x20    /* b5: 16000 */
+#define MP3_SAMP_FREQ_22050             0x10    /* b4: 22050 */
+#define MP3_SAMP_FREQ_24000             0x08    /* b3: 24000 */
+#define MP3_SAMP_FREQ_32000             0x04    /* b2: 32000 */
+#define MP3_SAMP_FREQ_44100             0x02    /* b1: 441000 */
+#define MP3_SAMP_FREQ_48000             0x01    /* b0: 48000 */
+
+#define MP3_VBR                         0x80    /* supported */
+
+/* APTX Codec Macros */
+#define APTX_SAMPLERATE_44100       0x20
+#define APTX_SAMPLERATE_48000       0x10
+#define APTX_CHANNELS_STEREO        0x02
+#define APTX_CHANNELS_MONO          0x01
+
+typedef struct
+{
+    uint8_t   samp_freq;
+    uint8_t   ch_mode;
+    uint8_t   block_len;
+    uint8_t   num_subbands;
+    uint8_t   alloc_mthd;
+    uint8_t   min_bitpool;
+    uint8_t   max_bitpool;
+} btav_sbc_codec_config_t;
+
+typedef struct {
+    uint32_t bit_rate;
+    uint16_t sampling_freq;
+    uint8_t  obj_type;
+    uint8_t  channel_count;
+    uint8_t  vbr; // variable bit rate
+}btav_aac_codec_config_t;
+
+typedef struct {
+    uint16_t bit_rate;
+    uint8_t  layer;
+    uint8_t  crc;
+    uint8_t  channel_count;
+    uint8_t  mpf;
+    uint8_t  sampling_freq;
+    uint8_t  vbr; // variable bit rate
+}btav_mp3_codec_config_t;
+
+typedef struct {
+    uint8_t  channel_count;
+    uint8_t  sampling_freq;
+}btav_aptx_codec_config_t;
+
+typedef union
+{
+    btav_sbc_codec_config_t sbc_config;
+    btav_aac_codec_config_t aac_config;
+    btav_mp3_codec_config_t mp3_config;
+    btav_aptx_codec_config_t aptx_config;
+} btav_codec_config_t;
+
+
+/** Callback for audio codec configuration change.
+ *  Used only for the A2DP sink interface.
+ *  codec_type: codec negotiated over A2DP link
+ *  codec_config: configuration parameters for which link is configured
+ */
+typedef void (* btav_audio_codec_config_vendor_callback)(bt_bdaddr_t *bd_addr,
+                 uint16_t codec_type, btav_codec_config_t codec_config);
+
+/** Vendor callback for connection priority of device for incoming connection
+ * btav_connection_priority_t
+ */
+typedef void (* btav_connection_priority_vendor_callback)(bt_bdaddr_t *bd_addr);
+
+/** Vendor callback for updating apps for A2dp multicast state.
+ */
+typedef void (* btav_is_multicast_enabled_vendor_callback)(int state);
+
+/** Callback to notify reconfig a2dp when A2dp Soft Handoff is triggered
+*/
+typedef void(* btav_reconfig_a2dp_trigger_callback)(int reason, bt_bdaddr_t *bd_addr);
+
+/*
+ * Vendor callback for audio focus request to be used only in
+ * case of A2DP Sink. This is required because we are using
+ * AudioTrack approach for audio data rendering.
+ */
+typedef void (* btav_audio_focus_request_vendor_callback)(bt_bdaddr_t *bd_addr);
+
+typedef void (* btav_delay_report_vendor_callback)(bt_bdaddr_t *bd_addr, uint16_t report_delay);
+/** BT-AV Vendor callback structure. */
+typedef struct {
+    /** set to sizeof(btav_vendor_callbacks_t) */
+    size_t      size;
+    btav_connection_priority_vendor_callback connection_priority_vendor_cb;
+    btav_is_multicast_enabled_vendor_callback multicast_state_vendor_cb;
+    btav_audio_focus_request_vendor_callback audio_focus_request_vendor_cb;
+    btav_reconfig_a2dp_trigger_callback reconfig_a2dp_trigger_cb;
+    btav_delay_report_vendor_callback delay_report_vendor_cb;
+} btav_vendor_callbacks_t;
+
+typedef struct {
+    /** set to sizeof(btav_sink_vendor_callbacks_t) */
+    size_t      size;
+    btav_audio_focus_request_vendor_callback audio_focus_request_vendor_cb;
+    btav_audio_codec_config_vendor_callback audio_codec_config_vendor_cb;
+} btav_sink_vendor_callbacks_t;
+
+/** Represents the standard BT-AV interface.
+ *  Used for both the A2DP source and sink interfaces.
+ */
+typedef struct {
+    /** set to sizeof(btav_vendor_interface_t) */
+    size_t          size;
+    /**
+     * Register the BtAvVendorcallbacks
+     */
+    bt_status_t (*init_vendor)( btav_vendor_callbacks_t* callbacks , int max_a2dp_connections,
+                        int a2dp_multicast_state, uint8_t streaming_prarm, const char *offload_cap);
+
+    /** Send priority of device to stack*/
+    void (*allow_connection_vendor)( int is_valid , bt_bdaddr_t *bd_addr);
+
+   /** Sends Audio Focus State. */
+   void  (*audio_focus_state_vendor)( int focus_state );
+    /** request config codec information **/
+    bool (*get_src_codec_config)(uint8_t *codecinfo , uint8_t *codectype);
+
+   /** Request PCM sample. */
+   uint32_t  (*get_pcm_data_vendor)( uint8_t* data, uint32_t size );
+
+   /** Closes the av vendor interface. */
+   void  (*cleanup_vendor)( void );
+} btav_vendor_interface_t;
+
+/** Represents the standard BT-AV interface.
+ *  Used for A2DP sink interfaces.
+ */
+typedef struct {
+    /** set to sizeof(btav_vendor_interface_t) */
+    size_t          size;
+    /**
+     * Register the BtAvVendorcallbacks
+     */
+    bt_status_t (*init_vendor)( btav_sink_vendor_callbacks_t* callbacks , int max_a2dp_connections,
+                        int a2dp_multicast_state, uint8_t streaming_prarm);
+    /** Sends Audio Focus State. */
+    void  (*audio_focus_state_vendor)( int focus_state,  bt_bdaddr_t *bd_addr );
+   /** Request PCM sample. */
+   uint32_t  (*get_a2dp_sink_streaming_data_vendor)( uint16_t codec_type, uint8_t* data, uint32_t size );
+
+   /** Send streaming device address to stack*/
+   void (*update_streaming_device_vendor)( bt_bdaddr_t *bd_addr);
+
+   /** Send flushing device address to stack*/
+   void (*update_flushing_device_vendor)( bt_bdaddr_t *bd_addr);
+
+   /** Closes the av vendor interface. */
+   void  (*cleanup_vendor)( void );
+
+   /** Send decoding delay to stack during decoding non_SBC stream in LPASS */
+   void(*update_qahw_delay_vendor)(uint16_t aqhw_delay);
+} btav_sink_vendor_interface_t;
+__END_DECLS
+
+#endif /* ANDROID_INCLUDE_BT_AV_VENDOR_H */
diff --git a/vhal/include/hardware/bt_hf_client_vendor.h b/vhal/include/hardware/bt_hf_client_vendor.h
new file mode 100644
index 0000000..9afd373
--- /dev/null
+++ b/vhal/include/hardware/bt_hf_client_vendor.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_INCLUDE_BT_HF_CLIENT_VENDOR_H
+#define ANDROID_INCLUDE_BT_HF_CLIENT_VENDOR_H
+
+#define BT_PROFILE_HANDSFREE_CLIENT_VENDOR_ID "handsfree_client_vendor"
+
+__BEGIN_DECLS
+
+
+/**
+ * Vendor callback for sending cgmi indication to app
+ */
+typedef void (* bthf_client_cgmi_indication_vendor_callback) (const char *str);
+
+/**
+ * Vendor callback for sending cgmm indication to app
+ */
+typedef void (* bthf_client_cgmm_indication_vendor_callback) (const char *str);
+
+/** BT-HF vendor callback structure. */
+typedef struct {
+    /** set to sizeof(BtHfClientVendorCallbacks) */
+    size_t      size;
+    bthf_client_cgmi_indication_vendor_callback   cgmi_vendor_cb;
+    bthf_client_cgmm_indication_vendor_callback   cgmm_vendor_cb;
+} bthf_client_vendor_callbacks_t;
+
+/** Represents the standard BT-HF Vendor interface. */
+typedef struct {
+
+    /** set to sizeof(BtHfClientVendorInterface) */
+    size_t size;
+    /**
+     * Register the BtHf vendor callbacks
+     */
+    bt_status_t (*init_vendor)(bthf_client_vendor_callbacks_t* callbacks);
+
+   /** Closes the hf client vendor interface. */
+   void  (*cleanup_vendor)( void );
+} bthf_client_vendor_interface_t;
+
+__END_DECLS
+
+#endif /* ANDROID_INCLUDE_BT_HF_CLIENT_VENDOR_H */
diff --git a/vhal/include/hardware/bt_hf_vendor.h b/vhal/include/hardware/bt_hf_vendor.h
new file mode 100644
index 0000000..b64df8e
--- /dev/null
+++ b/vhal/include/hardware/bt_hf_vendor.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_INCLUDE_BT_HF_VENDOR_H
+#define ANDROID_INCLUDE_BT_HF_VENDOR_H
+
+#define BT_PROFILE_HANDSFREE_VENDOR_ID "handsfree_vendor"
+
+__BEGIN_DECLS
+
+/* BIND type*/
+typedef enum
+{
+   BTHF_VENDOR_BIND_SET,
+   BTHF_VENDOR_BIND_READ,
+   BTHF_VENDOR_BIND_TEST
+} bthf_vendor_bind_type_t;
+
+typedef enum {
+    BTHF_VENDOR_HF_INDICATOR_STATE_DISABLED = 0,
+    BTHF_VENDOR_HF_INDICATOR_STATE_ENABLED
+} bthf_vendor_hf_indicator_status_t;
+
+typedef enum {
+    BTHF_VENDOR_VOIP_CALL_NETWORK_TYPE_MOBILE = 0,
+    BTHF_VENDOR_VOIP_CALL_NETWORK_TYPE_WIFI
+} bthf_vendor_voip_call_network_type_t;
+
+typedef enum {
+    BTHF_VENDOR_VOIP_STATE_STOPPED = 0,
+    BTHF_VENDOR_VOIP_STATE_STARTED
+} bthf_vendor_voip_state_t;
+
+/** Vendor callback for HF indicators (BIND)
+ */
+typedef void (* bthf_bind_cmd_vendor_callback)(char* hf_ind, bthf_vendor_bind_type_t type, bt_bdaddr_t *bd_addr);
+
+/** Vendor callback for HF indicator value (BIEV)
+ */
+typedef void (* bthf_biev_cmd_vendor_callback)(char* hf_ind_val, bt_bdaddr_t *bd_addr);
+
+/** BT-HF Vendor callback structure. */
+typedef struct {
+    /** set to sizeof(BtHfVendorCallbacks) */
+    size_t      size;
+    bthf_bind_cmd_vendor_callback          bind_cmd_vendor_cb;
+    bthf_biev_cmd_vendor_callback          biev_cmd_vendor_cb;
+} bthf_vendor_callbacks_t;
+
+/** Represents the standard BT-HF Vendor interface. */
+typedef struct {
+    /** set to sizeof(BtHfVendorInterface) */
+    size_t          size;
+    /**
+     * Register the BtHf Vendor callbacks
+     */
+    bt_status_t (*init_vendor)( bthf_vendor_callbacks_t* callbacks);
+
+    /** Response for BIND READ command and activation/deactivation of  HF indicator */
+    bt_status_t (*bind_response_vendor) (int anum, bthf_vendor_hf_indicator_status_t status,
+                                  bt_bdaddr_t *bd_addr);
+
+    /** Response for BIND TEST command */
+    bt_status_t (*bind_string_response_vendor) (const char* result, bt_bdaddr_t *bd_addr);
+
+    /** Sends connectivity network type used by Voip currently to stack */
+    bt_status_t (*voip_network_type_wifi_vendor) (bthf_vendor_voip_state_t is_voip_started,
+                                           bthf_vendor_voip_call_network_type_t is_network_wifi);
+
+   /** Closes the hf vednor interface. */
+   void (*cleanup_vendor)(void);
+} bthf_vendor_interface_t;
+
+__END_DECLS
+
+#endif /* ANDROID_INCLUDE_BT_HF_VENDOR_H */
diff --git a/vhal/include/hardware/bt_rc_vendor.h b/vhal/include/hardware/bt_rc_vendor.h
new file mode 100644
index 0000000..9e38cb0
--- /dev/null
+++ b/vhal/include/hardware/bt_rc_vendor.h
@@ -0,0 +1,387 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_INCLUDE_BT_RC_VENDOR_H
+#define ANDROID_INCLUDE_BT_RC_VENDOR_H
+
+#define BT_PROFILE_AV_RC_VENDOR_ID "avrcp_vendor"
+#define BT_PROFILE_AV_RC_CTRL_VENDOR_ID "avrcp_ctrl_vendor"
+
+__BEGIN_DECLS
+
+/* Macros */
+#define BTRC_MAX_ELEM_ATTR_SIZE     8
+#define BTRC_CHARSET_UTF8           0x006A
+#define BTRC_BROWSE_PDU_HEADER      3
+#define BTRC_AVCTP_HEADER           3
+#define BTRC_BROWSE_PKT_3TO7OCT_LEN 5
+#define BTRC_FOLDER_ITEM_HEADER     14
+#define BTRC_ITEM_ATTRIBUTE_HEADER  8
+#define BTRC_ITEM_TYPE_N_LEN_OCT    3
+
+typedef enum {
+    BTRC_VENDOR_EVT_PLAY_STATUS_CHANGED = 0x01,
+    BTRC_VENDOR_EVT_TRACK_CHANGE = 0x02,
+    BTRC_VENDOR_EVT_TRACK_REACHED_END = 0x03,
+    BTRC_VENDOR_EVT_TRACK_REACHED_START = 0x04,
+    BTRC_VENDOR_EVT_PLAY_POS_CHANGED = 0x05,
+    BTRC_VENDOR_EVT_APP_SETTINGS_CHANGED = 0x08,
+    BTRC_VENDOR_EVT_NOW_PLAYING_CONTENT_CHANGED = 0x09,
+    BTRC_VENDOR_EVT_AVAILABLE_PLAYERS_CHANGED = 0x0a,
+    BTRC_VENDOR_EVT_ADDRESSED_PLAYER_CHANGED = 0x0b,
+} btrc_vendor_event_id_t;
+
+//used for Scope
+typedef enum {
+    BTRC_VENDOR_EVT_MEDIA_PLAYLIST = 0,
+    BTRC_VENDOR_EVT_MEDIA_VIRTUALFILESYST = 1,
+    BTRC_VENDOR_EVT_SEARCH = 2,
+    BTRC_VENDOR_EVT_NOWPLAYING = 3,
+    BTRC_VENDOR_EVT_MAX_BROWSE = 4,
+} btrc_vendor_browse_folderitem_t;
+
+typedef enum {
+    BTRC_VENDOR_NOTIFICATION_TYPE_REJECT = 2,
+} btrc_vendor_notification_type_t;
+
+typedef enum {
+    BTRC_VENDOR_MEDIA_ATTR_TITLE = 0x01,
+    BTRC_VENDOR_MEDIA_ATTR_ARTIST = 0x02,
+    BTRC_VENDOR_MEDIA_ATTR_ALBUM = 0x03,
+    BTRC_VENDOR_MEDIA_ATTR_TRACK_NUM = 0x04,
+    BTRC_VENDOR_MEDIA_ATTR_NUM_TRACKS = 0x05,
+    BTRC_VENDOR_MEDIA_ATTR_GENRE = 0x06,
+    BTRC_VENDOR_MEDIA_ATTR_PLAYING_TIME = 0x07,
+    BTRC_VENDOR_MEDIA_ATTR_COVER_ART = 0x08,
+} btrc_vendor_media_attr_t;
+
+typedef enum {
+    BTRC_VENDOR_TYPE_MEDIA_PLAYER = 0x01,
+    BTRC_VENDOR_TYPE_FOLDER = 0x02,
+    BTRC_VENDOR_TYPE_MEDIA_ELEMENT = 0x03
+} btrc_vendor_folder_list_item_type_t;
+
+typedef struct {
+    uint32_t start_item;
+    uint32_t end_item;
+    uint32_t size;
+    uint32_t attrs[BTRC_MAX_ELEM_ATTR_SIZE];
+    uint8_t  attr_count;
+}btrc_vendor_getfolderitem_t;
+
+typedef union
+{
+    btrc_play_status_t play_status;
+    btrc_uid_t track; /* queue position in NowPlaying */
+    uint32_t song_pos;
+    btrc_player_settings_t player_setting;
+	uint16_t player_id;
+} btrc_vendor_register_notification_t;
+
+#define BTRC_FEATURE_MASK_SIZE 16
+
+typedef uint8_t btrc_feature_mask_t[BTRC_FEATURE_MASK_SIZE];
+
+typedef struct {
+    uint16_t              charset_id;
+    uint16_t              str_len;
+    uint8_t               *p_str;
+} btrc_vendor_player_full_name_t;
+
+typedef struct
+{
+    uint32_t              sub_type;
+    uint16_t              player_id;
+    uint8_t               major_type;
+    uint8_t               play_status;
+    btrc_feature_mask_t   features;       /* Supported feature bit mask*/
+    btrc_vendor_player_full_name_t     name;           /* The player name, name length and character set id.*/
+} btrc_vendor_folder_list_item_player_t;
+
+typedef struct
+{
+    uint64_t                    uid;
+    uint8_t                     type;
+    uint8_t                     playable;
+    btrc_vendor_player_full_name_t     name;
+} btrc_vendor_folder_list_item_folder_t;
+
+typedef struct
+{
+    uint32_t                    attr_id;
+    btrc_vendor_player_full_name_t     name;
+} btrc_vendor_attr_entry_t;
+
+typedef struct
+{
+    uint64_t                    uid;
+    uint8_t                     type;
+    uint8_t                     attr_count;
+    btrc_vendor_player_full_name_t     name;
+    btrc_vendor_attr_entry_t*          p_attr_list;
+} btrc_vendor_folder_list_item_media_t;
+
+typedef struct {
+    uint16_t              str_len;
+    uint8_t               *p_str;
+} btrc_vendor_name_t;
+
+/* SetBrowsedPlayer */
+typedef struct
+{
+    uint32_t              num_items;
+    uint16_t              uid_counter;
+    uint16_t              charset_id;
+    uint8_t               status;
+    uint8_t               folder_depth;
+    btrc_vendor_name_t           *p_folders;
+} btrc_vendor_set_browsed_player_rsp_t;
+
+typedef struct
+{
+    uint8_t                          item_type;
+    union
+    {
+        btrc_vendor_folder_list_item_player_t   player;
+        btrc_vendor_folder_list_item_folder_t   folder;
+        btrc_vendor_folder_list_item_media_t    media;
+    } u;
+} btrc_vendor_folder_list_item_t;
+
+/* GetFolderItems */
+typedef struct
+{
+    uint16_t                  uid_counter;
+    uint16_t                  item_count;
+    uint8_t                   status;
+    btrc_vendor_folder_list_item_t   *p_item_list;
+} btrc_vendor_folder_list_entries_t;
+
+typedef void (* btavrc_get_play_status_vendor_callback)(bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_list_player_app_attr_vendor_callback)(bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_list_player_app_values_vendor_callback)(btrc_player_attr_t attr_id,
+        bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_get_player_app_value_vendor_callback) (uint8_t num_attr, btrc_player_attr_t *p_attrs,
+        bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_get_player_app_attrs_text_vendor_callback) (uint8_t num_attr,
+        btrc_player_attr_t *p_attrs, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_get_player_app_values_text_vendor_callback) (uint8_t attr_id,
+         uint8_t num_val, uint8_t *p_vals, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_set_player_app_value_vendor_callback) (btrc_player_settings_t *p_vals,
+        bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_get_element_attr_vendor_callback) (uint8_t num_attr, btrc_vendor_media_attr_t *p_attrs,
+        bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_register_notification_vendor_callback) (btrc_vendor_event_id_t event_id, uint32_t param,
+        bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_volume_change_vendor_callback) (uint8_t volume, uint8_t ctype, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_passthrough_cmd_vendor_callback) (int id, int key_state, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_get_folder_items_vendor_callback) (btrc_vendor_browse_folderitem_t id,
+                  btrc_vendor_getfolderitem_t *param, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_set_addressed_player_vendor_callback) (uint32_t player_id, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_set_browsed_player_vendor_callback) (uint32_t player_id, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_change_path_vendor_callback) (uint8_t direction, uint64_t uid, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_play_item_vendor_callback) (uint8_t scope, uint64_t uid, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_get_item_attr_vendor_callback) (uint8_t scope, uint64_t uid,
+        uint8_t num_attr, btrc_vendor_media_attr_t *p_attrs, uint32_t size, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_connection_state_vendor_callback) (bool state, bt_bdaddr_t *bd_addr);
+
+typedef void (* btavrc_get_total_item_vendor_callback) (uint8_t scope, bt_bdaddr_t *bd_addr);
+
+/** BT-RC Target Vendor callback structure. */
+typedef struct {
+    /** set to sizeof(BtRcVendorCallbacks) */
+    size_t      size;
+    btavrc_get_play_status_vendor_callback               get_play_status_vendor_cb;
+    btavrc_list_player_app_attr_vendor_callback          list_player_app_attr_vendor_cb;
+    btavrc_list_player_app_values_vendor_callback        list_player_app_values_vendor_cb;
+    btavrc_get_player_app_value_vendor_callback          get_player_app_value_vendor_cb;
+    btavrc_get_player_app_attrs_text_vendor_callback     get_player_app_attrs_text_vendor_cb;
+    btavrc_get_player_app_values_text_vendor_callback    get_player_app_values_text_vendor_cb;
+    btavrc_set_player_app_value_vendor_callback          set_player_app_value_vendor_cb;
+    btavrc_get_element_attr_vendor_callback              get_element_attr_vendor_cb;
+    btavrc_register_notification_vendor_callback         register_notification_vendor_cb;
+    btavrc_volume_change_vendor_callback                 volume_change_vendor_cb;
+    btavrc_passthrough_cmd_vendor_callback               passthrough_cmd_vendor_cb;
+    btavrc_get_folder_items_vendor_callback              get_folderitems_vendor_cb;
+    btavrc_set_addressed_player_vendor_callback          set_addrplayer_vendor_cb;
+    btavrc_set_browsed_player_vendor_callback            set_browsed_player_vendor_cb;
+    btavrc_change_path_vendor_callback                   change_path_vendor_cb;
+    btavrc_play_item_vendor_callback                     play_item_vendor_cb;
+    btavrc_get_item_attr_vendor_callback                 get_item_attr_vendor_cb;
+    btavrc_connection_state_vendor_callback              connection_state_vendor_cb;
+    btavrc_get_total_item_vendor_callback                get_tot_item_vendor_cb;
+} btrc_vendor_callbacks_t;
+
+/** Represents the standard BT-RC AVRCP Target Vendor interface. */
+typedef struct {
+    /** set to sizeof(BtRcVendorInterface) */
+    size_t          size;
+
+    bt_status_t (*init_vendor)( btrc_vendor_callbacks_t* callbacks , int max_avrcp_connections);
+
+    bt_status_t (*get_play_status_response_vendor)( btrc_play_status_t play_status, uint32_t song_len,
+            int32_t song_pos, bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*list_player_app_attr_response_vendor)( uint8_t num_attr, btrc_player_attr_t *p_attrs,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*list_player_app_value_response_vendor)( uint8_t num_val, uint8_t *p_vals,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*get_player_app_value_response_vendor)( btrc_player_settings_t *p_vals,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*get_player_app_attr_text_response_vendor)( int num_attr, btrc_player_setting_text_t *p_attrs,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*get_player_app_value_text_response_vendor)( int num_val, btrc_player_setting_text_t *p_vals,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*get_element_attr_response_vendor)( uint8_t num_attr, btrc_element_attr_val_t *p_attrs,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*set_player_app_value_response_vendor)(btrc_status_t rsp_status, bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*register_notification_response_vendor)(btrc_vendor_event_id_t event_id,
+                                                         btrc_vendor_notification_type_t type,
+                                                         btrc_vendor_register_notification_t *p_param,
+                                                         bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*set_vol_vendor)(uint8_t volume, bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*get_folder_items_response_vendor) (btrc_vendor_folder_list_entries_t *p_param, bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*set_addressed_player_response_vendor) (btrc_status_t status_code, bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*set_browsed_player_response_vendor) (btrc_vendor_set_browsed_player_rsp_t *p_param,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*change_path_response_vendor) (uint8_t status_code, uint32_t item_count,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*play_item_response_vendor) (uint8_t status_code, bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*get_item_attr_response_vendor)( uint8_t num_attr, btrc_element_attr_val_t *p_attrs,
+            bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*is_dev_active_in_handoff_vendor) (bt_bdaddr_t *bd_addr);
+
+    bt_status_t (*get_total_items_response_vendor) (uint8_t status_code, uint32_t item_count,
+            uint16_t uid_counter, bt_bdaddr_t *bd_addr);
+
+    void (*cleanup_vendor)(void);
+} btrc_vendor_interface_t;
+
+/** BT-RC CT Vendor callbacks. */
+typedef void (* btavrc_ctrl_getrcfeatures_vendor_callback) (bt_bdaddr_t *bd_addr, int features);
+
+typedef void (* btavrc_ctrl_getcapability_rsp_vendor_callback) (bt_bdaddr_t *bd_addr, int cap_id,
+                                 uint32_t* supported_values, int num_supported, uint8_t rsp_type);
+
+typedef void (* btavrc_ctrl_listplayerappsettingattrib_rsp_vendor_callback) (bt_bdaddr_t *bd_addr,
+                                     uint8_t* supported_attribs, int num_attrib, uint8_t rsp_type);
+
+typedef void (* btavrc_ctrl_listplayerappsettingvalue_rsp_vendor_callback) (bt_bdaddr_t *bd_addr,
+                                        uint8_t* supported_val, uint8_t num_supported, uint8_t rsp_type);
+
+typedef void (* btavrc_ctrl_currentplayerappsetting_rsp_vendor_callback) (bt_bdaddr_t *bd_addr,uint8_t* supported_ids,
+                                                 uint8_t* supported_val, uint8_t num_attrib, uint8_t rsp_type);
+
+typedef void (* btavrc_ctrl_setplayerapplicationsetting_rsp_vendor_callback) (bt_bdaddr_t *bd_addr,uint8_t rsp_type);
+
+typedef void (* btavrc_ctrl_notification_rsp_vendor_callback) (bt_bdaddr_t *bd_addr, uint8_t rsp_type,
+                                 int rsp_len, uint8_t* notification_rsp);
+
+typedef void (* btavrc_ctrl_getelementattrib_rsp_vendor_callback) (bt_bdaddr_t *bd_addr, uint8_t num_attributes,
+                                                          int rsp_len, uint8_t* attrib_rsp, uint8_t rsp_type);
+
+typedef void (* btavrc_ctrl_getplaystatus_rsp_vendor_callback) (bt_bdaddr_t *bd_addr, int param_len, uint8_t* play_status_rsp
+                                                                           ,uint8_t rsp_type);
+
+typedef void (* btavrc_ctrl_passthrough_rsp_vendor_callback) (int id, int key_state,
+                                                                  bt_bdaddr_t *bd_addr);
+
+/** BT-RC Controller Vendor callback structure. */
+typedef struct {
+    /** set to sizeof(BtRcCtVendorCallbacks) */
+    size_t      size;
+    btavrc_ctrl_getcapability_rsp_vendor_callback                   getcap_rsp_vendor_cb;
+    btavrc_ctrl_listplayerappsettingattrib_rsp_vendor_callback      listplayerappsettingattrib_rsp_vendor_cb;
+    btavrc_ctrl_listplayerappsettingvalue_rsp_vendor_callback       listplayerappsettingvalue_rsp_vendor_cb;
+    btavrc_ctrl_currentplayerappsetting_rsp_vendor_callback         currentplayerappsetting_rsp_vendor_cb; //need to check
+    btavrc_ctrl_notification_rsp_vendor_callback                    notification_rsp_vendor_cb;
+    btavrc_ctrl_getelementattrib_rsp_vendor_callback                getelementattrib_rsp_vendor_cb;
+    btavrc_ctrl_getplaystatus_rsp_vendor_callback                   getplaystatus_rsp_vendor_cb;//need to check
+    btavrc_ctrl_passthrough_rsp_vendor_callback                     passthrough_rsp_vendor_cb;
+} btrc_ctrl_vendor_callbacks_t;
+
+/** Represents the standard BT-RC AVRCP Controller Vendor interface. */
+typedef struct {
+    /** set to sizeof(BtRcCtVendorInterface) */
+    size_t          size;
+
+    bt_status_t (*init_vendor)(btrc_ctrl_vendor_callbacks_t* callbacks, int max_avrcp_connections);
+
+    bt_status_t (*getcapabilities_command_vendor) (uint8_t cap_id);
+
+    bt_status_t (*list_player_app_setting_attrib_command_vendor) (void);
+
+    bt_status_t (*list_player_app_setting_value_command_vendor) (uint8_t attrib_id);
+
+    bt_status_t (*get_player_app_setting_command_vendor) (uint8_t num_attrib, uint8_t* attrib_ids);
+
+    bt_status_t (*register_notification_command_vendor) (uint8_t event_id, uint32_t event_value);
+
+    bt_status_t (*get_element_attribute_command_vendor) (uint8_t num_attribute, uint32_t attribute_id);
+
+    bt_status_t (*get_play_status_command_vendor) (void);
+
+    void (*cleanup_vendor)(void);
+} btrc_ctrl_vendor_interface_t;
+
+__END_DECLS
+
+#endif /* ANDROID_INCLUDE_BT_RC_VENDOR_H */
diff --git a/vhal/include/hardware/vendor.h b/vhal/include/hardware/vendor.h
new file mode 100644
index 0000000..13b731c
--- /dev/null
+++ b/vhal/include/hardware/vendor.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 The Linux Foundation. All rights reserved
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_INCLUDE_BT_VENDOR_H
+#define ANDROID_INCLUDE_BT_VENDOR_H
+
+#include <hardware/bluetooth.h>
+
+__BEGIN_DECLS
+
+#define BT_PROFILE_VENDOR_ID "vendor"
+#define BT_PROFILE_WIPOWER_VENDOR_ID "wipower"
+
+/** Callback when bredr cleanup is done.
+ */
+typedef void (*  btvendor_bredr_cleanup_callback)(bool status);
+
+/** Callback to notify ssr cleanup to app.
+ */
+typedef void (*  btvendor_ssr_cleanup_callback)(void);
+
+
+/** BT-Vendor callback structure. */
+typedef struct {
+    /** set to sizeof(BtVendorCallbacks) */
+    size_t      size;
+    btvendor_bredr_cleanup_callback  bredr_cleanup_cb;
+    btvendor_ssr_cleanup_callback    ssr_cleanup_cb;
+} btvendor_callbacks_t;
+
+/** Represents the standard BT-Vendor interface.
+ */
+typedef struct {
+
+    /** set to sizeof(BtVendorInterface) */
+    size_t          size;
+
+    /**
+     * Register the BtVendor callbacks
+     */
+    bt_status_t (*init)( btvendor_callbacks_t* callbacks );
+
+    /** Does SSR cleanup */
+    void (*ssrcleanup)(void);
+
+    /** Does BREDR cleanup */
+    void (*bredrcleanup)(void);
+
+    /** Closes the interface. */
+    void  (*cleanup)( void );
+
+} btvendor_interface_t;
+
+__END_DECLS
+
+#endif /* ANDROID_INCLUDE_BT_VENDOR_H */
+

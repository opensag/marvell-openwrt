diff --git a/Android.mk b/Android.mk
index 00e8261..22eac10 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,5 @@
 LOCAL_PATH := $(call my-dir)
-
+LOCAL_CFLAGS := -DANDROID
 # Setup Bluetooth local make variables for handling configuration
 ifneq ($(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR),)
   bluetooth_C_INCLUDES := $(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR)
diff --git a/Makefile.am b/Makefile.am
new file mode 100644
index 0000000..ca80d0b
--- /dev/null
+++ b/Makefile.am
@@ -0,0 +1,6 @@
+ACLOCAL_AMFLAGS = -I m4
+
+SUBDIRS = hci osi profile device btcore utils stack bta btif main embdrv/sbc/decoder audio_a2dp_hw test
+
+AM_CFLAGS = -ANDROID
+AM_CPPFLAGS = -DANDROID
diff --git a/audio_a2dp_hw/Makefile.am b/audio_a2dp_hw/Makefile.am
new file mode 100644
index 0000000..b7bf349
--- /dev/null
+++ b/audio_a2dp_hw/Makefile.am
@@ -0,0 +1,42 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS= \
+        -I. \
+        -I../ \
+        -I../utils/include \
+        -I${WORKSPACE}/system/media/audio/include \
+        -I../../../hardware/libhardware/include \
+        -I$(bdroid_C_INCLUDES)
+
+c_sources = \
+        audio_a2dp_hw.c
+
+common_LDFLAGS = -lpthread -lresolv -lrt ../osi/libbtosi.la
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES = libaudioa2dpdefault.la
+libaudioa2dpdefault_la_CC = @CC@
+libaudioa2dpdefault_la_SOURCES = $(c_sources)
+libaudioa2dpdefault_la_CPPFLAGS =$(AM_CPPFLAGS)
+libaudioa2dpdefault_la_CFLAGS = $(common_CFLAGS)
+libaudioa2dpdefault_la_LDFLAGS = $(common_LDFLAGS)
+
+########BT_HOST_IPC########
+
+ipc_sources = \
+           bthost_ipc.c
+
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES +=  libbthost_if.la
+libbthost_if_la_SOURCES = $(ipc_sources)
+libbthost_if_la_CPPFLAGS =$(AM_CPPFLAGS)
+libbthost_if_la_CFLAGS = $(common_CFLAGS)
+libbthost_if_la_LDFLAGS = $(common_LDFLAGS) -avoid-version
diff --git a/audio_a2dp_hw/audio_a2dp_hw.c b/audio_a2dp_hw/audio_a2dp_hw.c
index e901c26..7c625e5 100644
--- a/audio_a2dp_hw/audio_a2dp_hw.c
+++ b/audio_a2dp_hw/audio_a2dp_hw.c
@@ -47,10 +47,13 @@
 #include <sys/time.h>
 #include <sys/un.h>
 #include <unistd.h>
-
+#ifdef ANDROID
+#include <cutils/sockets.h>
+#include <system/audio.h>
+#endif
 #include <hardware/audio.h>
 #include <hardware/hardware.h>
-#include <system/audio.h>
+//#include <system/audio.h>
 
 #include "audio_a2dp_hw.h"
 #include "bt_utils.h"
@@ -74,8 +77,12 @@
 
 #ifdef BT_AUDIO_SAMPLE_LOG
 FILE *outputpcmsamplefile;
+#ifdef ANDROID
 char btoutputfilename [50] = "/data/audio/output_sample";
 static int number =0;
+#else
+char btoutputfilename [100] = "/etc/bluetooth/output_sample.pcm";
+#endif
 #endif
 /*****************************************************************************
 **  Constants & Macros
@@ -171,10 +178,19 @@ static const char* dump_a2dp_ctrl_event(char event)
 
 static int calc_audiotime(struct a2dp_config cfg, int bytes)
 {
+
+#ifdef ANDROID
     int chan_count = popcount(cfg.channel_flags);
-    int bytes_per_sample = 4;
+#else
+    int chan_count = __builtin_popcount(cfg.channel_flags);
+#endif
 
+    int bytes_per_sample = 4;
+#ifdef ANDROID
     ASSERTC(cfg.format == AUDIO_FORMAT_PCM_8_24_BIT,
+#else
+    ASSERTC(cfg.format == AUDIO_STREAM_DEFAULT_FORMAT,
+#endif
             "unsupported sample sz", cfg.format);
 
     return (int)(((int64_t)bytes * (1000000 / (chan_count * bytes_per_sample))) / cfg.rate);
@@ -806,8 +822,11 @@ static size_t out_get_buffer_size(const struct audio_stream *stream)
     if (period_size % mixer_unit_size != 0) {
         ERROR("period size %zu not a multiple of %zu", period_size, mixer_unit_size);
     }
-
+#ifdef ANDROID
     return period_size;
+#else
+    return out->common.buffer_sz;
+#endif
 }
 
 static uint32_t out_get_channels(const struct audio_stream *stream)
@@ -1330,9 +1349,13 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     if (!out)
         return -ENOMEM;
     #ifdef BT_AUDIO_SAMPLE_LOG
+#ifdef ANDROID
     snprintf(btoutputfilename, sizeof(btoutputfilename), "%s%d%s", btoutputfilename, number,".pcm");
     outputpcmsamplefile = fopen (btoutputfilename, "ab");
     number++;
+#else
+    outputpcmsamplefile = fopen (btoutputfilename, "w");
+#endif
     #endif
 
 #ifdef BT_HOST_IPC_ENABLED
@@ -1380,9 +1403,14 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     a2dp_stream_common_init(&out->common);
 #endif
     out->common.cfg.channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG;
+#ifdef ANDROID
     out->common.cfg.format = AUDIO_FORMAT_PCM_8_24_BIT;
+#else
+    out->common.cfg.format = AUDIO_STREAM_DEFAULT_FORMAT;
+#endif
     out->common.cfg.rate = AUDIO_STREAM_DEFAULT_RATE;
 
+#ifdef ANDROID
    /* set output config values */
    if (config)
    {
@@ -1390,6 +1418,8 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
       config->sample_rate = out_get_sample_rate((const struct audio_stream *)&out->stream);
       config->channel_mask = out_get_channels((const struct audio_stream *)&out->stream);
    }
+#endif
+
     *stream_out = &out->stream;
     a2dp_dev->output = out;
 
@@ -1454,8 +1484,10 @@ static void adev_close_output_stream(struct audio_hw_device *dev,
     skt_disconnect(out->common.ctrl_fd);
 #endif
     out->common.ctrl_fd = AUDIO_SKT_DISCONNECTED;
+#ifdef BT_HOST_IPC_ENABLED
     if (lib_handle)
         dlclose(lib_handle);
+#endif
     free(stream);
     a2dp_dev->output = NULL;
     pthread_mutex_unlock(&out->common.lock);
@@ -1696,8 +1728,10 @@ static void adev_close_input_stream(struct audio_hw_device *dev,
     in->common.ctrl_fd = AUDIO_SKT_DISCONNECTED;
     free(stream);
     a2dp_dev->input = NULL;
+#ifdef BT_HOST_IPC_ENABLED
     if (lib_handle)
         dlclose(lib_handle);
+#endif
     DEBUG("done");
 }
 
diff --git a/audio_a2dp_hw/audio_a2dp_hw.h b/audio_a2dp_hw/audio_a2dp_hw.h
index 67fd212..0e33967 100644
--- a/audio_a2dp_hw/audio_a2dp_hw.h
+++ b/audio_a2dp_hw/audio_a2dp_hw.h
@@ -32,13 +32,22 @@
 #ifndef AUDIO_A2DP_HW_H
 #define AUDIO_A2DP_HW_H
 #include <pthread.h>
+#ifndef ANDROID
+#include <stdint.h>
+#endif
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
 
 #define A2DP_AUDIO_HARDWARE_INTERFACE "audio.a2dp"
+
+#ifdef ANDROID
 #define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
 #define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
+#else
+#define A2DP_CTRL_PATH "/etc/bluetooth/.a2dp_ctrl"
+#define A2DP_DATA_PATH "/etc/bluetooth/.a2dp_data"
+#endif
 
 #ifndef BTA_AV_SPLIT_A2DP_DEF_FREQ_48KHZ
 #define AUDIO_STREAM_DEFAULT_RATE          44100
@@ -65,7 +74,11 @@
 // 20 * 512 is not sufficient size to smooth the variability for some BT devices,
 // resulting in mixer sleep and throttling. We increase this to 28 * 512 to help
 // reduce the effect of variable data consumption.
+#ifdef ANDROID
 #define AUDIO_STREAM_OUTPUT_BUFFER_SZ     (28*1024)
+#else
+#define AUDIO_STREAM_OUTPUT_BUFFER_SZ     (28*512)
+#endif
 
 // AUDIO_STREAM_OUTPUT_BUFFER_PERIODS controls how the socket buffer is divided
 // for AudioFlinger data delivery. The AudioFlinger mixer delivers data in chunks
diff --git a/audio_a2dp_hw/bthost_ipc.c b/audio_a2dp_hw/bthost_ipc.c
index 5137e94..e518113 100644
--- a/audio_a2dp_hw/bthost_ipc.c
+++ b/audio_a2dp_hw/bthost_ipc.c
@@ -37,7 +37,9 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <fcntl.h>
+#ifdef ANDROID
 #include <system/audio.h>
+#endif
 #include <hardware/audio.h>
 
 #include <hardware/hardware.h>
@@ -1172,24 +1174,16 @@ void clear_a2dpsuspend_flag()
 void * audio_get_codec_config(uint8_t *multicast_status, uint8_t *num_dev,
                               audio_format_t *codec_type)
 {
-    int i, status, j;
     INFO("%s: state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
 
     pthread_mutex_lock(&audio_stream.lock);
     a2dp_get_multicast_status(&audio_stream, multicast_status,num_dev);
 
     DEBUG("got multicast status = %d dev = %d",*multicast_status,*num_dev);
-
-    for (i = 0; i < STREAM_START_MAX_RETRY_COUNT; i++)
+    if (a2dp_read_codec_config(&audio_stream, 0) == 0)
     {
-        status = a2dp_read_codec_config(&audio_stream, 0);
-        if (status == A2DP_CTRL_ACK_SUCCESS)
-        {
-            pthread_mutex_unlock(&audio_stream.lock);
-            return (a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type));
-        }
-        INFO("%s: a2dp stream not configured,wait 100mse & retry", __func__);
-        usleep(100000);
+        pthread_mutex_unlock(&audio_stream.lock);
+        return (a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type));
     }
     pthread_mutex_unlock(&audio_stream.lock);
     return NULL;
@@ -1197,19 +1191,12 @@ void * audio_get_codec_config(uint8_t *multicast_status, uint8_t *num_dev,
 
 void* audio_get_next_codec_config(uint8_t idx, audio_format_t *codec_type)
 {
-    int i, status, j;
     INFO("%s",__func__);
     pthread_mutex_lock(&audio_stream.lock);
-    for (i = 0; i < STREAM_START_MAX_RETRY_COUNT; i++)
+    if (a2dp_read_codec_config(&audio_stream,idx) == 0)
     {
-        status = a2dp_read_codec_config(&audio_stream, 0);
-        if (status == A2DP_CTRL_ACK_SUCCESS)
-        {
-            pthread_mutex_unlock(&audio_stream.lock);
-            return (a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type));
-        }
-        INFO("%s: a2dp stream not configured,wait 100mse & retry", __func__);
-        usleep(100000);
+        pthread_mutex_unlock(&audio_stream.lock);
+        return a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type);
     }
     pthread_mutex_unlock(&audio_stream.lock);
     return NULL;
diff --git a/audio_a2dp_hw/bthost_ipc.h b/audio_a2dp_hw/bthost_ipc.h
index d0a561a..14c7154 100644
--- a/audio_a2dp_hw/bthost_ipc.h
+++ b/audio_a2dp_hw/bthost_ipc.h
@@ -30,14 +30,23 @@
 #ifndef BT_HOST_IPC_H
 #define BT_HOST_IPC_H
 #include "audio_a2dp_hw.h"
+#include <hardware/audio.h>
+#ifdef ANDROID
 #include <system/audio.h>
+#endif
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
 
 #define BT_AUDIO_HARDWARE_INTERFACE "libbthost"
+
+#ifdef ANDROID
 #define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
 #define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
+#else
+#define A2DP_CTRL_PATH "/etc/bluetooth/.a2dp_ctrl"
+#define A2DP_DATA_PATH "/etc/bluetooth/.a2dp_data"
+#endif
 
 typedef enum {
     A2DP_CTRL_GET_CODEC_CONFIG = 15,
@@ -116,6 +125,44 @@ codec specific definitions
 #define A2D_AAC_IE_VBR_MSK                     0x80
 #define A2D_AAC_IE_VBR                         0x80    /* supported */
 
+#ifndef ANDROID
+/* Information about BT SBC encoder configuration
+ * This data is used between audio HAL module and
+ * BT IPC library to configure DSP encoder  */
+typedef struct {
+    uint32_t subband;    /* 4, 8 */
+    uint32_t blk_len;    /* 4, 8, 12, 16 */
+    uint16_t sampling_rate; /*44.1khz,48khz*/
+    uint8_t  channels;      /*0(Mono),1(Dual_mono),2(Stereo),3(JS)*/
+    uint8_t  alloc;         /*0(Loudness),1(SNR)*/
+    uint8_t  min_bitpool;   /* 2 */
+    uint8_t  max_bitpool;   /*53(44.1khz),51 (48khz) */
+    uint32_t bitrate;      /* 320kbps to 512kbps */
+} audio_sbc_encoder_config;
+
+
+/* Information about BT APTX encoder configuration
+ * This data is used between audio HAL module and
+ * BT IPC library to configure DSP encoder */
+typedef struct {
+    uint16_t sampling_rate;
+    uint8_t  channels;
+    uint32_t bitrate;
+} audio_aptx_encoder_config;
+
+
+/* Information about BT AAC encoder configuration
+ * This data is used between audio HAL module and
+ * BT IPC library to configure DSP encoder */
+typedef struct {
+    uint32_t enc_mode; /* LC, SBR, PS */
+    uint16_t format_flag; /* RAW, ADTS */
+    uint16_t channels; /* 1-Mono, 2-Stereo */
+    uint32_t sampling_rate;
+    uint32_t bitrate;
+} audio_aac_encoder_config;
+#endif
+
 typedef struct {
     uint8_t  codec_type;
     uint8_t  dev_idx;
diff --git a/bta/Makefile.am b/bta/Makefile.am
new file mode 100644
index 0000000..b555e08
--- /dev/null
+++ b/bta/Makefile.am
@@ -0,0 +1,114 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+if MDM_CHEROKEE
+AM_CFLAGS += -DBTA_AV_SPLIT_A2DP_ENABLED
+AM_CFLAGS += -DBTA_AV_SPLIT_A2DP_DEF_FREQ_48KHZ
+endif
+
+AM_CPPFLAGS = -Iinclude \
+        -Isys \
+        -Idm \
+        -Ihh \
+        -I../ \
+        -I../btcore/include \
+        -I../hci/include \
+        -I../include \
+        -I../stack/include \
+        -I../stack/btm \
+        -I../udrv/include \
+        -I../vnd/include \
+        -I../utils/include \
+        -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext \
+	-I../../../hardware/libhardware/include  
+
+c_sources = \
+        dm/bta_dm_ci.c \
+        dm/bta_dm_act.c \
+        dm/bta_dm_pm.c \
+        dm/bta_dm_main.c \
+        dm/bta_dm_cfg.c \
+        dm/bta_dm_api.c \
+        dm/bta_dm_sco.c \
+        gatt/bta_gattc_api.c \
+        gatt/bta_gatts_act.c \
+        gatt/bta_gatts_main.c \
+        gatt/bta_gattc_utils.c \
+        gatt/bta_gatts_api.c \
+        gatt/bta_gattc_main.c \
+        gatt/bta_gattc_act.c \
+        gatt/bta_gattc_cache.c \
+        gatt/bta_gatts_utils.c \
+        ag/bta_ag_sdp.c \
+        ag/bta_ag_sco.c \
+        ag/bta_ag_cfg.c \
+        ag/bta_ag_main.c \
+        ag/bta_ag_api.c \
+        ag/bta_ag_rfc.c \
+        ag/bta_ag_act.c \
+        ag/bta_ag_cmd.c \
+        ag/bta_ag_ci.c \
+        ag/bta_ag_at.c \
+        hf_client/bta_hf_client_act.c \
+        hf_client/bta_hf_client_api.c \
+        hf_client/bta_hf_client_main.c \
+        hf_client/bta_hf_client_rfc.c \
+        hf_client/bta_hf_client_at.c \
+        hf_client/bta_hf_client_sdp.c \
+        hf_client/bta_hf_client_sco.c \
+        hf_client/bta_hf_client_cmd.c \
+        hh/bta_hh_cfg.c \
+        hh/bta_hh_act.c \
+        hh/bta_hh_api.c \
+        hh/bta_hh_le.c \
+        hh/bta_hh_utils.c \
+        hh/bta_hh_main.c \
+        pan/bta_pan_main.c \
+        pan/bta_pan_ci.c \
+        pan/bta_pan_act.c \
+        pan/bta_pan_api.c \
+        av/bta_av_act.c \
+        av/bta_av_ci.c \
+        av/bta_av_api.c \
+        av/bta_av_aact.c \
+        av/bta_av_main.c \
+        av/bta_av_cfg.c \
+        av/bta_av_ssm.c \
+        av/bta_av_sbc.c \
+        av/bta_av_aac.c \
+        ar/bta_ar.c \
+        hl/bta_hl_ci.c \
+        hl/bta_hl_act.c \
+        hl/bta_hl_api.c \
+        hl/bta_hl_main.c \
+        hl/bta_hl_utils.c \
+        hl/bta_hl_sdp.c \
+        sdp/bta_sdp_api.c \
+        sdp/bta_sdp_act.c \
+        sdp/bta_sdp.c \
+        sdp/bta_sdp_cfg.c \
+        sys/bta_sys_main.c \
+        sys/bta_sys_conn.c \
+        sys/utl.c \
+        jv/bta_jv_act.c \
+        jv/bta_jv_cfg.c \
+        jv/bta_jv_main.c \
+        jv/bta_jv_api.c
+
+
+common_LDFLAGS = -lpthread -lresolv -lrt ../stack/libbtstack.la -lbtif
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbtbta.la
+libbtbta_la_CC = @CC@
+libbtbta_la_SOURCES = $(c_sources)
+libbtbta_la_CPPFLAGS =$(AM_CPPFLAGS)
+libbtbta_la_CFLAGS = $(common_CFLAGS)
+libbtbta_la_LDFLAGS := $(common_LDFLAGS) -static
diff --git a/bta/ag/bta_ag_act.c b/bta/ag/bta_ag_act.c
index 65cd63e..92d5636 100644
--- a/bta/ag/bta_ag_act.c
+++ b/bta/ag/bta_ag_act.c
@@ -32,7 +32,9 @@
 #include <string.h>
 #include "bta_dm_int.h"
 #include "l2c_api.h"
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 #include <hardware/bluetooth.h>
 #include "device/include/interop.h"
 /*****************************************************************************
@@ -222,8 +224,13 @@ void bta_ag_start_open(tBTA_AG_SCB *p_scb, tBTA_AG_DATA *p_data)
     if (PORT_IsOpening (pending_bd_addr))
     {
         char value[PROPERTY_VALUE_MAX];
+#ifdef ANDROID
         if (property_get("persist.bt.max.hs.connections", value, "") &&
                      !strcmp(value, "2") )
+#else
+        if (property_get_bt("persist.bt.max.hs.connections", value, "") &&
+                     !strcmp(value, "2") )
+#endif
         {
             // Abort the outgoing connection if incoming connection is from the same device
             if (bdcmp (pending_bd_addr, p_scb->peer_addr) == 0)
@@ -616,8 +623,13 @@ void bta_ag_rfc_acp_open(tBTA_AG_SCB *p_scb, tBTA_AG_DATA *p_data)
             {
                 char value[PROPERTY_VALUE_MAX];
                 /* Read the property if multi hf is enabled */
+#ifdef ANDROID
                 if (property_get("persist.bt.max.hs.connections", value, "") &&
                      !strcmp(value, "2") )
+#else
+                if (property_get_bt("persist.bt.max.hs.connections", value, "") &&
+                     !strcmp(value, "2") )
+#endif
                 {
                     /* If incoming and outgoing device are same, nothing more to do.            */
                     /* Outgoing conn will be aborted because we have successful incoming conn.  */
diff --git a/bta/ag/bta_ag_cmd.c b/bta/ag/bta_ag_cmd.c
index 40a9c82..fee1c54 100644
--- a/bta/ag/bta_ag_cmd.c
+++ b/bta/ag/bta_ag_cmd.c
@@ -36,7 +36,9 @@
 #include "bt_common.h"
 #include "port_api.h"
 #include "utl.h"
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 #include "device/include/interop.h"
 #include "btif/include/btif_storage.h"
 
@@ -364,7 +366,11 @@ static void bta_ag_send_result(tBTA_AG_SCB *p_scb, UINT8 code, char *p_arg,
     *p++ = '\n';
 
     /* copy result code string */
+#ifdef ANDROID
     strlcpy(p, bta_ag_result_tbl[code].p_res, sizeof(buf) - 2);
+#else
+    strncpy(p, bta_ag_result_tbl[code].p_res, sizeof(buf) - 2);
+#endif
 #if defined(BTA_HSP_RESULT_REPLACE_COLON) && (BTA_HSP_RESULT_REPLACE_COLON == TRUE)
     if (p_scb->conn_service == BTA_AG_HSP)
     {
@@ -887,7 +893,11 @@ static void bta_ag_process_unat_res(char *unat_result)
         /* Add EOF */
         trim_data[j] = '\0';
         str_leng = str_leng - 4;
+#ifdef ANDROID
         strlcpy(unat_result, trim_data, str_leng+1);
+#else
+         strncpy(unat_result, trim_data, str_leng+1);
+#endif
         i=0;
         j=0;
 
@@ -983,7 +993,11 @@ void bta_ag_at_hsp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
     val.hdr.handle = bta_ag_scb_to_idx(p_scb);
     val.hdr.app_id = p_scb->app_id;
     val.num = (UINT16) int_arg;
+#ifdef ANDROID
     strlcpy(val.str, p_arg, BTA_AG_AT_MAX_LEN);
+#else
+        strncpy(val.str, p_arg, BTA_AG_AT_MAX_LEN);
+#endif
 
     /* call callback with event */
     (*bta_ag_cb.p_cback)(bta_ag_hsp_cb_evt[cmd], (tBTA_AG *) &val);
@@ -1026,7 +1040,11 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
     val.num = int_arg;
     bdcpy(val.bd_addr, p_scb->peer_addr);
     memset(val.str, 0, sizeof(val.str));
+#ifdef ANDROID
     strlcpy(val.str, p_arg, BTA_AG_AT_MAX_LEN);
+#else
+        strncpy(val.str, p_arg, BTA_AG_AT_MAX_LEN);
+#endif
 
     event = bta_ag_hfp_cb_evt[cmd];
 
@@ -1252,8 +1270,13 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
                  (!(p_scb->peer_features & BTA_AG_PEER_FEAT_HFIND)))
             {
                 /* For PTS keep flags as is. */
+#ifdef ANDROID
                 if (property_get("bt.pts.certification", value, "false") &&
                     strcmp(value, "true") != 0)
+#else
+                if (property_get_bt("bt.pts.certification", value, "false") &&
+                    strcmp(value, "true") != 0)
+#endif
                 {
                     features = features & ~(BTA_AG_FEAT_HFIND | BTA_AG_FEAT_S4);
                 }
@@ -1264,8 +1287,13 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB *p_scb, UINT16 cmd, UINT8 arg_type,
                 APPL_TRACE_WARNING("%s: Remote is hfp 1.7 but does not support HF indicators" \
                                      "unset hf indicator bit from BRSF", __func__);
                 /* For PTS keep flags as is. */
+#ifdef ANDROID
                 if (property_get("bt.pts.certification", value, "false") &&
                     strcmp(value, "true") != 0)
+#else
+                if (property_get_bt("bt.pts.certification", value, "false") &&
+                    strcmp(value, "true") != 0)
+#endif
                 {
                     features = features & ~(BTA_AG_FEAT_HFIND);
                 }
@@ -1576,7 +1604,11 @@ void bta_ag_at_err_cback(tBTA_AG_SCB *p_scb, BOOLEAN unknown, char *p_arg)
         val.hdr.handle = bta_ag_scb_to_idx(p_scb);
         val.hdr.app_id = p_scb->app_id;
         val.num = 0;
+#ifdef ANDROID
         strlcpy(val.str, p_arg, BTA_AG_AT_MAX_LEN);
+#else
+        strncpy(val.str, p_arg, BTA_AG_AT_MAX_LEN);
+#endif
         (*bta_ag_cb.p_cback)(BTA_AG_AT_UNAT_EVT, (tBTA_AG *) &val);
     }
     else
diff --git a/bta/av/bta_av_main.c b/bta/av/bta_av_main.c
index 50b116d..012255f 100644
--- a/bta/av/bta_av_main.c
+++ b/bta/av/bta_av_main.c
@@ -34,7 +34,9 @@
 
 #include "bt_target.h"
 #include "osi/include/log.h"
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 
 #if defined(BTA_AV_INCLUDED) && (BTA_AV_INCLUDED == TRUE)
 #include "bta_av_co.h"
@@ -174,6 +176,9 @@ static const tBTA_AV_ST_TBL bta_av_st_tbl[] =
 
 typedef void (*tBTA_AV_NSM_ACT)(tBTA_AV_DATA *p_data);
 static void bta_av_api_enable(tBTA_AV_DATA *p_data);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+void bta_av_assign_cbs(UINT16  profile_initialized);
+#endif
 static void bta_av_api_register(tBTA_AV_DATA *p_data);
 #if (BTA_AV_SINK_INCLUDED == TRUE)
 static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data);
@@ -232,6 +237,9 @@ static char *bta_av_st_code(UINT8 state);
 #endif
 
 static BOOLEAN is_multicast_enabled = FALSE;
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+tBTA_AV_CB  bta_av_cb_src,bta_av_cb_snk;
+#endif
 /*******************************************************************************
 **
 ** Function         bta_av_api_enable
@@ -473,7 +481,11 @@ static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data)
     activate_sink = p_data->hdr.layer_specific;
     APPL_TRACE_DEBUG("bta_av_api_sink_enable %d ", activate_sink)
     char p_service_name[BTA_SERVICE_NAME_LEN+1];
+#ifdef ANDROID
     strlcpy(p_service_name, BTIF_AVK_SERVICE_NAME, BTA_SERVICE_NAME_LEN);
+#else
+   strncpy(p_service_name, BTIF_AVK_SERVICE_NAME, BTA_SERVICE_NAME_LEN);
+#endif
 
     if (activate_sink)
     {
@@ -498,6 +510,33 @@ static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data)
     }
 }
 #endif
+
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+/*******************************************************************************
+**
+** Function         bta_av_assign_cbs
+**
+** Description      assigns callbacks based on AV profile
+**
+** Returns          void
+**
+*******************************************************************************/
+void bta_av_assign_cbs(UINT16  profile_initialized)
+{
+    APPL_TRACE_DEBUG("bta_av_assign_cbs:Assign cb based on A2DP role");
+    if (profile_initialized == UUID_SERVCLASS_AUDIO_SOURCE)
+    {
+        p_bta_av_cfg  = (tBTA_AV_CFG *) &bta_av_cfg;
+        bta_av_cb = bta_av_cb_src;
+    }
+    else if (profile_initialized == UUID_SERVCLASS_AUDIO_SINK)
+    {
+        p_bta_av_cfg  = (tBTA_AV_CFG *) &bta_avk_cfg;
+        bta_av_cb = bta_av_cb_snk;
+    }
+}
+#endif
+
 /*******************************************************************************
 **
 ** Function         bta_av_api_register
@@ -615,6 +654,7 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
                 cod.service = BTM_COD_SERVICE_CAPTURING;
             else if (profile_initialized == UUID_SERVCLASS_AUDIO_SINK)
                 cod.service = BTM_COD_SERVICE_RENDERING;
+
             utl_set_device_class(&cod, BTA_UTL_SET_COD_SERVICE_CLASS);
         } /* if 1st channel */
 
@@ -753,7 +793,12 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
                     } else {
                         char value[PROPERTY_VALUE_MAX];
                         bool enableAptXHD = false;
+#ifdef ANDROID
                         if (property_get("persist.bt.enableAptXHD", value, "false") && strcmp(value, "true") == 0)
+#else
+                        if (property_get_bt("persist.bt.enableAptXHD", value, "false") &&  strcmp(value, "true") != 0)
+#endif
+
                             enableAptXHD = true;
                         else
                             APPL_TRACE_WARNING("%s enableAptXHD property is not set", __func__);
@@ -877,6 +922,12 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
 
     /* call callback with register event */
     (*bta_av_cb.p_cback)(BTA_AV_REGISTER_EVT, (tBTA_AV *)&registr);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    if (p_data->api_reg.service_uuid == UUID_SERVCLASS_AUDIO_SOURCE)
+        bta_av_cb_src = bta_av_cb;
+    else if (p_data->api_reg.service_uuid == UUID_SERVCLASS_AUDIO_SINK)
+        bta_av_cb_snk = bta_av_cb;
+#endif
 }
 
 /*******************************************************************************
@@ -1330,9 +1381,15 @@ BOOLEAN bta_av_link_role_ok(tBTA_AV_SCB *p_scb, UINT8 bits)
 
     if (BTM_GetRole(p_scb->peer_addr, &role) == BTM_SUCCESS)
     {
+#ifdef ANDROID
         LOG_INFO("%s hndl:x%x role:%d conn_audio:x%x bits:%d features:x%x",
                 __func__, p_scb->hndl, role, bta_av_cb.conn_audio, bits,
                 bta_av_cb.features);
+#else
+        LOG_INFO(LOG_TAG,"%s hndl:x%x role:%d conn_audio:x%x bits:%d features:x%x",
+                __func__, p_scb->hndl, role, bta_av_cb.conn_audio, bits,
+                bta_av_cb.features);
+#endif
         if (BTM_ROLE_MASTER != role && (A2D_BitsSet(bta_av_cb.conn_audio) > bits || (bta_av_cb.features & BTA_AV_FEAT_MASTER)))
         {
             if (bta_av_cb.features & BTA_AV_FEAT_MASTER)
diff --git a/bta/dm/bta_dm_act.c b/bta/dm/bta_dm_act.c
index 985e758..8340b11 100644
--- a/bta/dm/bta_dm_act.c
+++ b/bta/dm/bta_dm_act.c
@@ -1,4 +1,11 @@
 /******************************************************************************
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
  *
  *  Copyright (C) 2003-2014 Broadcom Corporation
  *
@@ -45,7 +52,6 @@
 #include "sdp_api.h"
 #include "utl.h"
 #include "device/include/interop_config.h"
-
 #if (GAP_INCLUDED == TRUE)
 #include "gap_api.h"
 #endif
@@ -245,11 +251,16 @@ const tBTM_APPL_INFO bta_security =
 };
 
 #define MAX_DISC_RAW_DATA_BUF       (4096)
+
 UINT8 g_disc_raw_data_buf[MAX_DISC_RAW_DATA_BUF];
 
 extern DEV_CLASS local_device_default_class;
 extern fixed_queue_t *btu_bta_alarm_queue;
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+extern BOOLEAN btif_dm_is_controller_ready;
+#endif
+
 /*******************************************************************************
 **
 ** Function         bta_dm_enable
@@ -277,7 +288,7 @@ void bta_dm_enable(tBTA_DM_MSG *p_data)
 
     /* first, register our callback to SYS HW manager */
     bta_sys_hw_register( BTA_SYS_HW_BLUETOOTH, bta_dm_sys_hw_cback );
-
+        LOG_INFO(LOG_TAG," %sbta_dm_enable",__func__);
     /* make sure security callback is saved - if no callback, do not erase the previous one,
     it could be an error recovery mechanism */
     if( p_data->enable.p_sec_cback != NULL  )
@@ -458,14 +469,10 @@ static void bta_dm_sys_hw_cback( tBTA_SYS_HW_EVT status )
            when the ENABLE_EVT was sent. So modified this to fetch the local name which forces
            the DM_ENABLE_EVT to be sent only after all the init steps are complete */
         BTM_ReadLocalDeviceNameFromController((tBTM_CMPL_CB *)bta_dm_local_name_cback);
-
         bta_sys_rm_register((tBTA_SYS_CONN_CBACK*)bta_dm_rm_cback);
-
         /* initialize bluetooth low power manager */
         bta_dm_init_pm();
-
         bta_sys_policy_register((tBTA_SYS_CONN_CBACK*)bta_dm_policy_cback);
-
 #if (BLE_INCLUDED == TRUE && BTA_GATT_INCLUDED == TRUE)
         bta_dm_gattc_register();
 #endif
@@ -473,9 +480,16 @@ static void bta_dm_sys_hw_cback( tBTA_SYS_HW_EVT status )
     }
     else
         APPL_TRACE_DEBUG(" --- ignored event");
-
 }
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+void bta_dm_ble_clear_bg_conn_dev(tBTA_DM_MSG *p_data)
+{
+    UNUSED(p_data);
+    APPL_TRACE_DEBUG(" bta_dm_ble_clear_bg_conn_dev");
+    BTM_BleClearBgConnDev();
+}
+#endif
 
 /*******************************************************************************
 **
@@ -636,6 +650,21 @@ void bta_dm_set_visibility(tBTA_DM_MSG *p_data)
     UINT16 disc_mode = BTM_ReadDiscoverability(&window, &interval);
     UINT16 conn_mode = BTM_ReadConnectability(&window, &interval);
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+    APPL_TRACE_DEBUG("%s btif_dm_is_controller_ready:%d ", __func__, btif_dm_is_controller_ready);
+    if(btif_dm_is_controller_ready==FALSE)
+    {
+        APPL_TRACE_DEBUG("%s Bluetooth Controller is not ready!!", __func__);
+        /*
+        CR 2188418: Frequent Controller reset happening after  Host receiving error code  in response of Sleep indication command.
+        Root cause: When Host wake using system power button and Bluetooth settings screen is active then BT App sends set visibilty before BT Controller
+        wakes up resulting Bluetooth crash seen.
+        FIX: Don't handle command if controller is still in LPM.
+        TBD: This Fix may not be needed, if this condition is handled rightly in the Application.
+        */
+        return;
+    }
+#endif
     /* set modes for Discoverability and connectability if not ignore */
     if (p_data->set_visibility.disc_mode != (BTA_DM_IGNORE | BTA_DM_LE_IGNORE))
     {
@@ -1348,7 +1377,11 @@ void bta_dm_search_cancel (tBTA_DM_MSG *p_data)
     /* If no Service Search going on then issue cancel remote name in case it is active */
     else if (!bta_dm_search_cb.name_discover_done)
     {
-        BTM_CancelRemoteDeviceName();
+        /* Inquiry issue fix */
+        BTM_CancelRemoteDeviceName(); 
+
+	  if(BTM_CancelRemoteDeviceName() == BTM_CMD_STARTED)
+            bta_dm_search_cb.name_discover_done = TRUE;
 
         p_msg = (tBTA_DM_MSG *)osi_malloc(sizeof(tBTA_DM_MSG));
         p_msg->hdr.event = BTA_DM_SEARCH_CMPL_EVT;
@@ -2993,7 +3026,7 @@ static UINT8 bta_dm_sp_cback (tBTM_SP_EVT event, tBTM_SP_EVT_DATA *p_data)
               bdcpy(sec_event.key_notif.bd_addr, p_data->cfm_req.bd_addr);
               BTA_COPY_DEVICE_CLASS(sec_event.key_notif.dev_class, p_data->cfm_req.dev_class);
               strlcpy((char*)sec_event.key_notif.bd_name,
-                      (char*)p_data->cfm_req.bd_name, BD_NAME_LEN);
+                      (char*)p_data->cfm_req.bd_name, BD_NAME_LEN+1);
            }
         }
 
diff --git a/bta/dm/bta_dm_api.c b/bta/dm/bta_dm_api.c
index 42167ae..f65b602 100644
--- a/bta/dm/bta_dm_api.c
+++ b/bta/dm/bta_dm_api.c
@@ -102,6 +102,20 @@ tBTA_STATUS BTA_DisableBluetooth(void)
     return BTA_SUCCESS;
 }
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+tBTA_STATUS BTA_dm_ble_clear_bg_conn_dev(void)
+{
+    APPL_TRACE_API("%s", __func__);
+
+    BT_HDR *p_msg = (BT_HDR *)osi_malloc(sizeof(BT_HDR));
+
+    p_msg->event = BTA_DM_API_CLEAR_BG_CONN_EVT;
+
+    bta_sys_sendmsg(p_msg);
+
+    return BTA_SUCCESS;
+}
+#endif
 /*******************************************************************************
 **
 ** Function         BTA_EnableTestMode
@@ -160,8 +174,7 @@ void BTA_DmSetDeviceName(char *p_name)
         (tBTA_DM_API_SET_NAME *)osi_malloc(sizeof(tBTA_DM_API_SET_NAME));
 
     p_msg->hdr.event = BTA_DM_API_SET_NAME_EVT;
-    strlcpy((char*)p_msg->name, p_name, BD_NAME_LEN);
-
+    strncpy((char*)p_msg->name, p_name,sizeof(p_msg->name));
     bta_sys_sendmsg(p_msg);
 }
 
diff --git a/bta/dm/bta_dm_int.h b/bta/dm/bta_dm_int.h
index 3e8a2422..0e699b1 100644
--- a/bta/dm/bta_dm_int.h
+++ b/bta/dm/bta_dm_int.h
@@ -126,6 +126,9 @@ enum
     BTA_DM_API_REMOVE_DEVICE_EVT,
     BTA_DM_API_HCI_RAW_COMMAND_EVT,
     BTA_DM_API_VENDOR_SPECIFIC_COMMAND_EVT,
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+    BTA_DM_API_CLEAR_BG_CONN_EVT,
+#endif
     BTA_DM_MAX_EVT
 };
 
@@ -1135,6 +1138,10 @@ extern void bta_dm_search_sm_disable( void );
 
 extern void bta_dm_enable (tBTA_DM_MSG *p_data);
 extern void bta_dm_disable (tBTA_DM_MSG *p_data);
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+extern void bta_dm_ble_clear_bg_conn_dev (tBTA_DM_MSG *p_data);
+#endif
+
 extern void bta_dm_init_cb(void);
 extern void bta_dm_set_dev_name (tBTA_DM_MSG *p_data);
 extern void bta_dm_set_visibility (tBTA_DM_MSG *p_data);
diff --git a/bta/dm/bta_dm_main.c b/bta/dm/bta_dm_main.c
index 4e51183..df84fe3 100644
--- a/bta/dm/bta_dm_main.c
+++ b/bta/dm/bta_dm_main.c
@@ -123,6 +123,9 @@ const tBTA_DM_ACTION bta_dm_action[] =
     bta_dm_remove_device,       /* BTA_DM_API_REMOVE_DEVICE_EVT */
     bta_dm_hci_raw_command,    /* BTA_DM_API_HCI_RAW_COMMAND_EVT */
     bta_dm_vendor_spec_command,/* BTA_DM_API_VENDOR_SPECIFIC_COMMAND_EVT */
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+    bta_dm_ble_clear_bg_conn_dev, /* BTA_DM_API_CLEAR_BG_CONN_EVT*/
+#endif
 };
 
 
diff --git a/bta/include/bta_api.h b/bta/include/bta_api.h
index 0984f2c..0c2cde2 100644
--- a/bta/include/bta_api.h
+++ b/bta/include/bta_api.h
@@ -1381,6 +1381,19 @@ extern tBTA_STATUS BTA_DisableBluetooth(void);
 
 /*******************************************************************************
 **
+** Function         BTA_dm_ble_clear_bg_conn_dev
+**
+** Description      This function cancels BLE background connection that was initiated earlier.
+**
+**
+** Returns          void
+**
+*******************************************************************************/
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+extern tBTA_STATUS BTA_dm_ble_clear_bg_conn_dev(void) ;
+#endif
+/*******************************************************************************
+**
 ** Function         BTA_EnableTestMode
 **
 ** Description      Enables bluetooth device under test mode
diff --git a/bta/sys/bta_sys_main.c b/bta/sys/bta_sys_main.c
index 6bb64c6..4ee0e53 100644
--- a/bta/sys/bta_sys_main.c
+++ b/bta/sys/bta_sys_main.c
@@ -354,6 +354,8 @@ void bta_sys_hw_api_enable( tBTA_SYS_HW_MSG *p_sys_hw_msg )
         if (bta_sys_cb.sys_hw_cback[p_sys_hw_msg->hw_module ]!= NULL )
             bta_sys_cb.sys_hw_cback[p_sys_hw_msg->hw_module ](  BTA_SYS_HW_ON_EVT   );
     }
+        LOG_INFO (LOG_TAG," %s bta_sys_hw_api_enable for %d, active modules 0x%04X",__func__,
+                    p_sys_hw_msg->hw_module, bta_sys_cb.sys_hw_module_active);
 
     APPL_TRACE_EVENT ("bta_sys_hw_api_enable for %d, active modules 0x%04X",
                     p_sys_hw_msg->hw_module, bta_sys_cb.sys_hw_module_active);
diff --git a/btcore/Makefile.am b/btcore/Makefile.am
new file mode 100644
index 0000000..20c58c2
--- /dev/null
+++ b/btcore/Makefile.am
@@ -0,0 +1,35 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS = \
+        -I../ \
+        -Iinclude \
+        -I../osi/include \
+	-I../../../hardware/libhardware/include
+
+c_sources = \
+        src/bdaddr.c \
+        src/device_class.c \
+        src/module.c \
+        src/osi_module.c \
+        src/property.c \
+        src/uuid.c \
+        src/hal_util.c
+
+common_LDFLAGS = -lpthread  -lrt -lresolv
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbtcore.la
+libbtcore_la_CC = @CC@
+libbtcore_la_SOURCES = $(c_sources)
+libbtcore_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbtcore_la_CFLAGS = $(common_CFLAGS)
+libbtcore_la_LDFLAGS = $(common_LDFLAGS) -static
diff --git a/btcore/src/module.c b/btcore/src/module.c
index ab7710a..253d8ac 100644
--- a/btcore/src/module.c
+++ b/btcore/src/module.c
@@ -77,6 +77,7 @@ const module_t *get_module(const char *name) {
 bool module_init(const module_t *module) {
   assert(metadata != NULL);
   assert(module != NULL);
+    LOG_INFO(LOG_TAG, "%s module \"%s\"", __func__, module->name);
   assert(get_module_state(module) == MODULE_STATE_NONE);
 
   LOG_INFO(LOG_TAG, "%s Initializing module \"%s\"", __func__, module->name);
diff --git a/btcore/src/osi_module.c b/btcore/src/osi_module.c
index e7a580d..ec1f7aa 100644
--- a/btcore/src/osi_module.c
+++ b/btcore/src/osi_module.c
@@ -39,6 +39,11 @@ future_t *osi_clean_up(void) {
   return future_new_immediate(FUTURE_SUCCESS);
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t osi_module = {
   .name = OSI_MODULE,
   .init = osi_init,
diff --git a/btif/Makefile.am b/btif/Makefile.am
new file mode 100644
index 0000000..86552eb
--- /dev/null
+++ b/btif/Makefile.am
@@ -0,0 +1,114 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+if MDM_CHEROKEE
+AM_CFLAGS += -DBTA_AV_SPLIT_A2DP_ENABLED
+AM_CFLAGS += -DBTA_AV_SPLIT_A2DP_DEF_FREQ_48KHZ
+AM_CFLAGS += -DAPTX_48000
+endif
+
+AM_CPPFLAGS = \
+        -I../ \
+        -I../bta/include \
+        -I../bta/sys \
+        -I../bta/dm \
+        -I../btcore/include \
+        -I../include \
+        -I../stack/include \
+        -I../stack/l2cap \
+        -I../stack/a2dp \
+        -I../stack/btm \
+        -I../stack/avdt \
+        -I../hcis \
+        -I../hcis/include \
+        -I../hcis/patchram \
+        -I../udrv/include \
+        -I../btif/include \
+        -I../btif/co \
+        -I../hci/include\
+        -I../vnd/include \
+        -I../brcm/include \
+        -I../embdrv/sbc/encoder/include \
+        -I../embdrv/sbc/decoder/include \
+        -I../audio_a2dp_hw \
+        -I../utils/include \
+        -I${WORKSPACE}/external/tinyxml2 \
+        -I${WORKSPACE}/external/zlib \
+        -I../../../vendor/qcom/opensource/bluetooth/vhal/include \
+        -I$(WORKSPACE)/frameworks/av/include \
+        -I../../../system/media/audio/include \
+        -I../../../system/media/audio_utils/include \
+        -I$(WORKSPACE)/system/core/include \
+        -I../../../vendor/qcom/opensource/bluetooth/hal/include \
+        -I../../../hardware/libhardware/include
+
+c_sources = \
+        src/bluetooth.c \
+        src/btif_av.c \
+        src/btif_config.c \
+        src/btif_core.c \
+        src/btif_debug.c \
+        src/btif_debug_btsnoop.c \
+        src/btif_debug_conn.c \
+        src/btif_dm.c \
+        src/btif_gatt.c \
+        src/btif_gatt_client.c \
+        src/btif_gatt_multi_adv_util.c \
+        src/btif_gatt_server.c \
+        src/btif_gatt_test.c \
+        src/btif_gatt_util.c \
+        src/btif_hf.c \
+        src/btif_hf_client.c \
+        src/btif_hh.c \
+        src/btif_hl.c \
+	src/btif_debug_l2c.c \
+        src/btif_sdp.c \
+        src/btif_media_task.c \
+        src/btif_pan.c \
+        src/btif_profile_queue.c \
+        src/btif_rc.c \
+        src/btif_sm.c \
+        src/btif_sock.c \
+        src/btif_sock_rfc.c \
+        src/btif_sock_l2cap.c \
+        src/btif_sock_sco.c \
+        src/btif_sock_sdp.c \
+        src/btif_sock_thread.c \
+        src/btif_sdp_server.c \
+        src/btif_sock_util.c \
+        src/btif_storage.c \
+        src/btif_uid.c \
+        src/btif_util.c \
+        src/stack_manager.c \
+        src/btif_stack_log.c \
+        src/btif_rfcomm.c \
+        src/btif_l2cap.c \
+        src/btif_vendor.c \
+        src/btif_gap.c \
+        src/btif_smp.c \
+        co/bta_ag_co.c \
+        co/bta_dm_co.c \
+        co/bta_av_co.c \
+        co/bta_hh_co.c \
+        co/bta_hl_co.c \
+        co/bta_pan_co.c \
+        co/bta_gatts_co.c
+
+common_LDFLAGS = -lpthread -lz -lrt -lresolv ../bta/libbtbta.la ../osi/libbtosi.la \
+                 ../device/libbtdevice.la
+
+common_CFLAGS =  $(AM_CFLAGS) -D_GNU_SOURCE -DUSE_AUDIO_TRACK $(Z_LIB) -fPIC
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbtif.la
+libbtif_la_CC = @CC@
+libbtif_la_SOURCES = $(c_sources)
+libbtif_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbtif_la_CFLAGS = $(common_CFLAGS)
+libbtif_la_LDFLAGS = $(common_LDFLAGS) -static
diff --git a/btif/co/bta_ag_co.c b/btif/co/bta_ag_co.c
index c50c128..fa2c697 100644
--- a/btif/co/bta_ag_co.c
+++ b/btif/co/bta_ag_co.c
@@ -17,8 +17,9 @@
  ******************************************************************************/
 
 #define LOG_TAG "bt_btif_bta_ag"
-
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 
 #include "bta/include/bta_ag_api.h"
 #include "hci/include/hci_audio.h"
diff --git a/btif/co/bta_av_co.c b/btif/co/bta_av_co.c
index e6f480f..544176a 100644
--- a/btif/co/bta_av_co.c
+++ b/btif/co/bta_av_co.c
@@ -27,7 +27,9 @@
  *  BTIF.
  *
  ******************************************************************************/
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 #include "string.h"
 #include "a2d_api.h"
 #include "a2d_sbc.h"
@@ -1724,7 +1726,11 @@ BOOLEAN bta_av_co_audio_is_aac_enabled(bt_bdaddr_t *remote_bdaddr)
     int retval;
     BOOLEAN res = FALSE;
     char is_whitelist_by_default[255] = "false";
+#ifdef ANDROID
     retval = property_get("persist.bt.a2dp.aac_whitelist", is_whitelist_by_default, "false");
+#else
+    retval = property_get_bt("persist.bt.a2dp.aac_whitelist", is_whitelist_by_default, "false");
+#endif
     BTIF_TRACE_DEBUG("%s: property_get: bt.a2dp.aac_whitelist: %s, retval: %d",
                                     __func__, is_whitelist_by_default, retval);
 
diff --git a/btif/co/bta_hh_co.c b/btif/co/bta_hh_co.c
index 344f4ac..e82f474 100644
--- a/btif/co/bta_hh_co.c
+++ b/btif/co/bta_hh_co.c
@@ -27,6 +27,7 @@
 #include <stdint.h>
 #include <sys/poll.h>
 #include <unistd.h>
+#include <stack_config.h>
 
 #include "btcore/include/bdaddr.h"
 #include "osi/include/osi.h"
@@ -50,7 +51,7 @@ static tBTA_HH_RPT_CACHE_ENTRY sReportCache[BTA_HH_NV_LOAD_MAX];
 #define REPORT_DESC_DIGITIZER_PAGE      0x0D
 #define REPORT_DESC_START_COLLECTION    0xA1
 #define REPORT_DESC_END_COLLECTION      0xC0
-
+static void createHidReportLogs();
 static void remove_digitizer_descriptor(UINT8 **data, UINT16 *length)
 {
     UINT8 *startDescPtr = *data;
@@ -615,12 +616,36 @@ void bta_hh_co_data(UINT8 dev_handle, UINT8 *p_rpt, UINT16 len, tBTA_HH_PROTO_MO
     // Send the HID data to the kernel.
     if ((p_dev->fd >= 0) && p_dev->ready_for_data) {
         bta_hh_co_write(p_dev->fd, p_rpt, len);
+        if(stack_config_get_interface()->get_hid_logging_configuration())
+        {
+           createHidReportLogs(peer_addr);
+        }
     }else {
         APPL_TRACE_WARNING("%s: Error: fd = %d, ready %d, len = %d", __FUNCTION__, p_dev->fd, 
                             p_dev->ready_for_data, len);
     }
 }
-
+static void createHidReportLogs(BD_ADDR bd_addr)
+{ 
+
+  char buffer[26];
+  int millisec;
+  struct tm* tm_info;
+  struct timeval tv;
+  
+  gettimeofday(&tv, NULL);
+
+  millisec = (tv.tv_usec/1000.0); // Round to nearest millisec
+  if (millisec>=1000) { // Allow for rounding up to nearest second
+    millisec -=1000;
+    tv.tv_sec++;
+  }
+
+  tm_info = localtime(&tv.tv_sec);
+
+  strftime(buffer, 26, "%Y:%m:%d %H:%M:%S", tm_info);
+  APPL_TRACE_WARNING("HID Report Time %s.%03d BDAddress %08x%04x \n", buffer, millisec,(bd_addr[0]<<24)+(bd_addr[1]<<16)+(bd_addr[2]<<8)+bd_addr[3],(bd_addr[4]<<8)+bd_addr[5]);
+}
 /*******************************************************************************
 **
 ** Function         bta_hh_co_send_hid_info
@@ -803,7 +828,9 @@ void bta_hh_le_co_rpt_info(BD_ADDR remote_bda, tBTA_HH_RPT_CACHE_ENTRY *p_entry,
         remote_bda[0], remote_bda[1], remote_bda[2],
         remote_bda[3], remote_bda[4], remote_bda[5]);
 
-    size_t len = btif_config_get_bin_length(bdstr, "HidReport");
+    //TODO NAYLA
+    //size_t len = btif_config_get_bin_length(bdstr, "HidReport");
+    size_t len = 100;
     if (len >= sizeof(tBTA_HH_RPT_CACHE_ENTRY) && len <= sizeof(sReportCache))
     {
         btif_config_get_bin(bdstr, "HidReport", (uint8_t *)sReportCache, &len);
@@ -844,8 +871,9 @@ tBTA_HH_RPT_CACHE_ENTRY * bta_hh_le_co_cache_load (BD_ADDR remote_bda,
     sprintf(bdstr, "%02x:%02x:%02x:%02x:%02x:%02x",
         remote_bda[0], remote_bda[1], remote_bda[2],
         remote_bda[3], remote_bda[4], remote_bda[5]);
-
-    size_t len = btif_config_get_bin_length(bdstr, "HidReport");
+//TODO NAYla
+    //size_t len = btif_config_get_bin_length(bdstr, "HidReport");
+    size_t len = 100;
     if (!p_num_rpt || len < sizeof(tBTA_HH_RPT_CACHE_ENTRY))
         return NULL;
 
diff --git a/btif/include/btif_api.h b/btif/include/btif_api.h
index 14e16cb..415a763 100644
--- a/btif/include/btif_api.h
+++ b/btif/include/btif_api.h
@@ -431,4 +431,16 @@ bt_status_t btif_config_hci_snoop_log(uint8_t enable);
 **
 *******************************************************************************/
 void btif_debug_bond_event_dump(int fd);
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+/*******************************************************************************
+**
+** Function         btif_dm_unified_wakeup_sleep_ind
+**
+** Description     HOST SLEEP indication to controller
+**
+** Returns          void
+**
+*******************************************************************************/
+bt_status_t btif_dm_unified_wakeup_sleep_ind(BOOLEAN isSleep);
+#endif
 #endif /* BTIF_API_H */
diff --git a/btif/include/btif_av.h b/btif/include/btif_av.h
index 8e2de02..684d0a9 100644
--- a/btif/include/btif_av.h
+++ b/btif/include/btif_av.h
@@ -157,6 +157,18 @@ bt_status_t btif_av_init(int service_id);
 
 BOOLEAN btif_av_is_connected(void);
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+/*******************************************************************************
+**
+** Function         btif_av_state_is_not_idle
+**
+** Description      Checks if av state is not idle
+**
+** Returns          BOOLEAN
+**
+*******************************************************************************/
+BOOLEAN btif_av_state_is_not_idle(void);
+#endif
 
 /*******************************************************************************
 **
@@ -198,6 +210,17 @@ void audio_focus_status(int state);
 void btif_queue_focus_request(void);
 #endif
 
+/*******************************************************************************
+ **
+ ** Function         btif_media_enque_pcm_data
+ **
+ ** Description      queues PCM data
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void btif_media_enque_pcm_data(UINT8 *data, UINT16 size);
+
 /******************************************************************************
 **
 ** Function         btif_av_clear_remote_suspend_flag
diff --git a/btif/include/btif_storage.h b/btif/include/btif_storage.h
index a0d04c0..5f70d42 100644
--- a/btif/include/btif_storage.h
+++ b/btif/include/btif_storage.h
@@ -30,6 +30,19 @@
 #define BTIF_STORAGE_FILL_PROPERTY(p_prop, t, l, p_v) \
          (p_prop)->type = t;(p_prop)->len = l; (p_prop)->val = (p_v);
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+/*******************************************************************************
+**  Define AV role with respect to DUT which is useful in simultaneous A2DP sink/source roles
+********************************************************************************/
+enum a2dp_role
+{
+    A2DP_NONE = 0,
+    A2DP_SOURCE,
+    A2DP_SINK,
+};
+enum a2dp_role active_a2dp_role;
+#endif
+
 /*******************************************************************************
 **  Functions
 ********************************************************************************/
diff --git a/btif/src/bluetooth.c b/btif/src/bluetooth.c
index a264f32..bd1be9c 100644
--- a/btif/src/bluetooth.c
+++ b/btif/src/bluetooth.c
@@ -31,7 +31,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 #include <hardware/bluetooth.h>
 #include <hardware/bt_av.h>
 #include <hardware/bt_gatt.h>
@@ -197,15 +199,27 @@ static int disable(void) {
   if (!interface_ready())
     return BT_STATUS_NOT_READY;
 
-  stack_manager_get_interface()->shut_down_stack_async();
+if(bt_logger_enabled) {
+#ifdef ANDROID
+    property_set("bluetooth.startbtlogger", "false");
+#else
+  property_set_bt("bluetooth.startbtlogger", "false");
+#endif
+}
+ stack_manager_get_interface()->shut_down_stack_async();
   return BT_STATUS_SUCCESS;
 }
 
 static void cleanup(void) {
   stack_manager_get_interface()->clean_up_stack();
 
-  if(bt_logger_enabled)
+if(bt_logger_enabled) {
+#ifdef ANDROID
     property_set("bluetooth.startbtlogger", "false");
+#else
+  property_set_bt("bluetooth.startbtlogger", "false");
+#endif
+}
 }
 
 bool is_restricted_mode() {
@@ -383,14 +397,18 @@ static void dump(int fd, const char **arguments)
 {
     if (arguments != NULL && arguments[0] != NULL) {
       if (strncmp(arguments[0], "--proto-bin", 11) == 0) {
+#ifdef ANDROID
         metrics_write_base64(fd, true);
+#endif
         return;
       }
     }
     btif_debug_conn_dump(fd);
     btif_debug_bond_event_dump(fd);
     btif_debug_a2dp_dump(fd);
+#ifdef ANDROID
     btif_debug_l2c_dump(fd);
+#endif
     btif_debug_config_dump(fd);
     wakelock_debug_dump(fd);
     alarm_debug_dump(fd);
@@ -491,6 +509,18 @@ static const void* get_testapp_interface(int test_app_profile)
 
 #endif //TEST_APP_INTERFACE
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+static int unified_wakeup_sleep_ind(uint8_t isSleep)
+{
+    LOG_INFO(LOG_TAG, "unified_wakeup_sleep_ind");
+    /* sanity check */
+    if (interface_ready() == FALSE)
+        return BT_STATUS_NOT_READY;
+
+    return btif_dm_unified_wakeup_sleep_ind(isSleep);
+}
+#endif
+
 int dut_mode_configure(uint8_t enable)
 {
     LOG_INFO(LOG_TAG, "dut_mode_configure");
@@ -616,6 +646,11 @@ static const bt_interface_t bluetoothInterface = {
 #else
     NULL,
 #endif
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+    unified_wakeup_sleep_ind,
+#else
+    NULL,
+#endif
 };
 
 const bt_interface_t* bluetooth__get_bluetooth_interface ()
@@ -651,6 +686,11 @@ static struct hw_module_methods_t bt_stack_module_methods = {
     .open = open_bluetooth_stack,
 };
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL struct hw_module_t HAL_MODULE_INFO_SYM = {
     .tag = HARDWARE_MODULE_TAG,
     .version_major = 1,
diff --git a/btif/src/btif_av.c b/btif/src/btif_av.c
old mode 100755
new mode 100644
index e426ea3..7b6a054
--- a/btif/src/btif_av.c
+++ b/btif/src/btif_av.c
@@ -24,10 +24,16 @@
 
 #include <assert.h>
 #include <string.h>
-
+#ifdef ANDROID
 #include <system/audio.h>
+#include <cutils/properties.h>
+#endif
 #include <hardware/bluetooth.h>
 #include <hardware/bt_av.h>
+#ifndef ANDROID
+#include <hardware/bt_av_vendor.h>
+#include "osi/include/fixed_queue.h"
+#endif
 
 #include "bt_utils.h"
 #include "bta_api.h"
@@ -37,11 +43,9 @@
 #include "btu.h"
 #include "bt_common.h"
 #include "osi/include/allocator.h"
-#include <cutils/properties.h>
+
 #include "device/include/interop.h"
 #include "btif_storage.h"
-#include "audio_a2dp_hw.h"
-
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
@@ -79,11 +83,26 @@ typedef enum {
 #define HOST_ROLE_MASTER                   0x00
 #define HOST_ROLE_SLAVE                    0x01
 #define HOST_ROLE_UNKNOWN                  0xff
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+#define BT_AV_CAPTURER      0x08
+#define BT_AV_RENDERER      0x04
+#endif
+
+
+#ifndef ANDROID
+#define MAX_A2DP_SINK_PCM_QUEUE_SZ         20
+#endif
 
 /*****************************************************************************
 **  Local type definitions
 ******************************************************************************/
-
+#ifndef ANDROID
+typedef struct
+{
+    UINT16 len;
+    UINT16 offset;
+} tBT_PCM_HDR;
+#endif
 typedef struct
 {
     tBTA_AV_HNDL bta_handle;
@@ -99,11 +118,12 @@ typedef struct
     int service;
     BOOLEAN is_slave;
     BOOLEAN is_device_playing;
-    BOOLEAN is_remote_start_received;
-    BOOLEAN is_suspend_for_remote_start;
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
     UINT16 channel_id;
 #endif
+#ifndef ANDROID
+    fixed_queue_t *RxPcmQ;
+#endif
 } btif_av_cb_t;
 
 typedef struct
@@ -117,6 +137,10 @@ typedef struct
     int sample_rate;
     int channel_count;
     bt_bdaddr_t peer_bd;
+#ifndef ANDROID
+    UINT8 codec_type;
+    btav_snk_sbc_codec_config_t codec_config;
+#endif
 } btif_av_sink_config_req_t;
 
 typedef struct
@@ -134,6 +158,20 @@ typedef enum {
     APTXHD,
 }btif_av_codec_list;
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+typedef struct
+{
+    enum a2dp_role new_role_to_connect;
+    bt_bdaddr_t*  bdaddr_to_connect;
+    BOOLEAN new_request_to_connect_device;
+}btif_av_device_conn_details;
+btif_av_device_conn_details new_av_device_to_connect;
+#else
+#ifndef ANDROID
+BOOLEAN a2dp_snk_active = FALSE;
+#endif
+#endif
+
 /*****************************************************************************
 **  Static variables
 ******************************************************************************/
@@ -153,6 +191,7 @@ static BOOLEAN multicast_disabled = FALSE;
 BOOLEAN bt_split_a2dp_enabled = FALSE;
 BOOLEAN reconfig_a2dp = FALSE;
 btif_av_a2dp_offloaded_codec_cap_t btif_av_codec_offload;
+
 /* both interface and media task needs to be ready to alloc incoming request */
 #define CHECK_BTAV_INIT() if (((bt_av_src_callbacks == NULL) &&(bt_av_sink_callbacks == NULL)) \
         || (btif_av_cb[0].sm_handle == NULL))\
@@ -192,11 +231,12 @@ int btif_get_latest_playing_device_idx();
 static int btif_get_latest_device_idx_to_start();
 static int btif_av_get_valid_idx_for_rc_events(BD_ADDR bd_addr, int rc_handle);
 static int btif_get_conn_state_of_device(BD_ADDR address);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+int btif_av_update_local_a2dp_role(char dc);
+#endif
 static bt_status_t connect_int(bt_bdaddr_t *bd_addr, uint16_t uuid);
 static void btif_av_update_current_playing_device(int index);
 static void btif_av_check_rc_connection_priority(void *p_data);
-static int btif_get_is_remote_started_idx();
-static void btif_av_reset_remote_started_flag();
 
 #ifdef AVK_BACKPORT
 void btif_av_request_audio_focus( BOOLEAN enable);
@@ -211,6 +251,10 @@ static const btif_sm_handler_t btif_av_state_handlers[] =
 };
 
 static void btif_av_event_free_data(btif_sm_event_t event, void *p_data);
+#ifndef ANDROID
+static void btif_media_clear_pcm_queue();
+#endif
+
 
 /*************************************************************************
 ** Extern functions
@@ -226,8 +270,12 @@ extern void btif_rc_send_pause_command();
 extern UINT16 btif_dm_get_br_edr_links();
 extern UINT16 btif_dm_get_le_links();
 extern UINT16 btif_hf_is_call_vr_idle();
-extern void btif_media_on_cancel_remote_start_alarm();
-
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+extern void bta_av_assign_cbs(UINT16  profile_initialized);
+#endif
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+extern void btif_dm_add_device_whitelist(bt_bdaddr_t *bdaddr);
+#endif
 extern fixed_queue_t *btu_general_alarm_queue;
 
 /*****************************************************************************
@@ -249,13 +297,11 @@ BOOLEAN btif_av_is_codec_offload_supported(int codec);
 BOOLEAN btif_av_is_under_handoff();
 void btif_av_reset_reconfig_flag();
 BOOLEAN btif_av_is_device_disconnecting();
-BOOLEAN btif_av_is_suspend_stop_pending_ack();
 #else
 #define btif_av_is_codec_offload_supported(codec) (0)
 #define btif_av_is_under_handoff() (0)
 #define btif_av_reset_reconfig_flag() (0)
 #define btif_av_is_device_disconnecting() (0)
-#define btif_av_is_suspend_stop_pending_ack() (0)
 #endif
 
 const char *dump_av_sm_state_name(btif_av_state_t state)
@@ -303,7 +349,6 @@ const char *dump_av_sm_event_name(btif_av_sm_event_t event)
         CASE_RETURN_STR(BTIF_AV_START_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_STOP_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_SUSPEND_STREAM_REQ_EVT)
-        CASE_RETURN_STR(BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_SINK_CONFIG_REQ_EVT)
         CASE_RETURN_STR(BTIF_AV_OFFLOAD_START_REQ_EVT)
 #ifdef USE_AUDIO_TRACK
@@ -372,10 +417,18 @@ static void btif_initiate_av_open_timer_timeout(UNUSED_ATTR void *data)
                 return;
             }
             BTIF_TRACE_DEBUG("%s Issuing connect to the remote RC peer", __FUNCTION__);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK))
+#else
             if(bt_av_sink_callbacks != NULL)
+#endif
                 btif_queue_connect(UUID_SERVCLASS_AUDIO_SINK, (bt_bdaddr_t*)&peer_addr,
                         connect_int);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if((bt_av_src_callbacks != NULL) && (active_a2dp_role == A2DP_SOURCE))
+#else
             if(bt_av_src_callbacks != NULL)
+#endif
                 btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE, (bt_bdaddr_t*)&peer_addr,
                         connect_int);
         }
@@ -404,11 +457,41 @@ static void btif_initiate_av_open_timer_timeout(UNUSED_ATTR void *data)
 *******************************************************************************/
 static void btif_report_connection_state(btav_connection_state_t state, bt_bdaddr_t *bd_addr)
 {
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    if ((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK)) {
+#else
     if (bt_av_sink_callbacks != NULL) {
+#endif
         HAL_CBACK(bt_av_sink_callbacks, connection_state_cb, state, bd_addr);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    } else if (( bt_av_src_callbacks != NULL) && (active_a2dp_role == A2DP_SOURCE)) {
+#else
     } else if ( bt_av_src_callbacks != NULL) {
+#endif
         HAL_CBACK(bt_av_src_callbacks, connection_state_cb, state, bd_addr);
     }
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    BTIF_TRACE_DEBUG("btif_report_connection_state: state: %d", state);
+    if(state == BTAV_CONNECTION_STATE_DISCONNECTED)
+    {
+       if(new_av_device_to_connect.new_request_to_connect_device == TRUE)
+       {
+            if(new_av_device_to_connect.new_role_to_connect == A2DP_SOURCE)
+            {
+                bta_av_assign_cbs(UUID_SERVCLASS_AUDIO_SOURCE);
+                active_a2dp_role = A2DP_SOURCE;
+                btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE,new_av_device_to_connect.bdaddr_to_connect, connect_int);
+            }
+            else if(new_av_device_to_connect.new_role_to_connect == A2DP_SINK)
+            {
+                bta_av_assign_cbs(UUID_SERVCLASS_AUDIO_SINK);
+                active_a2dp_role = A2DP_SINK;
+                btif_queue_connect(UUID_SERVCLASS_AUDIO_SINK, new_av_device_to_connect.bdaddr_to_connect, connect_int);
+            }
+            new_av_device_to_connect.new_request_to_connect_device = FALSE;
+       }
+    }
+#endif
 }
 
 /*******************************************************************************
@@ -426,9 +509,17 @@ static void btif_report_connection_state(btav_connection_state_t state, bt_bdadd
 *******************************************************************************/
 static void btif_report_audio_state(btav_audio_state_t state, bt_bdaddr_t *bd_addr)
 {
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    if ((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK)) {
+#else
     if (bt_av_sink_callbacks != NULL) {
+#endif
         HAL_CBACK(bt_av_sink_callbacks, audio_state_cb, state, bd_addr);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    } else if ((bt_av_src_callbacks != NULL) && (active_a2dp_role == A2DP_SOURCE)) {
+#else
     } else if (bt_av_src_callbacks != NULL) {
+#endif
         HAL_CBACK(bt_av_src_callbacks, audio_state_cb, state, bd_addr);
     }
 }
@@ -447,16 +538,16 @@ static void btif_av_collission_timer_timeout(UNUSED_ATTR void *data)
 
     if (av_state == BTIF_AV_STATE_IDLE && conn_retry_count <= 1)
     {
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+        if ((bt_av_src_callbacks != NULL) && (active_a2dp_role == A2DP_SOURCE))
+#else
         if (bt_av_src_callbacks != NULL)
+#endif
         {
-            BTIF_TRACE_IMP("%s Starting A2dp connection", __FUNCTION__);
+            BTIF_TRACE_IMP("%s Starting A2dp Source connection", __FUNCTION__);
             conn_retry_count++;
             btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE, target_bda, connect_int);
         }
-        else
-        {
-            BTIF_TRACE_IMP("%s Aborting A2dp connection retry", __FUNCTION__);
-        }
     }
     else if (btif_rc_get_connected_peer_handle(av_address) == BTIF_RC_HANDLE_NONE
             && conn_retry_count <= 1)
@@ -516,7 +607,6 @@ void btif_av_check_and_start_collission_timer(int index)
               btu_general_alarm_queue);
 }
 
-
 /*****************************************************************************
 **
 ** Function     btif_av_state_idle_handler
@@ -529,8 +619,9 @@ void btif_av_check_and_start_collission_timer(int index)
 
 static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, int index)
 {
+#if (AV_BOTH_ROLES_ENABLED != TRUE)
     char a2dp_role[255] = "false";
-
+#endif
     BTIF_TRACE_IMP("%s event:%s flags %x on Index = %d", __FUNCTION__,
                      dump_av_sm_event_name(event), btif_av_cb[index].flags, index);
 
@@ -545,20 +636,31 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
             btif_av_cb[index].edr = 0;
             btif_av_cb[index].current_playing = FALSE;
             btif_av_cb[index].is_slave = FALSE;
-            btif_av_cb[index].is_remote_start_received = FALSE;
-            btif_av_cb[index].is_suspend_for_remote_start = FALSE;
             btif_av_cb[index].is_device_playing = FALSE;
             for (int i = 0; i < btif_max_av_clients; i++)
             {
                 btif_av_cb[i].dual_handoff = FALSE;
             }
+
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if (active_a2dp_role == A2DP_SINK) {
+#else
+#ifdef ANDROID
             property_get("persist.service.bt.a2dp.sink", a2dp_role, "false");
+#else
+            //property_get_bt("persist.service.bt.a2dp.sink", a2dp_role, "false");
+            if ( TRUE == a2dp_snk_active )
+            {
+                strlcpy(a2dp_role,"true",5);
+            }
+#endif
             if (!strncmp("false", a2dp_role, 5)) {
-                btif_av_cb[index].peer_sep = AVDT_TSEP_SNK;
-                btif_a2dp_set_peer_sep(AVDT_TSEP_SNK);
-            } else {
+#endif
                 btif_av_cb[index].peer_sep = AVDT_TSEP_SRC;
                 btif_a2dp_set_peer_sep(AVDT_TSEP_SRC);
+            } else {
+                btif_av_cb[index].peer_sep = AVDT_TSEP_SNK;
+                btif_a2dp_set_peer_sep(AVDT_TSEP_SNK);
             }
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
             btif_av_cb[index].channel_id = 0;
@@ -570,6 +672,9 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
             {
                 BTIF_TRACE_EVENT("reset A2dp states in IDLE ");
                 btif_a2dp_on_idle();
+#ifndef ANDROID
+	        btif_media_clear_pcm_queue();
+#endif
             }
             else
             {
@@ -614,9 +719,19 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
 
             BTIF_TRACE_WARNING("BTIF_AV_SINK_CONFIG_REQ_EVT %d %d", req.sample_rate,
                     req.channel_count);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if ((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK)) {
+#else
             if (bt_av_sink_callbacks != NULL) {
+#endif
+#ifdef ANDROID
                 HAL_CBACK(bt_av_sink_callbacks, audio_config_cb, &(req.peer_bd),
                         req.sample_rate, req.channel_count);
+#else
+                HAL_CBACK(bt_av_sink_callbacks, audio_config_cb, &(req.peer_bd),
+                        req.sample_rate, req.channel_count, req.codec_type, req.codec_config);
+#endif
+
             }
         } break;
 
@@ -676,14 +791,22 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
             if (event == BTA_AV_PENDING_EVT)
                 btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_OPENING);
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if ((bt_av_src_callbacks != NULL) && (active_a2dp_role == A2DP_SOURCE))
+#else
             if (bt_av_src_callbacks != NULL)
+#endif
             {
                 BTIF_TRACE_DEBUG("Calling connection priority callback ");
                 idle_rc_event = event;
                 HAL_CBACK(bt_av_src_callbacks, connection_priority_cb,
                          &(btif_av_cb[index].peer_bda));
             }
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if ((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK))
+#else
             if (bt_av_sink_callbacks != NULL)
+#endif
             {
                 if(event == BTA_AV_PENDING_EVT)
                 {
@@ -749,6 +872,9 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data, i
             /* change state to open based on the status */
             if (p_bta_data->open.status == BTA_AV_SUCCESS)
             {
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+                btif_dm_add_device_whitelist(&(btif_av_cb[index].peer_bda));
+#endif
                 /* inform the application of the event */
                 btif_report_connection_state(state, &(btif_av_cb[index].peer_bda));
                 btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_OPENED);
@@ -828,12 +954,20 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
     {
         case BTIF_SM_ENTER_EVT:
             /* inform the application that we are entering connecting state */
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if ((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK))
+#else
             if (bt_av_sink_callbacks != NULL)
+#endif
             {
                 HAL_CBACK(bt_av_sink_callbacks, connection_state_cb,
                          BTAV_CONNECTION_STATE_CONNECTING, &(btif_av_cb[index].peer_bda));
             }
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            else if ((bt_av_src_callbacks != NULL) && (active_a2dp_role == A2DP_SOURCE))
+#else
             else if (bt_av_src_callbacks != NULL)
+#endif
             {
                 HAL_CBACK(bt_av_src_callbacks, connection_state_cb,
                          BTAV_CONNECTION_STATE_CONNECTING, &(btif_av_cb[index].peer_bda));
@@ -860,6 +994,9 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
 
             if (p_bta_data->open.status == BTA_AV_SUCCESS)
             {
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+                btif_dm_add_device_whitelist(&(btif_av_cb[index].peer_bda));
+#endif
                  state = BTAV_CONNECTION_STATE_CONNECTED;
                  av_state = BTIF_AV_STATE_OPENED;
                  btif_av_cb[index].edr = p_bta_data->open.edr;
@@ -975,10 +1112,25 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
 
             BTIF_TRACE_WARNING("BTIF_AV_SINK_CONFIG_REQ_EVT %d %d", req.sample_rate,
                     req.channel_count);
-            if (btif_av_cb[index].peer_sep == AVDT_TSEP_SRC && bt_av_sink_callbacks != NULL) {
+#ifdef ANDROID
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if ((btif_av_cb[index].peer_sep == AVDT_TSEP_SRC && bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK)){
+#else
+            if ((btif_av_cb[index].peer_sep == AVDT_TSEP_SRC && bt_av_sink_callbacks != NULL)){
+#endif
                 HAL_CBACK(bt_av_sink_callbacks, audio_config_cb, &(btif_av_cb[index].peer_bda),
                         req.sample_rate, req.channel_count);
             }
+#else
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if ((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK)){
+#else
+            if (bt_av_sink_callbacks != NULL){
+#endif
+                HAL_CBACK(bt_av_sink_callbacks, audio_config_cb, &(btif_av_cb[index].peer_bda),
+                        req.sample_rate, req.channel_count, req.codec_type,  req.codec_config);
+            }
+#endif
         } break;
 
         case BTIF_AV_CONNECT_REQ_EVT:
@@ -1000,6 +1152,7 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
 
         case BTA_AV_PENDING_EVT:
             // Check for device, if same device which moved to opening then ignore callback
+            BTA_AvDisconnect(((tBTA_AV*)p_data)->pend.bd_addr);
             if (memcmp (((tBTA_AV*)p_data)->pend.bd_addr, &(btif_av_cb[index].peer_bda),
                 sizeof(btif_av_cb[index].peer_bda)) == 0)
             {
@@ -1212,14 +1365,13 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
     if ((event == BTA_AV_REMOTE_CMD_EVT) &&
          (p_av->remote_cmd.rc_id == BTA_AV_RC_PLAY) )
     {
-        if (btif_av_check_flag_remote_suspend(index))
+        for (int i = 0; i < btif_max_av_clients; i++)
         {
-            BTIF_TRACE_EVENT("%s: Resetting remote suspend flag on RC PLAY",
-                __FUNCTION__);
-            btif_av_clear_remote_suspend_flag();
-            if (btif_av_is_offload_supported())
+            if (btif_av_cb[i].flags & BTIF_AV_FLAG_REMOTE_SUSPEND)
             {
-                btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
+                BTIF_TRACE_EVENT("%s: Resetting remote suspend flag on RC PLAY",
+                        __FUNCTION__);
+                btif_av_cb[i].flags &= ~BTIF_AV_FLAG_REMOTE_SUSPEND;
             }
         }
     }
@@ -1313,9 +1465,8 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
             if ((!(btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START)) && (!btif_hf_is_call_vr_idle())) {
                 BTIF_TRACE_EVENT("%s: trigger suspend as call is in progress!!", __FUNCTION__);
                 btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
-                btif_av_cb[index].is_remote_start_received = TRUE;
                 btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_STARTED);
-                btif_dispatch_sm_event(BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+                btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
                 break;
             }
 
@@ -1367,9 +1518,36 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data,
                         }
                         else
                         {
-                            BTIF_TRACE_DEBUG("%s: honor remote started for BL device",__FUNCTION__);
-                            btif_a2dp_on_remote_started();
-                            btif_av_cb[index].is_remote_start_received = TRUE;
+                            bt_property_t prop_name;
+                            bt_bdname_t bdname;
+                            BOOLEAN is_device_blacklisted = FALSE;
+                            BOOLEAN remote_name = FALSE;
+                            BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_BDNAME,
+                                                       sizeof(bt_bdname_t), &bdname);
+                            if (btif_storage_get_remote_device_property(&btif_av_cb[index].peer_bda, &prop_name)
+                                                                        == BT_STATUS_SUCCESS)
+                            {
+                                remote_name = TRUE;
+                            }
+                            // did we find a match with bd_addr
+                            is_device_blacklisted = interop_match_addr(INTEROP_REMOTE_AVDTP_START,
+                                                                  &btif_av_cb[index].peer_bda);
+                            // if bd_aadr match not found, then check name
+                            if((remote_name) && (!is_device_blacklisted)) {
+                                is_device_blacklisted |= interop_match_name
+                                         (INTEROP_REMOTE_AVDTP_START, (const char *)bdname.name);
+                            }
+                            if (!is_device_blacklisted)
+                            {
+                                BTIF_TRACE_DEBUG("%s: trigger suspend as remote initiated!!",
+                                    __FUNCTION__);
+                                btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
+                            }
+                            else
+                            {
+                                BTIF_TRACE_DEBUG("%s: honor remote started for BL device",__FUNCTION__);
+                                btif_a2dp_on_remote_started();
+                            }
                         }
                     }
                 }
@@ -1527,7 +1705,6 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
     tBTA_AV *p_av = (tBTA_AV*)p_data;
     btif_sm_state_t state = BTIF_AV_STATE_IDLE;
     int i;
-    BOOLEAN hal_suspend_pending = FALSE;
 
     BTIF_TRACE_IMP("%s event:%s flags %x  index =%d", __FUNCTION__,
                      dump_av_sm_event_name(event), btif_av_cb[index].flags, index);
@@ -1538,23 +1715,12 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             /*Ack from entry point of started handler instead of open state to avoid race condition*/
             if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
             {
-                if (!((!enable_multicast)&&((btif_av_cb[index].is_remote_start_received)
-                && ((btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) == 0))))
-                {
-                    BTIF_TRACE_IMP("%s update media task on DUT initiated start for index =%d",
-                        __FUNCTION__, index);
-                    if (btif_a2dp_on_started(&p_av->start,
-                        ((btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) != 0),
-                          btif_av_cb[index].bta_handle))
-                    {
-                        /* only clear pending flag after acknowledgement */
-                        btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
-                    }
-                }
-                else
+                if (btif_a2dp_on_started(&p_av->start,
+                    ((btif_av_cb[index].flags & BTIF_AV_FLAG_PENDING_START) != 0),
+                      btif_av_cb[index].bta_handle))
                 {
-                    BTIF_TRACE_IMP("%s Do not update media task on remote start for index =%d",
-                        __FUNCTION__, index);
+                    /* only clear pending flag after acknowledgement */
+                    btif_av_cb[index].flags &= ~BTIF_AV_FLAG_PENDING_START;
                 }
             }
 
@@ -1568,16 +1734,7 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             /* we are again in started state, clear any remote suspend flags */
             btif_av_cb[index].flags &= ~BTIF_AV_FLAG_REMOTE_SUSPEND;
 
-            if ((!enable_multicast)&&((btif_av_cb[index].is_remote_start_received)
-            && (btif_av_is_playing_on_other_idx(index))))
-            {
-                BTIF_TRACE_IMP("%s Do not update audio state change to app for index =%d",
-                    __FUNCTION__, index);
-            }
-            else
-            {
-                btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
-            }
+            btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
             btif_av_cb[index].is_device_playing = TRUE;
 
             /* increase the a2dp consumer task priority temporarily when start
@@ -1611,20 +1768,7 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
         case BTIF_AV_START_STREAM_REQ_EVT:
             /* we were remotely started, just ack back the local request */
             if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
-            {
                 btif_a2dp_on_started(NULL, TRUE, btif_av_cb[index].bta_handle);
-                btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
-                btif_av_cb[index].is_device_playing = TRUE;
-                for (i = 0; i < btif_max_av_clients; i++)
-                {
-                    //Other device is not current playing
-                    if (i != index)
-                        btif_av_cb[i].current_playing = FALSE;
-                }
-                //This is latest device to play now
-                btif_av_cb[index].current_playing = TRUE;
-                btif_av_reset_reconfig_flag();
-            }
             break;
 
         case BTIF_AV_UPDATE_ENCODER_REQ_EVT:
@@ -1642,21 +1786,14 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
              * be sent to only one stream as internally BTA takes care of
              * suspending both streams.
              */
-            if (enable_multicast)
+            for(i = 0; i < btif_max_av_clients; i++)
             {
-                for(i = 0; i < btif_max_av_clients; i++)
+                state = btif_sm_get_state(btif_av_cb[i].sm_handle);
+                if (state == BTIF_AV_STATE_STARTED)
                 {
-                    state = btif_sm_get_state(btif_av_cb[i].sm_handle);
-                    if (state == BTIF_AV_STATE_STARTED)
-                    {
-                        btif_av_cb[i].flags |= BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING;
-                    }
+                    btif_av_cb[i].flags |= BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING;
                 }
             }
-            else
-            {
-                btif_av_cb[index].flags |= BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING;
-            }
 
             /* if we were remotely suspended but suspend locally, local suspend
                always overrides */
@@ -1716,6 +1853,7 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             break;
 
         case BTA_AV_SUSPEND_EVT:
+
             BTIF_TRACE_EVENT("BTA_AV_SUSPEND_EVT status %d, init %d",
                  p_av->suspend.status, p_av->suspend.initiator);
             //Check if this suspend is due to DUAL_Handoff
@@ -1758,14 +1896,8 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
              * Keep the suspend failure handling untouched and handle
              * only success case to check and avoid calling onsuspended.
              */
-            if (btif_a2dp_get_pending_hal_command() == A2DP_CTRL_CMD_SUSPEND ||
-                btif_a2dp_get_pending_hal_command() == A2DP_CTRL_CMD_STOP)
-            {
-                BTIF_TRACE_DEBUG("HAL suspend/stop pending ack the suspend");
-                hal_suspend_pending = TRUE;
-            }
             if ((p_av->suspend.status != BTA_AV_SUCCESS) ||
-                hal_suspend_pending || !btif_av_is_playing_on_other_idx(index))
+                !btif_av_is_playing_on_other_idx(index))
             {
                 btif_a2dp_on_suspended(&p_av->suspend);
             }
@@ -1787,18 +1919,14 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
                 return FALSE;
             }
 
-            if ((!enable_multicast)&& btif_av_cb[index].is_suspend_for_remote_start
-            && (btif_av_is_playing_on_other_idx(index)))
+            if (p_av->suspend.initiator != TRUE)
             {
-                BTIF_TRACE_IMP("%s Do not update audio state change to app for index =%d",
-                    __FUNCTION__, index);
+                btif_report_audio_state(BTAV_AUDIO_STATE_REMOTE_SUSPEND, &(btif_av_cb[index].peer_bda));
             }
             else
             {
                 btif_report_audio_state(BTAV_AUDIO_STATE_REMOTE_SUSPEND, &(btif_av_cb[index].peer_bda));
             }
-            btif_av_cb[index].is_suspend_for_remote_start = FALSE;
-
             btif_av_cb[index].is_device_playing = FALSE;
             btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_OPENED);
 
@@ -1828,17 +1956,8 @@ static BOOLEAN btif_av_state_started_handler(btif_sm_event_t event, void *p_data
             }
             btif_av_cb[index].is_device_playing = FALSE;
 
-            if ((!enable_multicast)&& btif_av_cb[index].is_suspend_for_remote_start
-            && (btif_av_is_playing_on_other_idx(index)))
-            {
-                BTIF_TRACE_IMP("%s Do not update audio state change to app for index =%d",
-                    __FUNCTION__, index);
-            }
-            else
-            {
-                btif_report_audio_state(BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb[index].peer_bda));
-            }
-            btif_av_cb[index].is_suspend_for_remote_start = FALSE;
+
+            btif_report_audio_state(BTAV_AUDIO_STATE_STOPPED, &(btif_av_cb[index].peer_bda));
             /* if stop was successful, change state to open */
             if (p_av->suspend.status == BTA_AV_SUCCESS)
                 btif_sm_change_state(btif_av_cb[index].sm_handle, BTIF_AV_STATE_OPENED);
@@ -2070,48 +2189,12 @@ static void btif_av_handle_event(UINT16 event, char* p_param)
         case BTIF_AV_STOP_STREAM_REQ_EVT:
         case BTIF_AV_SUSPEND_STREAM_REQ_EVT:
             /*Should be handled by current STARTED*/
-            index = btif_get_latest_playing_device_idx();
-            if ((index < btif_max_av_clients) && (index == btif_get_is_remote_started_idx()))
-            {
-                BTIF_TRACE_IMP("%s: Postpone handling suspend/stop req @ index = %d",
-                    __FUNCTION__, index);
-                return;
-            }
 #ifdef BTA_AV_SPLIT_A2DP_ENABLED
             if (bt_split_a2dp_enabled)
                 btif_media_on_stop_vendor_command();
 #endif
+            index = btif_get_latest_playing_device_idx();
             break;
-        case BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT:
-            index = btif_get_is_remote_started_idx();
-            if (index >= btif_max_av_clients)
-            {
-                BTIF_TRACE_ERROR("%s: Invalid index for connection", __FUNCTION__);
-                return;
-            }
-            BTIF_TRACE_IMP("%s: Remote Started set @ index = %d", __FUNCTION__, index);
-            btif_av_cb[index].is_remote_start_received = FALSE;
-            btif_av_cb[index].is_suspend_for_remote_start = TRUE;
-#ifdef BTA_AV_SPLIT_A2DP_ENABLED
-            if ((bt_split_a2dp_enabled) && (!btif_av_is_playing_on_other_idx(index)))
-            {
-                BTIF_TRACE_IMP("%s: Other index is not playing", __FUNCTION__);
-                btif_media_on_stop_vendor_command();
-            }
-#endif
-            event = BTIF_AV_SUSPEND_STREAM_REQ_EVT;
-            break;
-        case BTIF_AV_RESET_REMOTE_STARTED_FLAG_UPDATE_AUDIO_STATE_EVT:
-            index = btif_get_is_remote_started_idx();
-            if (btif_av_cb[index].peer_sep == AVDT_TSEP_SNK)
-            {
-                BTIF_TRACE_IMP("%s: on remote start clean up update audio started state for index %d",
-                    __FUNCTION__, index);
-                btif_report_audio_state(BTAV_AUDIO_STATE_STARTED, &(btif_av_cb[index].peer_bda));
-            }
-        case BTIF_AV_RESET_REMOTE_STARTED_FLAG_EVT:
-            btif_av_reset_remote_started_flag();
-            return;
         /*Events from the stack, BTA*/
         case BTA_AV_ENABLE_EVT:
             index = 0;
@@ -2203,19 +2286,9 @@ static void btif_av_handle_event(UINT16 event, char* p_param)
         btif_sm_dispatch(btif_av_cb[index].sm_handle, event, (void*)p_param);
     else
         BTIF_TRACE_ERROR("Unhandled Index = %d", index);
+#ifdef ANDROID
     btif_av_event_free_data(event, p_param);
-
-}
-
-void btif_av_reset_remote_started_flag()
-{
-    int i;
-    BTIF_TRACE_DEBUG("btif_av_reset_remote_started_flag");
-    for (i = 0; i < btif_max_av_clients; i++)
-    {
-        if (btif_av_cb[i].is_remote_start_received)
-            btif_av_cb[i].is_remote_start_received = FALSE;
-    }
+#endif
 }
 
 /*******************************************************************************
@@ -2263,8 +2336,7 @@ BOOLEAN btif_av_is_current_device(BD_ADDR address)
     UINT8 index;
 
     index = btif_av_idx_by_bdaddr(address);
-    if ((index < btif_max_av_clients) && (btif_av_cb[index].current_playing)
-        && (!btif_av_cb[index].is_remote_start_received))
+    if((index < btif_max_av_clients) && btif_av_cb[index].current_playing)
     {
         return TRUE;
     }
@@ -2344,31 +2416,6 @@ int btif_get_latest_playing_device_idx()
         state = btif_sm_get_state(btif_av_cb[i].sm_handle);
         if (state == BTIF_AV_STATE_STARTED)
         {
-            BTIF_TRACE_IMP("Latest playing device index %d", i);
-            break;
-        }
-    }
-    return i;
-}
-
-/*******************************************************************************
-**
-** Function         btif_get_is_remote_started_idx
-**
-** Description      Get the index of AV where remote Start is received
-**
-** Returns          int
-**
-*******************************************************************************/
-
-int btif_get_is_remote_started_idx()
-{
-    int i;
-    for (i = 0; i < btif_max_av_clients; i++)
-    {
-        if (btif_av_cb[i].is_remote_start_received == TRUE)
-        {
-            BTIF_TRACE_IMP("remote started set for device index %d", i);
             break;
         }
     }
@@ -2554,6 +2601,18 @@ static void bte_av_media_callback(tBTA_AV_EVT event, tBTA_AV_MEDIA *p_data)
             config_req.channel_count = btif_a2dp_get_track_channel_count(sbc_cie.ch_mode);
             memcpy(&config_req.peer_bd,(UINT8*)(p_data->avk_config.bd_addr),
                                                               sizeof(config_req.peer_bd));
+#ifndef ANDROID
+
+	    config_req.codec_type = A2D_MEDIA_CT_SBC;
+	    config_req.codec_config.samp_freq = sbc_cie.samp_freq;
+	    config_req.codec_config.ch_mode = sbc_cie.ch_mode;
+	    config_req.codec_config.block_len =  sbc_cie.block_len;
+	    config_req.codec_config.num_subbands = sbc_cie.num_subbands;
+	    config_req.codec_config.alloc_mthd = sbc_cie.alloc_mthd;
+	    config_req.codec_config.max_bitpool = sbc_cie.max_bitpool;
+	    config_req.codec_config.min_bitpool = sbc_cie.min_bitpool;
+#endif
+
             btif_transfer_context(btif_av_handle_event, BTIF_AV_SINK_CONFIG_REQ_EVT,
                                      (char*)&config_req, sizeof(config_req), NULL);
         } else {
@@ -2657,6 +2716,9 @@ bt_status_t btif_av_init(int service_id)
         if(!btif_a2dp_is_media_task_stopped())
             return BT_STATUS_FAIL;
         btif_av_cb[0].service = service_id;
+#ifndef ANDROID
+        btif_av_cb[0].RxPcmQ = fixed_queue_new(SIZE_MAX);
+#endif
 
         /* Also initialize the AV state machine */
         for (i = 0; i < btif_max_av_clients; i++)
@@ -2667,9 +2729,13 @@ bt_status_t btif_av_init(int service_id)
 
         btif_transfer_context(btif_av_handle_event, BTIF_AV_INIT_REQ_EVT,
                 (char*)&service_id, sizeof(int), NULL);
-
+#if (AV_BOTH_ROLES_ENABLED != TRUE)
         btif_enable_service(service_id);
+#endif
     }
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    btif_enable_service(service_id);
+#endif
 
     return BT_STATUS_SUCCESS;
 }
@@ -2691,11 +2757,13 @@ static bt_status_t init_src(btav_callbacks_t* callbacks, int max_a2dp_connection
 
     BTIF_TRACE_EVENT("%s with max conn = %d", __FUNCTION__, max_a2dp_connections);
 
+#if (AV_BOTH_ROLES_ENABLED != TRUE)
     if (bt_av_sink_callbacks != NULL) {
         // already did btif_av_init()
         status = BT_STATUS_SUCCESS;
     }
     else
+#endif
     {
         if (a2dp_multicast_state)
         {
@@ -2713,11 +2781,75 @@ static bt_status_t init_src(btav_callbacks_t* callbacks, int max_a2dp_connection
 
     if (status == BT_STATUS_SUCCESS) {
         bt_av_src_callbacks = callbacks;
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+        active_a2dp_role = A2DP_SOURCE;
+        new_av_device_to_connect.new_request_to_connect_device = FALSE;
+#endif
     }
 
     return status;
 }
+#ifndef ANDROID
+/*******************************************************************************
+**
+** Function         get_sink_pcm_data
+**
+** Description      get sink pcm data stored from PCM Q
+**
+** Returns          number of bytes returned
+**
+*******************************************************************************/
+static uint32_t get_sink_pcm_data (UINT8* data, uint32_t size)
+{
+    uint16_t pcm_q_bytes_left = 0;// bytes left in topmost element of PCM Q
+    tBT_PCM_HDR* p_pcm_q_buf; // pointer to first element in que;
+    uint32_t bytes_to_be_written = size;// bytes written to buffer supplied by app.
+    UINT8* p_src; UINT8* p_dest;
+    BTIF_TRACE_DEBUG(" %s size = %d", __FUNCTION__, size);
+
+    BTIF_TRACE_DEBUG(" Num of Packets in Que %d",
+                             fixed_queue_length(btif_av_cb[0].RxPcmQ));
+
+    if (fixed_queue_is_empty(btif_av_cb[0].RxPcmQ)) {
+        BTIF_TRACE_DEBUG("%s PCM Que Empty, returning", __FUNCTION__);
+        return 0;
+    }
+
+    while ((bytes_to_be_written > 0) && (! fixed_queue_is_empty(btif_av_cb[0].RxPcmQ)))
+    {
+        p_pcm_q_buf = (tBT_PCM_HDR *)fixed_queue_try_peek_first(btif_av_cb[0].RxPcmQ);
+        if (p_pcm_q_buf == NULL)
+            break;
+
+        pcm_q_bytes_left = p_pcm_q_buf->len - p_pcm_q_buf->offset;
+        BTIF_TRACE_DEBUG(" %s Q_Len %d, bytes_to_be_written %d, bytes_left_in_Q %d", __FUNCTION__,
+                 fixed_queue_length(btif_av_cb[0].RxPcmQ), bytes_to_be_written, pcm_q_bytes_left);
+
+        if (bytes_to_be_written >= pcm_q_bytes_left)
+        {
+            // read from topmost element and deque it
+            p_pcm_q_buf = (tBT_PCM_HDR *)fixed_queue_try_dequeue(btif_av_cb[0].RxPcmQ);
+            p_dest = data + (size - bytes_to_be_written);
+            p_src = (UINT8*)(p_pcm_q_buf + 1) + p_pcm_q_buf->offset;
+            memcpy(p_dest, p_src, pcm_q_bytes_left);
+            osi_free(p_pcm_q_buf);
+            bytes_to_be_written = bytes_to_be_written - pcm_q_bytes_left;
+        }
+        else
+        {
+            // read only required data and keep the node in Q
+            p_dest = data + (size - bytes_to_be_written);
+            p_src = (UINT8*)(p_pcm_q_buf + 1) + p_pcm_q_buf->offset;
+            memcpy(p_dest, p_src, bytes_to_be_written);
+            p_pcm_q_buf->offset += bytes_to_be_written;
+            bytes_to_be_written = 0;
+        }
 
+    }
+    BTIF_TRACE_DEBUG(" %s Wrote %d bytes",__FUNCTION__, size - bytes_to_be_written);
+    return (size - bytes_to_be_written);
+}
+#endif
 /*******************************************************************************
 **
 ** Function         init_sink
@@ -2735,11 +2867,13 @@ static bt_status_t init_sink(btav_callbacks_t* callbacks, int max,
 
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
 
+#if (AV_BOTH_ROLES_ENABLED != TRUE)
     if (bt_av_src_callbacks != NULL) {
         // already did btif_av_init()
         status = BT_STATUS_SUCCESS;
     }
     else
+#endif
     {
         enable_multicast = FALSE; // Clear multicast flag for sink
         bt_split_a2dp_enabled = FALSE; //Clear split a2dp for sink
@@ -2751,14 +2885,67 @@ static bt_status_t init_sink(btav_callbacks_t* callbacks, int max,
         btif_max_av_clients = max; //Should be 1
         status = btif_av_init(BTA_A2DP_SINK_SERVICE_ID);
     }
-
     if (status == BT_STATUS_SUCCESS) {
         bt_av_sink_callbacks = callbacks;
         //BTA_AvEnable_Sink(TRUE);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+        active_a2dp_role = A2DP_SINK;
+#endif
     }
-
     return status;
 }
+#ifndef ANDROID
+/*******************************************************************************
+ **
+ ** Function         btif_media_enque_pcm_data
+ **
+ ** Description      queues PCM data
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void btif_media_enque_pcm_data(UINT8 *data, UINT16 size)
+{
+    tBT_PCM_HDR* p_msg;
+
+    if(fixed_queue_length(btif_av_cb[0].RxPcmQ) >= MAX_A2DP_SINK_PCM_QUEUE_SZ)
+    {
+         BTIF_TRACE_ERROR(" %s PCM Que Full, returning", __FUNCTION__);
+         return;
+    }
+
+    if ((p_msg = (tBT_PCM_HDR *)osi_malloc(sizeof(tBT_PCM_HDR) + size)) != NULL)
+    {
+        UINT8 *p_dest;
+
+        p_dest = (UINT8*)(p_msg + 1);
+        memcpy(p_dest, (UINT8*)(data), size);
+
+        p_msg->len = size;
+        p_msg->offset = 0;
+
+        fixed_queue_enqueue(btif_av_cb[0].RxPcmQ, p_msg);
+        BTIF_TRACE_DEBUG("%s pkt_size %d  PCM_Q_Size %d", __FUNCTION__, size,
+                                                fixed_queue_length(&btif_av_cb[0].RxPcmQ));
+    }
+}
+
+static void btif_media_clear_pcm_queue()
+{
+    void *p_buf = NULL;
+    BTIF_TRACE_DEBUG(" Clear PCM QUeue ");
+    while ( NULL != fixed_queue_get_list(btif_av_cb[0].RxPcmQ) )
+    {
+	if(! fixed_queue_is_empty(btif_av_cb[0].RxPcmQ))
+         {
+             p_buf = fixed_queue_try_dequeue(btif_av_cb[0].RxPcmQ);
+             osi_free(p_buf);
+         }
+	else
+	    break;
+    }
+}
+#endif
 
 #ifdef USE_AUDIO_TRACK
 /*******************************************************************************
@@ -2845,17 +3032,6 @@ void btif_av_trigger_dual_handoff(BOOLEAN handoff, BD_ADDR address)
         if (bt_split_a2dp_enabled)
             btif_media_on_stop_vendor_command();
         /*Initiate SUSPEND for this device*/
-
-        next_idx = btif_av_get_other_connected_idx(index);
-        if (next_idx != INVALID_INDEX && next_idx != btif_max_av_clients)
-        {
-            if (btif_av_cb[next_idx].is_remote_start_received)
-            {
-                btif_media_on_cancel_remote_start_alarm();
-                BTIF_TRACE_DEBUG("Reset remote start alarm on index = %d", next_idx);
-                btif_av_cb[next_idx].is_remote_start_received = FALSE;
-            }
-        }
         BTIF_TRACE_DEBUG("Initiate SUSPEND for this device on index = %d", index);
         btif_sm_dispatch(btif_av_cb[index].sm_handle, BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL);
     }
@@ -2865,6 +3041,7 @@ void btif_av_trigger_dual_handoff(BOOLEAN handoff, BD_ADDR address)
     }
     if (bt_split_a2dp_enabled)
     {
+        btif_media_send_reset_vendor_state();
         next_idx = btif_av_get_other_connected_idx(index);
         /* Fix for below Klockwork Issue
         Array 'btif_av_cb' of size 2 may use index value(s) -1 */
@@ -2966,11 +3143,73 @@ static bt_status_t connect_int(bt_bdaddr_t *bd_addr, uint16_t uuid)
     return BT_STATUS_SUCCESS;
 }
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+/*******************************************************************************
+**
+** Function         btif_av_update_local_a2dp_role
+**
+** Description      Assigns proper callbacks based on device class
+**
+** Returns          0- if success else 1
+**
+*******************************************************************************/
+int btif_av_update_local_a2dp_role(char dc)
+{
+    BTIF_TRACE_DEBUG("%s device_class:%d",__FUNCTION__,dc);
+    if(!((dc & BT_AV_CAPTURER) || (dc & BT_AV_RENDERER))) //If device doesn't support AV profiles, accept connection irrespective of AV connection.
+    {
+        return 0;
+    }
+    if(btif_av_is_connected())
+    {
+        BTIF_TRACE_DEBUG("%s Already connected one device",__FUNCTION__);
+	return 1;
+    }
+
+    if(dc & BT_AV_CAPTURER)  //Remote is Src
+    {
+        BTIF_TRACE_DEBUG("%s:Assigning Sink",__FUNCTION__);
+        bta_av_assign_cbs(UUID_SERVCLASS_AUDIO_SINK);
+        active_a2dp_role = A2DP_SINK;
+        return 0;
+    }
+    else if (dc & BT_AV_RENDERER)  //Remote is Sink
+    {
+        BTIF_TRACE_DEBUG("%s:Assigning Source",__FUNCTION__);
+        bta_av_assign_cbs(UUID_SERVCLASS_AUDIO_SOURCE);
+        active_a2dp_role = A2DP_SOURCE;
+        return 0;
+    }
+
+    return 0;
+}
+#endif
+
 static bt_status_t src_connect_sink(bt_bdaddr_t *bd_addr)
 {
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
     CHECK_BTAV_INIT();
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    if(btif_av_state_is_not_idle())
+    {
+        if(active_a2dp_role == A2DP_SOURCE)
+        {
+            BTIF_TRACE_DEBUG("%s:Since it is same profile,so processing further", __FUNCTION__);
+        }
+	else
+	{
+            BTIF_TRACE_DEBUG("%s:Since it is complimentary AV profile,save details to connect later", __FUNCTION__);
+            new_av_device_to_connect.bdaddr_to_connect = bd_addr;
+            new_av_device_to_connect.new_role_to_connect = A2DP_SOURCE;
+            new_av_device_to_connect.new_request_to_connect_device = TRUE;
+            return BT_STATUS_SUCCESS;
+	}
+    }
+    bta_av_assign_cbs(UUID_SERVCLASS_AUDIO_SOURCE);
+    active_a2dp_role = A2DP_SOURCE;
+#endif
+
     return btif_queue_connect(UUID_SERVCLASS_AUDIO_SOURCE, bd_addr, connect_int);
 }
 
@@ -2978,6 +3217,25 @@ static bt_status_t sink_connect_src(bt_bdaddr_t *bd_addr)
 {
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
     CHECK_BTAV_INIT();
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    if(btif_av_state_is_not_idle())
+    {
+        if(active_a2dp_role == A2DP_SINK)
+        {
+            BTIF_TRACE_DEBUG("%s:Since it is same profile,so processing further", __FUNCTION__);
+        }
+	else
+	{
+            BTIF_TRACE_DEBUG("%s:Since it is complimentary AV profile,save details to connect later", __FUNCTION__);
+            new_av_device_to_connect.bdaddr_to_connect = bd_addr;
+            new_av_device_to_connect.new_role_to_connect = A2DP_SINK;
+            new_av_device_to_connect.new_request_to_connect_device = TRUE;
+            return BT_STATUS_SUCCESS;
+	}
+    }
+    bta_av_assign_cbs(UUID_SERVCLASS_AUDIO_SINK);
+    active_a2dp_role = A2DP_SINK;
+#endif
 
     return btif_queue_connect(UUID_SERVCLASS_AUDIO_SINK, bd_addr, connect_int);
 }
@@ -3019,6 +3277,11 @@ static void cleanup(int service_uuid)
             (char*)&service_uuid, sizeof(int), NULL);
 
     btif_disable_service(service_uuid);
+#ifndef ANDROID
+    fixed_queue_free(btif_av_cb[0].RxPcmQ , NULL);
+
+    btif_av_cb[0].RxPcmQ = NULL;
+#endif
 }
 
 static void cleanup_src(void) {
@@ -3030,6 +3293,9 @@ static void cleanup_src(void) {
 static void cleanup_sink(void) {
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
     cleanup(BTA_A2DP_SINK_SERVICE_ID);
+#ifndef ANDROID
+    btif_media_clear_pcm_queue();
+#endif
 }
 
 static void allow_connection(int is_valid, bt_bdaddr_t *bd_addr)
@@ -3107,6 +3373,9 @@ static const btav_interface_t bt_av_sink_interface = {
     NULL,
 #endif
 	NULL,
+#ifndef ANDROID
+    get_sink_pcm_data,
+#endif
 };
 
 /*******************************************************************************
@@ -3159,7 +3428,11 @@ bt_bdaddr_t btif_av_get_addr(BD_ADDR address)
 
 BOOLEAN btif_av_is_sink_enabled(void)
 {
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    return ((bt_av_sink_callbacks != NULL) && (active_a2dp_role == A2DP_SINK)) ? TRUE : FALSE;
+#else
     return (bt_av_sink_callbacks != NULL) ? TRUE : FALSE;
+#endif
 }
 
 /*******************************************************************************
@@ -3255,39 +3528,6 @@ BOOLEAN btif_av_stream_started_ready(void)
 
 /*******************************************************************************
 **
-** Function         btif_av_stream_started_ready
-**
-** Description      Checks whether AV ready for media start in streaming state
-**
-** Returns          None
-**
-*******************************************************************************/
-
-BOOLEAN btif_av_is_suspend_stop_pending_ack(void)
-{
-    int i;
-    BOOLEAN status = FALSE;
-
-    for (i = 0; i < btif_max_av_clients; i++)
-    {
-        btif_av_cb[i].state = btif_sm_get_state(btif_av_cb[i].sm_handle);
-        BTIF_TRACE_DEBUG("btif_av_stream_ready flags: %d, state: %d",
-                                btif_av_cb[i].flags, btif_av_cb[i].state);
-        if ((btif_av_cb[i].flags &
-            (BTIF_AV_FLAG_LOCAL_SUSPEND_PENDING |
-            BTIF_AV_FLAG_PENDING_STOP)) &&
-            (btif_av_cb[i].state == BTIF_AV_STATE_STARTED))
-        {
-            status = TRUE;
-            break;
-        }
-    }
-    BTIF_TRACE_DEBUG("btif_av_is_stream_suspend_pending_ack: %d", status);
-    return status;
-}
-
-/*******************************************************************************
-**
 ** Function         btif_dispatch_sm_event
 **
 ** Description      Send event to AV statemachine
@@ -3435,6 +3675,22 @@ bt_status_t btif_av_sink_execute_service(BOOLEAN b_enable)
 const btav_interface_t *btif_av_get_src_interface(void)
 {
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
+
+#if (AV_BOTH_ROLES_ENABLED != TRUE)
+#ifdef ANDROID
+    char a2dp_role[255] = "false";
+    property_get("persist.service.bt.a2dp.sink", a2dp_role, "false");
+
+    BTIF_TRACE_EVENT("%s a2dp_role:%s",__FUNCTION__,a2dp_role);
+    if (!strncmp("true", a2dp_role, 4))
+    {
+        return NULL;
+    }
+#else
+    a2dp_snk_active = FALSE;
+#endif
+#endif
+
     return &bt_av_src_interface;
 }
 
@@ -3450,6 +3706,23 @@ const btav_interface_t *btif_av_get_src_interface(void)
 const btav_interface_t *btif_av_get_sink_interface(void)
 {
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
+
+#if (AV_BOTH_ROLES_ENABLED != TRUE)
+#ifdef ANDROID
+    char a2dp_role[255] = "false";
+
+    property_get("persist.service.bt.a2dp.sink", a2dp_role, "false");
+
+    BTIF_TRACE_EVENT("%s a2dp_role:%s",__FUNCTION__,a2dp_role);
+    if (!strncmp("false", a2dp_role, 5))
+    {
+        return NULL;
+    }
+#else
+    a2dp_snk_active = TRUE;
+#endif
+#endif
+
     return &bt_av_sink_interface;
 }
 
@@ -3476,6 +3749,29 @@ BOOLEAN btif_av_is_connected(void)
     return status;
 }
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+/*******************************************************************************
+**
+** Function         btif_av_state_is_not_idle
+**
+** Description      Checks if av state is not idle
+**
+** Returns          BOOLEAN
+**
+*******************************************************************************/
+BOOLEAN btif_av_state_is_not_idle(void)
+{
+    int i;
+    BOOLEAN status = FALSE;
+    for (i = 0; i < btif_max_av_clients; i++)
+    {
+        btif_av_cb[i].state = btif_sm_get_state(btif_av_cb[i].sm_handle);
+        if (btif_av_cb[i].state != BTIF_AV_STATE_IDLE)
+            status = TRUE;
+    }
+    return status;
+}
+#endif
 /*******************************************************************************
 **
 ** Function         btif_av_is_connected_on_other_idx
@@ -4071,7 +4367,11 @@ BOOLEAN btif_av_is_codec_offload_supported(int codec)
             break;
         case AAC:
             ret = btif_av_codec_offload.aac_offload;
+#ifdef ANDROID
             retval = property_get("persist.bt.a2dp.aac_disable", value, "false");
+#else
+            retval = property_get_bt("persist.bt.a2dp.aac_disable", value, "false");
+#endif
             BTIF_TRACE_DEBUG("%s: property_get: bt.a2dp.aac_disable: %s, retval: %d", __func__, value, retval);
             if (strncmp(value, "true", 5) == 0) {
                 ret = FALSE;
@@ -4137,21 +4437,10 @@ BOOLEAN btif_av_is_device_disconnecting()
     }
     return FALSE;
 }
-
 void btif_av_reset_reconfig_flag()
 {
-    int i;
     BTIF_TRACE_DEBUG("%s",__func__);
     reconfig_a2dp = FALSE;
-    for (i = 0; i < btif_max_av_clients; i++)
-    {
-        if (btif_av_cb[i].dual_handoff)
-        {
-            BTIF_TRACE_DEBUG("%s resetting dual handoff flag for index %d",
-                __func__, i);
-            btif_av_cb[i].dual_handoff = FALSE;
-        }
-    }
 }
 #endif
 
diff --git a/btif/src/btif_config.c b/btif/src/btif_config.c
index b2b4b68..f330018 100644
--- a/btif/src/btif_config.c
+++ b/btif/src/btif_config.c
@@ -43,6 +43,7 @@
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
 
+#ifdef ANDROID
 /**
  * TODO(apanicke): cutils/properties.h is only being used to pull-in runtime
  * settings on Android. Remove this conditional include once we have a generic
@@ -51,7 +52,7 @@
 #if !defined(OS_GENERIC)
 #include <cutils/properties.h>
 #endif  /* !defined(OS_GENERIC) */
-
+#endif 
 #define BT_CONFIG_SOURCE_TAG_NUM 1010001
 
 #define INFO_SECTION "Info"
@@ -59,17 +60,22 @@
 #define FILE_SOURCE "FileSource"
 #define TIME_STRING_LENGTH sizeof("YYYY-MM-DD HH:MM:SS")
 static const char* TIME_STRING_FORMAT = "%Y-%m-%d %H:%M:%S";
-
 // TODO(armansito): Find a better way than searching by a hardcoded path.
+
 #if defined(OS_GENERIC)
 static const char *CONFIG_FILE_PATH = "bt_config.conf";
 static const char *CONFIG_BACKUP_PATH = "bt_config.bak";
 static const char *CONFIG_LEGACY_FILE_PATH = "bt_config.xml";
-#else  // !defined(OS_GENERIC)
+#elif !defined(ANDROID)
+static const char *CONFIG_FILE_PATH = "/etc/bluetooth/bt_config.conf";
+static const char *CONFIG_BACKUP_PATH = "/etc/bluetooth/bt_config.bak";
+static const char *CONFIG_LEGACY_FILE_PATH = "/etc/bluetooth/bt_config.xml";
+#else
 static const char *CONFIG_FILE_PATH = "/data/misc/bluedroid/bt_config.conf";
 static const char *CONFIG_BACKUP_PATH = "/data/misc/bluedroid/bt_config.bak";
 static const char *CONFIG_LEGACY_FILE_PATH = "/data/misc/bluedroid/bt_config.xml";
 #endif  // defined(OS_GENERIC)
+
 static const period_ms_t CONFIG_SETTLE_PERIOD_MS = 3000;
 
 static void timer_config_save_cb(void *data);
@@ -139,13 +145,14 @@ static alarm_t *config_timer;
 static future_t *init(void) {
   pthread_mutex_init(&lock, NULL);
   pthread_mutex_lock(&lock);
-
+#ifdef ANDROID
   if (is_factory_reset())
     delete_config_files();
-
+#endif
   const char *file_source = NULL;
 
   config = btif_config_open(CONFIG_FILE_PATH);
+  LOG_ERROR(LOG_TAG," %s Reaching here %s",__func__,CONFIG_FILE_PATH);
   btif_config_source = ORIGINAL;
   if (!config) {
     LOG_WARN("%s unable to load config file: %s; using backup.",
@@ -154,14 +161,21 @@ static future_t *init(void) {
     btif_config_source = BACKUP;
     file_source = "Backup";
   }
+   LOG_ERROR(LOG_TAG," %s Reaching here ALSo %s",__func__,CONFIG_FILE_PATH);
+#ifdef ANDROID
   if (!config) {
     LOG_WARN("%s unable to load backup; attempting to transcode legacy file.", __func__);
     config = btif_config_transcode(CONFIG_LEGACY_FILE_PATH);
     btif_config_source = LEGACY;
     file_source = "Legacy";
   }
+#endif
   if (!config) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to transcode legacy file; creating empty config.", __func__);
+#else
+    LOG_ERROR(LOG_TAG,"%s unable to transcode legacy file; creating empty config.", __func__);
+#endif
     config = config_new_empty();
     btif_config_source = NEW_FILE;
     file_source = "Empty";
@@ -171,7 +185,11 @@ static future_t *init(void) {
     config_set_string(config, INFO_SECTION, FILE_SOURCE, file_source);
 
   if (!config) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to allocate a config object.", __func__);
+#else
+     LOG_ERROR(LOG_TAG, "%s unable to allocate a config object.", __func__);
+#endif
     goto error;
   }
 
@@ -184,7 +202,11 @@ static future_t *init(void) {
   // Read or set config file creation timestamp
   const char* time_str = config_get_string(config, INFO_SECTION, FILE_TIMESTAMP, NULL);
   if (time_str != NULL) {
+#ifdef ANDROID
     strlcpy(btif_config_time_created, time_str, TIME_STRING_LENGTH);
+#else
+    strncpy(btif_config_time_created, time_str, TIME_STRING_LENGTH);
+#endif
   } else {
     time_t current_time = time(NULL);
     struct tm* time_created = localtime(&current_time);
@@ -202,8 +224,9 @@ static future_t *init(void) {
     LOG_ERROR(LOG_TAG, "%s unable to create alarm.", __func__);
     goto error;
   }
-
+#ifdef ANDROID
   LOG_EVENT_INT(BT_CONFIG_SOURCE_TAG_NUM, btif_config_source);
+#endif
 
   pthread_mutex_unlock(&lock);
   return future_new_immediate(FUTURE_SUCCESS);
@@ -249,6 +272,11 @@ static future_t *clean_up(void) {
   return future_new_immediate(FUTURE_SUCCESS);
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t btif_config_module = {
   .name = BTIF_CONFIG_MODULE,
   .init = init,
@@ -323,10 +351,12 @@ bool btif_config_get_str(const char *section, const char *key, char *value, int
 
   if (!stored_value)
     return false;
-
+#ifdef ANDROID
   strlcpy(value, stored_value, *size_bytes);
+#else
+  strncpy(value, stored_value, *size_bytes);
+#endif
   *size_bytes = strlen(value) + 1;
-
   return true;
 }
 
@@ -339,8 +369,7 @@ bool btif_config_set_str(const char *section, const char *key, const char *value
   pthread_mutex_lock(&lock);
   config_set_string(config, section, key, value);
   pthread_mutex_unlock(&lock);
-
-  return true;
+   return true;
 }
 
 bool btif_config_get_bin(const char *section, const char *key, uint8_t *value, size_t *length) {
@@ -367,8 +396,7 @@ bool btif_config_get_bin(const char *section, const char *key, uint8_t *value, s
 
   for (*length = 0; *value_str; value_str += 2, *length += 1)
     sscanf(value_str, "%02hhx", &value[*length]);
-
-  return true;
+	  return true;
 }
 
 size_t btif_config_get_bin_length(const char *section, const char *key) {
@@ -384,7 +412,9 @@ size_t btif_config_get_bin_length(const char *section, const char *key) {
     return 0;
 
   size_t value_len = strlen(value_str);
+
   return ((value_len % 2) != 0) ? 0 : (value_len / 2);
+
 }
 
 bool btif_config_set_bin(const char *section, const char *key, const uint8_t *value, size_t length) {
@@ -580,12 +610,20 @@ static void btif_config_remove_restricted(config_t* config) {
 
 static bool is_factory_reset(void) {
   char factory_reset[PROPERTY_VALUE_MAX] = {0};
+#ifdef ANDROID
   property_get("persist.bluetooth.factoryreset", factory_reset, "false");
+#else
+  property_get_bt("persist.bluetooth.factoryreset", factory_reset, "false");
+#endif
   return strncmp(factory_reset, "true", 4) == 0;
 }
 
 static void delete_config_files(void) {
   remove(CONFIG_FILE_PATH);
   remove(CONFIG_BACKUP_PATH);
+#ifdef ANDROID
   property_set("persist.bluetooth.factoryreset", "false");
+#else
+  property_set_bt("persist.bluetooth.factoryreset", "false");
+#endif
 }
diff --git a/btif/src/btif_core.c b/btif/src/btif_core.c
index ef73e89..0ad4102 100644
--- a/btif/src/btif_core.c
+++ b/btif/src/btif_core.c
@@ -268,6 +268,7 @@ void btif_init_ok(UNUSED_ATTR uint16_t event, UNUSED_ATTR char *p_param) {
   btif_dm_load_ble_local_keys();
 #endif
   BTA_EnableBluetooth(bte_dm_evt);
+  LOG_INFO(LOG_TAG," %s ENABLED BLUETOOTH ",__func__);
 }
 
 /*******************************************************************************
@@ -445,8 +446,13 @@ static void btif_fetch_local_bdaddr(bt_bdaddr_t *local_addr)
     }
 
     /* No factory BDADDR found. Look for BDA in ro.boot.btmacaddr */
+#ifdef ANDROID
     if ((!valid_bda) && \
         (property_get("ro.boot.btmacaddr", val, NULL)))
+#else
+    if ((!valid_bda) && \
+        (property_get_bt("ro.boot.btmacaddr", val, NULL)))
+#endif
     {
         valid_bda = string_to_bdaddr(val, local_addr);
         if (valid_bda) {
@@ -516,8 +522,9 @@ bt_status_t btif_init_bluetooth() {
 
   /* As part of the init, fetch the local BD ADDR */
   memset(&btif_local_bd_addr, 0, sizeof(bt_bdaddr_t));
+//#ifdef ANDROID
   btif_fetch_local_bdaddr(&btif_local_bd_addr);
-
+//#endif
   bt_jni_workqueue_thread = thread_new(BT_JNI_WORKQUEUE_NAME);
   if (bt_jni_workqueue_thread == NULL) {
     LOG_ERROR(LOG_TAG, "%s Unable to create thread %s", __func__, BT_JNI_WORKQUEUE_NAME);
@@ -555,7 +562,7 @@ void btif_enable_bluetooth_evt(tBTA_STATUS status)
     bdaddr_to_string(controller->get_address(), bdstr, sizeof(bdstr));
 
     BTIF_TRACE_DEBUG("%s: status %d, local bd [%s]", __FUNCTION__, status, bdstr);
-
+    LOG_INFO(LOG_TAG,"%s: status %d, local bd [%s]", __FUNCTION__, status, bdstr);
     ssr_triggered = FALSE;
 
     if (bdcmp(btif_local_bd_addr.address, controller->get_address()->address))
diff --git a/btif/src/btif_debug_btsnoop.c b/btif/src/btif_debug_btsnoop.c
index 6490eff..be0bf54 100644
--- a/btif/src/btif_debug_btsnoop.c
+++ b/btif/src/btif_debug_btsnoop.c
@@ -17,7 +17,9 @@
  ******************************************************************************/
 
 #include <assert.h>
+#ifdef ANDROID
 #include <resolv.h>
+#endif
 #include <zlib.h>
 
 #include "btif/include/btif_debug.h"
@@ -27,7 +29,7 @@
 #include "osi/include/ringbuffer.h"
 
 #define REDUCE_HCI_TYPE_TO_SIGNIFICANT_BITS(type) (type >> 8)
-
+#define L2CAP_CID_OFFSET (HCI_ACL_HEADER_SIZE + 2)
 // Total btsnoop memory log buffer size
 #ifndef BTSNOOP_MEM_BUFFER_SIZE
 static const size_t BTSNOOP_MEM_BUFFER_SIZE = (256 * 1024);
@@ -75,7 +77,7 @@ static void btsnoop_cb(const uint16_t type, const uint8_t *data, const size_t le
 static size_t btsnoop_calculate_packet_length(uint16_t type, const uint8_t *data, size_t length) {
   static const size_t HCI_ACL_HEADER_SIZE = 4;
   static const size_t L2CAP_HEADER_SIZE = 4;
-  static const size_t L2CAP_CID_OFFSET = (HCI_ACL_HEADER_SIZE + 2);
+//  static const size_t L2CAP_CID_OFFSET = (HCI_ACL_HEADER_SIZE + 2);
   static const uint16_t L2CAP_SIGNALING_CID = 0x0001;
 
   // Maximum amount of ACL data to log.
@@ -98,7 +100,7 @@ static size_t btsnoop_calculate_packet_length(uint16_t type, const uint8_t *data
       size_t len_hci_acl = HCI_ACL_HEADER_SIZE + L2CAP_HEADER_SIZE;
       // Check if we have enough data for an L2CAP header
       if (length > len_hci_acl) {
-        uint16_t l2cap_cid = data[L2CAP_CID_OFFSET] | (data[L2CAP_CID_OFFSET + 1] << 8);
+       uint16_t l2cap_cid = data[L2CAP_CID_OFFSET] | (data[L2CAP_CID_OFFSET + 1] << 8);
         if (l2cap_cid == L2CAP_SIGNALING_CID) {
           // For the signaling CID, take the full packet.
           // That way, the PSM setup is captured, allowing decoding of PSMs down the road.
@@ -125,9 +127,10 @@ static bool btsnoop_compress(ringbuffer_t *rb_dst, ringbuffer_t *rb_src) {
   assert(rb_src != NULL);
 
   z_stream zs = {.zalloc = Z_NULL, .zfree = Z_NULL, .opaque = Z_NULL};
+#ifdef BTSNOOP_DEBUG
   if (deflateInit(&zs, Z_DEFAULT_COMPRESSION) != Z_OK)
     return false;
-
+#endif
   bool rc = true;
   uint8_t block_src[BLOCK_SIZE];
   uint8_t block_dst[BLOCK_SIZE];
@@ -140,8 +143,10 @@ static bool btsnoop_compress(ringbuffer_t *rb_dst, ringbuffer_t *rb_src) {
     do {
       zs.avail_out = BLOCK_SIZE;
       zs.next_out = block_dst;
-
+      int err =0;
+#ifdef BTSNOOP_DEBUG
       int err = deflate(&zs, (i == num_blocks - 1) ? Z_FINISH : Z_NO_FLUSH);
+#endif
       if (err == Z_STREAM_ERROR) {
         rc = false;
         break;
@@ -151,8 +156,9 @@ static bool btsnoop_compress(ringbuffer_t *rb_dst, ringbuffer_t *rb_src) {
       ringbuffer_insert(rb_dst, block_dst, length);
     } while (zs.avail_out == 0);
   }
-
+#ifdef BTSNOOP_DEBUG
   deflateEnd(&zs);
+#endif
   return rc;
 }
 
@@ -198,7 +204,9 @@ void btif_debug_btsnoop_dump(int fd) {
       dprintf(fd, "\n");
       line_length = 0;
     }
+#ifdef ANDROID
     line_length += b64_ntop(b64_in, read, b64_out, 5);
+#endif
     dprintf(fd, "%s", b64_out);
   }
 
diff --git a/btif/src/btif_dm.c b/btif/src/btif_dm.c
index 75cccde..ce83f61 100644
--- a/btif/src/btif_dm.c
+++ b/btif/src/btif_dm.c
@@ -1,5 +1,10 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2018 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *  NOT A CONTRIBUTION
+ *
  *  Copyright (C) 2009-2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -60,6 +65,7 @@
 #include "osi/include/properties.h"
 #include "stack_config.h"
 #include "stack/btm/btm_int.h"
+#include "osi/include/semaphore.h"
 
 /******************************************************************************
 **  Constants & Macros
@@ -190,7 +196,10 @@ typedef struct
 #define UUID_HUMAN_INTERFACE_DEVICE "00001124-0000-1000-8000-00805f9b34fb"
 
 #define MAX_BTIF_BOND_EVENT_ENTRIES 15
-
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+#define UNIFIED_WAKEUP_ENABLE_LENGTH    2
+#define UNIFIED_WAKEUP_CONFIG_LENGTH    14
+#endif
 /* This flag will be true if HCI_Inquiry is in progress */
 static BOOLEAN btif_dm_inquiry_in_progress = FALSE;
 
@@ -210,6 +219,10 @@ static pthread_mutex_t bond_event_lock;
 static size_t btif_num_bond_events = 0;
 static size_t btif_events_start_index = 0;
 static size_t btif_events_end_index = 0;
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+BOOLEAN btif_dm_is_controller_ready = TRUE;
+#endif
+
 
 /******************************************************************************
 **  Static functions
@@ -244,6 +257,11 @@ static void btif_stats_add_bond_event(const bt_bdaddr_t *bd_addr,
                                       bt_bond_function_t function,
                                       bt_bond_state_t state);
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+static void btif_enable_unified_wakeup(BOOLEAN enable);
+static void btif_config_unified_wakeup(void);
+#endif
+
 /******************************************************************************
 **  Externs
 ******************************************************************************/
@@ -830,6 +848,7 @@ static void btif_dm_cb_create_bond(bt_bdaddr_t *bd_addr, tBTA_TRANSPORT transpor
             btif_storage_set_remote_addr_type(bd_addr, addr_type);
         }
     }
+
     if((btif_config_get_int((char const *)&bdstr,"DevType", &device_type) &&
        (btif_storage_get_remote_addr_type(bd_addr, &addr_type) == BT_STATUS_SUCCESS) &&
        (device_type & BT_DEVICE_TYPE_BLE) == BT_DEVICE_TYPE_BLE) || (transport == BT_TRANSPORT_LE))
@@ -1896,6 +1915,39 @@ static void btif_dm_remote_service_record_evt(UINT16 event, char *p_param)
     }
 }
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+/*******************************************************************************
+**
+** Function         btif_dm_remove_device_whitelist_vsc_cback
+**
+** Description      remove device to whitelist VSC callback
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_dm_remove_device_whitelist_vsc_cback(tBTM_VSC_CMPL *pCmplEvt)
+{
+    UINT8 status = 0xFF;
+    UINT8 *p;
+
+    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
+
+    /* Check status of command complete event */
+    if ((pCmplEvt->opcode == HCI_VS_UNIFIED_WAKEUP_OPCODE) &&
+        (pCmplEvt->param_len > 0))
+    {
+        p = pCmplEvt->p_param_buf;
+        STREAM_TO_UINT8(status, p);
+    }
+
+    if (status == HCI_SUCCESS)
+    {
+        BTIF_TRACE_DEBUG("Removing device from whitelist is successful");
+    }
+    else
+        BTIF_TRACE_ERROR("Removing device from whitelist Failed");
+}
+#endif
 /*******************************************************************************
 **
 ** Function         btif_dm_upstreams_cback
@@ -1918,6 +1970,7 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
     {
         case BTA_DM_ENABLE_EVT:
         {
+        LOG_INFO(LOG_TAG," Sending BT ON to upper %s Status:%d",__func__,p_data->enable.status);
              BD_NAME bdname;
              bt_status_t status;
              bt_property_t prop;
@@ -1930,6 +1983,9 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
              {
                  /* A name exists in the storage. Make this the device name */
                  BTA_DmSetDeviceName((char*)prop.val);
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+                 btif_enable_unified_wakeup(TRUE);
+#endif
              }
              else
              {
@@ -1943,7 +1999,7 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
              /* Enable local privacy */
              BTA_DmBleConfigLocalPrivacy(BLE_LOCAL_PRIVACY_ENABLED);
 #endif
-
+        LOG_INFO(LOG_TAG," Sending BT ON to upper Mid !%s",__func__);
              /* for each of the enabled services in the mask, trigger the profile
               * enable */
              service_mask = btif_get_enabled_services_mask();
@@ -1962,10 +2018,11 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
              /* This function will also trigger the adapter_properties_cb
              ** and bonded_devices_info_cb
              */
+             LOG_INFO(LOG_TAG," Sending BT ON to upper 1 %s",__func__);
              btif_storage_load_bonded_devices();
-
+        LOG_INFO(LOG_TAG," Sending BT ON to upper  2%s",__func__);
              load_iot_devlist(IOT_DEV_CONF_FILE);
-
+        LOG_INFO(LOG_TAG," Sending BT ON to upper 3 %s",__func__);
              btif_enable_bluetooth_evt(p_data->enable.status);
         }
         break;
@@ -2018,6 +2075,28 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
             #endif
             btif_storage_remove_bonded_device(&bd_addr);
             bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_NONE);
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+            if (check_cod_hid(&bd_addr))
+            {
+                UINT8           param[10], *pp;
+                UINT8           sub_code = 0x06;  //Remove device from WHITE LIST for Unified WAKE UP
+                UINT8           addr_type=0x0; //Public:0x0, Random:0x1
+                BD_ADDR     remote_bd_addr;
+
+                pp = param;
+                memset(param, 0, sizeof(param));
+
+                bdcpy(remote_bd_addr, bd_addr.address);
+                BTIF_TRACE_EVENT("%s Device %02X:%02X:%02X:%02X:%02X:%02X removed from whitelist", __FUNCTION__,
+                                                 remote_bd_addr[0], remote_bd_addr[1], remote_bd_addr[2],
+                                                 remote_bd_addr[3], remote_bd_addr[4], remote_bd_addr[5]);
+                UINT8_TO_STREAM (pp, sub_code);
+                BDADDR_TO_STREAM(pp, remote_bd_addr);
+                UINT8_TO_STREAM (pp, addr_type);
+                BTA_DmVendorSpecificCommand(HCI_VS_UNIFIED_WAKEUP_OPCODE, 8,
+                                                param, btif_dm_remove_device_whitelist_vsc_cback);
+            }
+#endif
             break;
 
         case BTA_DM_BUSY_LEVEL_EVT:
@@ -2085,7 +2164,6 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
             bdcpy(bd_addr.address, p_data->link_down.bd_addr);
 
             btm_set_bond_type_dev(p_data->link_down.bd_addr, BOND_TYPE_UNKNOWN);
-
             BTIF_TRACE_DEBUG("BTA_DM_LINK_DOWN_EVT. Sending BT_ACL_STATE_DISCONNECTED");
             if (num_active_le_links > 0 &&
                 p_data->link_down.link_type == BT_TRANSPORT_LE)
@@ -2540,6 +2618,361 @@ static void bte_scan_filt_param_cfg_evt(UINT8 action_type,
     }
 }
 
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+
+/*******************************************************************************
+**
+** Function         btif_dm_sleep_wake_ind_vsc_cback
+**
+** Description      SLEEP/WAKE IND VSC callback
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_dm_sleep_wake_ind_vsc_cback(tBTM_VSC_CMPL *pCmplEvt, BOOLEAN sleep)
+{
+    UINT8 status = 0xFF;
+    UINT8 *p;
+    char *str = (sleep == TRUE)? "sleep":"wake";
+
+    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
+
+    /* Check status of command complete event */
+    if ((pCmplEvt->opcode == HCI_VS_UNIFIED_WAKEUP_OPCODE) &&
+        (pCmplEvt->param_len > 0))
+    {
+        p = pCmplEvt->p_param_buf;
+        STREAM_TO_UINT8(status, p);
+    }
+
+    if (status == HCI_SUCCESS)
+    {
+        BTIF_TRACE_DEBUG("%s Indication successful", str);
+        btif_dm_is_controller_ready = !sleep;
+    }
+    else
+        BTIF_TRACE_ERROR("%s Indication Failed", str);
+}
+
+/*******************************************************************************
+**
+** Function         btif_sleep_ind_vsc_cback
+**
+** Description      SLEEP IND VSC callback
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_sleep_ind_vsc_cback(tBTM_VSC_CMPL *pCmplEvt)
+{
+    btif_dm_sleep_wake_ind_vsc_cback(pCmplEvt, TRUE);
+}
+
+/*******************************************************************************
+**
+** Function         btif_wake_ind_vsc_cback
+**
+** Description      WAKE IND VSC callback
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_wake_ind_vsc_cback(tBTM_VSC_CMPL *pCmplEvt)
+{
+    btif_dm_sleep_wake_ind_vsc_cback(pCmplEvt, FALSE);
+}
+/*******************************************************************************
+**
+** Function         btif_dm_add_device_whitelist_vsc_cback
+**
+** Description      Add device to whitelist VSC callback
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_dm_add_device_whitelist_vsc_cback(tBTM_VSC_CMPL *pCmplEvt)
+{
+    UINT8 status = 0xFF;
+    UINT8 *p;
+
+    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
+
+    /* Check status of command complete event */
+    if ((pCmplEvt->opcode == HCI_VS_UNIFIED_WAKEUP_OPCODE) &&
+        (pCmplEvt->param_len > 0))
+    {
+        p = pCmplEvt->p_param_buf;
+        STREAM_TO_UINT8(status, p);
+    }
+
+    if (status == HCI_SUCCESS)
+    {
+        BTIF_TRACE_DEBUG("Adding device to whitelist is successful");
+    }
+    else
+        BTIF_TRACE_ERROR("Adding device to whitelist Failed");
+}
+
+/*******************************************************************************
+**
+** Function         btif_dm_add_device_whitelist
+**
+** Description      Add device to LPM whitelist
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_dm_add_device_whitelist(bt_bdaddr_t *bdaddr)
+{
+    UINT8           param[10], *pp;
+    UINT8           sub_code = 0x05;  //Add devices to WHITE LIST for Unified WAKE UP
+    UINT8           addr_type=0x0; //Public:0x0, Random:0x1
+    BD_ADDR     remote_bd_addr;
+
+    pp = param;
+    memset(param, 0, sizeof(param));
+
+    BTIF_TRACE_EVENT("%s Device %02X:%02X:%02X:%02X:%02X:%02X ", __FUNCTION__,
+                                     bdaddr->address[0], bdaddr->address[1], bdaddr->address[2],
+                                     bdaddr->address[3], bdaddr->address[4], bdaddr->address[5]);
+
+    bdcpy(remote_bd_addr, bdaddr->address);
+    UINT8_TO_STREAM (pp, sub_code);
+    BDADDR_TO_STREAM(pp, remote_bd_addr);
+    UINT8_TO_STREAM (pp, addr_type);
+    BTA_DmVendorSpecificCommand(HCI_VS_UNIFIED_WAKEUP_OPCODE, 8,
+                                    param, btif_dm_add_device_whitelist_vsc_cback);
+}
+
+/*******************************************************************************
+**
+** Function         btif_dm_unified_wakeup_sleep_ind
+**
+** Description      Send sleep indication to controller
+**
+** Returns          bt_status_t
+**
+*******************************************************************************/
+bt_status_t btif_dm_unified_wakeup_sleep_ind(BOOLEAN isSleep)
+{
+    UINT8           param[10], *pp;
+    UINT8           sub_code;
+
+    pp = param;
+    memset(param, 0, sizeof(param));
+
+    BTIF_TRACE_DEBUG("%s Send %s INDICATION to controller", __FUNCTION__, isSleep ? "SLEEP":"WAKE");
+
+    if(isSleep)
+    {
+#if BLE_INCLUDED == TRUE && BTA_GATT_INCLUDED == TRUE
+            BTA_dm_ble_clear_bg_conn_dev();
+#endif
+            sub_code = 0x03;  //SLEEP INDICATION
+            UINT8_TO_STREAM (pp, sub_code);
+            BTA_DmVendorSpecificCommand(HCI_VS_UNIFIED_WAKEUP_OPCODE, 1,
+                                            param, btif_sleep_ind_vsc_cback);
+    }
+    else
+    {
+        sub_code = 0x04;  //WAKE INDICATION to controller
+        UINT8_TO_STREAM (pp, sub_code);
+        BTA_DmVendorSpecificCommand(HCI_VS_UNIFIED_WAKEUP_OPCODE, 1,
+                                        param, btif_wake_ind_vsc_cback);
+    }
+    return BT_STATUS_SUCCESS;
+}
+
+
+/*******************************************************************************
+**
+** Function         btif_enable_unified_wakeup_vsc_cback
+**
+** Description     Enable Unified Wake up feature VSC Cback
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_enable_unified_wakeup_vsc_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8 status = 0xFF;
+    UINT8 *p;
+
+    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
+
+    /* Check status of command complete event */
+    if ((p_params->opcode == HCI_VS_UNIFIED_WAKEUP_OPCODE) &&
+        (p_params->param_len > 0))
+    {
+        p = p_params->p_param_buf;
+        STREAM_TO_UINT8(status, p);
+    }
+
+    if (status == HCI_SUCCESS)
+    {
+        BTIF_TRACE_DEBUG("Unified Wakeup Enable Success");
+        btif_config_unified_wakeup();
+    }
+    else
+        BTIF_TRACE_ERROR("Unified Wakeup Enable Failed");
+}
+
+/*******************************************************************************
+**
+** Function         btif_enable_unified_wakeup
+**
+** Description      Enable/Disable Unified Wake up feature on the host and controller
+**
+** Parameters:      Boolean value.
+**
+** Returns          void
+**
+*******************************************************************************/
+static void btif_enable_unified_wakeup(BOOLEAN enable)
+{
+    UINT8           param[UNIFIED_WAKEUP_ENABLE_LENGTH], *pp;
+    UINT8           sub_code = 0x01;
+    UINT8           enb = enable ? 1: 0;
+
+    pp = param;
+    memset(param, 0, sizeof(param));
+
+    UINT8_TO_STREAM (pp, sub_code);
+    UINT8_TO_STREAM (pp, enb);
+
+    BTIF_TRACE_EVENT (" %s: sub_code %d, enb %d", __FUNCTION__, sub_code,enb);
+
+    BTA_DmVendorSpecificCommand (HCI_VS_UNIFIED_WAKEUP_OPCODE,
+                                    UNIFIED_WAKEUP_ENABLE_LENGTH, param, btif_enable_unified_wakeup_vsc_cback);
+}
+
+/*******************************************************************************
+**
+** Function         btif_config_unified_wakeup_vsc_cback
+**
+** Description     Configure Unified Wake up feature VSC Cback
+**
+** Returns          void
+**
+*******************************************************************************/
+void btif_config_unified_wakeup_vsc_cback(tBTM_VSC_CMPL *p_params)
+{
+    UINT8 status = 0xFF;
+    UINT8 *p;
+
+    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
+
+    /* Check status of command complete event */
+    if ((p_params->opcode == HCI_VS_UNIFIED_WAKEUP_OPCODE) &&
+        (p_params->param_len > 0))
+    {
+        p = p_params->p_param_buf;
+        STREAM_TO_UINT8(status, p);
+    }
+
+    if (status == HCI_SUCCESS)
+    {
+        BTIF_TRACE_DEBUG("Unified Wakeup Configuration Success");
+    }
+    else
+        BTIF_TRACE_ERROR("Unified Wakeup Enable Failed");
+}
+/*******************************************************************************
+**
+** Function         btif_config_unified_wakeup
+**
+** Description      Configure Unified Wake up feature
+**
+** Parameters:      void.
+**
+** Returns          void
+**
+*******************************************************************************/
+static void btif_config_unified_wakeup(void)
+{
+    UINT8           param[UNIFIED_WAKEUP_CONFIG_LENGTH], *pp;
+    UINT8           sub_code = 0x02;  //CONFIG INDICATION
+    UINT8           transport_or_oob = 0x00;//USB:0x0, GPIO:0x1, UART:0x1
+//    UINT16         delay_to_sleep =0x0010;//16x0.625ms=> 10ms
+/* Fix for CR:2191479: Host is not wake up from LPM with  CSR LE Keyboard(LE HOGP)
+** RCA: if the Host is put to sleep, even before USB transport is suspended the controller enter LPM mode because the delay_to_sleep
+** LPM config value of 10ms is very less and is also able to filter out whitelisted remote device BLE advertisement */
+    UINT16         delay_to_sleep =0x0800;//800x0.625ms=> 500ms
+    UINT8           wake_sources;//Eg: 0x03 i.e LPM_WAKE_SOURCE_BLE_SCAN = 0x01,   LPM_WAKE_SOURCE_PAGE_SCAN = 0x02,
+    UINT16         le_scan_interaval;//Eg: 0x0010; i.e 16x0.625ms=> 10ms
+    UINT16         le_scan_window; //Eg: 0x0010; i.e 16x0.625ms=> 10ms
+    UINT16         page_scan_interaval; //Eg:0x0800 i.e 0.625*2048=>1.28s
+    UINT16         page_scan_window; //Eg: 0x0024 i.e 0.625*36=>22.5ms
+    UINT8           ble_adv_scan_flags; //Eg: 0x03 i.e LPM_ADV_WAKE_WHITE_LIST:0x1, LPM_ADV_WAKE_UNIDRECTED_EVENT = 0x02,
+
+    char conf[64];
+    const char* recv = stack_config_get_interface()->get_unified_sleep_wake_configuration();
+    char* pch;
+    char* endptr;
+
+    pp = param;
+    memset(param, 0, sizeof(param));
+
+    if(!stack_config_get_interface()->get_unified_sleep_wake_configuration()) {
+        BTIF_TRACE_DEBUG ("%s: UNIFIED WAKEUP Configuration is not defined", __func__);
+        return;
+    }
+
+    strncpy(conf, recv, 64);
+    conf[63] = 0; // null terminate
+
+    if ((pch = strtok(conf, ",")) != NULL)
+        wake_sources = (UINT8) strtoul(pch, &endptr, 16);
+    else
+           return;
+    BTIF_TRACE_EVENT (" bta_config_unified_wakeup wake_sources:0x%02x", wake_sources);
+
+    if ((pch = strtok(NULL, ",")) != NULL)
+        le_scan_interaval =  (UINT16) strtoul(pch, &endptr, 16);
+    else
+           return;
+    BTIF_TRACE_EVENT (" bta_config_unified_wakeup le_scan_interaval:0x%04x", le_scan_interaval);
+
+    if ((pch = strtok(NULL, ",")) != NULL)
+        le_scan_window =  (UINT16) strtoul(pch, &endptr, 16);
+    else
+           return;
+    BTIF_TRACE_EVENT (" bta_config_unified_wakeup le_scan_window:0x%04x", le_scan_window );
+
+    if ((pch = strtok(NULL, ",")) != NULL)
+        page_scan_interaval =  (UINT16) strtoul(pch, &endptr, 16);
+    else
+           return;
+    BTIF_TRACE_EVENT (" bta_config_unified_wakeup page_scan_interaval:0x%04x", page_scan_interaval);
+
+    if ((pch = strtok(NULL, ",")) != NULL)
+        page_scan_window =  (UINT16) strtoul(pch, &endptr, 16);
+    else
+           return;
+    BTIF_TRACE_EVENT (" bta_config_unified_wakeup page_scan_window:0x%04x", page_scan_window);
+
+    if ((pch = strtok(NULL, ",")) != NULL)
+        ble_adv_scan_flags = (UINT8) strtoul(pch, &endptr, 16);
+    else
+           return;
+    BTIF_TRACE_EVENT (" bta_config_unified_wakeup ble_adv_scan_flags:0x%02x", ble_adv_scan_flags);
+
+    UINT8_TO_STREAM (pp, sub_code);
+    UINT8_TO_STREAM (pp, transport_or_oob);
+    UINT16_TO_STREAM (pp, delay_to_sleep);
+    UINT8_TO_STREAM (pp, wake_sources);
+    UINT16_TO_STREAM (pp, le_scan_interaval);
+    UINT16_TO_STREAM (pp, le_scan_window);
+    UINT16_TO_STREAM (pp, page_scan_interaval);
+    UINT16_TO_STREAM (pp, page_scan_window);
+    UINT8_TO_STREAM (pp, ble_adv_scan_flags);
+
+    BTA_DmVendorSpecificCommand (HCI_VS_UNIFIED_WAKEUP_OPCODE,
+                                    UNIFIED_WAKEUP_CONFIG_LENGTH, param, btif_config_unified_wakeup_vsc_cback);
+}
+#endif
+
+
 /*****************************************************************************
 **
 **   btif api functions (no context switch)
@@ -2772,6 +3205,9 @@ bt_status_t btif_dm_cancel_bond(const bt_bdaddr_t *bd_addr)
 
 void btif_dm_hh_open_success(bt_bdaddr_t *bdaddr)
 {
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+    btif_dm_add_device_whitelist(bdaddr);
+#endif
     if (pairing_cb.state != BT_BOND_STATE_BONDING ||
             bdcmp(bdaddr->address, pairing_cb.bd_addr))
         return;
@@ -2950,13 +3386,19 @@ bt_status_t btif_dm_ssp_reply(const bt_bdaddr_t *bd_addr,
 bt_status_t btif_dm_get_adapter_property(bt_property_t *prop)
 {
     BTIF_TRACE_EVENT("%s: type=0x%x", __FUNCTION__, prop->type);
+    LOG_INFO(LOG_TAG,"%s: type=0x%x", __FUNCTION__, prop->type);
     switch (prop->type)
     {
         case BT_PROPERTY_BDNAME:
         {
             bt_bdname_t *bd_name = (bt_bdname_t*)prop->val;
+#ifdef ANDROID
             strncpy((char *)bd_name->name, (char *)btif_get_default_local_name(),
                    sizeof(bd_name->name) - 1);
+#else
+            strncpy((char *)bd_name->name, (char *)btif_get_default_local_name(),
+                   sizeof(bd_name->name) - 1);
+#endif
             bd_name->name[sizeof(bd_name->name) - 1] = 0;
             prop->len = strlen((char *)bd_name->name);
         }
@@ -3198,7 +3640,11 @@ void btif_dm_set_oob_for_le_io_req(BD_ADDR bd_addr, tBTA_OOB_DATA  *p_has_oob_da
 void btif_dm_load_local_oob(void)
 {
     char prop_oob[PROPERTY_VALUE_MAX];
+#ifdef ANDROID
     osi_property_get("service.brcm.bt.oob", prop_oob, "3");
+#else
+    property_get_bt("service.brcm.bt.oob", prop_oob, "3");
+#endif
     BTIF_TRACE_DEBUG("%s: prop_oob = %s", __func__, prop_oob);
     if (prop_oob[0] != '3')
     {
@@ -3213,8 +3659,13 @@ void btif_dm_load_local_oob(void)
 void btif_dm_proc_loc_oob(BOOLEAN valid, BT_OCTET16 c, BT_OCTET16 r)
 {
     FILE *fp;
+#ifdef ANDROID
     char *path_a = "/data/misc/bluedroid/LOCAL/a.key";
     char *path_b = "/data/misc/bluedroid/LOCAL/b.key";
+#else
+    char *path_a = "/data/misc/bluetooth/LOCAL/a.key";
+    char *path_b = "/data/misc/bluetooth/LOCAL/b.key";
+#endif
     char *path = NULL;
     char prop_oob[PROPERTY_VALUE_MAX];
     BTIF_TRACE_DEBUG("%s: valid=%d", __func__, valid);
@@ -3223,7 +3674,11 @@ void btif_dm_proc_loc_oob(BOOLEAN valid, BT_OCTET16 c, BT_OCTET16 r)
         BTIF_TRACE_DEBUG("save local OOB data in memory");
         memcpy(oob_cb.oob_data.c192, c, BT_OCTET16_LEN);
         memcpy(oob_cb.oob_data.r192, r, BT_OCTET16_LEN);
+#ifdef ANDROID
         osi_property_get("service.brcm.bt.oob", prop_oob, "3");
+#else
+		property_get_bt("service.brcm.bt.oob", prop_oob, "3");
+#endif
         BTIF_TRACE_DEBUG("%s: prop_oob = %s", __func__, prop_oob);
         if (prop_oob[0] == '1')
             path = path_a;
@@ -3310,14 +3765,23 @@ BOOLEAN btif_dm_proc_rmt_oob(BD_ADDR bd_addr,  BT_OCTET16 p_c, BT_OCTET16 p_r)
 {
     char t[128];
     FILE *fp;
+#ifdef ANDROID
     char *path_a = "/data/misc/bluedroid/LOCAL/a.key";
     char *path_b = "/data/misc/bluedroid/LOCAL/b.key";
+#else
+    char *path_a = "/data/misc/bluetooth/LOCAL/a.key";
+    char *path_b = "/data/misc/bluetooth/LOCAL/b.key";
+#endif
     char *path = NULL;
     char prop_oob[PROPERTY_VALUE_MAX];
     BOOLEAN result = FALSE;
     bt_bdaddr_t bt_bd_addr;
     bdcpy(oob_cb.bdaddr, bd_addr);
+#ifdef ANDROID
     osi_property_get("service.brcm.bt.oob", prop_oob, "3");
+#else
+	property_get_bt("service.brcm.bt.oob", prop_oob, "3");
+#endif
     BTIF_TRACE_DEBUG("%s: prop_oob = %s", __func__, prop_oob);
     if (prop_oob[0] == '1')
         path = path_b;
@@ -3872,7 +4336,11 @@ static char* btif_get_default_local_name() {
         else
         {
             char prop_model[PROPERTY_VALUE_MAX];
+#ifdef ANDROID
             osi_property_get(PROPERTY_PRODUCT_MODEL, prop_model, "");
+#else
+            property_get_bt(PROPERTY_PRODUCT_MODEL, prop_model, "");
+#endif
             strncpy(btif_default_local_name, prop_model, max_len);
         }
         btif_default_local_name[max_len] = '\0';
@@ -3919,8 +4387,9 @@ static void btif_stats_add_bond_event(const bt_bdaddr_t *bd_addr,
     uint32_t cod = get_cod(bd_addr);
     uint64_t ts = event->timestamp.tv_sec * 1000 +
                   event->timestamp.tv_nsec / 1000000;
+#ifdef ANDROID
     metrics_log_pair_event(0, ts, cod, device_type);
-
+#endif
     pthread_mutex_unlock(&bond_event_lock);
 }
 
diff --git a/btif/src/btif_hf.c b/btif/src/btif_hf.c
index fffafa6..165cb6d 100644
--- a/btif/src/btif_hf.c
+++ b/btif/src/btif_hf.c
@@ -30,7 +30,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 
 #include <hardware/bluetooth.h>
 #include <hardware/bt_hf.h>
@@ -1982,8 +1984,13 @@ bt_status_t btif_hf_execute_service(BOOLEAN b_enable)
         else
         {
             /* Read the property if local supported codecs commands is not supported */
+#ifdef ANDROID
             if (property_get("ro.bluetooth.hfp.ver", value, "1.5") &&
                      (!strcmp(value, "1.6") || !strcmp(value, "1.7")) )
+#else
+            if (property_get_bt("ro.bluetooth.hfp.ver", value, "1.5") &&
+                     (!strcmp(value, "1.6") || !strcmp(value, "1.7")) )
+#endif
                btif_features |= BTA_AG_FEAT_CODEC;
         }
 
diff --git a/btif/src/btif_media_task.c b/btif/src/btif_media_task.c
index a512a7b..a8d023e 100644
--- a/btif/src/btif_media_task.c
+++ b/btif/src/btif_media_task.c
@@ -48,8 +48,11 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <unistd.h>
+#ifdef ANDROID
 #include <audio_utils/primitives.h>
 #include <audio_utils/format.h>
+#endif
+
 
 #include <hardware/bluetooth.h>
 
@@ -221,8 +224,6 @@ enum {
 #endif
 #endif
 
-#define BTIF_A2DP_MAX_BITPOOL_MQ 35
-
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
 /* A2DP header will contain a CP header of size 1 */
 #define A2DP_HDR_SIZE               2
@@ -435,12 +436,12 @@ static void btif_a2dp_encoder_update(void);
 #if (BTA_AV_SINK_INCLUDED == TRUE)
 extern OI_STATUS OI_CODEC_SBC_DecodeFrame(OI_CODEC_SBC_DECODER_CONTEXT *context,
                                           const OI_BYTE **frameData,
-                                          unsigned long *frameBytes,
+                                          OI_UINT32 *frameBytes,
                                           OI_INT16 *pcmData,
-                                          unsigned long *pcmBytes);
+                                          OI_UINT32 *pcmBytes);
 extern OI_STATUS OI_CODEC_SBC_DecoderReset(OI_CODEC_SBC_DECODER_CONTEXT *context,
-                                           unsigned long *decoderData,
-                                           unsigned long decoderDataBytes,
+                                           OI_UINT32 *decoderData,
+                                           OI_UINT32 decoderDataBytes,
                                            OI_UINT8 maxChannels,
                                            OI_UINT8 pcmStride,
                                            OI_BOOL enhanced);
@@ -504,7 +505,6 @@ void disconnect_a2dp_on_vendor_start_failure();
 BOOLEAN btif_media_send_vendor_selected_codec();
 BOOLEAN btif_media_send_vendor_transport_cfg();
 BOOLEAN btif_media_send_vendor_scmst_hdr();
-BOOLEAN btif_av_is_suspend_stop_pending_ack();
 #else
 #define btif_av_get_av_hdl_from_idx(idx) (0)
 #define btif_av_is_under_handoff() (0)
@@ -521,13 +521,11 @@ BOOLEAN btif_av_is_suspend_stop_pending_ack();
 #define btif_media_send_vendor_selected_codec() (0)
 #define btif_media_send_vendor_transport_cfg()  (0)
 #define btif_media_send_vendor_scmst_hdr()      (0)
-#define btif_av_is_suspend_stop_pending_ack() (0)
 #endif
 void btif_a2dp_remote_start_timer();
 
 static tBTIF_MEDIA_CB btif_media_cb;
 static int media_task_running = MEDIA_TASK_STATE_OFF;
-static BOOLEAN enc_update_in_progress = FALSE;
 
 static fixed_queue_t *btif_media_cmd_msg_queue;
 static thread_t *worker_thread;
@@ -816,15 +814,7 @@ static void btif_recv_ctrl_data(void)
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_INCALL_FAILURE);
                 return;
             }
-            /*There can be instances where because of remote start received early, reconfig
-            flag may get reset, for such case check for tx_started flag set as well,
-            this would help returning proper status to MM*/
-            if (bt_split_a2dp_enabled)
-                APPL_TRACE_IMP("%s: A2DP command %s, reconfig: %d, tx_started: %d",
-                   __func__, dump_a2dp_ctrl_event(cmd), reconfig_a2dp,
-                   btif_media_cb.tx_started);
-            if (bt_split_a2dp_enabled && (btif_av_is_under_handoff() || reconfig_a2dp
-                || btif_media_cb.tx_started))
+            if (bt_split_a2dp_enabled && (btif_av_is_under_handoff() || reconfig_a2dp))
             {
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
                 return;
@@ -878,7 +868,6 @@ static void btif_recv_ctrl_data(void)
                                    __func__);
                 alarm_free(btif_media_cb.remote_start_alarm);
                 btif_media_cb.remote_start_alarm = NULL;
-                btif_dispatch_sm_event(BTIF_AV_RESET_REMOTE_STARTED_FLAG_UPDATE_AUDIO_STATE_EVT, NULL, 0);
             }
             /* In Dual A2dp, first check for started state of stream
             * as we dont want to START again as while doing Handoff
@@ -899,17 +888,12 @@ static void btif_recv_ctrl_data(void)
                     APPL_TRACE_DEBUG("Av stream already started");
                     if (btif_media_cb.peer_sep == AVDT_TSEP_SNK)
                         btif_a2dp_encoder_update();
-                    if (btif_media_cb.tx_start_initiated == TRUE) {
-                        APPL_TRACE_DEBUG("VSC exchange alreday started on Handoff Start, wait");
-                        break;
-                    }
-                    else if (btif_media_cb.tx_started == FALSE) {
-                        APPL_TRACE_DEBUG("Start VSC exchange on MM Start when state is remote started");
-                        btif_media_on_start_vendor_command();
+                    if (btif_media_cb.tx_started == FALSE) {
+                        APPL_TRACE_DEBUG("Split a2dp mode, VSC exchange not completed");
+                        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
                         break;
                     }
                 }
-                btif_av_reset_reconfig_flag();
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             }
             else if (btif_av_stream_ready() == TRUE)
@@ -966,14 +950,30 @@ static void btif_recv_ctrl_data(void)
             if (bt_split_a2dp_enabled && reconfig_a2dp)
             {
                 APPL_TRACE_DEBUG("Suspend called due to reconfig");
-                APPL_TRACE_DEBUG("VS exchange started: ACK suspend, cmd_start will block");
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+                if (btif_av_is_under_handoff() && !btif_av_is_device_disconnecting())
+                {
+                    APPL_TRACE_DEBUG("AV is under handoff: do nothing");
+                }
+                //else if(btif_media_cb.tx_start_initiated || btif_av_is_device_disconnecting())
+                else
+                {
+                   APPL_TRACE_DEBUG("VS exchange started: ACK suspend, cmd_start will block");
+                   a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+                }
+                break;
             }
-            else if (btif_av_stream_started_ready())
+            if (btif_av_stream_started_ready())
             {
                 APPL_TRACE_DEBUG("Suspend stream request to Av");
                 btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
             }
+            else if (bt_split_a2dp_enabled && btif_av_is_under_handoff())
+            {
+                /* Do nothing when handoff is in progress. On suspend cfm, a2dp cmd will
+                   be acknowledged. ACKing might lead to wrong codec config will be updated
+                   to hal during multi-codec connection */
+                APPL_TRACE_DEBUG("AV is under handoff");
+            }
             else
             {
                 /* if we are not in started state, just ack back ok and let
@@ -1008,8 +1008,7 @@ static void btif_recv_ctrl_data(void)
             UIPC_Read(UIPC_CH_ID_AV_CTRL, NULL, &idx, 1);
             memset(param,0,MAX_CODEC_CFG_SIZE);
 
-            if ((btif_av_stream_started_ready() == FALSE) ||
-                (enc_update_in_progress == TRUE))
+            if (btif_av_stream_started_ready() == FALSE)
             {
                 BTIF_TRACE_ERROR("A2DP_CTRL_GET_CODEC_CONFIG: stream not started");
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
@@ -1438,7 +1437,6 @@ static void btif_a2dp_encoder_update(void)
 
     UINT8 codectype = 0;
     codectype = bta_av_co_get_current_codec();
-    enc_update_in_progress = TRUE;
     if (codectype == A2D_NON_A2DP_MEDIA_CT)
     {
         UINT8* ptr = bta_av_co_get_current_codecInfo();
@@ -1605,7 +1603,6 @@ void btif_a2dp_stop_media_task(void)
     {
         alarm_free(btif_media_cb.remote_start_alarm);
         btif_media_cb.remote_start_alarm = NULL;
-        btif_dispatch_sm_event(BTIF_AV_RESET_REMOTE_STARTED_FLAG_EVT, NULL, 0);
     }
     // Exit thread
     fixed_queue_free(btif_media_cmd_msg_queue, NULL);
@@ -1663,7 +1660,13 @@ tBTIF_STATUS btif_a2dp_setup_codec(tBTA_AV_HNDL hdl)
     /* for now hardcode 44.1 khz 32 bit stereo PCM format */
     media_feeding.cfg.pcm.sampling_freq = BTIF_A2DP_SRC_SAMPLING_RATE;
 #endif
+
+#ifdef ANDROID
     media_feeding.cfg.pcm.bit_per_sample = BTIF_A2DP_SRC_BIT_DEPTH;
+#else
+     /* LE supports only 16bit sample */
+    media_feeding.cfg.pcm.bit_per_sample = 16;
+#endif
     media_feeding.cfg.pcm.num_channel = BTIF_A2DP_SRC_NUM_CHANNELS;
     media_feeding.format = BTIF_AV_CODEC_PCM;
 
@@ -1842,8 +1845,7 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
         else
         {
             /* ack back a local start request */
-            if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
         }
         return TRUE;
     }
@@ -1863,10 +1865,7 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
                         }
                     }
                     else
-                    {
-                        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
-                            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-                    }
+                        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
                     ack = TRUE;
                 }
             }
@@ -1878,8 +1877,8 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
                 {
                     if (btif_media_cb.peer_sep == AVDT_TSEP_SNK)
                     {
-                        APPL_TRACE_IMP("Do not Initiate VSC exchange on remote start");
-                        //btif_media_on_start_vendor_command();
+                        APPL_TRACE_IMP("Initiate VSC exchange on remote start");
+                        btif_media_on_start_vendor_command();
                     }
                 }
                 else
@@ -1893,8 +1892,7 @@ BOOLEAN btif_a2dp_on_started(tBTA_AV_START *p_av, BOOLEAN pending_start, tBTA_AV
     {
         APPL_TRACE_WARNING("%s: A2DP start request failed: status = %d",
                          __func__, p_av->status);
-        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
         ack = TRUE;
     }
     return ack;
@@ -1950,9 +1948,7 @@ void btif_a2dp_on_stopped(tBTA_AV_SUSPEND *p_av)
             if (p_av->initiator) {
                 APPL_TRACE_WARNING("%s: A2DP stop request failed: status = %d",
                                    __func__, p_av->status);
-                if ((btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP) ||
-                    (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND))
-                    a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
             }
             return;
         }
@@ -2000,9 +1996,7 @@ void btif_a2dp_on_suspended(tBTA_AV_SUSPEND *p_av)
         if (p_av->initiator == TRUE) {
             APPL_TRACE_WARNING("%s: A2DP suspend request failed: status = %d",
                                __func__, p_av->status);
-            if ((btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP) ||
-                    (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND))
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
         }
     }
 
@@ -2015,11 +2009,6 @@ void btif_a2dp_on_suspended(tBTA_AV_SUSPEND *p_av)
     btif_media_task_stop_aa_req();
 }
 
-UINT8 btif_a2dp_get_pending_hal_command()
-{
-    return btif_media_cb.a2dp_cmd_pending;
-}
-
 /*****************************************************************************
 **
 ** Function        btif_media_remote_start_alarm_cb
@@ -2047,21 +2036,7 @@ void btif_a2dp_remote_start_timer()
     alarm_free(btif_media_cb.remote_start_alarm);
     btif_media_cb.remote_start_alarm = NULL;
     APPL_TRACE_DEBUG("Suspend stream request to Av");
-    btif_dispatch_sm_event(BTIF_AV_REMOTE_SUSPEND_STREAM_REQ_EVT, NULL, 0);
-}
-
-void btif_a2dp_cancel_remote_start_timer()
-{
-    if (alarm_is_scheduled(btif_media_cb.remote_start_alarm))
-    {
-        APPL_TRACE_DEBUG("Cancel remote start timer");
-        alarm_free(btif_media_cb.remote_start_alarm);
-        btif_media_cb.remote_start_alarm = NULL;
-    }
-}
-
-void btif_media_on_cancel_remote_start_alarm() {
-  thread_post(worker_thread, btif_a2dp_cancel_remote_start_timer, NULL);
+    btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
 }
 
 /*****************************************************************************
@@ -2151,8 +2126,10 @@ void btif_a2dp_set_audio_focus_state(btif_media_audio_focus_state state)
 
 void btif_a2dp_set_audio_track_gain(float gain)
 {
+#ifdef ANDROID
     APPL_TRACE_DEBUG("%s set gain to %f", __func__, gain);
     BtifAvrcpSetAudioTrackGain(btif_media_cb.audio_track, gain);
+#endif
 }
 #endif
 
@@ -2174,7 +2151,7 @@ static void btif_media_task_avk_handle_timer(UNUSED_ATTR void *context)
         if (btif_media_cb.rx_audio_focus_state == BTIF_MEDIA_FOCUS_NOT_GRANTED)
         {
             APPL_TRACE_DEBUG("%s skipping frames since focus is not present.", __func__);
-            return;
+            //return;
         }
         /* play only in BTIF_MEDIA_FOCUS_GRANTED case */
 #endif
@@ -2277,9 +2254,10 @@ static void btif_media_thread_init(UNUSED_ATTR void *context) {
 
   raise_priority_a2dp(TASK_HIGH_MEDIA);
   media_task_running = MEDIA_TASK_STATE_ON;
-  enc_update_in_progress = FALSE;
   APPL_TRACE_DEBUG(" btif_media_thread_init complete");
+#ifdef ANDROID
   metrics_log_bluetooth_session_start(CONNECTION_TECHNOLOGY_TYPE_BREDR, 0);
+#endif
 }
 
 static void btif_media_thread_cleanup(UNUSED_ATTR void *context) {
@@ -2299,9 +2277,10 @@ static void btif_media_thread_cleanup(UNUSED_ATTR void *context) {
 
   /* Clear media task flag */
   media_task_running = MEDIA_TASK_STATE_OFF;
-  enc_update_in_progress = FALSE;
   APPL_TRACE_DEBUG(" btif_media_thread_cleanup complete");
+#ifdef ANDROID
   metrics_log_bluetooth_session_end(DISCONNECT_REASON_UNKNOWN, 0);
+#endif
 }
 
 /*******************************************************************************
@@ -2429,96 +2408,50 @@ static void btif_media_thread_handle_cmd(fixed_queue_t *queue, UNUSED_ATTR void
             APPL_TRACE_IMP("ignore VS stop request");
         break;
     case BTIF_MEDIA_VS_A2DP_START_SUCCESS:
-        if (get_soc_type() == BT_SOC_SMD)
-        {
-            btif_media_cb.vs_configs_exchanged = false;
-        }
         btif_media_cb.tx_start_initiated = FALSE;
         btif_media_cb.tx_started = TRUE;
-        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
-        {
-            btif_av_reset_reconfig_flag();
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-        }
-        else
-        {
-            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
-                                    btif_media_cb.a2dp_cmd_pending);
-        }
+        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
         break;
     case BTIF_MEDIA_VS_A2DP_START_FAILURE:
-        if (get_soc_type() == BT_SOC_SMD)
-        {
-            btif_media_cb.vs_configs_exchanged = false;
-        }
         btif_media_cb.tx_start_initiated = FALSE;
-        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_START)
-        {
-            btif_av_reset_reconfig_flag();
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
-        }
-        else
-        {
-            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
-                                    btif_media_cb.a2dp_cmd_pending);
-        }
+        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
         disconnect_a2dp_on_vendor_start_failure();
         break;
     case BTIF_MEDIA_VS_A2DP_STOP_SUCCESS:
         btif_media_cb.tx_started = FALSE;
         btif_media_cb.tx_stop_initiated = FALSE;
+        /*Reset vendor state after stop success
+          to handle stream started for touch tone
+          to connect to second other device
+        */
+        btif_media_send_reset_vendor_state();
         if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND ||
             btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP)
         {
-            /*Reset vendor state after stop success
-              to handle stream started for touch tone
-              to connect to second other device
-            */
-            btif_media_send_reset_vendor_state();
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
         }
         else
         {
-            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
-                                    btif_media_cb.a2dp_cmd_pending);
+            APPL_TRACE_ERROR("wrong cmd pending");
+            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
         }
         break;
     case BTIF_MEDIA_VS_A2DP_STOP_FAILURE:
         btif_media_cb.tx_stop_initiated = FALSE;
-        if (btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_SUSPEND ||
-            btif_media_cb.a2dp_cmd_pending == A2DP_CTRL_CMD_STOP)
-        {
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
-        }
-        else
-        {
-            APPL_TRACE_ERROR("wrong cmd %d pending, ignore ACK",
-                                    btif_media_cb.a2dp_cmd_pending);
-        }
+        a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
         break;
     case BTIF_MEDIA_VS_A2DP_MEDIA_CHNL_CFG_SUCCESS:
         //btif_media_send_vendor_pref_bit_rate();
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
         btif_media_send_vendor_scmst_hdr();
 #else
-        if (get_soc_type() == BT_SOC_SMD)
-        {
-            if (!btif_media_cb.vs_configs_exchanged &&
-                  btif_media_cb.tx_start_initiated)
-                btif_media_cb.vs_configs_exchanged = TRUE;
-            else
-            {
-                APPL_TRACE_ERROR("Dont send start,stream suspended")
-                break;
-            }
-        }
+        if (!btif_media_cb.vs_configs_exchanged &&
+              btif_media_cb.tx_start_initiated)
+            btif_media_cb.vs_configs_exchanged = TRUE;
         else
         {
-            if (!btif_media_cb.tx_start_initiated)
-            {
-                APPL_TRACE_ERROR("Dont send start,stream suspended")
-                break;
-            }
+            APPL_TRACE_ERROR("Dont send start,stream suspended")
+            break;
         }
         btif_media_send_vendor_start();
 #endif
@@ -2536,34 +2469,20 @@ static void btif_media_thread_handle_cmd(fixed_queue_t *queue, UNUSED_ATTR void
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
         btif_media_send_vendor_scmst_hdr();
 #else
-        if ((get_soc_type() == BT_SOC_SMD) &&
-                    (!btif_media_cb.vs_configs_exchanged))
-        {
+        if (!btif_media_cb.vs_configs_exchanged)
             btif_media_cb.vs_configs_exchanged = TRUE;
-        }
         btif_media_send_vendor_start();
 #endif
         break;
 #if (BTA_AV_CO_CP_SCMS_T == TRUE)
     case BTIF_MEDIA_VS_A2DP_SET_SCMST_HDR_SUCCESS:
-        if (get_soc_type() == BT_SOC_SMD)
-        {
-            if (!btif_media_cb.vs_configs_exchanged &&
-                  btif_media_cb.tx_start_initiated)
-                btif_media_cb.vs_configs_exchanged = TRUE;
-            else
-            {
-                APPL_TRACE_ERROR("Dont send start,stream suspended")
-                break;
-            }
-        }
+        if (!btif_media_cb.vs_configs_exchanged &&
+              btif_media_cb.tx_start_initiated)
+            btif_media_cb.vs_configs_exchanged = TRUE;
         else
         {
-            if (!btif_media_cb.tx_start_initiated)
-            {
-                APPL_TRACE_ERROR("Dont send start,stream suspended")
-                break;
-            }
+            APPL_TRACE_ERROR("Dont send start,stream suspended")
+            break;
         }
         btif_media_send_vendor_start();
         break;
@@ -2632,11 +2551,18 @@ static void btif_media_task_handle_inc_media(tBT_SBC_HDR*p_msg)
     }
 
 #ifdef USE_AUDIO_TRACK
+
+#ifdef ANDROID
     BtifAvrcpAudioTrackWriteData(
         btif_media_cb.audio_track, (void*)pcmData, (sizeof(pcmData) - availPcmBytes));
 #else
+        btif_media_enque_pcm_data((void*)pcmData, (sizeof(pcmData) - availPcmBytes));
+#endif /* ANDROID */
+
+#else
     UIPC_Send(UIPC_CH_ID_AV_AUDIO, 0, (UINT8 *)pcmData, (sizeof(pcmData) - availPcmBytes));
-#endif
+
+#endif /* USE_AUDIO_TRACK */
 }
 #endif
 
@@ -2992,14 +2918,12 @@ static void btif_media_task_enc_update(BT_HDR *p_msg)
             btif_media_cb.TxAaMtuSize = ((BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_OFFSET - sizeof(BT_HDR)) < pUpdateAudio->MinMtuSize) ?
                                                   (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_OFFSET - sizeof(BT_HDR)) : pUpdateAudio->MinMtuSize;
             APPL_TRACE_DEBUG("%s : aptX btif_media_cb.TxAaMtuSize %d", __func__, btif_media_cb.TxAaMtuSize);
-            enc_update_in_progress = FALSE;
             return;
         } else if ((pUpdateAudio->BluetoothVendorID == A2D_APTX_HD_VENDOR_ID)
             && (pUpdateAudio->BluetoothCodecID == A2D_APTX_HD_CODEC_ID_BLUETOOTH)) {
             APPL_TRACE_DEBUG("%s aptX HD", __func__);
             btif_media_cb.TxAaMtuSize = ((BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_HD_OFFSET - sizeof(BT_HDR)) < pUpdateAudio->MinMtuSize) ?
                                                   (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_APTX_HD_OFFSET - sizeof(BT_HDR)) : pUpdateAudio->MinMtuSize;
-            enc_update_in_progress = FALSE;
             return;
         } else {
             /* do nothing, fall through to SBC */
@@ -3012,7 +2936,6 @@ static void btif_media_task_enc_update(BT_HDR *p_msg)
                                       BTIF_MEDIA_AA_AAC_OFFSET - sizeof(BT_HDR))
                 < pUpdateAudio->MinMtuSize) ? (BTIF_MEDIA_AA_BUF_SIZE - BTIF_MEDIA_AA_AAC_OFFSET
                 - sizeof(BT_HDR)) : pUpdateAudio->MinMtuSize;
-       enc_update_in_progress = FALSE;
        return;
     }
 #endif
@@ -3158,7 +3081,6 @@ static void btif_media_task_enc_update(BT_HDR *p_msg)
         }
         btif_media_cb.tx_sbc_frames = calculate_max_frames_per_packet();
     }
-    enc_update_in_progress = FALSE;
 }
 
 /*******************************************************************************
@@ -3514,16 +3436,20 @@ static void btif_media_task_aa_handle_stop_decoding(void) {
   alarm_free(btif_media_cb.decode_alarm);
   btif_media_cb.decode_alarm = NULL;
 #ifdef USE_AUDIO_TRACK
+#ifdef ANDROID
   BtifAvrcpAudioTrackPause(btif_media_cb.audio_track);
 #endif
+#endif
 }
 
 static void btif_media_task_aa_handle_start_decoding(void) {
   if (btif_media_cb.decode_alarm)
     return;
 #ifdef USE_AUDIO_TRACK
+#ifdef ANDROID
   BtifAvrcpAudioTrackStart(btif_media_cb.audio_track);
 #endif
+#endif
   btif_media_cb.decode_alarm = alarm_new_periodic("btif.media_decode");
   if (!btif_media_cb.decode_alarm) {
     LOG_ERROR(LOG_TAG, "%s unable to allocate decode alarm.", __func__);
@@ -3540,10 +3466,12 @@ static void btif_media_task_aa_handle_clear_track (void)
 {
     APPL_TRACE_DEBUG("btif_media_task_aa_handle_clear_track");
 #ifdef USE_AUDIO_TRACK
+#ifdef ANDROID
     BtifAvrcpAudioTrackStop(btif_media_cb.audio_track);
     BtifAvrcpAudioTrackDelete(btif_media_cb.audio_track);
     btif_media_cb.audio_track = NULL;
 #endif
+#endif
 }
 
 /*******************************************************************************
@@ -3587,6 +3515,7 @@ static void btif_media_task_aa_handle_decoder_reset(BT_HDR *p_msg)
     }
 
 #ifdef USE_AUDIO_TRACK
+#ifdef ANDROID
     APPL_TRACE_DEBUG("%s A2dpSink: sbc Create Track", __func__);
     btif_media_cb.audio_track =
         BtifAvrcpAudioTrackCreate(btif_a2dp_get_track_frequency(sbc_cie.samp_freq),
@@ -3595,9 +3524,12 @@ static void btif_media_task_aa_handle_decoder_reset(BT_HDR *p_msg)
         APPL_TRACE_ERROR("%s A2dpSink: Track creation fails!!!", __func__);
         return;
     }
+#endif
 #else
+#ifdef ANDROID
     UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);
 #endif
+#endif
 
     switch (sbc_cie.samp_freq)
     {
@@ -3927,7 +3859,6 @@ static void btif_media_task_aa_stop_tx(void)
         {
             alarm_free(btif_media_cb.remote_start_alarm);
             btif_media_cb.remote_start_alarm = NULL;
-            btif_dispatch_sm_event(BTIF_AV_RESET_REMOTE_STARTED_FLAG_EVT, NULL, 0);
         }
         if (btif_media_cb.tx_started && !btif_media_cb.tx_stop_initiated)
             btif_media_send_vendor_stop();
@@ -3947,6 +3878,7 @@ static void btif_media_task_aa_stop_tx(void)
             else
             {
                 BTIF_TRACE_ERROR("Invalid cmd pending for ack");
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
             }
         }
     }
@@ -4484,7 +4416,11 @@ static void btif_media_aa_prep_sbc_2_send(UINT8 nb_frame,
             if (btif_media_aa_read_feeding(UIPC_CH_ID_AV_AUDIO))
             {
                 size_t frames  = blocm_x_subband * btif_media_cb.encoder.s16NumOfChannels;
+#ifdef ANDROID
                 memcpy_by_audio_format(btif_media_cb.encoder.as16PcmBuffer, AUDIO_FORMAT_PCM_16_BIT, btif_media_cb.encoder.as32PcmBuffer, AUDIO_FORMAT_PCM_8_24_BIT, frames);
+#else
+                memcpy(btif_media_cb.encoder.as16PcmBuffer,  btif_media_cb.encoder.as32PcmBuffer, frames * audio_bytes_per_sample(AUDIO_STREAM_DEFAULT_FORMAT));
+#endif
                 SBC_Encoder(&(btif_media_cb.encoder));
 
                 /* Update SBC frame length */
@@ -4722,26 +4658,25 @@ void btif_media_send_reset_vendor_state()
 
 void btif_media_start_vendor_command()
 {
-    APPL_TRACE_IMP("btif_media_start_vendor_command_exchange");
+    APPL_TRACE_IMP("btif_media_start_vendor_command_exchange:\
+        vs_configs_exchanged:%u", btif_media_cb.vs_configs_exchanged);
     btif_media_cb.tx_start_initiated = TRUE;
     btif_media_cb.tx_enc_update_initiated = FALSE;
-
-    if (get_soc_type() == BT_SOC_SMD)
+    if(btif_media_cb.vs_configs_exchanged)
+    {
+        btif_media_send_vendor_start();
+    }
+    else
     {
-        APPL_TRACE_IMP("vs_configs_exchanged:%u", btif_media_cb.vs_configs_exchanged);
-        if(btif_media_cb.vs_configs_exchanged)
+        if (get_soc_type() == BT_SOC_SMD)
         {
-            btif_media_send_vendor_start();
+            btif_media_send_vendor_write_sbc_cfg();
         }
         else
         {
-            btif_media_send_vendor_write_sbc_cfg();
+            btif_media_send_vendor_selected_codec();
         }
     }
-    else
-    {
-        btif_media_send_vendor_selected_codec();
-    }
 }
 
 void btif_media_on_start_vendor_command()
@@ -4768,6 +4703,7 @@ void btif_media_a2dp_start_cb(tBTM_VSC_CMPL *param)
     unsigned char status = 0;
     BT_HDR *p_buf;
 
+    btif_av_reset_reconfig_flag();
     if (param->param_len)
     {
         status = param->p_param_buf[0];
@@ -4792,7 +4728,6 @@ void btif_media_a2dp_start_cb(tBTM_VSC_CMPL *param)
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
         else
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
-        btif_av_reset_reconfig_flag();
     }
 }
 
@@ -5011,54 +4946,12 @@ BOOLEAN btif_media_send_vendor_media_chn_cfg()
     UINT8 param[8];
     bt_bdaddr_t bd_addr;
     BD_ADDR addr;
-    UINT8 codec_type = A2DP_CODEC_SBC;
-
-    if (btif_av_is_peer_edr() && (btif_av_peer_supports_3mbps() == FALSE)) {
-        // This condition would be satisfied only if the remote device is
-        // EDR and supports only 2 Mbps, but the effective AVDTP MTU size
-        // exceeds the 2DH5 packet size.
-        APPL_TRACE_DEBUG("%s The remote devce is EDR but does not support 3 Mbps", __func__);
-
-        if (btif_media_cb.TxAaMtuSize > MAX_2MBPS_AVDTP_MTU) {
-            APPL_TRACE_WARNING("%s Restricting AVDTP MTU size to %d",
-                __func__, MAX_2MBPS_AVDTP_MTU);
-            btif_media_cb.TxAaMtuSize = MAX_2MBPS_AVDTP_MTU;
-        }
-    }
-
-    codec_type = bta_av_co_get_current_codec();
-    if (codec_type == A2D_NON_A2DP_MEDIA_CT) {
-        UINT8* ptr = bta_av_co_get_current_codecInfo();
-        if (ptr) {
-            tA2D_APTX_CIE* codecInfo = (tA2D_APTX_CIE*) &ptr[BTA_AV_CFG_START_IDX];
-            if (codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID && codecInfo->codecId == A2D_APTX_CODEC_ID_BLUETOOTH)
-                   codec_type = A2DP_CODEC_APTX;
-            else if (codecInfo && codecInfo->vendorId == A2D_APTX_HD_VENDOR_ID && codecInfo->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH)
-                   codec_type = A2DP_CODEC_APTX_HD;
-        }
-    }
-
-    if ((codec_type == A2DP_CODEC_APTX) || (codec_type == A2DP_CODEC_APTX_HD))
-    {
-        if (btif_media_cb.TxAaMtuSize > MAX_2MBPS_AVDTP_MTU)
-        {
-            APPL_TRACE_IMP("Restricting AVDTP MTU size to 663 for APTx codecs");
-            btif_media_cb.TxAaMtuSize = MAX_2MBPS_AVDTP_MTU;
-        }
-    }
-
     btif_av_get_peer_addr(&bd_addr);
     memcpy(addr, bd_addr.address, sizeof(BD_ADDR));
     UINT16 acl_hdl = BTM_GetHCIConnHandle(addr, BT_TRANSPORT_BR_EDR);
     APPL_TRACE_IMP("btif_media_send_vendor_media_chn_cfg");
     APPL_TRACE_IMP("AVDTP mtu: %u, hdl: %u", btif_media_cb.TxAaMtuSize, acl_hdl);
 
-    if ((codec_type == A2DP_CODEC_SBC) && (btif_media_cb.max_bitpool <= BTIF_A2DP_MAX_BITPOOL_MQ))
-    {
-        APPL_TRACE_IMP("Restricting streaming MTU size for MQ Bitpool");
-        btif_media_cb.TxAaMtuSize = MAX_2MBPS_AVDTP_MTU;
-    }
-
     param[0] = VS_QHCI_WRITE_A2DP_MEDIA_CHANNEL_CFG;
     param[1] = 0; /*needs to send index for multi A2dp*/
     param[2] = (UINT8)(acl_hdl & 0x00ff);
@@ -5489,5 +5382,7 @@ void btif_update_a2dp_metrics(void)
                         metrics.buffer_underruns_count;
         }
     }
+#ifdef ANDROID
     metrics_log_a2dp_session(&metrics);
+#endif
 }
diff --git a/btif/src/btif_rc.c b/btif/src/btif_rc.c
index c3ca306..dbca081 100644
--- a/btif/src/btif_rc.c
+++ b/btif/src/btif_rc.c
@@ -1152,6 +1152,14 @@ void handle_rc_passthrough_cmd ( tBTA_AV_REMOTE_CMD *p_remote_cmd)
             {
                 BTIF_TRACE_DEBUG("%s: AVRC %s Release Faked earlier, drowned now",
                                   __FUNCTION__, key_map[i].name);
+#ifndef ANDROID
+              {
+		        BTIF_TRACE_DEBUG("%s AVRCP:send passthrough cmd = %s to BT Apps ",
+		                        __FUNCTION__, key_map[i].name);
+		        bdcpy(remote_address.address, btif_rc_cb[index].rc_addr);
+		        HAL_CBACK(bt_rc_callbacks, passthrough_cmd_cb, p_remote_cmd->rc_id, pressed, &remote_address);
+              }
+#endif
                 return;
             }
             send_key(uinput_fd, key_map[i].mapped_id, pressed);
@@ -1173,7 +1181,7 @@ void handle_rc_passthrough_cmd ( tBTA_AV_REMOTE_CMD *p_remote_cmd)
     }
     else
     {
-        BTIF_TRACE_ERROR("%s AVRCP:send passthrough cmd = %s to BT Apps ",
+        BTIF_TRACE_DEBUG("%s AVRCP:send passthrough cmd = %s to BT Apps ",
                         __FUNCTION__, key_map[i].name);
         bdcpy(remote_address.address, btif_rc_cb[index].rc_addr);
         HAL_CBACK(bt_rc_callbacks, passthrough_cmd_cb, p_remote_cmd->rc_id, pressed, &remote_address);
@@ -2434,6 +2442,20 @@ static void btif_rc_upstreams_evt(UINT16 event, tAVRC_COMMAND *pavrc_cmd, UINT8
                 btif_rc_cb[index].rc_notif[BTRC_EVT_PLAY_POS_CHANGED - 1].bNotify = FALSE;
                 return;
             }
+
+            if ( pavrc_cmd->reg_notif.event_id == AVRC_EVT_VOLUME_CHANGE )
+            {
+                /* AVRC_EVT_VOLUME_CHANGE notification is not supported
+                 * Hence sending REJECT.
+                 */
+                BTIF_TRACE_WARNING("%s AVRC_EVT_VOLUME_CHANGE not supported, sending REJECT",
+                    __FUNCTION__);
+                send_reject_response (btif_rc_cb[index].rc_handle, label, pavrc_cmd->pdu, AVRC_STS_BAD_CMD);
+                /* de-register this notification for a rejected response */
+                btif_rc_cb[index].rc_notif[AVRC_EVT_VOLUME_CHANGE - 1].bNotify = FALSE;
+                return;
+            }
+
             HAL_CBACK(bt_rc_callbacks, register_notification_cb, pavrc_cmd->reg_notif.event_id,
                 pavrc_cmd->reg_notif.param, &remote_addr);
         }
diff --git a/btif/src/btif_sdp_server.c b/btif/src/btif_sdp_server.c
index b0d53ee..743d451 100644
--- a/btif/src/btif_sdp_server.c
+++ b/btif/src/btif_sdp_server.c
@@ -216,9 +216,13 @@ static int alloc_sdp_slot(bluetooth_sdp_record* in_record) {
 static int free_sdp_slot(int id) {
     int handle = -1;
     bluetooth_sdp_record* record = NULL;
-    if(id >= MAX_SDP_SLOTS) {
-        APPL_TRACE_ERROR("%s() failed - id %d is invalid", __func__, id);
-        return handle;
+    if(id < 0 || id >= MAX_SDP_SLOTS) 
+    {
+#ifdef ANDROID
+       android_errorWriteLog(0x534e4554, "37502513");
+#endif
+       APPL_TRACE_ERROR("%s() failed - id %d is invalid", __func__, id);
+       return handle;
     }
     pthread_mutex_lock(&sdp_lock);
     handle = sdp_slots[id].sdp_handle;
diff --git a/btif/src/btif_uid.c b/btif/src/btif_uid.c
index 0a7f378..72aab18 100644
--- a/btif/src/btif_uid.c
+++ b/btif/src/btif_uid.c
@@ -25,8 +25,9 @@
 #define LOG_TAG "bt_uid_set"
 #include "bt_common.h"
 #include "btif_uid.h"
-
+#ifdef ANDROID
 #include <log/log.h>
+#endif
 #include <pthread.h>
 
 typedef struct uid_set_node_t {
diff --git a/btif/src/btif_vendor.c b/btif/src/btif_vendor.c
index 7bc7703..9279d6c 100644
--- a/btif/src/btif_vendor.c
+++ b/btif/src/btif_vendor.c
@@ -1,4 +1,12 @@
 /*
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  * Copyright (C) 2016 The Linux Foundation. All rights reserved
  * Not a Contribution.
  *  Copyright (C) 2009-2012 Broadcom Corporation
@@ -31,16 +39,18 @@
 #include <string.h>
 
 #define LOG_TAG "bt_btif_vendor"
-
+#ifdef ANDROID
 #include <cutils/properties.h>
+#include "device/include/interop_config.h"
+#include "device/include/interop.h"
+#endif
 #include "bt_utils.h"
 #include "btif_common.h"
 #include "btif_util.h"
 #include "btif_profile_queue.h"
 #include "stack_config.h"
 #include "stack_manager.h"
-#include "device/include/interop_config.h"
-#include "device/include/interop.h"
+
 
 #define BTA_SERVICE_ID_TO_SERVICE_MASK(id)  (1 << (id))
 extern bt_status_t btif_in_execute_service_request(tBTA_SERVICE_ID service_id,
@@ -97,7 +107,9 @@ static void btif_vendor_bredr_cleanup_event(UINT16 event, char *p_param)
             btif_in_execute_service_request(i, FALSE);
         }
     }
+#ifdef ANDROID
     btif_queue_release();
+#endif
     HAL_CBACK(bt_vendor_callbacks, bredr_cleanup_cb, true);
 }
 
@@ -107,20 +119,20 @@ static void bredrcleanup(void)
     btif_transfer_context(btif_vendor_bredr_cleanup_event,BTIF_VENDOR_BREDR_CLEANUP,
                           NULL, 0, NULL);
 }
-
+#ifdef ANDROID
 static void capture_vnd_logs(void)
 {
     LOG_INFO(LOG_TAG,"capture_vnd_logs");
     GENERATE_VND_LOGS();
 }
-
+#endif
 static void cleanup(void)
 {
     LOG_INFO(LOG_TAG,"cleanup");
     if (bt_vendor_callbacks)
         bt_vendor_callbacks = NULL;
 }
-
+#ifdef ANDROID
 // API's to match entries with in dynamic interop database
 static bool interop_db_match(int feature, int type, void *value) {
     if ( type == INTEROP_BL_TYPE_ADDR)
@@ -129,15 +141,19 @@ static bool interop_db_match(int feature, int type, void *value) {
         return interop_database_match_name((interop_feature_t)feature, (char *)value);
     return false;
 }
-
+#endif
 static const btvendor_interface_t btvendorInterface = {
     sizeof(btvendorInterface),
     init,
     ssrcleanup,
     bredrcleanup,
+#ifdef ANDROID
     capture_vnd_logs,
+#endif
     cleanup,
+#ifdef ANDROID
     interop_db_match,
+#endif
 };
 
 /*******************************************************************************
@@ -175,7 +191,11 @@ void set_logging_pref(uint16_t pref_val)
 {
   char new_log_pref[2];
   snprintf(new_log_pref, 2, "%d", pref_val);
+#ifdef ANDROID
   property_set("persist.bluetooth.log_pref", new_log_pref);
+#else
+  property_set_bt("persist.bluetooth.log_pref", new_log_pref);
+#endif
   LOG_INFO(LOG_TAG, "%s, New Logging preference value: %d", __func__, pref_val);
 }
 
@@ -250,7 +270,11 @@ void enable_bt_logger_debug(bool enable)
     if(stack_manager_get_interface()->get_stack_is_running()) {
         if(enable && !bt_logger_enabled)
         {
+#ifdef ANDROID
             property_set("bluetooth.startbtlogger", "true");
+#else
+            property_set_bt("bluetooth.startbtlogger", "true");
+#endif
             usleep(500000);
             bt_logger_enabled = true;
             init_vnd_Logger();
@@ -277,7 +301,11 @@ void enable_bt_logger_debug(bool enable)
         }
         LOG_INFO(LOG_TAG, "config_hci_snoop_log, logging status = %d", bt_logger_enabled);
         if(bt_logger_enabled)
+#ifdef ANDROID
             property_set("bluetooth.startbtlogger", "true");
+#else
+            property_set_bt("bluetooth.startbtlogger", "true");
+#endif
     }
 }
 #else
@@ -296,7 +324,11 @@ void enable_bt_logger(bool enable)
     if(stack_manager_get_interface()->get_stack_is_running()) {
         if(enable && !bt_logger_enabled)
         {
+#ifdef ANDROID
             property_set("bluetooth.startbtlogger", "true");
+#else
+            property_set_bt("bluetooth.startbtlogger", "true");
+#endif
             usleep(500000);
             bt_logger_enabled = true;
             init_vnd_Logger();
@@ -304,7 +336,11 @@ void enable_bt_logger(bool enable)
     } else {
         bt_logger_enabled = enable;
         if(bt_logger_enabled)
+#ifdef ANDROID
             property_set("bluetooth.startbtlogger", "true");
+#else
+            property_set_bt("bluetooth.startbtlogger", "true");
+#endif
     }
 }
 #endif
@@ -321,5 +357,6 @@ void enable_bt_logger(bool enable)
 void btif_vendor_snooplog_status_event(UINT16 status, char *p_param)
 {
     LOG_INFO(LOG_TAG, "%s", __func__);
-    HAL_CBACK(bt_vendor_callbacks, update_snooplog_status_cb, status);
+    // TBD for LEA.1.0 removed for ASSERT
+    //HAL_CBACK(bt_vendor_callbacks, update_snooplog_status_cb, status);
 }
diff --git a/btif/src/stack_manager.c b/btif/src/stack_manager.c
index f6a5298..f4d4c2d 100644
--- a/btif/src/stack_manager.c
+++ b/btif/src/stack_manager.c
@@ -21,7 +21,9 @@
 #include "stack_manager.h"
 
 #include <hardware/bluetooth.h>
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 
 #include "btcore/include/module.h"
 #include "btcore/include/osi_module.h"
@@ -119,7 +121,11 @@ static void event_init_stack(void *context) {
     module_init(get_module(BT_UTILS_MODULE));
     module_init(get_module(BTIF_CONFIG_MODULE));
     btif_init_bluetooth();
-
+#ifndef ANDROID
+#ifdef BT_SOC_TYPE_ROME_USB
+    module_start_up(get_module(HCI_MODULE));
+#endif
+#endif
     // stack init is synchronous, so no waiting necessary here
     stack_is_initialized = true;
   }
@@ -165,10 +171,12 @@ static void event_start_up_stack(UNUSED_ATTR void *context) {
 
   // Include this for now to put btif config into a shutdown-able state
   module_start_up(get_module(BTIF_CONFIG_MODULE));
+    LOG_INFO(LOG_TAG, "%s is bringing up the stack  1", __func__);
   bte_main_enable();
+  LOG_INFO(LOG_TAG, "%s is bringing up the stack   2", __func__);
 
   if (future_await(local_hack_future) != FUTURE_SUCCESS) {
-    LOG_ERROR(LOG_TAG, "%s failed to start up the stack", __func__);
+    LOG_INFO(LOG_TAG, "%s failed to start up the stack", __func__);
     stack_is_running = true; // So stack shutdown actually happens
     event_shut_down_stack(NULL);
     return;
@@ -222,6 +230,11 @@ static void event_clean_up_stack(void *context) {
   LOG_INFO(LOG_TAG, "%s is cleaning up the stack", __func__);
   stack_is_initialized = false;
 
+#ifndef ANDROID
+#ifdef BT_SOC_TYPE_ROME_USB
+  module_shut_down(get_module(HCI_MODULE));
+#endif
+#endif
   btif_cleanup_bluetooth();
   module_clean_up(get_module(BTIF_CONFIG_MODULE));
   module_clean_up(get_module(BT_UTILS_MODULE));
diff --git a/conf/bt_stack.conf b/conf/bt_stack.conf
index 5516ac5..4b0fd1a 100644
--- a/conf/bt_stack.conf
+++ b/conf/bt_stack.conf
@@ -1,18 +1,18 @@
 # Enable BtSnoop configuration from this config file
 # Snoop is enabled by default on userdebug builds, below configuration
 # enables to override it and take effect from the configurations here.
-BtSnoopConfigFromFile=false
+BtSnoopConfigFromFile=yes
 
 # Enable BtSnoop logging function
 # valid value : true, false
-BtSnoopLogOutput=false
-BtSnoopExtDump=false
+BtSnoopLogOutput=true
+BtSnoopExtDump=true
 
 # BtSnoop log output file
-BtSnoopFileName=/data/misc/bluetooth/logs/btsnoop_hci.log
+BtSnoopFileName=/sdcard/btsnoop_hci.log
 
 # Preserve existing BtSnoop log before overwriting
-BtSnoopSaveLog=false
+BtSnoopSaveLog=yes
 
 # Enable trace level reconfiguration function
 # Must be present before any TRC_ trace level settings
@@ -78,3 +78,16 @@ TRC_PAN=2
 #  8 = SMP_PASSKEY_ENTRY_FAIL
 #  9 = SMP_NUMERIC_COMPAR_FAIL;
 #PTS_SmpFailureCase=0
+
+# Unified Wake up LPM configuration
+# 1st Param is wake_sources Eg: 0x03meaning BLE and BR-EDR
+# 2nd Param is le_scan_interaval Eg:0x0010 meaning 10ms i.e 16x0.625ms
+# 3rd Param is le_scan_window Eg:0x0010 meaning 10ms i.e 16x0.625ms
+# 4th Param is page_scan_interaval Eg:0x0800 meaning 1.28s i.e 0.625*2048
+# 5th Param is page_scan_window Eg:0x0024 meaning 22.5ms i.e 0.625*36
+# 6th Param is ble_adv_scan_flags Eg:0x03 meaning WHITE_LIST and UNDIRECTED ADV
+# For more details on the parameters please refer design document.
+LMP_WAKEUP_CONFIG=0x03,0x0010,0x0010,0x0800,0x0024,0x03
+#HID_AUTOMATION to enable logging with timestamp on every HID report
+#valid value: true, false
+HID_AUTOMATION=false
diff --git a/configure.ac b/configure.ac
new file mode 100644
index 0000000..abb7233
--- /dev/null
+++ b/configure.ac
@@ -0,0 +1,172 @@
+#                                               -*- Autoconf -*-
+
+# configure.ac -- Autoconf script for diag
+#
+
+# Process this file with autoconf to produce a configure script.
+
+AC_PREREQ([2.68])
+AC_INIT([fluoride], [1.0.0])
+AM_INIT_AUTOMAKE([foreign subdir-objects])
+AM_MAINTAINER_MODE
+AC_CONFIG_SRCDIR([hci/src/hci_hal.c])
+AC_CONFIG_HEADER([config.h])
+AC_CONFIG_MACRO_DIR([m4])
+
+AM_PROG_LIBTOOL
+# Checks for programs.
+AC_PROG_CC
+AM_PROG_CC_C_O
+AC_PROG_LIBTOOL
+AC_PROG_AWK
+AC_PROG_CPP
+AC_PROG_CXX
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+PKG_PROG_PKG_CONFIG
+
+# Library configs
+AC_ARG_WITH([common_includes],
+      AC_HELP_STRING([--with-common-includes=@<:@dir@:>@],
+         [Specify the location of the common headers]),
+      [common_incdir=$withval],
+      with_common_includes=no)
+
+if test "x$with_common_includes" != "xno"; then
+   CFLAGS="${CFLAGS} -I${common_incdir}"
+fi
+
+AC_ARG_WITH([hardware_include],
+                  AC_HELP_STRING([--with-hardware-include=@<:@dir@:>@],
+                                 [Specify the location of the hardware headers]),
+                                 [hardware_incdir=$withval],
+                                 with_hardware_include=no)
+
+if test "x$with_hardware_include" != "xno"; then
+       CPPFLAGS="${CPPFLAGS} -I${hardware_incdir}"
+fi
+
+AC_ARG_WITH([hardware_libraries],
+                 AC_HELP_STRING([--with-hardware-libraries=@<:@dir@:>@],
+                                     [Specify the location of the hardware libraries]),
+                                     [hardware_libdir=$withval],
+                                          with_hardware_libraries=no)
+
+if test "x$with_hardware_libraries" != "xno"; then
+    LDFLAGS="${LDFLAGS} -L${hardware_libdir}"
+fi
+
+AC_SUBST([CFLAGS])
+AC_SUBST([CPPFLAGS])
+AC_SUBST([CC])
+
+# Checks for header files.
+AC_CHECK_HEADERS([fcntl.h stdlib.h string.h sys/socket.h sys/time.h termios.h unistd.h])
+
+# Build all components by default
+#
+# To add new components: add AC_ARG_ENABLE, AM_CONDITIONAL and update AC_OUTPUT
+#
+AC_ARG_ENABLE(target,
+  [AS_HELP_STRING([--enable-target=TARGET], [Specify the target product to build])],
+  [TARGET=$enableval],
+  [TARGET=none]
+)
+
+AC_ARG_ENABLE(rome,
+  [AS_HELP_STRING([--enable-rome=ROME], [Specify the rome product to build])],
+  [ROME=$enableval],
+  [ROME=none]
+)
+
+AM_CONDITIONAL([MDM_ROME], [test "x$TARGET" = "xmdm9607" -o "x$TARGET" = "xmdm9635" -o "x$TARGET" = "xmdm9640" -o "x$TARGET" = "xmdm9650" -o "x$TARGET" = "xapq8096" -o "x$TARGET" = "xsdx20" -o "x$ROME" = "xqsap" -o "x$ROME" = "xrobot-rome"])
+AM_CONDITIONAL([MDM_PRONTO], [test "x$TARGET" = "xapq8009" -o "x$TARGET" = "xapq8017" -o "x$TARGET" = "xapq8053" -o "x$TARGET" = "xapq8016"])
+AM_CONDITIONAL([MDM_CHEROKEE], [test "x$TARGET" = "xapq8098"])
+AM_CONDITIONAL([BT_AUDIO_HAL_INTEGRATION], [test "x$TARGET" = "xapq8009" -o "x$TARGET" = "xapq8017" -o "x$TARGET" = "xapq8053" -o "x$TARGET" = "xapq8098"])
+# BTC support
+# make below flag to true to enable the BTC
+AM_CONDITIONAL([BTC_SUPPORT], false)
+
+# SSR_Cleanup support
+# make below flag to true to cleanup audio related things from BT app
+# on detection of SSR/command timeout/Hw eror event
+AM_CONDITIONAL([SSR_CLEANUP_SUPPORT], true)
+
+
+AC_MSG_CHECKING(for zlib support)
+AC_ARG_WITH(zlib, AC_HELP_STRING([--with-zlib],[Enable zlib support for mod_compress]),
+    [WITH_ZLIB=$withval],[WITH_ZLIB=yes])
+AC_MSG_RESULT([$WITH_ZLIB])
+
+if test "$WITH_ZLIB" != "no"; then
+  AC_CHECK_LIB(z, deflate, [
+    AC_CHECK_HEADERS([zlib.h],[
+      Z_LIB=-lz
+      AC_DEFINE([HAVE_LIBZ], [1], [libz])
+      AC_DEFINE([HAVE_ZLIB_H], [1])
+    ])
+  ])
+  if test x$Z_LIB = x; then
+     AC_MSG_ERROR([zlib-headers and/or libs where not found, install them or build with --without-zlib])
+  fi
+fi
+AC_SUBST(Z_LIB)
+
+AC_ARG_WITH([lib_path],
+      AC_HELP_STRING([--with-lib-path=@<:@dir@:>@],
+         [Specify the location of the libraries]),
+      [std_libdir=$withval],
+      with_lib_path=no)
+
+if test "x$with_lib_path" != "xno"; then
+   SYS_LIB=${std_libdir}
+fi
+
+AC_SUBST(SYS_LIB)
+
+AC_CHECK_FUNC(signalfd, dummy=yes,
+      AC_MSG_ERROR(signalfd support is required))
+
+AC_CHECK_LIB(rt, clock_gettime, dummy=yes,
+      AC_MSG_ERROR(realtime clock support is required))
+
+AC_CHECK_LIB(pthread, pthread_create, dummy=yes,
+      AC_MSG_ERROR(posix thread support is required))
+
+AC_CHECK_LIB(dl, dlopen, dummy=yes,
+      AC_MSG_ERROR(dynamic linking loader is required))
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_HEADER_STDBOOL
+AC_TYPE_OFF_T
+AC_TYPE_SIZE_T
+AC_TYPE_UINT32_T
+AC_TYPE_UINT8_T
+
+# Checks for library functions.
+AC_FUNC_MALLOC
+AC_CHECK_FUNCS([gettimeofday memset select socket strerror])
+
+AC_CONFIG_FILES([ \
+         Makefile \
+         hci/Makefile \
+         osi/Makefile \
+         profile/Makefile \
+         device/Makefile \
+         utils/Makefile \
+         btcore/Makefile \
+         stack/Makefile \
+         bta/Makefile \
+         main/Makefile \
+         tools/Makefile \
+         tools/bdtool/Makefile \
+         tools/btsnoop_dump/Makefile \
+         embdrv/sbc/decoder/Makefile \
+         btif/Makefile
+         audio_a2dp_hw/Makefile \
+         test/Makefile \
+         test/bluedroidtest/Makefile \
+         ])
+
+AC_OUTPUT
diff --git a/device/Makefile.am b/device/Makefile.am
new file mode 100644
index 0000000..c1fd8c4
--- /dev/null
+++ b/device/Makefile.am
@@ -0,0 +1,35 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS = \
+        -I../ \
+        -Iinclude \
+        -I../btcore/include \
+        -I../hci/include \
+        -I../include \
+        -I../stack/include \
+	-I../../../vendor/qcom/opensource/bluetooth/system_bt_ext \
+	-I../../../hardware/libhardware/include
+
+c_sources = \
+        src/classic/peer.c \
+        src/controller.c \
+	../../../vendor/qcom/opensource/bluetooth/system_bt_ext/device/src/interop.c
+
+common_LDFLAGS = -lpthread -lresolv
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbtdevice.la
+libbtdevice_la_CC = @CC@
+libbtdevice_la_SOURCES = $(c_sources)
+libbtdevice_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbtdevice_la_CFLAGS = $(common_CFLAGS)
+libbtdevice_la_LDFLAGS = $(common_LDFLAGS) -static
diff --git a/device/include/interop.h b/device/include/interop.h
index 8edcd01..2fc9d51 100644
--- a/device/include/interop.h
+++ b/device/include/interop.h
@@ -146,6 +146,11 @@ typedef enum {
   // as supported version.
   INTEROP_ADV_PBAP_VER_1_1,
 
+  // Honor remote avdtp start, certain carkits send avdt_start along with avrcp
+  // passthrough cmd. If DUT suspends remote start and initiate avdtp start, remote
+  // suspends DUT's start request. So honor remote start for certain devices.
+  INTEROP_REMOTE_AVDTP_START,
+
   // Devices requiring this workaround do not handle SSR max latency values as mentioned,
   // in their SDP HID Record properly and lead to connection timeout or lags. To prevent
   // such scenarios, device requiring this workaorund need to use specific ssr max latency
diff --git a/device/include/interop_database.h b/device/include/interop_database.h
index 4423aea..f6e885d 100644
--- a/device/include/interop_database.h
+++ b/device/include/interop_database.h
@@ -140,6 +140,10 @@ static const interop_addr_entry_t interop_addr_database[] = {
   // Parrot Zik2.0
   {{{0xA0, 0x14, 0x3D,      0,0,0}}, 3, INTEROP_DISABLE_AAC_CODEC},
 
+  // Porsche, Audi Q7
+  {{{0xbc, 0x30, 0x7e,      0,0,0}}, 3, INTEROP_REMOTE_AVDTP_START},
+  // Audi
+  {{{0xa4, 0x08, 0xea,      0,0,0}}, 3, INTEROP_REMOTE_AVDTP_START},
 };
 
 typedef struct {
@@ -181,6 +185,9 @@ static const interop_name_entry_t interop_name_database[] = {
   {"Motorola Keyboard KZ500", 23, INTEROP_REMOVE_HID_DIG_DESCRIPTOR},
   {"Motorola Keyboard KZ500 v122", 28, INTEROP_REMOVE_HID_DIG_DESCRIPTOR},
 
+  // Honor remote's avdtp start request
+  {"Audi",    4, INTEROP_REMOTE_AVDTP_START},
+  {"Porsche", 7, INTEROP_REMOTE_AVDTP_START},
 };
 
 typedef struct {
diff --git a/device/src/classic/peer.c b/device/src/classic/peer.c
index 1bab300..8f3637d 100644
--- a/device/src/classic/peer.c
+++ b/device/src/classic/peer.c
@@ -21,7 +21,9 @@
 #include "device/include/classic/peer.h"
 
 #include <assert.h>
+#ifdef ANDROID
 #include <cutils/log.h>
+#endif
 #include <pthread.h>
 #include <stdbool.h>
 
@@ -69,6 +71,11 @@ static future_t *clean_up(void) {
   return NULL;
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t classic_peer_module = {
   .name = CLASSIC_PEER_MODULE,
   .init = init,
diff --git a/device/src/controller.c b/device/src/controller.c
index d0a1469..effadce 100644
--- a/device/src/controller.c
+++ b/device/src/controller.c
@@ -22,7 +22,9 @@
 
 #include <assert.h>
 #include <string.h>
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 
 #include "bt_types.h"
 #include "btcore/include/event_mask.h"
@@ -45,7 +47,9 @@ const bt_event_mask_t CLASSIC_EVENT_MASK = { HCI_LISBON_EVENT_MASK_EXT };
 
 // TODO(zachoverflow): factor out into common module
 const uint8_t SCO_HOST_BUFFER_SIZE = 0xff;
-
+#ifndef ANDROID
+#define PROPERTY_VALUE_MAX 92
+#endif
 #define HCI_SUPPORTED_COMMANDS_ARRAY_SIZE 64
 #define MAX_FEATURES_CLASSIC_PAGE_COUNT 3
 #define BLE_SUPPORTED_STATES_SIZE         8
@@ -116,7 +120,7 @@ static future_t *start_up(void) {
   BT_HDR *response;
   int ret =0;
   char value[PROPERTY_VALUE_MAX] = {'\0'};
-
+   LOG_INFO(LOG_TAG, "%s Controller Start UP!!!!!!", __func__);
   // Send the initial reset command
   response = AWAIT_COMMAND(packet_factory->make_reset());
   packet_parser->parse_generic_command_complete(response);
@@ -125,7 +129,7 @@ static future_t *start_up(void) {
   response = AWAIT_COMMAND(packet_factory->make_read_buffer_size());
   packet_parser->parse_read_buffer_size_response(
       response, &acl_data_size_classic, &acl_buffer_count_classic);
-
+   LOG_INFO(LOG_TAG, "%s Controller Start UP*****", __func__);
   // Tell the controller about our buffer sizes and buffer counts next
   // TODO(zachoverflow): factor this out. eww l2cap contamination. And why just a hardcoded 10?
   response = AWAIT_COMMAND(
@@ -138,7 +142,7 @@ static future_t *start_up(void) {
   );
 
   packet_parser->parse_generic_command_complete(response);
-
+   LOG_INFO(LOG_TAG, "%s Controller Start UP##################", __func__);
   #ifdef QLOGKIT_USERDEBUG
     send_soc_log_command(true);
   #else
@@ -238,7 +242,11 @@ static future_t *start_up(void) {
 #if (BLE_INCLUDED == TRUE)
 
 #if (defined BLE_EXTENDED_ADV_SUPPORT && (BLE_EXTENDED_ADV_SUPPORT == TRUE))
+#ifdef ANDROID
   ret = property_get("ble.ae_supported", value, NULL);
+#else
+  //ret = property_get_bt("ble.ae_supported", value, NULL);
+#endif
   if (ret) {
     adv_ext_enabled = (strcmp(value, "true") ==0) ? true : false;
     LOG_INFO(LOG_TAG, "%s BLE Adv Extensions enabled:%d", __func__, adv_ext_enabled);
@@ -291,7 +299,7 @@ static future_t *start_up(void) {
             response,
             &ble_suggested_default_data_length);
     }
-
+   LOG_INFO(LOG_TAG, "%s Controller Start UP Mid WAY", __func__);
     if (adv_ext_enabled && HCI_LE_ADV_EXTENSION_SUPPORTED(features_ble.as_array)) {
         response = AWAIT_COMMAND(packet_factory->make_ble_read_adv_ext_size());
         packet_parser->parse_ble_read_adv_ext_size_response(
@@ -321,7 +329,7 @@ static future_t *start_up(void) {
         response,
         &number_of_local_supported_codecs, local_supported_codecs);
   }
-
+   LOG_INFO(LOG_TAG, "%s Controller Start UP DOne", __func__);
   readable = true;
   return future_new_immediate(FUTURE_SUCCESS);
 }
@@ -331,6 +339,11 @@ static future_t *shut_down(void) {
   return future_new_immediate(FUTURE_SUCCESS);
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t controller_module = {
   .name = CONTROLLER_MODULE,
   .init = NULL,
diff --git a/embdrv/sbc/decoder/Makefile.am b/embdrv/sbc/decoder/Makefile.am
new file mode 100644
index 0000000..2b4fc39
--- /dev/null
+++ b/embdrv/sbc/decoder/Makefile.am
@@ -0,0 +1,40 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS = -Iinclude \
+              -Isrce
+
+c_sources = \
+        ./srce/alloc.c \
+        ./srce/bitalloc.c \
+        ./srce/bitalloc-sbc.c \
+        ./srce/bitstream-decode.c \
+        ./srce/decoder-oina.c \
+        ./srce/decoder-private.c \
+        ./srce/decoder-sbc.c \
+        ./srce/dequant.c \
+        ./srce/framing.c \
+        ./srce/framing-sbc.c \
+        ./srce/oi_codec_version.c \
+        ./srce/synthesis-sbc.c \
+        ./srce/synthesis-dct8.c \
+        ./srce/synthesis-8-generated.c
+
+common_LDFLAGS = -lpthread  -lrt
+#../stack/libbtstack.la
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbt_qcom_sbc_decoder.la
+libbt_qcom_sbc_decoder_la_CC = @CC@
+libbt_qcom_sbc_decoder_la_SOURCES = $(c_sources)
+libbt_qcom_sbc_decoder_la_CPPFLAGS =$(AM_CPPFLAGS)
+libbt_qcom_sbc_decoder_la_CFLAGS = $(common_CFLAGS)
+libbt_qcom_sbc_decoder_la_LDFLAGS := $(common_LDFLAGS) -static
diff --git a/embdrv/sbc/decoder/include/oi_cpu_dep.h b/embdrv/sbc/decoder/include/oi_cpu_dep.h
index da7473a..c10da9e 100644
--- a/embdrv/sbc/decoder/include/oi_cpu_dep.h
+++ b/embdrv/sbc/decoder/include/oi_cpu_dep.h
@@ -74,8 +74,13 @@ extern "C" {
 #define OI_CPU_CR16C      18 /**< National Semiconductor 16 bit processor family */
 #define OI_CPU_M64111     19 /**< Renesas M64111 processor (M32R family) */
 #define OI_CPU_ARMV5_LEND 20 //*< ARM5, little-endian */
+#define OI_CPU_X86_64     21 /**< 64-bit x86 processor family */
 
-#define OI_CPU_TYPE 12
+#if __x86_64__
+#define OI_CPU_TYPE OI_CPU_X86_64
+#else
+#define OI_CPU_TYPE OI_CPU_X86
+#endif
 
 #ifndef OI_CPU_TYPE
     #error "OI_CPU_TYPE type not defined"
@@ -131,6 +136,27 @@ typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to su
 
 /*********************************************************************************/
 
+#if OI_CPU_TYPE==OI_CPU_X86_64
+
+#define OI_CPU_BYTE_ORDER OI_LITTLE_ENDIAN_BYTE_ORDER  /**< x86 platform byte ordering is little-endian */
+
+/** @name CPU/compiler-dependent primitive data type definitions for x86 processor family
+ *  @{
+ */
+typedef signed char     OI_INT8;   /**< 8-bit signed integer values use native signed character data type for x86 processor. */
+typedef signed short    OI_INT16;  /**< 16-bit signed integer values use native signed short integer data type for x86 processor. */
+typedef signed int     OI_INT32;  /**< 32-bit signed integer values use native signed long integer data type for x86 processor. */
+typedef unsigned char   OI_UINT8;  /**< 8-bit unsigned integer values use native unsigned character data type for x86 processor. */
+typedef unsigned short  OI_UINT16; /**< 16-bit unsigned integer values use native unsigned short integer data type for x86 processor. */
+typedef unsigned int   OI_UINT32; /**< 32-bit unsigned integer values use native unsigned long integer data type for x86 processor. */
+
+typedef OI_UINT32 OI_ELEMENT_UNION; /**< Type for first element of a union to support all data types up to pointer width. */
+
+/**@}*/
+
+#endif
+
+/*********************************************************************************/
 #if OI_CPU_TYPE==OI_CPU_ARM
 /* This CPU type is deprecated (removed from use). Instead, use OI_CPU_ARM7_LEND or OI_CPU_ARM7_BEND for
    little-endian or big-endian configurations of the ARM7, respectively. */
diff --git a/embdrv/sbc/encoder/include/sbc_encoder.h b/embdrv/sbc/encoder/include/sbc_encoder.h
index 977473d..78e4c2c 100644
--- a/embdrv/sbc/encoder/include/sbc_encoder.h
+++ b/embdrv/sbc/encoder/include/sbc_encoder.h
@@ -93,13 +93,13 @@
 
 /* ARM compiler option -> Used to distinguish the syntax for inline assembly code */
 #ifndef SBC_ARM_COMPILER
-#define SBC_ARM_COMPILER TRUE
+#define SBC_ARM_COMPILER FALSE
 #endif
 
 /* Set SBC_IPAQ_OPT to TRUE in case the target is an ARM */
 /* 32 and 64 bit mult will be performed using SINT64 ( usualy __int64 ) cast that usualy give optimal performance if supported */
 #ifndef SBC_IPAQ_OPT
-#define SBC_IPAQ_OPT TRUE
+#define SBC_IPAQ_OPT FALSE
 #endif
 
 /* Debug only: set SBC_IS_64_MULT_IN_WINDOW_ACCU to TRUE to use 64 bit multiplication in the windowing */
diff --git a/embdrv/sbc/encoder/include/sbc_types.h b/embdrv/sbc/encoder/include/sbc_types.h
index 4bb8829..7a58eed 100644
--- a/embdrv/sbc/encoder/include/sbc_types.h
+++ b/embdrv/sbc/encoder/include/sbc_types.h
@@ -34,12 +34,20 @@
 #include "bt_types.h"
 
 typedef short SINT16;
+#if __x86_64__
+typedef int SINT32;
+#else
 typedef long SINT32;
+#endif
 
 #if (SBC_IPAQ_OPT == TRUE)
 
 #if (SBC_FOR_EMBEDDED_LINUX == TRUE)
+#if __x86_64__
+typedef long SINT64;
+#else
 typedef long long SINT64;
+#endif
 #else
 typedef int64_t SINT64;
 #endif
@@ -47,7 +55,11 @@ typedef int64_t SINT64;
 #elif (SBC_IS_64_MULT_IN_WINDOW_ACCU == TRUE) || (SBC_IS_64_MULT_IN_IDCT == TRUE)
 
 #if (SBC_FOR_EMBEDDED_LINUX == TRUE)
+#if __x86_64__
+typedef long SINT64;
+#else
 typedef long long SINT64;
+#endif
 #else
 typedef int64_t SINT64;
 #endif
diff --git a/hci/Makefile.am b/hci/Makefile.am
new file mode 100644
index 0000000..b469877
--- /dev/null
+++ b/hci/Makefile.am
@@ -0,0 +1,68 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS = -Iinclude -I../include \
+        -I../btcore/include \
+        -I../stack/include \
+        -I../utils/include \
+	-I../bta/include \
+	-I../../../hardware/libhardware/include
+
+if MDM_ROME
+AM_CFLAGS += -DBT_SOC_TYPE_ROME
+AM_CPPFLAGS += -DBT_SOC_TYPE_ROME
+else
+if MDM_PRONTO
+AM_CFLAGS += -DHCI_USE_MCT
+AM_CPPFLAGS += -DHCI_USE_MCT
+endif
+endif
+
+if MDM_CHEROKEE
+AM_CFLAGS += -DBT_SOC_TYPE_CHEROKEE
+AM_CPPFLAGS += -DBT_SOC_TYPE_CHEROKEE
+endif
+
+if BTC_SUPPORT
+AM_CFLAGS += -DBTC_INCLUDED=TRUE
+AM_CPPFLAGS += -DBTC_INCLUDED=TRUE
+endif
+
+if SSR_CLEANUP_SUPPORT
+AM_CFLAGS += -DSSR_CLEANUP=TRUE
+endif
+
+c_sources = \
+        src/btsnoop.c \
+        src/btsnoop_mem.c \
+        src/btsnoop_net.c \
+        src/buffer_allocator.c \
+        src/hci_audio.c \
+        src/hci_hal.c \
+        src/hci_hal_h4.c \
+        src/hci_hal_mct.c \
+        src/hci_inject.c \
+        src/hci_layer.c \
+        src/hci_packet_factory.c \
+        src/hci_packet_parser.c \
+        src/low_power_manager.c \
+        src/packet_fragmenter.c \
+        src/vendor.c
+
+common_LDFLAGS = -lpthread -lrt -lresolv
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE -DBTSNOOP_DEFAULT=TRUE -DBT_NET_DEBUG=TRUE
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbt-hci.la
+libbt_hci_la_CC = @CC@
+libbt_hci_la_SOURCES = $(c_sources)
+libbt_hci_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbt_hci_la_CFLAGS = $(common_CFLAGS)
+libbt_hci_la_LDFLAGS := $(common_LDFLAGS) -static
diff --git a/hci/src/btsnoop.c b/hci/src/btsnoop.c
index 88c37f7..99cbd0e 100644
--- a/hci/src/btsnoop.c
+++ b/hci/src/btsnoop.c
@@ -20,7 +20,9 @@
 
 #include <arpa/inet.h>
 #include <assert.h>
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
@@ -113,6 +115,11 @@ static future_t *shut_down(void) {
   return NULL;
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t btsnoop_module = {
   .name = BTSNOOP_MODULE,
   .init = NULL,
diff --git a/hci/src/btsnoop_net.c b/hci/src/btsnoop_net.c
index 274b546..fcae051 100644
--- a/hci/src/btsnoop_net.c
+++ b/hci/src/btsnoop_net.c
@@ -19,7 +19,9 @@
 #define LOG_TAG "bt_snoop_net"
 
 #include <assert.h>
+#ifdef ANDROID
 #include <cutils/sockets.h>
+#endif
 #include <sys/un.h>
 #include <sys/poll.h>
 #include <errno.h>
@@ -31,6 +33,9 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <unistd.h>
+#ifndef ANDROID
+//#include <sys/time.h>
+#endif
 
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
@@ -56,15 +61,26 @@ int client_socket_btsnoop = -1;
 static int listen_socket_local_ = -1;
 
 static int local_socket_create(void) {
+#ifndef ANDROID
+  struct sockaddr_un addr;
+#endif
 
   listen_socket_local_ = socket(AF_LOCAL, SOCK_STREAM, 0);
   if(listen_socket_local_ < 0) {
     return -1;
   }
 
+#ifdef ANDROID
   if(socket_local_server_bind(listen_socket_local_, LOCAL_SOCKET_NAME,
       ANDROID_SOCKET_NAMESPACE_ABSTRACT) < 0) {
-    LOG_ERROR(LOG_TAG, "Failed to create Local Socket (%s)", strerror(errno));
+#else
+  memset(&addr, 0, sizeof(addr));
+  addr.sun_family = AF_LOCAL;
+  strncpy(addr.sun_path, LOCAL_SOCKET_NAME, sizeof(addr.sun_path));
+  unlink(LOCAL_SOCKET_NAME);
+  if (bind(listen_socket_local_, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
+#endif
+    LOG_ERROR(LOG_TAG,"Failed to create Local Socket (%s)", strerror(errno));
     return -1;
   }
 
diff --git a/hci/src/hci_hal.c b/hci/src/hci_hal.c
index 8337695..afb5492 100644
--- a/hci/src/hci_hal.c
+++ b/hci/src/hci_hal.c
@@ -1,5 +1,13 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  *  Copyright (C) 2014 Google, Inc.
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -15,6 +23,8 @@
  *  limitations under the License.
  *
  ******************************************************************************/
+#define LOG_TAG "hci_hal"
+
 #include <string.h>
 #include "hci_hal.h"
 #include "hci_internals.h"
@@ -30,8 +40,14 @@ bt_soc_type soc_type;
 
 const hci_hal_t *hci_hal_get_interface() {
     soc_type = get_soc_type();
-
-    if (soc_type == BT_SOC_ROME || soc_type == BT_SOC_CHEROKEE) {
+#ifdef ANDROID
+    LOG_ERROR("%s LEA SoC Type %d ", __func__, soc_type);
+#else
+	LOG_ERROR(LOG_TAG,"%s LEA SoC Type %d ", __func__, soc_type);
+#endif
+    
+    if ((soc_type == BT_SOC_ROME) || (soc_type == BT_SOC_CHEROKEE) 
+            || (soc_type == BT_SOC_ROME_USB)) {
         return hci_hal_h4_get_interface();
     } else {
         return hci_hal_mct_get_interface();
@@ -70,7 +86,11 @@ hci_reader_t *hci_reader_new(
 
   hci_reader_t *ret = osi_calloc(sizeof(hci_reader_t));
   if (!ret) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to allocate memory for new hci_reader.", __func__);
+#else
+	LOG_ERROR(LOG_TAG,"%s unable to allocate memory for new hci_reader.", __func__);
+#endif
     goto error;
   }
 
@@ -83,7 +103,11 @@ hci_reader_t *hci_reader_new(
 
   ret->inbound_read_thread = thread;
   if (!ret->inbound_read_thread) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to make reading thread.", __func__);
+#else
+	LOG_ERROR(LOG_TAG,"%s unable to make reading thread.", __func__);
+#endif
     goto error;
   }
 
diff --git a/hci/src/hci_hal_h4.c b/hci/src/hci_hal_h4.c
index a1a9b14..b390f10 100644
--- a/hci/src/hci_hal_h4.c
+++ b/hci/src/hci_hal_h4.c
@@ -98,7 +98,11 @@ static bool hal_open() {
 #if (defined(REMOVE_EAGER_THREADS) && (REMOVE_EAGER_THREADS == TRUE))
   uart_stream = hci_reader_new(uart_fd, HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX, thread, event_uart_has_bytes);
   if (!uart_stream) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to create hci reader for the uart serial port.", __func__);
+#else
+	LOG_ERROR(LOG_TAG,"%s unable to create hci reader for the uart serial port.", __func__);
+#endif
     goto error;
   }
 #else
@@ -173,8 +177,13 @@ static void packet_finished(serial_data_type_t type) {
     uint8_t type_byte;
     type_byte = uart_stream->data_buffer[uart_stream->rd_ptr++];
     if (type_byte < DATA_TYPE_ACL || type_byte > DATA_TYPE_EVENT) {
+#ifdef ANDROID
       LOG_ERROR("%s Unknown HCI message type. Dropping this byte 0x%x, min %x, max %x", __func__,
                                                     type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
+#else
+      LOG_ERROR(LOG_TAG,"%s Unknown HCI message type. Dropping this byte 0x%x, min %x, max %x", __func__,
+                                                    type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
+#endif
       return;
     }
     current_data_type = type_byte;
@@ -281,7 +290,11 @@ static void event_uart_has_bytes(void *context) {
   bytes_read = read(reader->inbound_fd, reader->data_buffer + reader->wr_ptr, reader->buffer_size - reader->wr_ptr);
 
   if (bytes_read <= 0)  {
+#ifdef ANDROID
     LOG_ERROR("%s could not read HCI message type", __func__);
+#else
+    LOG_ERROR(LOG_TAG,"%s could not read HCI message type", __func__);
+#endif
     return;
   }
   reader->wr_ptr += bytes_read;
@@ -289,7 +302,12 @@ static void event_uart_has_bytes(void *context) {
     type_byte = reader->data_buffer[reader->rd_ptr++];
 
     if (type_byte < DATA_TYPE_ACL || type_byte > DATA_TYPE_EVENT) {
+#ifdef ANDROID
       LOG_ERROR("%s Unknown HCI message type. Dropping this byte 0x%x, min %x, max %x", __func__, type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
+#else
+      LOG_ERROR(LOG_TAG,"%s Unknown HCI message type. Dropping this byte 0x%x, min %x, max %x", __func__, type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
+
+#endif
       return;
     }
 
@@ -316,7 +334,9 @@ static void event_uart_has_bytes(eager_reader_t *reader, UNUSED_ATTR void *conte
     if (type_byte < DATA_TYPE_ACL || type_byte > DATA_TYPE_EVENT) {
       LOG_ERROR(LOG_TAG, "%s Unknown HCI message type 0x%x (min=0x%x max=0x%x). Aborting...",
                 __func__, type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
+#ifdef ANDROID
       LOG_EVENT_INT(BT_HCI_UNKNOWN_MESSAGE_TYPE_NUM, type_byte);
+#endif
       assert(false && "Unknown HCI message type");
       return;
     }
diff --git a/hci/src/hci_hal_mct.c b/hci/src/hci_hal_mct.c
index 2406567..73e4572 100644
--- a/hci/src/hci_hal_mct.c
+++ b/hci/src/hci_hal_mct.c
@@ -33,8 +33,12 @@
 
 #define HCI_HAL_SERIAL_BUFFER_SIZE 1026
 
+#ifdef ANDROID
 #include <termios.h>
 #include <sys/ioctl.h>
+#else
+#include <asm-generic/termios.h>
+#endif
 
 // Our interface and modules we import
 static const hci_hal_t interface;
@@ -110,14 +114,22 @@ static bool hal_open() {
   event_stream = hci_reader_new(uart_fds[CH_EVT], HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX,
                                                  thread, event_event_stream_has_bytes);
   if (!event_stream) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to create hci reader for the event uart serial port.", __func__);
+#else
+    LOG_ERROR(LOG_TAG,"%s unable to create hci reader for the event uart serial port.", __func__);
+#endif
     goto error;
   }
 
   acl_stream = hci_reader_new(uart_fds[CH_ACL_IN], HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX,
                                                     thread, event_acl_stream_has_bytes);
   if (!acl_stream) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to create hci reader for the acl-in uart serial port.", __func__);
+#else
+   LOG_ERROR(LOG_TAG,"%s unable to create hci reader for the acl-in uart serial port.", __func__);
+#endif
     goto error;
   }
 #else
@@ -224,7 +236,11 @@ static void packet_finished(UNUSED_ATTR serial_data_type_t type) {
   }
 
   if(!stream) {
+#ifdef ANDROID
     LOG_ERROR("%s invalid data type: %d", __func__, type);
+#else
+    LOG_ERROR(LOG_TAG,"%s invalid data type: %d", __func__, type);
+#endif
     return;
   }
 
@@ -282,7 +298,11 @@ static void event_event_stream_has_bytes(void *context) {
   bytes_read = read(reader->inbound_fd, reader->data_buffer+reader->wr_ptr,
                                     reader->buffer_size - reader->wr_ptr);
   if (bytes_read <= 0) {
+#ifdef ANDROID
     LOG_ERROR("%s could not read HCI message type", __func__);
+#else
+    LOG_ERROR(LOG_TAG,"%s could not read HCI message type", __func__);
+#endif
     return;
   }
   reader->wr_ptr += bytes_read;
@@ -302,7 +322,11 @@ static void event_acl_stream_has_bytes(void *context) {
   bytes_read = read(reader->inbound_fd, reader->data_buffer+reader->wr_ptr,
                                   reader->buffer_size - reader->wr_ptr);
   if (bytes_read <= 0) {
+#ifdef ANDROID
     LOG_ERROR("%s could not read HCI message type", __func__);
+#else
+    LOG_ERROR(LOG_TAG,"%s could not read HCI message type", __func__);
+#endif
     return;
   }
   reader->wr_ptr += bytes_read;
diff --git a/hci/src/hci_layer.c b/hci/src/hci_layer.c
index 0b7e35a..d763968 100644
--- a/hci/src/hci_layer.c
+++ b/hci/src/hci_layer.c
@@ -1,5 +1,13 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  *  Copyright (C) 2014 Google, Inc.
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -47,7 +55,9 @@
 // TODO(zachoverflow): remove this hack extern
 #include <hardware/bluetooth.h>
 bt_bdaddr_t btif_local_bd_addr;
-
+#ifndef ANDROID
+#define PROPERTY_VALUE_MAX 92 
+#endif
 #define INBOUND_PACKET_TYPE_COUNT 3
 #define PACKET_TYPE_TO_INBOUND_INDEX(type) ((type) - 2)
 #define PACKET_TYPE_TO_INDEX(type) ((type) - 1)
@@ -109,6 +119,7 @@ typedef enum {
     BT_SOC_AR3K,
     BT_SOC_ROME,
     BT_SOC_CHEROKEE,
+    BT_SOC_ROME_USB,
     /* Add chipset type here */
     BT_SOC_RESERVED
 } bt_soc_type;
@@ -120,7 +131,16 @@ typedef enum {
 } low_power_config_t;
 
 // Using a define here, because it can be stringified for the property lookup
+//TODO: revert this after implementing property set functionality in wcnss filter
+#ifndef ANDROID
+#ifdef BT_SOC_TYPE_ROME
+#define DEFAULT_STARTUP_TIMEOUT_MS 100
+#else
+#define DEFAULT_STARTUP_TIMEOUT_MS 8000
+#endif
+#else //ANDROID
 #define DEFAULT_STARTUP_TIMEOUT_MS 8000
+#endif
 #define STRING_VALUE_OF(x) #x
 
 low_power_config_t lpm_config = LPM_CONFIG_NONE;
@@ -210,6 +230,9 @@ static future_t *start_up(void) {
   firmware_is_configured = false;
 
   char prop_lpm_config[PROPERTY_VALUE_MAX];
+  lpm_config = LPM_CONFIG_NONE;
+  period_ms_t startup_timeout_ms = DEFAULT_STARTUP_TIMEOUT_MS;
+#ifdef ANDROID
   osi_property_get("persist.service.bdroid.lpmcfg", prop_lpm_config, "all");
   if (!strcmp(prop_lpm_config, "all")) {
      // LPM configured for both Tx and Rx channels
@@ -223,22 +246,22 @@ static future_t *start_up(void) {
      lpm_config = LPM_CONFIG_NONE;
   }
 
-  LOG_INFO(LOG_TAG, "%s lpm configure value = %d.", __func__, lpm_config);
-
-  pthread_mutex_init(&commands_pending_response_lock, NULL);
-
   // TODO(armansito): cutils/properties.h is only being used to pull-in runtime
   // settings on Android. Remove this conditional include once we have a generic
   // way to obtain system properties. For now, always use the default timeout on
   // non-Android builds.
-  period_ms_t startup_timeout_ms = DEFAULT_STARTUP_TIMEOUT_MS;
 
   // Grab the override startup timeout ms, if present.
   char timeout_prop[PROPERTY_VALUE_MAX];
-  if (!osi_property_get("bluetooth.enable_timeout_ms", timeout_prop, STRING_VALUE_OF(DEFAULT_STARTUP_TIMEOUT_MS))
+  if (!property_get("bluetooth.enable_timeout_ms", timeout_prop, STRING_VALUE_OF(DEFAULT_STARTUP_TIMEOUT_MS))
       || (startup_timeout_ms = atoi(timeout_prop)) < 100)
     startup_timeout_ms = DEFAULT_STARTUP_TIMEOUT_MS;
+#endif
+
+  LOG_INFO(LOG_TAG, "%s lpm configure value = %d.", __func__, lpm_config);
 
+  pthread_mutex_init(&commands_pending_response_lock, NULL);
+  
   startup_timer = alarm_new("hci.startup_timer");
   if (!startup_timer) {
     LOG_ERROR(LOG_TAG, "%s unable to create startup timer.", __func__);
@@ -282,7 +305,11 @@ static future_t *start_up(void) {
   }
   commands_pending_in_queue = list_new(NULL);
   if (!commands_pending_in_queue) {
+#ifdef ANDROID
     LOG_ERROR("%s unable to create list for commands pending response.", __func__);
+#else
+   LOG_ERROR(LOG_TAG,"%s unable to create list for commands pending response.", __func__);
+#endif
     goto error;
   }
 
@@ -390,6 +417,11 @@ static future_t *shut_down() {
   return NULL;
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t hci_module = {
   .name = HCI_MODULE,
   .init = NULL,
@@ -419,7 +451,11 @@ static void transmit_command(
     command_status_cb status_callback,
     void *context) {
   if (hci_state < HCI_STARTED) {
+#ifdef ANDROID
     LOG_ERROR("%s Returning, hci_layer not ready", __func__);
+#else
+    LOG_ERROR(LOG_TAG,"%s Returning, hci_layer not ready", __func__);
+#endif
     return;
   }
 
@@ -463,7 +499,11 @@ static void transmit_downward(data_dispatcher_type_t type, void *data) {
     LOG_WARN("%s legacy transmit of command. Use transmit_command instead.", __func__);
   } else {
     if (hci_state < HCI_STARTED) {
+#ifdef ANDROID
       LOG_ERROR("%s Returning, hci_layer not ready", __func__);
+#else
+      LOG_ERROR(LOG_TAG,"%s Returning, hci_layer not ready", __func__);
+#endif
       return;
     } else {
     fixed_queue_enqueue(packet_queue, data);
@@ -542,7 +582,11 @@ static void epilog_timer_expired(UNUSED_ATTR void *context) {
 }
 
 static void hardware_error_timer_expired(UNUSED_ATTR void *context) {
+#ifdef ANDROID
   LOG_INFO("%s", __func__);
+#else
+ LOG_INFO(LOG_TAG,"%s", __func__);
+ #endif
   alarm_free(hardware_error_timer);
   hardware_error_timer = NULL;
   ssr_cleanup(0x33);//SSR reason 0x33 = HW ERR EVT
@@ -580,7 +624,11 @@ static void send_cmd_to_lower(waiting_command_t *wait_entry) {
 
 static void event_command_ready(fixed_queue_t *queue, UNUSED_ATTR void *context) {
   if (hci_state < HCI_STARTED) {
+#ifdef ANDROID
     LOG_ERROR("%s Returning, hci_layer not ready", __func__);
+#else
+  LOG_ERROR(LOG_TAG,"%s Returning, hci_layer not ready", __func__);
+#endif
     return;
   }
   if (command_credits > 0) {
@@ -596,7 +644,11 @@ static void event_command_ready(fixed_queue_t *queue, UNUSED_ATTR void *context)
 
 static void event_packet_ready(fixed_queue_t *queue, UNUSED_ATTR void *context) {
   if (hci_state < HCI_STARTED) {
+#ifdef ANDROID
     LOG_ERROR("%s Returning, hci_layer not ready", __func__);
+#else
+    LOG_ERROR(LOG_TAG,"%s Returning, hci_layer not ready", __func__);
+#endif
     return;
   }
   // The queue may be the command queue or the packet queue, we don't care
@@ -642,14 +694,23 @@ static void command_timed_out(UNUSED_ATTR void *context) {
     // We shouldn't try to recover the stack from this command timeout.
     // If it's caused by a software bug, fix it. If it's a hardware bug, fix it.
     LOG_ERROR(LOG_TAG, "%s hci layer timeout waiting for response to a command. opcode: 0x%x", __func__, wait_entry->opcode);
+#ifdef ANDROID
     LOG_EVENT_INT(BT_HCI_TIMEOUT_TAG_NUM, wait_entry->opcode);
+#endif
   }
-
+#ifdef ANDROID
   LOG_ERROR("%s restarting the bluetooth process.", __func__);
+#else
+  LOG_ERROR(LOG_TAG,"%s restarting the bluetooth process.", __func__);
+#endif
   ssr_cleanup(0x22);//SSR reasno 0x22 = CMD TO
 
   //Reset SOC status to trigger hciattach service
+#ifdef ANDROID
   if (property_set("bluetooth.status", "off") < 0) {
+#else
+  if (property_set_bt("bluetooth.status", "off") < 0) {
+#endif
      LOG_ERROR(LOG_TAG, "hci_cmd_timeout: Error resetting SOC status\n ");
   } else {
      LOG_ERROR(LOG_TAG, "hci_cmd_timeout: SOC Status is reset\n ");
@@ -662,12 +723,20 @@ static void command_timed_out(UNUSED_ATTR void *context) {
 #ifdef ENABLE_DBG_FLAGS
     enabled = true;
 #endif
+#ifdef ANDROID
     if (property_get("wc_transport.force_special_byte", value, NULL))
+#else
+    if (property_get_bt("wc_transport.force_special_byte", value, NULL))
+#endif
       enabled = (strcmp(value, "false") == 0) ? false : true;
     if (enabled) {
       hardware_error_timer = alarm_new("hci.hardware_error_timer");
       if (!hardware_error_timer) {
+#ifdef ANDROID
         LOG_ERROR("%s unable to create hardware error timer.", __func__);
+#else
+        LOG_ERROR(LOG_TAG,"%s unable to create hardware error timer.", __func__);
+#endif
         usleep(2000000);
         kill(getpid(), SIGKILL);
       }
@@ -700,7 +769,11 @@ static void hal_says_data_ready(serial_data_type_t type) {
                 break;
             else {
             //Reset SOC status to trigger hciattach service
+#ifdef ANDROID
                 if(property_set("bluetooth.status", "off") < 0) {
+#else
+                if(property_set_bt("bluetooth.status", "off") < 0) {
+#endif
                     LOG_ERROR(LOG_TAG, "SSR: Error resetting SOC status\n ");
                 } else {
                     ALOGE("SSR: SOC Status is reset\n ");
@@ -761,6 +834,12 @@ static void hal_says_data_ready(serial_data_type_t type) {
             incoming->index++;
             incoming->bytes_remaining--;
 
+            if((type == DATA_TYPE_EVENT) && (incoming->bytes_remaining == 0))
+            {
+                incoming->state = FINISHED;
+                break;
+            }
+
             size_t bytes_read = hal->read_data(type, (incoming->buffer->data + incoming->index), incoming->bytes_remaining);
             incoming->index += bytes_read;
             incoming->bytes_remaining -= bytes_read;
@@ -913,15 +992,27 @@ intercepted:
 ** which would close all the client channels
 ** and turns off the chip*/
 void ssr_cleanup (int reason) {
+#ifdef ANDROID
    LOG_INFO("%s", __func__);
+#else
+   LOG_INFO(LOG_TAG,"%s", __func__);
+#endif
    if (hci_state < HCI_STARTED) {
+#ifdef ANDROID
      LOG_ERROR("%s Returning, hci_layer already shut down", __func__);
+#else
+     LOG_ERROR(LOG_TAG,"%s Returning, hci_layer already shut down", __func__);
+#endif
      return;
    }
    if (vendor != NULL) {
        vendor->ssr_cleanup(reason);
    } else {
+#ifdef ANDROID
        LOG_ERROR("%s: vendor is NULL", __func__);
+#else
+       LOG_ERROR(LOG_TAG, "%s: vendor is NULL", __func__);
+#endif
    }
 }
 
@@ -980,7 +1071,11 @@ static waiting_command_t *get_waiting_command(command_opcode_t opcode) {
     if (wait_entry && (wait_entry->opcode != opcode) &&
         (((wait_entry->opcode & HCI_GRP_VENDOR_SPECIFIC) == HCI_GRP_VENDOR_SPECIFIC) &&
         ((opcode & HCI_GRP_VENDOR_SPECIFIC) == HCI_GRP_VENDOR_SPECIFIC))) {
+#ifdef ANDROID
         LOG_DEBUG("%s VS event found treat it as valid 0x%x", __func__, opcode);
+#else
+        LOG_DEBUG(LOG_TAG,"%s VS event found treat it as valid 0x%x", __func__, opcode);
+#endif
     }
     else {
         continue;
diff --git a/hci/src/vendor.c b/hci/src/vendor.c
index 46ae0ac..7802755 100644
--- a/hci/src/vendor.c
+++ b/hci/src/vendor.c
@@ -29,8 +29,11 @@
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
 
-
+#ifdef ANDROID
 static const char *VENDOR_LIBRARY_NAME = "libbt-vendor.so";
+#else
+static const char *VENDOR_LIBRARY_NAME = "/usr/lib/libbt-vendor.so";
+#endif
 static const char *VENDOR_LIBRARY_SYMBOL_NAME = "BLUETOOTH_VENDOR_LIB_INTERFACE";
 
 static const vendor_t interface;
@@ -94,7 +97,11 @@ void vendor_ssrcleanup(int reason) {
   if (lib_interface)
     lib_interface->ssr_cleanup(reason);
   else
+#ifdef ANDROID
     LOG_ERROR("%s lib_interface is NULL", __func__);
+#else
+  LOG_ERROR(LOG_TAG,"%s lib_interface is NULL", __func__);
+#endif
 
 }
 
diff --git a/include/bt_logger_lib.h b/include/bt_logger_lib.h
index 30467af..29a8088 100644
--- a/include/bt_logger_lib.h
+++ b/include/bt_logger_lib.h
@@ -32,6 +32,9 @@
 
 #include <stdio.h>
 #include <sys/types.h>
+#ifndef ANDROID
+#include <stdarg.h>
+#endif
 
 /**
  * Commands
diff --git a/include/bt_target.h b/include/bt_target.h
index 37ef9ae..66646c9 100644
--- a/include/bt_target.h
+++ b/include/bt_target.h
@@ -97,6 +97,11 @@
 #define BTA_GATT_INCLUDED TRUE
 #endif
 
+
+#ifndef AV_BOTH_ROLES_ENABLED
+#define AV_BOTH_ROLES_ENABLED TRUE
+#endif
+
 #ifndef BTA_AV_SINK_INCLUDED
 #define BTA_AV_SINK_INCLUDED TRUE
 #endif
@@ -203,7 +208,7 @@
 ******************************************************************************/
 
 #ifndef TEST_APP_INTERFACE
-#define TEST_APP_INTERFACE           TRUE
+#define TEST_APP_INTERFACE           FALSE
 #endif
 
 /******************************************************************************
@@ -1647,7 +1652,11 @@ The maximum number of payload octets that the local device can receive in a sing
 ******************************************************************************/
 
 #ifndef HCILP_INCLUDED
+#ifdef ANDROID
 #define HCILP_INCLUDED                  TRUE
+#else
+#define HCILP_INCLUDED                  FALSE
+#endif
 #endif
 
 /******************************************************************************
@@ -1707,4 +1716,8 @@ The maximum number of payload octets that the local device can receive in a sing
 #define WEAR_LE_IO_CAP_OVERRIDE FALSE
 #endif
 
+/* Enable/Disable UNIFIED SLEEP WAKEUP Feature*/
+#ifndef UNIFIED_SLEEP_WAKEUP
+#define UNIFIED_SLEEP_WAKEUP TRUE
+#endif
 #endif /* BT_TARGET_H */
diff --git a/include/bt_testapp.h b/include/bt_testapp.h
index 421b3fd..c0b817a 100644
--- a/include/bt_testapp.h
+++ b/include/bt_testapp.h
@@ -43,8 +43,10 @@
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <netdb.h>
+#ifdef ANDROID
 #include <private/android_filesystem_config.h>
 #include <android/log.h>
+#endif
 #include <hardware/bluetooth.h>
 #include "l2c_api.h"
 #include "sdp_api.h"
diff --git a/include/stack_config.h b/include/stack_config.h
index 837fdbe..1d6ff18 100644
--- a/include/stack_config.h
+++ b/include/stack_config.h
@@ -42,6 +42,8 @@ typedef struct {
   int (*get_pts_smp_failure_case)(void);
   bool (*get_pts_le_nonconn_adv_enabled)(void);
   config_t *(*get_all)(void);
+  const char* (*get_unified_sleep_wake_configuration)(void);
+  bool (*get_hid_logging_configuration)(void);
 } stack_config_t;
 
 const stack_config_t *stack_config_get_interface();
diff --git a/main/Makefile b/main/Makefile
new file mode 100644
index 0000000..38b597b
--- /dev/null
+++ b/main/Makefile
@@ -0,0 +1,1126 @@
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# main/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+# sources and intermediate files are separated
+
+
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/fluoride
+pkgincludedir = $(includedir)/fluoride
+pkglibdir = $(libdir)/fluoride
+pkglibexecdir = $(libexecdir)/fluoride
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = x86_64-unknown-linux-gnu
+host_triplet = x86_64-unknown-linux-gnu
+#am__append_1 = -DBT_SOC_TYPE_ROME
+#am__append_2 = -DBT_SOC_TYPE_ROME
+#am__append_3 = -DHCI_USE_MCT
+#am__append_4 = -DHCI_USE_MCT
+#am__append_5 = -DBT_SOC_TYPE_CHEROKEE
+#am__append_6 = -DBT_SOC_TYPE_CHEROKEE
+
+# BTC
+#am__append_7 = -DBTC_INCLUDED=TRUE
+#am__append_8 = -DBTC_INCLUDED=TRUE -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/include
+#am__append_9 = \
+#        ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c
+
+
+# SSR_CLEANUP
+am__append_10 = -DSSR_CLEANUP=TRUE
+subdir = main
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/depcomp
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(libdir)"
+LTLIBRARIES = $(lib_LTLIBRARIES)
+libbluetoothdefault_la_LIBADD =
+am__libbluetoothdefault_la_SOURCES_DIST = bte_main.c bte_init.c \
+	bte_logmsg.c bte_conf.c stack_config.c \
+	../embdrv/sbc/decoder/srce/alloc.c \
+	../embdrv/sbc/decoder/srce/bitalloc.c \
+	../embdrv/sbc/decoder/srce/bitalloc-sbc.c \
+	../embdrv/sbc/decoder/srce/bitstream-decode.c \
+	../embdrv/sbc/decoder/srce/decoder-oina.c \
+	../embdrv/sbc/decoder/srce/decoder-private.c \
+	../embdrv/sbc/decoder/srce/decoder-sbc.c \
+	../embdrv/sbc/decoder/srce/dequant.c \
+	../embdrv/sbc/decoder/srce/framing.c \
+	../embdrv/sbc/decoder/srce/framing-sbc.c \
+	../embdrv/sbc/decoder/srce/oi_codec_version.c \
+	../embdrv/sbc/decoder/srce/synthesis-sbc.c \
+	../embdrv/sbc/decoder/srce/synthesis-dct8.c \
+	../embdrv/sbc/decoder/srce/synthesis-8-generated.c \
+	../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c \
+	../embdrv/sbc/encoder/srce/sbc_analysis.c \
+	../embdrv/sbc/encoder/srce/sbc_dct.c \
+	../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c \
+	../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c \
+	../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c \
+	../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c \
+	../embdrv/sbc/encoder/srce/sbc_encoder.c \
+	../embdrv/sbc/encoder/srce/sbc_packing.c ../udrv/ulinux/uipc.c
+am__dirstamp = $(am__leading_dot)dirstamp
+#am__objects_1 = ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/libbluetoothdefault_la-btc_common.lo
+am__objects_2 = libbluetoothdefault_la-bte_main.lo \
+	libbluetoothdefault_la-bte_init.lo \
+	libbluetoothdefault_la-bte_logmsg.lo \
+	libbluetoothdefault_la-bte_conf.lo \
+	libbluetoothdefault_la-stack_config.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-alloc.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc-sbc.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitstream-decode.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-oina.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-private.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-sbc.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-dequant.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing-sbc.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-oi_codec_version.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-sbc.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-dct8.lo \
+	../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-8-generated.lo \
+	$(am__objects_1) \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_analysis.lo \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct.lo \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct_coeffs.lo \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.lo \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.lo \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_coeffs.lo \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_encoder.lo \
+	../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_packing.lo \
+	../udrv/ulinux/libbluetoothdefault_la-uipc.lo
+am_libbluetoothdefault_la_OBJECTS = $(am__objects_2)
+libbluetoothdefault_la_OBJECTS = $(am_libbluetoothdefault_la_OBJECTS)
+AM_V_lt = $(am__v_lt_$(V))
+am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+libbluetoothdefault_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libbluetoothdefault_la_CFLAGS) $(CFLAGS) \
+	$(libbluetoothdefault_la_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_$(V))
+am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I. -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_$(V))
+am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_$(V))
+am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libbluetoothdefault_la_SOURCES)
+DIST_SOURCES = $(am__libbluetoothdefault_la_SOURCES_DIST)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /local/mnt/workspace/common/system/bt/missing aclocal-1.14
+AMTAR = $${TAR-tar}
+AM_DEFAULT_VERBOSITY = 1
+AR = ar
+AUTOCONF = ${SHELL} /local/mnt/workspace/common/system/bt/missing autoconf
+AUTOHEADER = ${SHELL} /local/mnt/workspace/common/system/bt/missing autoheader
+AUTOMAKE = ${SHELL} /local/mnt/workspace/common/system/bt/missing automake-1.14
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DLLTOOL = false
+DSYMUTIL = 
+DUMPBIN = 
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /bin/grep -E
+EXEEXT = 
+FGREP = /bin/grep -F
+GREP = /bin/grep
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LD = /usr/bin/ld -m elf_x86_64
+LDFLAGS = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LIPO = 
+LN_S = ln -s
+LTLIBOBJS = 
+MAINT = #
+MAKEINFO = ${SHELL} /local/mnt/workspace/common/system/bt/missing makeinfo
+MANIFEST_TOOL = :
+MKDIR_P = /bin/mkdir -p
+NM = /usr/bin/nm -B
+NMEDIT = 
+OBJDUMP = objdump
+OBJEXT = o
+OTOOL = 
+OTOOL64 = 
+PACKAGE = fluoride
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = fluoride
+PACKAGE_STRING = fluoride 1.0.0
+PACKAGE_TARNAME = fluoride
+PACKAGE_URL = 
+PACKAGE_VERSION = 1.0.0
+PATH_SEPARATOR = :
+PKG_CONFIG = /usr/bin/pkg-config
+PKG_CONFIG_LIBDIR = 
+PKG_CONFIG_PATH = 
+RANLIB = ranlib
+SED = /bin/sed
+SET_MAKE = 
+SHELL = /bin/bash
+STRIP = strip
+SYS_LIB = 
+VERSION = 1.0.0
+Z_LIB = -lz
+abs_builddir = /local/mnt/workspace/common/system/bt/main
+abs_srcdir = /local/mnt/workspace/common/system/bt/main
+abs_top_builddir = /local/mnt/workspace/common/system/bt
+abs_top_srcdir = /local/mnt/workspace/common/system/bt
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_DUMPBIN = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = $${TAR-tar} chof - "$$tardir"
+am__untar = $${TAR-tar} xf -
+bindir = ${exec_prefix}/bin
+build = x86_64-unknown-linux-gnu
+build_alias = 
+build_cpu = x86_64
+build_os = linux-gnu
+build_vendor = unknown
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = x86_64-unknown-linux-gnu
+host_alias = 
+host_cpu = x86_64
+host_os = linux-gnu
+host_vendor = unknown
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /local/mnt/workspace/common/system/bt/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+mandir = ${datarootdir}/man
+mkdir_p = $(MKDIR_P)
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+AM_CFLAGS = -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -std=c99 \
+	-DHAS_NO_BDROID_BUILDCFG $(am__append_1) $(am__append_3) \
+	$(am__append_5) $(am__append_7) $(am__append_10)
+AM_CPPFLAGS = -I../ -I../bta/include -I../bta/sys -I../bta/dm \
+	-I../btcore/include -I../include -I../stack/include \
+	-I../stack/l2cap -I../stack/a2dp -I../stack/btm \
+	-I../stack/avdt -I../hcis -I../hcis/include -I../hcis/patchram \
+	-I../udrv/include -I../btif/include -I../btif/co \
+	-I../hci/include -I../vnd/include -I../brcm/include \
+	-I../embdrv/sbc/encoder/include \
+	-I../embdrv/sbc/decoder/include -I../audio_a2dp_hw \
+	-I../utils/include \
+	-I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/bta/include \
+	-I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/bta/ar \
+	-I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btif/include \
+	-I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/udrv/include \
+	-I../../../vendor/qcom/opensource/bluetooth/vhal/include \
+	-I../../../hardware/libhardware/include $(am__append_2) \
+	$(am__append_4) $(am__append_6) $(am__append_8)
+# platform specific
+
+# sbc encoder
+c_sources = bte_main.c bte_init.c bte_logmsg.c bte_conf.c \
+	stack_config.c ../embdrv/sbc/decoder/srce/alloc.c \
+	../embdrv/sbc/decoder/srce/bitalloc.c \
+	../embdrv/sbc/decoder/srce/bitalloc-sbc.c \
+	../embdrv/sbc/decoder/srce/bitstream-decode.c \
+	../embdrv/sbc/decoder/srce/decoder-oina.c \
+	../embdrv/sbc/decoder/srce/decoder-private.c \
+	../embdrv/sbc/decoder/srce/decoder-sbc.c \
+	../embdrv/sbc/decoder/srce/dequant.c \
+	../embdrv/sbc/decoder/srce/framing.c \
+	../embdrv/sbc/decoder/srce/framing-sbc.c \
+	../embdrv/sbc/decoder/srce/oi_codec_version.c \
+	../embdrv/sbc/decoder/srce/synthesis-sbc.c \
+	../embdrv/sbc/decoder/srce/synthesis-dct8.c \
+	../embdrv/sbc/decoder/srce/synthesis-8-generated.c \
+	$(am__append_9) ../embdrv/sbc/encoder/srce/sbc_analysis.c \
+	../embdrv/sbc/encoder/srce/sbc_dct.c \
+	../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c \
+	../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c \
+	../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c \
+	../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c \
+	../embdrv/sbc/encoder/srce/sbc_encoder.c \
+	../embdrv/sbc/encoder/srce/sbc_packing.c ../udrv/ulinux/uipc.c
+
+#if ($(BOARD_USES_WIPOWER), true)
+#c_sources += \
+#   ../wipowerif/src/wipower.c
+#endif
+common_LDFLAGS = -ldl -lz -lrt -lresolv -Wl,--whole-archive,../hci/.libs/libbt-hci.a,--no-whole-archive \
+                 -Wl,--whole-archive,../bta/.libs/libbtbta.a,--no-whole-archive -Wl,--whole-archive,../btif/.libs/libbtif.a,--no-whole-archive \
+                 -Wl,--whole-archive,../stack/.libs/libbtstack.a,--no-whole-archive \
+                 -Wl,--whole-archive,../utils/.libs/libbtutils.a,--no-whole-archive -Wl,--whole-archive,../btcore/.libs/libbtcore.a,--no-whole-archive \
+                 -Wl,--whole-archive,../osi/.libs/libbtosi.a,--no-whole-archive -Wl,--whole-archive,../device/.libs/libbtdevice.a,--no-whole-archive \
+				 #-laudioutils
+
+common_CFLAGS = $(AM_CFLAGS) -fPIC -DUSE_AUDIO_TRACK -D_GNU_SOURCE $(Z_LIB)
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES = libbluetoothdefault.la
+libbluetoothdefault_la_CC = gcc
+libbluetoothdefault_la_SOURCES = $(c_sources)
+libbluetoothdefault_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbluetoothdefault_la_CFLAGS = $(common_CFLAGS)
+libbluetoothdefault_la_LDFLAGS = $(common_LDFLAGS)
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign main/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign main/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: # $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libdir)"; \
+	}
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$f"; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+../embdrv/sbc/decoder/srce/$(am__dirstamp):
+	@$(MKDIR_P) ../embdrv/sbc/decoder/srce
+	@: > ../embdrv/sbc/decoder/srce/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) ../embdrv/sbc/decoder/srce/$(DEPDIR)
+	@: > ../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-alloc.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc-sbc.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitstream-decode.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-oina.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-private.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-sbc.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-dequant.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing-sbc.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-oi_codec_version.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-sbc.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-dct8.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-8-generated.lo:  \
+	../embdrv/sbc/decoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(am__dirstamp):
+	@$(MKDIR_P) ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src
+	@: > ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(am__dirstamp)
+../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)
+	@: > ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/$(am__dirstamp)
+../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/libbluetoothdefault_la-btc_common.lo: ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(am__dirstamp) \
+	../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/$(am__dirstamp):
+	@$(MKDIR_P) ../embdrv/sbc/encoder/srce
+	@: > ../embdrv/sbc/encoder/srce/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) ../embdrv/sbc/encoder/srce/$(DEPDIR)
+	@: > ../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_analysis.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct_coeffs.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_coeffs.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_encoder.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_packing.lo:  \
+	../embdrv/sbc/encoder/srce/$(am__dirstamp) \
+	../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+../udrv/ulinux/$(am__dirstamp):
+	@$(MKDIR_P) ../udrv/ulinux
+	@: > ../udrv/ulinux/$(am__dirstamp)
+../udrv/ulinux/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) ../udrv/ulinux/$(DEPDIR)
+	@: > ../udrv/ulinux/$(DEPDIR)/$(am__dirstamp)
+../udrv/ulinux/libbluetoothdefault_la-uipc.lo:  \
+	../udrv/ulinux/$(am__dirstamp) \
+	../udrv/ulinux/$(DEPDIR)/$(am__dirstamp)
+
+libbluetoothdefault.la: $(libbluetoothdefault_la_OBJECTS) $(libbluetoothdefault_la_DEPENDENCIES) $(EXTRA_libbluetoothdefault_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libbluetoothdefault_la_LINK) -rpath $(libdir) $(libbluetoothdefault_la_OBJECTS) $(libbluetoothdefault_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+	-rm -f ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/*.$(OBJEXT)
+	-rm -f ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/*.lo
+	-rm -f ../embdrv/sbc/decoder/srce/*.$(OBJEXT)
+	-rm -f ../embdrv/sbc/decoder/srce/*.lo
+	-rm -f ../embdrv/sbc/encoder/srce/*.$(OBJEXT)
+	-rm -f ../embdrv/sbc/encoder/srce/*.lo
+	-rm -f ../udrv/ulinux/*.$(OBJEXT)
+	-rm -f ../udrv/ulinux/*.lo
+
+distclean-compile:
+	-rm -f *.tab.c
+
+include ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/libbluetoothdefault_la-btc_common.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-alloc.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc-sbc.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitstream-decode.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-oina.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-private.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-sbc.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-dequant.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing-sbc.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-oi_codec_version.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-8-generated.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-dct8.Plo
+include ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-sbc.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_analysis.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct_coeffs.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_coeffs.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_encoder.Plo
+include ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_packing.Plo
+include ../udrv/ulinux/$(DEPDIR)/libbluetoothdefault_la-uipc.Plo
+include ./$(DEPDIR)/libbluetoothdefault_la-bte_conf.Plo
+include ./$(DEPDIR)/libbluetoothdefault_la-bte_init.Plo
+include ./$(DEPDIR)/libbluetoothdefault_la-bte_logmsg.Plo
+include ./$(DEPDIR)/libbluetoothdefault_la-bte_main.Plo
+include ./$(DEPDIR)/libbluetoothdefault_la-stack_config.Plo
+
+.c.o:
+	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+	$(am__mv) $$depbase.Tpo $$depbase.Po
+#	$(AM_V_CC)source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(COMPILE) -c -o $@ $<
+
+.c.obj:
+	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
+	$(am__mv) $$depbase.Tpo $$depbase.Po
+#	$(AM_V_CC)source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.c.lo:
+	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+	$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+	$(am__mv) $$depbase.Tpo $$depbase.Plo
+#	$(AM_V_CC)source='$<' object='$@' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LTCOMPILE) -c -o $@ $<
+
+libbluetoothdefault_la-bte_main.lo: bte_main.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT libbluetoothdefault_la-bte_main.lo -MD -MP -MF $(DEPDIR)/libbluetoothdefault_la-bte_main.Tpo -c -o libbluetoothdefault_la-bte_main.lo `test -f 'bte_main.c' || echo '$(srcdir)/'`bte_main.c
+	$(AM_V_at)$(am__mv) $(DEPDIR)/libbluetoothdefault_la-bte_main.Tpo $(DEPDIR)/libbluetoothdefault_la-bte_main.Plo
+#	$(AM_V_CC)source='bte_main.c' object='libbluetoothdefault_la-bte_main.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o libbluetoothdefault_la-bte_main.lo `test -f 'bte_main.c' || echo '$(srcdir)/'`bte_main.c
+
+libbluetoothdefault_la-bte_init.lo: bte_init.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT libbluetoothdefault_la-bte_init.lo -MD -MP -MF $(DEPDIR)/libbluetoothdefault_la-bte_init.Tpo -c -o libbluetoothdefault_la-bte_init.lo `test -f 'bte_init.c' || echo '$(srcdir)/'`bte_init.c
+	$(AM_V_at)$(am__mv) $(DEPDIR)/libbluetoothdefault_la-bte_init.Tpo $(DEPDIR)/libbluetoothdefault_la-bte_init.Plo
+#	$(AM_V_CC)source='bte_init.c' object='libbluetoothdefault_la-bte_init.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o libbluetoothdefault_la-bte_init.lo `test -f 'bte_init.c' || echo '$(srcdir)/'`bte_init.c
+
+libbluetoothdefault_la-bte_logmsg.lo: bte_logmsg.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT libbluetoothdefault_la-bte_logmsg.lo -MD -MP -MF $(DEPDIR)/libbluetoothdefault_la-bte_logmsg.Tpo -c -o libbluetoothdefault_la-bte_logmsg.lo `test -f 'bte_logmsg.c' || echo '$(srcdir)/'`bte_logmsg.c
+	$(AM_V_at)$(am__mv) $(DEPDIR)/libbluetoothdefault_la-bte_logmsg.Tpo $(DEPDIR)/libbluetoothdefault_la-bte_logmsg.Plo
+#	$(AM_V_CC)source='bte_logmsg.c' object='libbluetoothdefault_la-bte_logmsg.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o libbluetoothdefault_la-bte_logmsg.lo `test -f 'bte_logmsg.c' || echo '$(srcdir)/'`bte_logmsg.c
+
+libbluetoothdefault_la-bte_conf.lo: bte_conf.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT libbluetoothdefault_la-bte_conf.lo -MD -MP -MF $(DEPDIR)/libbluetoothdefault_la-bte_conf.Tpo -c -o libbluetoothdefault_la-bte_conf.lo `test -f 'bte_conf.c' || echo '$(srcdir)/'`bte_conf.c
+	$(AM_V_at)$(am__mv) $(DEPDIR)/libbluetoothdefault_la-bte_conf.Tpo $(DEPDIR)/libbluetoothdefault_la-bte_conf.Plo
+#	$(AM_V_CC)source='bte_conf.c' object='libbluetoothdefault_la-bte_conf.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o libbluetoothdefault_la-bte_conf.lo `test -f 'bte_conf.c' || echo '$(srcdir)/'`bte_conf.c
+
+libbluetoothdefault_la-stack_config.lo: stack_config.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT libbluetoothdefault_la-stack_config.lo -MD -MP -MF $(DEPDIR)/libbluetoothdefault_la-stack_config.Tpo -c -o libbluetoothdefault_la-stack_config.lo `test -f 'stack_config.c' || echo '$(srcdir)/'`stack_config.c
+	$(AM_V_at)$(am__mv) $(DEPDIR)/libbluetoothdefault_la-stack_config.Tpo $(DEPDIR)/libbluetoothdefault_la-stack_config.Plo
+#	$(AM_V_CC)source='stack_config.c' object='libbluetoothdefault_la-stack_config.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o libbluetoothdefault_la-stack_config.lo `test -f 'stack_config.c' || echo '$(srcdir)/'`stack_config.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-alloc.lo: ../embdrv/sbc/decoder/srce/alloc.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-alloc.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-alloc.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-alloc.lo `test -f '../embdrv/sbc/decoder/srce/alloc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/alloc.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-alloc.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-alloc.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/alloc.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-alloc.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-alloc.lo `test -f '../embdrv/sbc/decoder/srce/alloc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/alloc.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc.lo: ../embdrv/sbc/decoder/srce/bitalloc.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc.lo `test -f '../embdrv/sbc/decoder/srce/bitalloc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/bitalloc.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/bitalloc.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc.lo `test -f '../embdrv/sbc/decoder/srce/bitalloc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/bitalloc.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc-sbc.lo: ../embdrv/sbc/decoder/srce/bitalloc-sbc.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc-sbc.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc-sbc.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc-sbc.lo `test -f '../embdrv/sbc/decoder/srce/bitalloc-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/bitalloc-sbc.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc-sbc.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitalloc-sbc.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/bitalloc-sbc.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc-sbc.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitalloc-sbc.lo `test -f '../embdrv/sbc/decoder/srce/bitalloc-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/bitalloc-sbc.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitstream-decode.lo: ../embdrv/sbc/decoder/srce/bitstream-decode.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitstream-decode.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitstream-decode.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitstream-decode.lo `test -f '../embdrv/sbc/decoder/srce/bitstream-decode.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/bitstream-decode.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitstream-decode.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-bitstream-decode.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/bitstream-decode.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitstream-decode.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-bitstream-decode.lo `test -f '../embdrv/sbc/decoder/srce/bitstream-decode.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/bitstream-decode.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-oina.lo: ../embdrv/sbc/decoder/srce/decoder-oina.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-oina.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-oina.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-oina.lo `test -f '../embdrv/sbc/decoder/srce/decoder-oina.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/decoder-oina.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-oina.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-oina.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/decoder-oina.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-oina.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-oina.lo `test -f '../embdrv/sbc/decoder/srce/decoder-oina.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/decoder-oina.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-private.lo: ../embdrv/sbc/decoder/srce/decoder-private.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-private.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-private.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-private.lo `test -f '../embdrv/sbc/decoder/srce/decoder-private.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/decoder-private.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-private.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-private.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/decoder-private.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-private.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-private.lo `test -f '../embdrv/sbc/decoder/srce/decoder-private.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/decoder-private.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-sbc.lo: ../embdrv/sbc/decoder/srce/decoder-sbc.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-sbc.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-sbc.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-sbc.lo `test -f '../embdrv/sbc/decoder/srce/decoder-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/decoder-sbc.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-sbc.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-decoder-sbc.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/decoder-sbc.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-sbc.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-decoder-sbc.lo `test -f '../embdrv/sbc/decoder/srce/decoder-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/decoder-sbc.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-dequant.lo: ../embdrv/sbc/decoder/srce/dequant.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-dequant.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-dequant.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-dequant.lo `test -f '../embdrv/sbc/decoder/srce/dequant.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/dequant.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-dequant.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-dequant.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/dequant.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-dequant.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-dequant.lo `test -f '../embdrv/sbc/decoder/srce/dequant.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/dequant.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing.lo: ../embdrv/sbc/decoder/srce/framing.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing.lo `test -f '../embdrv/sbc/decoder/srce/framing.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/framing.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/framing.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing.lo `test -f '../embdrv/sbc/decoder/srce/framing.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/framing.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing-sbc.lo: ../embdrv/sbc/decoder/srce/framing-sbc.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing-sbc.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing-sbc.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing-sbc.lo `test -f '../embdrv/sbc/decoder/srce/framing-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/framing-sbc.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing-sbc.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-framing-sbc.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/framing-sbc.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing-sbc.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-framing-sbc.lo `test -f '../embdrv/sbc/decoder/srce/framing-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/framing-sbc.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-oi_codec_version.lo: ../embdrv/sbc/decoder/srce/oi_codec_version.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-oi_codec_version.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-oi_codec_version.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-oi_codec_version.lo `test -f '../embdrv/sbc/decoder/srce/oi_codec_version.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/oi_codec_version.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-oi_codec_version.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-oi_codec_version.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/oi_codec_version.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-oi_codec_version.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-oi_codec_version.lo `test -f '../embdrv/sbc/decoder/srce/oi_codec_version.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/oi_codec_version.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-sbc.lo: ../embdrv/sbc/decoder/srce/synthesis-sbc.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-sbc.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-sbc.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-sbc.lo `test -f '../embdrv/sbc/decoder/srce/synthesis-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/synthesis-sbc.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-sbc.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-sbc.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/synthesis-sbc.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-sbc.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-sbc.lo `test -f '../embdrv/sbc/decoder/srce/synthesis-sbc.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/synthesis-sbc.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-dct8.lo: ../embdrv/sbc/decoder/srce/synthesis-dct8.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-dct8.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-dct8.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-dct8.lo `test -f '../embdrv/sbc/decoder/srce/synthesis-dct8.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/synthesis-dct8.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-dct8.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-dct8.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/synthesis-dct8.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-dct8.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-dct8.lo `test -f '../embdrv/sbc/decoder/srce/synthesis-dct8.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/synthesis-dct8.c
+
+../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-8-generated.lo: ../embdrv/sbc/decoder/srce/synthesis-8-generated.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-8-generated.lo -MD -MP -MF ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-8-generated.Tpo -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-8-generated.lo `test -f '../embdrv/sbc/decoder/srce/synthesis-8-generated.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/synthesis-8-generated.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-8-generated.Tpo ../embdrv/sbc/decoder/srce/$(DEPDIR)/libbluetoothdefault_la-synthesis-8-generated.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/decoder/srce/synthesis-8-generated.c' object='../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-8-generated.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/decoder/srce/libbluetoothdefault_la-synthesis-8-generated.lo `test -f '../embdrv/sbc/decoder/srce/synthesis-8-generated.c' || echo '$(srcdir)/'`../embdrv/sbc/decoder/srce/synthesis-8-generated.c
+
+../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/libbluetoothdefault_la-btc_common.lo: ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/libbluetoothdefault_la-btc_common.lo -MD -MP -MF ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/libbluetoothdefault_la-btc_common.Tpo -c -o ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/libbluetoothdefault_la-btc_common.lo `test -f '../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c' || echo '$(srcdir)/'`../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c
+	$(AM_V_at)$(am__mv) ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/libbluetoothdefault_la-btc_common.Tpo ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/libbluetoothdefault_la-btc_common.Plo
+#	$(AM_V_CC)source='../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c' object='../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/libbluetoothdefault_la-btc_common.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/libbluetoothdefault_la-btc_common.lo `test -f '../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c' || echo '$(srcdir)/'`../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_analysis.lo: ../embdrv/sbc/encoder/srce/sbc_analysis.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_analysis.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_analysis.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_analysis.lo `test -f '../embdrv/sbc/encoder/srce/sbc_analysis.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_analysis.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_analysis.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_analysis.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_analysis.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_analysis.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_analysis.lo `test -f '../embdrv/sbc/encoder/srce/sbc_analysis.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_analysis.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct.lo: ../embdrv/sbc/encoder/srce/sbc_dct.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct.lo `test -f '../embdrv/sbc/encoder/srce/sbc_dct.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_dct.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_dct.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct.lo `test -f '../embdrv/sbc/encoder/srce/sbc_dct.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_dct.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct_coeffs.lo: ../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct_coeffs.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct_coeffs.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct_coeffs.lo `test -f '../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct_coeffs.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_dct_coeffs.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct_coeffs.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_dct_coeffs.lo `test -f '../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.lo: ../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.lo `test -f '../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_mono.lo `test -f '../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.lo: ../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.lo `test -f '../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_bit_alloc_ste.lo `test -f '../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_coeffs.lo: ../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_coeffs.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_coeffs.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_coeffs.lo `test -f '../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_coeffs.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_enc_coeffs.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_coeffs.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_enc_coeffs.lo `test -f '../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_encoder.lo: ../embdrv/sbc/encoder/srce/sbc_encoder.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_encoder.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_encoder.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_encoder.lo `test -f '../embdrv/sbc/encoder/srce/sbc_encoder.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_encoder.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_encoder.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_encoder.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_encoder.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_encoder.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_encoder.lo `test -f '../embdrv/sbc/encoder/srce/sbc_encoder.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_encoder.c
+
+../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_packing.lo: ../embdrv/sbc/encoder/srce/sbc_packing.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_packing.lo -MD -MP -MF ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_packing.Tpo -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_packing.lo `test -f '../embdrv/sbc/encoder/srce/sbc_packing.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_packing.c
+	$(AM_V_at)$(am__mv) ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_packing.Tpo ../embdrv/sbc/encoder/srce/$(DEPDIR)/libbluetoothdefault_la-sbc_packing.Plo
+#	$(AM_V_CC)source='../embdrv/sbc/encoder/srce/sbc_packing.c' object='../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_packing.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../embdrv/sbc/encoder/srce/libbluetoothdefault_la-sbc_packing.lo `test -f '../embdrv/sbc/encoder/srce/sbc_packing.c' || echo '$(srcdir)/'`../embdrv/sbc/encoder/srce/sbc_packing.c
+
+../udrv/ulinux/libbluetoothdefault_la-uipc.lo: ../udrv/ulinux/uipc.c
+	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -MT ../udrv/ulinux/libbluetoothdefault_la-uipc.lo -MD -MP -MF ../udrv/ulinux/$(DEPDIR)/libbluetoothdefault_la-uipc.Tpo -c -o ../udrv/ulinux/libbluetoothdefault_la-uipc.lo `test -f '../udrv/ulinux/uipc.c' || echo '$(srcdir)/'`../udrv/ulinux/uipc.c
+	$(AM_V_at)$(am__mv) ../udrv/ulinux/$(DEPDIR)/libbluetoothdefault_la-uipc.Tpo ../udrv/ulinux/$(DEPDIR)/libbluetoothdefault_la-uipc.Plo
+#	$(AM_V_CC)source='../udrv/ulinux/uipc.c' object='../udrv/ulinux/libbluetoothdefault_la-uipc.lo' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libbluetoothdefault_la_CPPFLAGS) $(CPPFLAGS) $(libbluetoothdefault_la_CFLAGS) $(CFLAGS) -c -o ../udrv/ulinux/libbluetoothdefault_la-uipc.lo `test -f '../udrv/ulinux/uipc.c' || echo '$(srcdir)/'`../udrv/ulinux/uipc.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+	-rm -rf ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/.libs ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/_libs
+	-rm -rf ../embdrv/sbc/decoder/srce/.libs ../embdrv/sbc/decoder/srce/_libs
+	-rm -rf ../embdrv/sbc/encoder/srce/.libs ../embdrv/sbc/encoder/srce/_libs
+	-rm -rf ../udrv/ulinux/.libs ../udrv/ulinux/_libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(libdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+	-rm -f ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR)/$(am__dirstamp)
+	-rm -f ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(am__dirstamp)
+	-rm -f ../embdrv/sbc/decoder/srce/$(DEPDIR)/$(am__dirstamp)
+	-rm -f ../embdrv/sbc/decoder/srce/$(am__dirstamp)
+	-rm -f ../embdrv/sbc/encoder/srce/$(DEPDIR)/$(am__dirstamp)
+	-rm -f ../embdrv/sbc/encoder/srce/$(am__dirstamp)
+	-rm -f ../udrv/ulinux/$(DEPDIR)/$(am__dirstamp)
+	-rm -f ../udrv/ulinux/$(am__dirstamp)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR) ../embdrv/sbc/decoder/srce/$(DEPDIR) ../embdrv/sbc/encoder/srce/$(DEPDIR) ../udrv/ulinux/$(DEPDIR) ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am: install-libLTLIBRARIES
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/$(DEPDIR) ../embdrv/sbc/decoder/srce/$(DEPDIR) ../embdrv/sbc/encoder/srce/$(DEPDIR) ../udrv/ulinux/$(DEPDIR) ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libLTLIBRARIES clean-libtool cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libLTLIBRARIES install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-am uninstall uninstall-am uninstall-libLTLIBRARIES
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/main/Makefile.am b/main/Makefile.am
new file mode 100644
index 0000000..f67c83e
--- /dev/null
+++ b/main/Makefile.am
@@ -0,0 +1,126 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS= \
+        -I../ \
+        -I../bta/include \
+        -I../bta/sys \
+        -I../bta/dm \
+        -I../btcore/include \
+        -I../include \
+        -I../stack/include \
+        -I../stack/l2cap \
+        -I../stack/a2dp \
+        -I../stack/btm \
+        -I../stack/avdt \
+        -I../hcis \
+        -I../hcis/include \
+        -I../hcis/patchram \
+        -I../udrv/include \
+        -I../btif/include \
+        -I../btif/co \
+        -I../hci/include\
+        -I../vnd/include \
+        -I../brcm/include \
+        -I../embdrv/sbc/encoder/include \
+        -I../embdrv/sbc/decoder/include \
+        -I../audio_a2dp_hw \
+        -I../utils/include \
+        -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/bta/include \
+        -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/bta/ar \
+        -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btif/include \
+        -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/udrv/include \
+	-I../../../vendor/qcom/opensource/bluetooth/vhal/include \
+        -I../../../hardware/libhardware/include 
+
+if MDM_ROME
+AM_CFLAGS += -DBT_SOC_TYPE_ROME
+AM_CPPFLAGS += -DBT_SOC_TYPE_ROME
+else
+if MDM_PRONTO
+AM_CFLAGS += -DHCI_USE_MCT
+AM_CPPFLAGS += -DHCI_USE_MCT
+endif
+endif
+
+if MDM_CHEROKEE
+AM_CFLAGS += -DBT_SOC_TYPE_CHEROKEE
+AM_CPPFLAGS += -DBT_SOC_TYPE_CHEROKEE
+endif
+# platform specific
+c_sources = \
+        bte_main.c \
+        bte_init.c \
+        bte_logmsg.c \
+        bte_conf.c \
+        stack_config.c \
+        ../embdrv/sbc/decoder/srce/alloc.c \
+        ../embdrv/sbc/decoder/srce/bitalloc.c \
+        ../embdrv/sbc/decoder/srce/bitalloc-sbc.c \
+        ../embdrv/sbc/decoder/srce/bitstream-decode.c \
+        ../embdrv/sbc/decoder/srce/decoder-oina.c \
+        ../embdrv/sbc/decoder/srce/decoder-private.c \
+        ../embdrv/sbc/decoder/srce/decoder-sbc.c \
+        ../embdrv/sbc/decoder/srce/dequant.c \
+        ../embdrv/sbc/decoder/srce/framing.c \
+        ../embdrv/sbc/decoder/srce/framing-sbc.c \
+        ../embdrv/sbc/decoder/srce/oi_codec_version.c \
+        ../embdrv/sbc/decoder/srce/synthesis-sbc.c \
+        ../embdrv/sbc/decoder/srce/synthesis-dct8.c \
+        ../embdrv/sbc/decoder/srce/synthesis-8-generated.c
+
+# BTC
+if BTC_SUPPORT
+AM_CFLAGS += -DBTC_INCLUDED=TRUE
+AM_CPPFLAGS += -DBTC_INCLUDED=TRUE -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/include
+c_sources += \
+        ../../../vendor/qcom/opensource/bluetooth/system_bt_ext/btc/src/btc_common.c
+endif
+
+
+# SSR_CLEANUP
+if SSR_CLEANUP_SUPPORT
+AM_CFLAGS += -DSSR_CLEANUP=TRUE
+endif
+
+# sbc encoder
+c_sources += \
+    ../embdrv/sbc/encoder/srce/sbc_analysis.c \
+    ../embdrv/sbc/encoder/srce/sbc_dct.c \
+    ../embdrv/sbc/encoder/srce/sbc_dct_coeffs.c \
+    ../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_mono.c \
+    ../embdrv/sbc/encoder/srce/sbc_enc_bit_alloc_ste.c \
+    ../embdrv/sbc/encoder/srce/sbc_enc_coeffs.c \
+    ../embdrv/sbc/encoder/srce/sbc_encoder.c \
+    ../embdrv/sbc/encoder/srce/sbc_packing.c
+
+c_sources += \
+    ../udrv/ulinux/uipc.c
+
+#if ($(BOARD_USES_WIPOWER), true)
+#c_sources += \
+#   ../wipowerif/src/wipower.c
+#endif
+
+common_LDFLAGS = -ldl -lz -lrt -lresolv -Wl,--whole-archive,../hci/.libs/libbt-hci.a,--no-whole-archive \
+                 -Wl,--whole-archive,../bta/.libs/libbtbta.a,--no-whole-archive -Wl,--whole-archive,../btif/.libs/libbtif.a,--no-whole-archive \
+                 -Wl,--whole-archive,../stack/.libs/libbtstack.a,--no-whole-archive \
+                 -Wl,--whole-archive,../utils/.libs/libbtutils.a,--no-whole-archive -Wl,--whole-archive,../btcore/.libs/libbtcore.a,--no-whole-archive \
+                 -Wl,--whole-archive,../osi/.libs/libbtosi.a,--no-whole-archive -Wl,--whole-archive,../device/.libs/libbtdevice.a,--no-whole-archive \
+				 #-laudioutils
+
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -DUSE_AUDIO_TRACK -D_GNU_SOURCE $(Z_LIB)
+
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES = libbluetoothdefault.la
+libbluetoothdefault_la_CC = @CC@
+libbluetoothdefault_la_SOURCES = $(c_sources)
+libbluetoothdefault_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbluetoothdefault_la_CFLAGS = $(common_CFLAGS)
+libbluetoothdefault_la_LDFLAGS = $(common_LDFLAGS)
diff --git a/main/bte_logmsg.c b/main/bte_logmsg.c
index 2d6d208..f59434c 100644
--- a/main/bte_logmsg.c
+++ b/main/bte_logmsg.c
@@ -59,6 +59,36 @@
 #include "smp_api.h"
 #endif
 
+#ifndef ANDROID /*If Linux Image*/
+#ifdef USE_ANDROID_LOGGING
+#include <utils/Log.h>
+#define LOGI0 ALOGI
+#define LOGD0 ALOGD
+#define LOGW0 ALOGW
+#define LOGE0 ALOGE
+#endif
+
+#ifndef LOGE
+#define LOGE ALOGE
+#endif
+
+#ifndef LOGW
+#define LOGW ALOGW
+#endif
+
+#ifndef LOGD
+#define LOGD ALOGD
+#endif
+
+#ifndef LOGV
+#define LOGV ALOGV
+#endif
+
+#ifndef LOGI
+#define LOGI ALOGI
+#endif
+#endif
+
 #ifndef DEFAULT_CONF_TRACE_LEVEL
 #define DEFAULT_CONF_TRACE_LEVEL BT_TRACE_LEVEL_WARNING
 #endif
@@ -172,6 +202,50 @@ static tBTTRC_FUNC_MAP bttrc_set_level_map[] = {
   {0, 0, NULL, NULL, DEFAULT_CONF_TRACE_LEVEL}
 };
 
+#ifndef ANDROID
+void LogMsg(uint32_t trace_set_mask, const char *fmt_str, ...) {
+  char buffer[BTE_LOG_BUF_SIZE];
+  int offset = MSG_BUFFER_OFFSET;
+  int trace_layer = TRACE_GET_LAYER(trace_set_mask);
+  if (trace_layer >= TRACE_LAYER_MAX_NUM)
+    trace_layer = 0;
+
+#ifndef USE_ANDROID_LOGGING
+  offset += strlen("bt_stack : ") +
+            strlen(bt_layer_tags[trace_layer]) + strlen(" : ");
+  snprintf(buffer, offset+1 , "bt_stack : %s : ",
+        bt_layer_tags[trace_layer]);
+#else
+  offset += strlen(bt_layer_tags[trace_layer]) + strlen(" : ");
+  snprintf(buffer, offset+1 , "%s : ",
+        bt_layer_tags[trace_layer]);
+#endif
+
+  va_list ap;
+  va_start(ap, fmt_str);
+  vsnprintf(&buffer[offset], BTE_LOG_MAX_SIZE - offset, fmt_str, ap);
+  va_end(ap);
+
+  switch ( TRACE_GET_TYPE(trace_set_mask) ) {
+    case TRACE_TYPE_ERROR:
+      LOG_ERROR(bt_layer_tags[trace_layer],"Error %s",buffer);
+      break;
+    case TRACE_TYPE_WARNING:
+      LOG_WARN("Warning %s",buffer);
+      break;
+    case TRACE_TYPE_API:
+    case TRACE_TYPE_EVENT:
+      LOG_INFO(bt_layer_tags[trace_layer],"Info %s",buffer);
+      break;
+    case TRACE_TYPE_DEBUG:
+      LOG_DEBUG(bt_layer_tags[trace_layer],"Debug %s",buffer);
+      break;
+    default:
+      LOG_ERROR(bt_layer_tags[trace_layer],"Error %s",buffer);
+      break;
+    }
+}
+#else
 void LogMsg(uint32_t trace_set_mask, const char *fmt_str, ...) {
   static char buffer[BTE_LOG_BUF_SIZE];
   int trace_layer = TRACE_GET_LAYER(trace_set_mask);
@@ -202,6 +276,7 @@ void LogMsg(uint32_t trace_set_mask, const char *fmt_str, ...) {
       break;
   }
 }
+#endif
 
 void vnd_LogMsg(uint32_t trace_set_mask, const char *fmt_str, ...) {
   int trace_layer = TRACE_GET_LAYER(trace_set_mask);
@@ -278,6 +353,11 @@ static future_t *init(void) {
   return NULL;
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t bte_logmsg_module = {
   .name = BTE_LOGMSG_MODULE,
   .init = init,
@@ -317,7 +397,11 @@ void BTA_setStackLog( const char* log_layer, int log_level)
         if( (NULL != p_f_map->p_f) && !strcmp( p_f_map->trc_name, log_layer))
         {
             new_level = p_f_map->p_f(log_level);
+#ifdef ANDROID
             LOG_INFO("BTA_setStackLog: New trace level set for layer %s is %d", log_layer, new_level);
+#else
+			LOG_INFO(LOG_TAG,"BTA_setStackLog: New trace level set for layer %s is %d", log_layer, new_level);
+#endif
             layer_found = 1;
             break;
         }
@@ -326,6 +410,10 @@ void BTA_setStackLog( const char* log_layer, int log_level)
 
     if ( layer_found == 0 )
     {
+#ifdef ANDROID
         LOG_INFO("BTA_setStackLog: Unable to set Layer %s with level %d. Layer not found", log_layer, log_level);
+#else
+		LOG_INFO(LOG_TAG,"BTA_setStackLog: Unable to set Layer %s with level %d. Layer not found", log_layer, log_level);
+#endif
     }
 }
diff --git a/main/bte_main.c b/main/bte_main.c
index 7ab0440..adf2a1a 100644
--- a/main/bte_main.c
+++ b/main/bte_main.c
@@ -154,8 +154,15 @@ void bte_main_enable()
     APPL_TRACE_DEBUG("%s", __FUNCTION__);
 
     module_start_up(get_module(BTSNOOP_MODULE));
+#ifndef ANDROID
+#ifdef BT_SOC_TYPE_ROME
     module_start_up(get_module(HCI_MODULE));
+#endif
+#endif
 
+#ifdef ANDROID
+   module_start_up(get_module(HCI_MODULE));
+#endif
     BTU_StartUp();
 }
 
@@ -172,8 +179,14 @@ void bte_main_enable()
 void bte_main_disable(void)
 {
     APPL_TRACE_DEBUG("%s", __FUNCTION__);
-
-    module_shut_down(get_module(HCI_MODULE));
+#ifndef ANDROID
+#ifdef BT_SOC_TYPE_ROME
+    module_shut_down(get_module(HCI_MODULE)); /*Default Android*/
+#endif
+#endif
+#ifdef ANDROID
+    module_shut_down(get_module(HCI_MODULE)); /*Default Android*/
+#endif
     module_shut_down(get_module(BTSNOOP_MODULE));
 
     BTU_ShutDown();
diff --git a/main/stack_config.c b/main/stack_config.c
index f12a789..95262d7 100644
--- a/main/stack_config.c
+++ b/main/stack_config.c
@@ -37,6 +37,8 @@ const char *PTS_DISABLE_SDP_LE_PAIR = "PTS_DisableSDPOnLEPair";
 const char *PTS_SMP_PAIRING_OPTIONS_KEY = "PTS_SmpOptions";
 const char *PTS_SMP_FAILURE_CASE_KEY = "PTS_SmpFailureCase";
 const char *PTS_LE_NONCONN_ADV_MODE = "PTS_EnableNonConnAdvMode";
+const char *UNIFIED_SLEEP_WAKEUP_CONFIG_KEY = "LMP_WAKEUP_CONFIG";
+const char *HID_AUTOMATION_KEY = "HID_AUTOMATION";
 
 static config_t *config;
 
@@ -68,6 +70,11 @@ static future_t *clean_up() {
   return future_new_immediate(FUTURE_SUCCESS);
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t stack_config_module = {
   .name = STACK_CONFIG_MODULE,
   .init = init,
@@ -82,8 +89,13 @@ EXPORT_SYMBOL const module_t stack_config_module = {
 // Interface functions
 
 static const char *get_btsnoop_log_path(void) {
+#ifdef ANDROID
+  return config_get_string(config, CONFIG_DEFAULT_SECTION, BTSNOOP_LOG_PATH_KEY,
+     "/data/misc/bluetooth/logs/btsnoop_hci.log");
+#else
   return config_get_string(config, CONFIG_DEFAULT_SECTION, BTSNOOP_LOG_PATH_KEY,
-      "/data/misc/bluetooth/logs/btsnoop_hci.log");
+   "/data/misc/bluetooth/btsnoop_hci.log");
+#endif
 }
 
 static bool get_btsnoop_turned_on(void) {
@@ -127,6 +139,14 @@ static bool get_pts_le_nonconn_adv_enabled(void) {
   return config_get_bool(config, CONFIG_DEFAULT_SECTION, PTS_LE_NONCONN_ADV_MODE, false);
 }
 
+static const char *get_unified_sleep_wake_configuration(void) {
+  return config_get_string(config, CONFIG_DEFAULT_SECTION, UNIFIED_SLEEP_WAKEUP_CONFIG_KEY, NULL);
+}
+
+static bool get_hid_logging_configuration(void) {
+  return config_get_bool(config, CONFIG_DEFAULT_SECTION, HID_AUTOMATION_KEY,false);
+}
+
 static config_t *get_all(void) {
   return config;
 }
@@ -143,7 +163,9 @@ const stack_config_t interface = {
   get_pts_smp_options,
   get_pts_smp_failure_case,
   get_pts_le_nonconn_adv_enabled,
-  get_all
+  get_all,
+  get_unified_sleep_wake_configuration,
+  get_hid_logging_configuration
 };
 
 const stack_config_t *stack_config_get_interface() {
diff --git a/osi/Makefile.am b/osi/Makefile.am
new file mode 100644
index 0000000..f99af6b
--- /dev/null
+++ b/osi/Makefile.am
@@ -0,0 +1,58 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG \
+        -D__GLIBC__
+
+AM_CPPFLAGS = \
+        -I../ \
+	-I../include \
+        -I../utils/include \
+        -I../stack/include \
+        -I../../../hardware/libhardware/include
+
+c_sources = \
+        src/alarm.c \
+        src/allocation_tracker.c \
+        src/allocator.c \
+        src/array.c \
+        src/buffer.c \
+        src/config.c \
+        src/compat.c \
+        src/data_dispatcher.c \
+        src/eager_reader.c \
+        src/fixed_queue.c \
+        src/future.c \
+        src/hash_functions.c \
+        src/hash_map.c \
+        src/hash_map_utils.c \
+	src/list.c \
+        src/mutex.c \
+        src/osi.c \
+        src/properties.c \
+        src/reactor.c \
+        src/ringbuffer.c \
+        src/semaphore.c \
+        src/socket.c \
+        src/socket_utils/socket_local_client.c \
+        src/socket_utils/socket_local_server.c \
+        src/thread.c \
+        src/time.c \
+        src/wakelock.c \
+        src/vnd_log.c
+
+common_LDFLAGS = -lpthread 
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbtosi.la
+libbtosi_la_CC = @CC@
+libbtosi_la_SOURCES = $(c_sources)
+libbtosi_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbtosi_la_CFLAGS = $(common_CFLAGS)
+libbtosi_la_LDFLAGS = $(common_LDFLAGS) -static
diff --git a/osi/include/log.h b/osi/include/log.h
index a579ded..046dd42 100644
--- a/osi/include/log.h
+++ b/osi/include/log.h
@@ -42,7 +42,7 @@ extern bool bt_logger_enabled;
 #define LOG_ERROR(...) LOGWRAPPER(__VA_ARGS__)
 
 #else  /* !defined(OS_GENERIC) */
-
+#ifdef ANDROID
 #include <cutils/log.h>
 
 //#define VNDLOG(tag, fmt, ## args) if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args)
@@ -57,4 +57,43 @@ extern bool bt_logger_enabled;
 #define LOG_WARN(tag, fmt, args...)    {if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args);ALOG(LOG_WARN, tag, fmt, ## args);}
 #define LOG_ERROR(tag, fmt, args...)   {if(logger_interface)logger_interface->send_log_data(tag, fmt, ## args);ALOG(LOG_ERROR, tag, fmt, ## args);}
 
+#else
+#include <errno.h>
+#include <limits.h>
+//#include <stdio.h>
+
+#ifdef USE_ANDROID_LOGGING
+#include <utils/Log.h>
+#define LOG_TAG "bt_stack"
+#define LOG_VERBOSE(...) ALOGV(__VA_ARGS__)
+#define LOG_DEBUG(...)   ALOGD(__VA_ARGS__)
+#define LOG_INFO(...)   ALOGI(__VA_ARGS__)
+#define LOG_WARN(...)   ALOGW(__VA_ARGS__)
+#define LOG_ERROR(...)   ALOGE(__VA_ARGS__)
+#else
+#include <syslog.h>
+
+#define LOG_TAG "bt_stack : "
+
+#define PRI_INFO " I"
+#define PRI_WARN " W"
+#define PRI_ERROR " E"
+#define PRI_DEBUG " D"
+#define PRI_VERB " V"
+
+#define ALOGV(fmt, arg...) syslog (LOG_WARNING, LOG_TAG fmt, ##arg)
+#define ALOGD(fmt, arg...) syslog (LOG_NOTICE, LOG_TAG fmt, ##arg)
+#define ALOGI(fmt, arg...) syslog (LOG_NOTICE, LOG_TAG fmt, ##arg)
+#define ALOGW(fmt, arg...) syslog (LOG_WARNING, LOG_TAG fmt, ##arg)
+#define ALOGE(fmt, arg...) syslog (LOG_ERR, LOG_TAG fmt, ##arg)
+
+#define LOG_VERBOSE(tag,fmt, arg...) syslog (LOG_WARNING, LOG_TAG fmt, ##arg)
+#define LOG_DEBUG(tag,fmt, arg...) syslog (LOG_NOTICE, LOG_TAG fmt, ##arg)
+#define LOG_INFO(tag,fmt, arg...)  syslog (LOG_NOTICE, LOG_TAG fmt, ##arg)
+#define LOG_WARN(fmt, arg...)  syslog (LOG_WARNING, LOG_TAG fmt, ##arg)
+#define LOG_ERROR(tag,fmt, arg...) syslog (LOG_ERR, LOG_TAG fmt, ##arg)
+
+#endif
+#endif
+
 #endif  /* defined(OS_GENERIC) */
diff --git a/osi/include/properties.h b/osi/include/properties.h
index bb3e61d..e961dc3 100644
--- a/osi/include/properties.h
+++ b/osi/include/properties.h
@@ -21,9 +21,14 @@
 #if defined(OS_GENERIC)
 #define PROPERTY_VALUE_MAX 92
 #else
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 #endif  // defined(OS_GENERIC)
 
+#ifndef ANDROID
+#define PROPERTY_VALUE_MAX 92
+#endif
 // Get value associated with key |key| into |value|.
 // Returns the length of the value which will never be greater than
 // PROPERTY_VALUE_MAX - 1 and will always be zero terminated.
diff --git a/osi/src/alarm.c b/osi/src/alarm.c
index be43b84..e06f215 100644
--- a/osi/src/alarm.c
+++ b/osi/src/alarm.c
@@ -95,6 +95,9 @@ struct alarm_t {
 // unit tests to run faster. It should not be modified by production code.
 int64_t TIMER_INTERVAL_FOR_WAKELOCK_IN_MS = 3000;
 static const clockid_t CLOCK_ID = CLOCK_BOOTTIME;
+#ifndef ANDROID
+#define KERNEL_MISSING_CLOCK_BOOTTIME_ALARM TRUE
+#endif
 #if defined(KERNEL_MISSING_CLOCK_BOOTTIME_ALARM) && (KERNEL_MISSING_CLOCK_BOOTTIME_ALARM == TRUE)
 static const clockid_t CLOCK_ID_ALARM = CLOCK_BOOTTIME;
 #else
@@ -478,6 +481,7 @@ static void reschedule_root_alarm(void) {
   if (list_is_empty(alarms))
     goto done;
 
+#ifdef ANDROID
   const alarm_t *next = list_front(alarms);
   const int64_t next_expiration = next->deadline - now();
   if (next_expiration < TIMER_INTERVAL_FOR_WAKELOCK_IN_MS) {
@@ -527,6 +531,14 @@ done:
   if (timer_was_set && !timer_set) {
     wakelock_release();
   }
+#else
+  alarm_t *next = list_front(alarms);
+  timer_time.it_value.tv_sec = (next->deadline / 1000);
+  timer_time.it_value.tv_nsec = (next->deadline % 1000) * 1000000LL;
+
+done:
+  timer_set = timer_time.it_value.tv_sec != 0 || timer_time.it_value.tv_nsec != 0;
+#endif
 
   if (timer_settime(timer, TIMER_ABSTIME, &timer_time, NULL) == -1)
     LOG_ERROR(LOG_TAG, "%s unable to set timer: %s", __func__, strerror(errno));
diff --git a/osi/src/eager_reader.c b/osi/src/eager_reader.c
index 86fcecc..e363c25 100644
--- a/osi/src/eager_reader.c
+++ b/osi/src/eager_reader.c
@@ -25,6 +25,9 @@
 #include <string.h>
 #include <sys/eventfd.h>
 #include <unistd.h>
+#ifndef ANDROID
+#include <sys/time.h>
+#endif
 
 #include "osi/include/fixed_queue.h"
 #include "osi/include/log.h"
diff --git a/osi/src/properties.c b/osi/src/properties.c
index 7fddfff..80ed1f9 100644
--- a/osi/src/properties.c
+++ b/osi/src/properties.c
@@ -35,7 +35,9 @@ int osi_property_get(const char *key, char *value, const char *default_value) {
     value[len] = '\0';
     return len;
 #else
+#ifdef ANDROID
     return property_get(key, value, default_value);
+#endif
 #endif  // defined(OS_GENERIC)
 }
 
@@ -43,6 +45,8 @@ int osi_property_set(const char *key, const char *value) {
 #if defined(OS_GENERIC)
     return -1;
 #else
+#ifdef ANDROID
     return property_set(key, value);
+#endif
 #endif  // defined(OS_GENERIC)
 }
\ No newline at end of file
diff --git a/osi/src/wakelock.c b/osi/src/wakelock.c
index 9681bd0..d2321e8 100644
--- a/osi/src/wakelock.c
+++ b/osi/src/wakelock.c
@@ -293,8 +293,9 @@ static void update_wakelock_acquired_stats(bt_status_t acquired_status) {
   wakelock_stats.last_acquired_timestamp_ms = now_ms;
 
   pthread_mutex_unlock(&monitor);
-
+#ifdef ANDROID
   metrics_log_wake_event(WAKE_EVENT_ACQUIRED, "", "", now_ms);
+#endif
 }
 
 //
@@ -337,8 +338,9 @@ static void update_wakelock_released_stats(bt_status_t released_status) {
   wakelock_stats.total_acquired_interval_ms += delta_ms;
 
   pthread_mutex_unlock(&monitor);
-
+#ifdef ANDROID
   metrics_log_wake_event(WAKE_EVENT_RELEASED, "", "", now_ms);
+#endif
 }
 
 void wakelock_debug_dump(int fd) {
diff --git a/profile/Makefile.am b/profile/Makefile.am
new file mode 100644
index 0000000..2f7d3bd
--- /dev/null
+++ b/profile/Makefile.am
@@ -0,0 +1,30 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS= \
+        -I/.. \
+        -I/include \
+        -I/../btcore/include \
+        -I/../include \
+        -I/../osi/include \
+        -I$(bdroid_C_INCLUDES)
+
+c_sources = \
+        src/manager.c
+
+common_LDFLAGS = -lpthread
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES = libbtprofile.la
+libbtprofile_la_CC = @CC@
+libbtprofile_la_SOURCES = $(c_sources)
+libbtprofile_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbtprofile_la_CFLAGS = $(common_CFLAGS)
+libbtprofile_la_LDFLAGS = $(common_LDFLAGS) -static
diff --git a/profile/src/manager.c b/profile/src/manager.c
index 6e3d45c..f18f1a0 100644
--- a/profile/src/manager.c
+++ b/profile/src/manager.c
@@ -57,6 +57,11 @@ static future_t *clean_up(void) {
   return NULL;
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t profile_manager_module = {
   .name = PROFILE_MANAGER_MODULE,
   .init = init,
diff --git a/service/hal/fake_bluetooth_interface.cpp b/service/hal/fake_bluetooth_interface.cpp
index 07de595..81410e4 100644
--- a/service/hal/fake_bluetooth_interface.cpp
+++ b/service/hal/fake_bluetooth_interface.cpp
@@ -76,7 +76,8 @@ bt_interface_t fake_bt_iface = {
   nullptr, /* interop_database_clear */
   nullptr, /* interop_database_add */
   nullptr, /* hci_cmd_send */
-  nullptr  /* bt test app interface */
+  nullptr,  /* bt test app interface */
+  nullptr /* Unified Wakeup app interface */
 };
 
 }  // namespace
diff --git a/service/main.cpp b/service/main.cpp
index 3ab81e6..2073d3e 100644
--- a/service/main.cpp
+++ b/service/main.cpp
@@ -68,7 +68,11 @@ int main(int argc, char *argv[]) {
   // TODO(armansito): Remove Chromecast specific property out of here. This
   // should just be obtained from global config.
   char disable_value[PROPERTY_VALUE_MAX];
+#ifdef ANDROID
   int status = property_get(kDisableProperty, disable_value, nullptr);
+#else
+  int status = property_get_bt(kDisableProperty, disable_value, nullptr);
+#endif
   if (status && !strcmp(disable_value, "1")) {
     LOG(INFO) << "service disabled";
     return EXIT_SUCCESS;
diff --git a/stack/Makefile.am b/stack/Makefile.am
new file mode 100644
index 0000000..4093ffc
--- /dev/null
+++ b/stack/Makefile.am
@@ -0,0 +1,178 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+if MDM_CHEROKEE
+AM_CFLAGS += -DBTA_AV_SPLIT_A2DP_ENABLED
+endif
+
+AM_CPPFLAGS = \
+        -I.. \
+        -I../include \
+        -Iinclude \
+        -Iavct \
+        -Ibtm \
+        -Iavrc \
+        -Il2cap \
+        -Iavdt \
+        -Igatt \
+        -Igap \
+        -Ipan \
+        -Ibnep \
+        -Ihid \
+        -Isdp \
+        -Ismp \
+        -Isrvc \
+        -I../btcore/include \
+        -I../vnd/include \
+        -I../vnd/ble \
+        -I../btif/include \
+        -I../hci/include \
+        -I../include \
+        -I../udrv/include \
+        -I../rpc/include \
+        -I../hcis \
+        -I../ctrlr/include \
+        -I../bta/include \
+        -I../bta/sys \
+        -I../utils/include \
+        -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext \
+        -I../../../vendor/qcom/opensource/bluetooth/system_bt_ext/bta/ar \
+        -I../../../hardware/libhardware/include 
+
+c_sources:= \
+    ./a2dp/a2d_api.c \
+    ./a2dp/a2d_sbc.c \
+    ./a2dp/a2d_aptx.c \
+    ./a2dp/a2d_aptx_hd.c \
+    ./a2dp/a2d_aac.c \
+    ./avrc/avrc_api.c \
+    ./avrc/avrc_sdp.c \
+    ./avrc/avrc_opt.c \
+    ./avrc/avrc_bld_tg.c \
+    ./avrc/avrc_bld_ct.c \
+    ./avrc/avrc_pars_tg.c \
+    ./avrc/avrc_pars_ct.c \
+    ./avrc/avrc_utils.c \
+    ./hid/hidh_api.c \
+    ./hid/hidh_conn.c \
+    ./bnep/bnep_main.c \
+    ./bnep/bnep_utils.c \
+    ./bnep/bnep_api.c \
+    ./hcic/hciblecmds.c \
+    ./hcic/hcicmds.c \
+    ./btm/btm_ble.c \
+    ./btm/btm_sec.c \
+    ./btm/btm_inq.c \
+    ./btm/btm_ble_addr.c \
+    ./btm/btm_ble_bgconn.c \
+    ./btm/btm_main.c \
+    ./btm/btm_dev.c \
+    ./btm/btm_ble_gap.c \
+    ./btm/btm_ble_adv_filter.c \
+    ./btm/btm_ble_multi_adv.c \
+    ./btm/btm_ble_batchscan.c \
+    ./btm/btm_ble_cont_energy.c \
+    ./btm/btm_ble_privacy.c \
+    ./btm/btm_acl.c \
+    ./btm/btm_sco.c \
+    ./btm/btm_pm.c \
+    ./btm/btm_devctl.c \
+    ./rfcomm/rfc_utils.c \
+    ./rfcomm/port_rfc.c \
+    ./rfcomm/rfc_l2cap_if.c \
+    ./rfcomm/rfc_mx_fsm.c \
+    ./rfcomm/port_utils.c \
+    ./rfcomm/rfc_port_fsm.c \
+    ./rfcomm/rfc_port_if.c \
+    ./rfcomm/port_api.c \
+    ./rfcomm/rfc_ts_frames.c \
+    ./mcap/mca_dact.c \
+    ./mcap/mca_dsm.c \
+    ./mcap/mca_l2c.c \
+    ./mcap/mca_main.c \
+    ./mcap/mca_csm.c \
+    ./mcap/mca_cact.c \
+    ./mcap/mca_api.c \
+    ./gatt/gatt_sr.c \
+    ./gatt/gatt_cl.c \
+    ./gatt/gatt_api.c \
+    ./gatt/gatt_auth.c \
+    ./gatt/gatt_utils.c \
+    ./gatt/gatt_main.c \
+    ./gatt/att_protocol.c \
+    ./gatt/gatt_attr.c \
+    ./gatt/gatt_db.c \
+    ./avct/avct_api.c \
+    ./avct/avct_l2c.c \
+    ./avct/avct_lcb.c \
+    ./avct/avct_ccb.c \
+    ./avct/avct_lcb_act.c \
+    ./smp/smp_main.c \
+    ./smp/smp_l2c.c \
+    ./smp/smp_cmac.c \
+    ./smp/smp_utils.c \
+    ./smp/smp_act.c \
+    ./smp/smp_keys.c \
+    ./smp/smp_api.c \
+    ./smp/aes.c \
+    ./smp/smp_br_main.c\
+    ./smp/p_256_curvepara.c \
+    ./smp/p_256_ecc_pp.c \
+    ./smp/p_256_multprecision.c \
+    ./avdt/avdt_ccb.c \
+    ./avdt/avdt_scb_act.c \
+    ./avdt/avdt_msg.c \
+    ./avdt/avdt_ccb_act.c \
+    ./avdt/avdt_api.c \
+    ./avdt/avdt_scb.c \
+    ./avdt/avdt_ad.c \
+    ./avdt/avdt_l2c.c \
+    ./sdp/sdp_server.c \
+    ./sdp/sdp_main.c \
+    ./sdp/sdp_db.c \
+    ./sdp/sdp_utils.c \
+    ./sdp/sdp_api.c \
+    ./sdp/sdp_discovery.c \
+    ./pan/pan_main.c \
+    ./srvc/srvc_battery.c \
+    ./srvc/srvc_dis.c \
+    ./srvc/srvc_eng.c \
+    ./pan/pan_api.c \
+    ./pan/pan_utils.c \
+    ./btu/btu_hcif.c \
+    ./btu/btu_init.c \
+    ./btu/btu_task.c \
+    ./l2cap/l2c_fcr.c \
+    ./l2cap/l2c_ucd.c \
+    ./l2cap/l2c_main.c \
+    ./l2cap/l2c_api.c \
+    ./l2cap/l2c_utils.c \
+    ./l2cap/l2c_csm.c \
+    ./l2cap/l2c_link.c \
+    ./l2cap/l2c_ble.c \
+    ./l2cap/l2cap_client.c \
+    ./gap/gap_api.c \
+    ./gap/gap_ble.c \
+    ./gap/gap_conn.c \
+    ./gap/gap_utils.c
+
+if SSR_CLEANUP_SUPPORT
+AM_CFLAGS += -DSSR_CLEANUP=TRUE
+endif
+
+common_LDFLAGS = -lpthread -lresolv
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)\
+library_include_HEADERS = $(h_sources)
+lib_LTLIBRARIES = libbtstack.la
+libbtstack_la_CC = @CC@
+libbtstack_la_SOURCES = $(c_sources)
+libbtstack_la_CPPFLAGS = $(AM_CPPFLAGS)
+libbtstack_la_CFLAGS = $(common_CFLAGS)
+libbtstack_la_LDFLAGS = $(common_LDFLAGS) -static
diff --git a/stack/a2dp/a2d_aptx.c b/stack/a2dp/a2d_aptx.c
index 05011bb..f699319 100644
--- a/stack/a2dp/a2d_aptx.c
+++ b/stack/a2dp/a2d_aptx.c
@@ -46,8 +46,9 @@
 #include "a2d_int.h"
 #include "a2d_aptx.h"
 #include "a2d_aptx_hd.h"
+#ifdef ANDROID
 #include <utils/Log.h>
-
+#endif
 const char* A2D_APTX_SCHED_LIB_NAME = "libaptXScheduler.so";
 void *A2dAptXSchedLibHandle = NULL;
 thread_t *A2d_aptx_thread = NULL;
diff --git a/stack/a2dp/a2d_aptx_hd.c b/stack/a2dp/a2d_aptx_hd.c
index ee6d65e..ebdfa1d 100644
--- a/stack/a2dp/a2d_aptx_hd.c
+++ b/stack/a2dp/a2d_aptx_hd.c
@@ -45,8 +45,9 @@
 #include "a2d_int.h"
 #include "a2d_aptx.h"
 #include "a2d_aptx_hd.h"
+#ifdef ANDROID
 #include <utils/Log.h>
-
+#endif
 
 BOOLEAN isA2dAptXHdEnabled = FALSE;
 
diff --git a/stack/avdt/avdt_api.c b/stack/avdt/avdt_api.c
index 4336b24..9b69f3c 100644
--- a/stack/avdt/avdt_api.c
+++ b/stack/avdt/avdt_api.c
@@ -1284,8 +1284,7 @@ UINT16 AVDT_SendReport(UINT8 handle, AVDT_REPORT_TYPE type,
         /* build SR - assume fit in one packet */
         p_tbl = avdt_ad_tc_tbl_by_type(AVDT_CHAN_REPORT, p_scb->p_ccb, p_scb);
         if (p_tbl->state == AVDT_AD_ST_OPEN) {
-            BT_HDR *p_pkt = (BT_HDR *)osi_malloc(p_tbl->peer_mtu);
-
+            BT_HDR *p_pkt = (BT_HDR *)osi_malloc(p_tbl->peer_mtu + sizeof(BT_HDR));
             p_pkt->offset = L2CAP_MIN_OFFSET;
             p = (UINT8 *)(p_pkt + 1) + p_pkt->offset;
 #if AVDT_MULTIPLEXING == TRUE
diff --git a/stack/bnep/bnep_main.c b/stack/bnep/bnep_main.c
index 078a72e..6d3684e 100644
--- a/stack/bnep/bnep_main.c
+++ b/stack/bnep/bnep_main.c
@@ -575,7 +575,7 @@ static void bnep_data_ind (UINT16 l2cap_cid, BT_HDR *p_buf)
             p_bcb->con_state != BNEP_STATE_CONNECTED &&
             extension_present && p && rem_len)
         {
-            p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len);
+            p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len + sizeof(BT_HDR));
             memcpy((UINT8 *)(p_bcb->p_pending_data + 1), p, rem_len);
             p_bcb->p_pending_data->len    = rem_len;
             p_bcb->p_pending_data->offset = 0;
diff --git a/stack/bnep/bnep_utils.c b/stack/bnep/bnep_utils.c
index 13fb189..a6fd884 100644
--- a/stack/bnep/bnep_utils.c
+++ b/stack/bnep/bnep_utils.c
@@ -154,6 +154,7 @@ void bnepu_release_bcb (tBNEP_CONN *p_bcb)
 
     /* Drop any response pointer we may be holding */
     p_bcb->con_state        = BNEP_STATE_IDLE;
+    osi_free(p_bcb->p_pending_data);
     p_bcb->p_pending_data   = NULL;
 
     /* Free transmit queue */
@@ -762,35 +763,44 @@ void bnep_process_setup_conn_responce (tBNEP_CONN *p_bcb, UINT8 *p_setup)
 UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len, BOOLEAN is_ext)
 {
     UINT8       control_type;
-    BOOLEAN     bad_pkt = FALSE;
     UINT16      len, ext_len = 0;
+    
+    if (p == NULL || rem_len == NULL) {	
+      if (rem_len != NULL) *rem_len = 0;	
+      BNEP_TRACE_DEBUG("%s: invalid packet: p = %p rem_len = %p", __func__, p,rem_len);	
+      return NULL;	
+    }UINT16 rem_len_orig = *rem_len;
 
     if (is_ext)
     {
+        if (*rem_len < 1) goto bad_packet_length;
         ext_len = *p++;
         *rem_len = *rem_len - 1;
     }
-
+    if (*rem_len < 1) goto bad_packet_length;
     control_type = *p++;
     *rem_len = *rem_len - 1;
 
-    BNEP_TRACE_EVENT ("BNEP processing control packet rem_len %d, is_ext %d, ctrl_type %d", *rem_len, is_ext, control_type);
+    BNEP_TRACE_EVENT("%s: BNEP processing control packet rem_len %d, is_ext %d, ctrl_type %d",	
+			                     __func__, *rem_len, is_ext, control_type);
 
     switch (control_type)
     {
     case BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD:
-        BNEP_TRACE_ERROR ("BNEP Received Cmd not understood for ctl pkt type: %d", *p);
-        p++;
-        *rem_len = *rem_len - 1;
-        break;
-
+       if (*rem_len < 1) {
+         BNEP_TRACE_ERROR("%s: Received BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD with bad length", __func__);	
+	 goto bad_packet_length;	
+       }	
+       BNEP_TRACE_ERROR("%s: Received BNEP_CONTROL_COMMAND_NOT_UNDERSTOOD for pkt type: %d", __func__, *p);
+       p++;
+       *rem_len = *rem_len - 1;
+       break;
     case BNEP_SETUP_CONNECTION_REQUEST_MSG:
         len = *p++;
         if (*rem_len < ((2 * len) + 1))
         {
-            bad_pkt = TRUE;
-            BNEP_TRACE_ERROR ("BNEP Received Setup message with bad length");
-            break;
+	    BNEP_TRACE_ERROR("%s: Received BNEP_SETUP_CONNECTION_REQUEST_MSG with bad length", __func__);
+            goto bad_packet_length;
         }
         if (!is_ext)
             bnep_process_setup_conn_req (p_bcb, p, (UINT8)len);
@@ -799,6 +809,10 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         break;
 
     case BNEP_SETUP_CONNECTION_RESPONSE_MSG:
+	if (*rem_len < 2) {
+           BNEP_TRACE_ERROR("%s: Received BNEP_SETUP_CONNECTION_RESPONSE_MSG with bad length", __func__);
+           goto bad_packet_length;
+	}
         if (!is_ext)
             bnep_process_setup_conn_responce (p_bcb, p);
         p += 2;
@@ -809,9 +823,8 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         BE_STREAM_TO_UINT16 (len, p);
         if (*rem_len < (len + 2))
         {
-            bad_pkt = TRUE;
-            BNEP_TRACE_ERROR ("BNEP Received Filter set message with bad length");
-            break;
+           BNEP_TRACE_ERROR("%s: Received  BNEP_FILTER_NET_TYPE_SET_MSG with bad length", __func__);
+           goto bad_packet_length;
         }
         bnepu_process_peer_filter_set (p_bcb, p, len);
         p += len;
@@ -819,6 +832,10 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         break;
 
     case BNEP_FILTER_NET_TYPE_RESPONSE_MSG:
+        if (*rem_len < 2) {
+           BNEP_TRACE_ERROR("%s: Received BNEP_FILTER_NET_TYPE_RESPONSE_MSG with bad length", __func__);
+           goto bad_packet_length;
+        }
         bnepu_process_peer_filter_rsp (p_bcb, p);
         p += 2;
         *rem_len = *rem_len - 2;
@@ -828,9 +845,8 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         BE_STREAM_TO_UINT16 (len, p);
         if (*rem_len < (len + 2))
         {
-            bad_pkt = TRUE;
-            BNEP_TRACE_ERROR ("BNEP Received Multicast Filter Set message with bad length");
-            break;
+           BNEP_TRACE_ERROR("%s: Received BNEP_FILTER_MULTI_ADDR_SET_MSG with bad length", __func__);
+           goto bad_packet_length;
         }
         bnepu_process_peer_multicast_filter_set (p_bcb, p, len);
         p += len;
@@ -838,30 +854,35 @@ UINT8 *bnep_process_control_packet (tBNEP_CONN *p_bcb, UINT8 *p, UINT16 *rem_len
         break;
 
     case BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG:
+        if (*rem_len < 2) {
+           BNEP_TRACE_ERROR("%s: Received BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG with bad length", __func__);
+           goto bad_packet_length;
+        }
         bnepu_process_multicast_filter_rsp (p_bcb, p);
         p += 2;
         *rem_len = *rem_len - 2;
         break;
 
     default :
-        BNEP_TRACE_ERROR ("BNEP - bad ctl pkt type: %d", control_type);
+        BNEP_TRACE_ERROR (" %s BNEP - bad ctl pkt type: %d",__func__, control_type);
         bnep_send_command_not_understood (p_bcb, control_type);
-        if (is_ext)
-        {
+        if (is_ext && (ext_len > 0))
+        {   
+            if (*rem_len < (ext_len - 1)) {	
+               goto bad_packet_length;	
+	    }
             p += (ext_len - 1);
             *rem_len -= (ext_len - 1);
         }
         break;
     }
 
-    if (bad_pkt)
-    {
-        BNEP_TRACE_ERROR ("BNEP - bad ctl pkt length: %d", *rem_len);
-        *rem_len = 0;
-        return NULL;
-    }
-
     return p;
+
+    bad_packet_length:	
+    BNEP_TRACE_ERROR("%s: bad control packet length: original=%d remaining=%d", __func__, rem_len_orig, *rem_len);	
+    *rem_len = 0;	
+    return NULL;
 }
 
 
diff --git a/stack/btm/btm_ble.c b/stack/btm/btm_ble.c
index 9645cc5..3db87dc 100644
--- a/stack/btm/btm_ble.c
+++ b/stack/btm/btm_ble.c
@@ -755,11 +755,16 @@ BOOLEAN BTM_ReadConnectedTransportAddress(BD_ADDR remote_bda, tBT_TRANSPORT tran
 
     if (transport == BT_TRANSPORT_LE)
     {
-        memcpy(remote_bda, p_dev_rec->ble.pseudo_addr, BD_ADDR_LEN);
         if (btm_bda_to_acl(p_dev_rec->ble.pseudo_addr, transport) != NULL)
+        {
+            memcpy(remote_bda, p_dev_rec->ble.pseudo_addr, BD_ADDR_LEN);
             return TRUE;
+        }
         else
+        {
+            memset(remote_bda, 0, BD_ADDR_LEN);
             return FALSE;
+        }
     }
 
     return FALSE;
@@ -936,7 +941,7 @@ BOOLEAN BTM_UseLeLink (BD_ADDR bd_addr)
 tBTM_STATUS BTM_SetBleDataLength(BD_ADDR bd_addr, UINT16 tx_pdu_length)
 {
     tACL_CONN *p_acl = btm_bda_to_acl(bd_addr, BT_TRANSPORT_LE);
-    UINT16 tx_time = BTM_BLE_DATA_TX_TIME_MAX_LEGACY;
+    /*UINT16 tx_time = BTM_BLE_DATA_TX_TIME_MAX_LEGACY;*/
 
     BTM_TRACE_DEBUG("%s: tx_pdu_length =%d", __FUNCTION__, tx_pdu_length);
 
@@ -959,11 +964,11 @@ tBTM_STATUS BTM_SetBleDataLength(BD_ADDR bd_addr, UINT16 tx_pdu_length)
         else if (tx_pdu_length < BTM_BLE_DATA_SIZE_MIN)
             tx_pdu_length =  BTM_BLE_DATA_SIZE_MIN;
 
-        if (controller_get_interface()->get_bt_version()->hci_version >= HCI_PROTO_VERSION_5_0)
-            tx_time = BTM_BLE_DATA_TX_TIME_MAX;
+        /*if (controller_get_interface()->get_bt_version()->hci_version >= HCI_PROTO_VERSION_5_0)
+            tx_time = BTM_BLE_DATA_TX_TIME_MAX;*/
 
         /* always set the TxTime to be max, as controller does not care for now */
-        btsnd_hcic_ble_set_data_length(p_acl->hci_handle, tx_pdu_length, tx_time);
+        btsnd_hcic_ble_set_data_length(p_acl->hci_handle, tx_pdu_length,BTM_BLE_DATA_TX_TIME_MAX_LEGACY);
 
         return BTM_SUCCESS;
     }
diff --git a/stack/btm/btm_ble_gap.c b/stack/btm/btm_ble_gap.c
index 1a1ddf8..3e6bb5a 100644
--- a/stack/btm/btm_ble_gap.c
+++ b/stack/btm/btm_ble_gap.c
@@ -1,5 +1,13 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  *  Copyright (C) 2008-2014 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -83,7 +91,7 @@ static void btm_ble_stop_observe(void);
 static void btm_ble_fast_adv_timer_timeout(void *data);
 static void btm_ble_start_slow_adv(void);
 static void btm_ble_inquiry_timer_gap_limited_discovery_timeout(void *data);
-static void btm_ble_inquiry_timer_timeout(void *data);
+/*static void btm_ble_inquiry_timer_timeout(void *data);*/
 static void btm_ble_observer_timer_timeout(void *data);
 
 
@@ -2187,6 +2195,10 @@ tBTM_STATUS btm_ble_start_inquiry (UINT8 mode, UINT8   duration)
 
         BTM_TRACE_DEBUG("btm_ble_start_inquiry inq_active = 0x%02x", p_inq->inq_active);
 
+#if 0
+/* Inquiry issue fix */
+/* removing this timer as BR/EDR inquiry timer is 12.8s and there is a gap of 2.8s.
+    Stopping BLE scan from HCI_INQUIRY_COMPLETE event */
         if (duration != 0) {
             /* start inquiry timer */
             period_ms_t duration_ms = duration * 1000;
@@ -2194,8 +2206,8 @@ tBTM_STATUS btm_ble_start_inquiry (UINT8 mode, UINT8   duration)
                                duration_ms, btm_ble_inquiry_timer_timeout,
                                NULL, btu_general_alarm_queue);
         }
+#endif
     }
-
     return status;
 
 }
@@ -2582,7 +2594,6 @@ UINT8 btm_ble_is_discoverable(BD_ADDR bda, UINT8 evt_type, UINT8 *p)
 static void btm_ble_appearance_to_cod(UINT16 appearance, UINT8 *dev_class)
 {
     dev_class[0] = 0;
-
     switch (appearance)
     {
         case BTM_BLE_APPEARANCE_GENERIC_PHONE:
@@ -3069,14 +3080,12 @@ void btm_ble_process_adv_pkt (UINT8 *p_data, BOOLEAN extended)
 
         STREAM_TO_UINT8    (addr_type, p);
         STREAM_TO_BDADDR   (bda, p);
-
         p1 = p;
 #if (defined BLE_PRIVACY_SPT && BLE_PRIVACY_SPT == TRUE)
         /* map address to security record */
-        match = btm_identity_addr_to_random_pseudo(bda, &addr_type, FALSE);
-
         BTM_TRACE_DEBUG("btm_ble_process_adv_pkt:bda= %0x:%0x:%0x:%0x:%0x:%0x",
-                                     bda[0],bda[1],bda[2],bda[3],bda[4],bda[5]);
+            		bda[0],bda[1],bda[2],bda[3],bda[4],bda[5]);	
+        match = btm_identity_addr_to_random_pseudo(bda, &addr_type, FALSE);
         /* always do RRA resolution on host */
         if (!match && BTM_BLE_IS_RESOLVE_BDA(bda))
         {
@@ -3552,10 +3561,12 @@ static void btm_ble_inquiry_timer_gap_limited_discovery_timeout(UNUSED_ATTR void
                          btm_cb.btm_inq_vars.discoverable_mode);
 }
 
+#if 0
 static void btm_ble_inquiry_timer_timeout(UNUSED_ATTR void *data)
 {
     btm_ble_stop_inquiry();
 }
+#endif
 
 static void btm_ble_observer_timer_timeout(UNUSED_ATTR void *data)
 {
diff --git a/stack/btm/btm_ble_privacy.c b/stack/btm/btm_ble_privacy.c
index 0805d34..c7b14ae 100644
--- a/stack/btm/btm_ble_privacy.c
+++ b/stack/btm/btm_ble_privacy.c
@@ -836,10 +836,21 @@ BOOLEAN btm_ble_resolving_list_load_dev(tBTM_SEC_DEV_REC *p_dev_rec)
 {
     BOOLEAN rt = FALSE;
     UINT8 rl_mask = btm_cb.ble_ctr_cb.rl_state;
+    tACL_CONN *p_acl = btm_bda_to_acl(p_dev_rec->bd_addr,BT_TRANSPORT_LE);
+    if(p_acl == NULL)
+    {		
+        BTM_TRACE_DEBUG("%s Device is using BR/EDR Transport ", __func__);
+	p_acl = btm_bda_to_acl(p_dev_rec->bd_addr,BT_TRANSPORT_BR_EDR); 
+    }
+    if(p_acl != NULL)
+    {
+       BTM_TRACE_DEBUG("%s Device is LE Transport ", __func__);
+       if(HCI_LE_ENHANCED_PRIVACY_SUPPORTED(p_acl->peer_le_features) == 0)
+       return FALSE;
+    }
 
     BTM_TRACE_DEBUG("%s btm_cb.ble_ctr_cb.privacy_mode = %d", __func__,
                                 btm_cb.ble_ctr_cb.privacy_mode);
-
     /* if controller does not support RPA offloading or privacy 1.2, skip */
     if (controller_get_interface()->get_ble_resolving_list_max_size() == 0)
         return FALSE;
diff --git a/stack/btm/btm_devctl.c b/stack/btm/btm_devctl.c
index 8105298..714d6a5 100644
--- a/stack/btm/btm_devctl.c
+++ b/stack/btm/btm_devctl.c
@@ -485,11 +485,10 @@ tBTM_STATUS BTM_SetLocalDeviceName (char *p_name)
     /* Save the device name if local storage is enabled */
     p = (UINT8 *)btm_cb.cfg.bd_name;
     if (p != (UINT8 *)p_name)
-        strlcpy(btm_cb.cfg.bd_name, p_name, BTM_MAX_LOC_BD_NAME_LEN);
+        strlcpy(btm_cb.cfg.bd_name, p_name, BTM_MAX_LOC_BD_NAME_LEN+1);
 #else
     p = (UINT8 *)p_name;
 #endif
-
     if (btsnd_hcic_change_name(p))
         return (BTM_CMD_STARTED);
     else
diff --git a/stack/btm/btm_inq.c b/stack/btm/btm_inq.c
index 9d9a213..701343c 100644
--- a/stack/btm/btm_inq.c
+++ b/stack/btm/btm_inq.c
@@ -1,5 +1,13 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  *  Copyright (C) 1999-2014 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -1838,6 +1846,7 @@ static void btm_initiate_inquiry (tBTM_INQUIRY_VAR_ST *p_inq)
 
         if (!btsnd_hcic_inquiry(*lap, p_inqparms->duration, 0))
             btm_process_inq_complete (BTM_NO_RESOURCES, (UINT8)(p_inqparms->mode & BTM_BR_INQUIRY_MASK));
+
     }
 }
 
diff --git a/stack/btm/btm_int.h b/stack/btm/btm_int.h
index d633c33..46397bd 100644
--- a/stack/btm/btm_int.h
+++ b/stack/btm/btm_int.h
@@ -1,4 +1,4 @@
-/******************************************************************************
+/****************************************************************************
  *
  *  Copyright (C) 1999-2012 Broadcom Corporation
  *
@@ -612,7 +612,6 @@ typedef struct
     tBTM_SEC_BLE        ble;
     tBTM_LE_CONN_PRAMS  conn_params;
 #endif
-
 #if BTM_DISC_DURING_RS == TRUE
 #define BTM_SEC_RS_NOT_PENDING          0           /* Role Switch not in progress */
 #define BTM_SEC_RS_PENDING              1           /* Role Switch in progress */
diff --git a/stack/btm/btm_sec.c b/stack/btm/btm_sec.c
index ceb46ab..e9af458 100644
--- a/stack/btm/btm_sec.c
+++ b/stack/btm/btm_sec.c
@@ -3124,7 +3124,7 @@ void btm_sec_rmt_name_request_complete (UINT8 *p_bd_addr, UINT8 *p_bd_name, UINT
         old_sec_state = p_dev_rec->sec_state;
         if (status == HCI_SUCCESS)
         {
-            strlcpy((char *)p_dev_rec->sec_bd_name, (char *)p_bd_name, BTM_MAX_REM_BD_NAME_LEN);
+            strlcpy((char *)p_dev_rec->sec_bd_name, (char *)p_bd_name, BTM_MAX_REM_BD_NAME_LEN+1);
             p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
             BTM_TRACE_EVENT ("setting BTM_SEC_NAME_KNOWN sec_flags:0x%x", p_dev_rec->sec_flags);
         }
@@ -3651,8 +3651,7 @@ void btm_proc_sp_req_evt (tBTM_SP_EVT event, UINT8 *p)
         memcpy (evt_data.cfm_req.bd_addr, p_dev_rec->bd_addr, BD_ADDR_LEN);
         memcpy (evt_data.cfm_req.dev_class, p_dev_rec->dev_class, DEV_CLASS_LEN);
 
-        strlcpy((char *)evt_data.cfm_req.bd_name, (char *)p_dev_rec->sec_bd_name, BTM_MAX_REM_BD_NAME_LEN);
-
+        strlcpy((char *)evt_data.cfm_req.bd_name, (char *)p_dev_rec->sec_bd_name, BTM_MAX_REM_BD_NAME_LEN+1);
         switch (event)
         {
             case BTM_SP_CFM_REQ_EVT:
@@ -3898,7 +3897,7 @@ void btm_rem_oob_req (UINT8 *p)
     {
         memcpy (evt_data.bd_addr, p_dev_rec->bd_addr, BD_ADDR_LEN);
         memcpy (evt_data.dev_class, p_dev_rec->dev_class, DEV_CLASS_LEN);
-        strlcpy((char *)evt_data.bd_name, (char *)p_dev_rec->sec_bd_name, BTM_MAX_REM_BD_NAME_LEN);
+        strlcpy((char *)evt_data.bd_name, (char *)p_dev_rec->sec_bd_name, BTM_MAX_REM_BD_NAME_LEN+1);
 
         btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_LOCAL_OOB_RSP);
         if ((*btm_cb.api.p_sp_callback) (BTM_SP_RMT_OOB_EVT, (tBTM_SP_EVT_DATA *)&evt_data) == BTM_NOT_AUTHORIZED)
diff --git a/stack/btu/btu_hcif.c b/stack/btu/btu_hcif.c
index 28ea831..da51cdf 100644
--- a/stack/btu/btu_hcif.c
+++ b/stack/btu/btu_hcif.c
@@ -1,5 +1,13 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  *  Copyright (C) 1999-2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -31,6 +39,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#ifndef ANDROID
+#include <signal.h>
+#endif
 
 #include "device/include/controller.h"
 #include "osi/include/log.h"
@@ -52,6 +63,9 @@ extern fixed_queue_t *btu_hci_msg_queue;
 
 extern void btm_process_cancel_complete(UINT8 status, UINT8 mode);
 extern void btm_ble_test_command_complete(UINT8 *p);
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+extern int btif_av_update_local_a2dp_role(char dc);
+#endif
 
 /********************************************************************************/
 /*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
@@ -425,6 +439,8 @@ static void btu_hcif_inquiry_comp_evt (UINT8 *p)
 
     STREAM_TO_UINT8    (status, p);
 
+    /* Inquiry issue fix */		
+    btm_ble_stop_inquiry();
     /* Tell inquiry processing that we are done */
     btm_process_inq_complete(status, BTM_BR_INQUIRY_MASK);
 }
@@ -538,6 +554,13 @@ static void btu_hcif_connection_request_evt (UINT8 *p)
     STREAM_TO_DEVCLASS (dc, p);
     STREAM_TO_UINT8    (link_type, p);
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    if(btif_av_update_local_a2dp_role(dc[0]))
+    {
+        HCI_TRACE_DEBUG("btu_hcif_connection_request_evt:Already there is some connection,so disconnect and connect");
+        return;
+    }
+#endif
     /* Pass request to security manager to check connect filters before */
     /* passing request to l2cap */
     if (link_type == HCI_LINK_TYPE_ACL)
diff --git a/stack/btu/btu_init.c b/stack/btu/btu_init.c
index 688ed88..91a97d6 100644
--- a/stack/btu/btu_init.c
+++ b/stack/btu/btu_init.c
@@ -117,6 +117,12 @@ void btu_free_core(void)
 
 #if BLE_INCLUDED == TRUE
       gatt_free();
+#ifndef ANDROID
+#if (defined(SMP_INCLUDED) && SMP_INCLUDED == TRUE)
+    SMP_DeInit();
+#endif
+#endif
+
 #endif
 }
 
diff --git a/stack/btu/btu_task.c b/stack/btu/btu_task.c
index 6c2a7a8..91c5100 100644
--- a/stack/btu/btu_task.c
+++ b/stack/btu/btu_task.c
@@ -176,22 +176,21 @@ void btu_task_start_up(UNUSED_ATTR void *context) {
      (BTU, BTM, L2CAP, and SDP)
    */
   btu_init_core();
-
   /* Initialize any optional stack components */
   BTE_InitStack();
-
   bta_sys_init();
-
   /* Initialise platform trace levels at this point as BTE_InitStack() and bta_sys_init()
    * reset the control blocks and preset the trace level with XXX_INITIAL_TRACE_LEVEL
    */
+#ifdef ANDROID
 #if ( BT_USE_TRACES==TRUE )
   module_init(get_module(BTE_LOGMSG_MODULE));
 #endif
+#endif
 
   // Inform the bt jni thread initialization is ok.
   btif_transfer_context(btif_init_ok, 0, NULL, 0, NULL);
-
+LOG_INFO(LOG_TAG, "BTA SEND OK Initialised!!!!!");
   fixed_queue_register_dequeue(btu_bta_msg_queue,
       thread_get_reactor(bt_workqueue_thread),
       btu_bta_msg_ready,
@@ -211,7 +210,7 @@ void btu_task_shut_down(UNUSED_ATTR void *context) {
   alarm_unregister_processing_queue(btu_general_alarm_queue);
 
 #if ( BT_USE_TRACES==TRUE )
-  module_clean_up(get_module(BTE_LOGMSG_MODULE));
+  //module_clean_up(get_module(BTE_LOGMSG_MODULE));
 #endif
 
   bta_sys_free();
diff --git a/stack/include/hcidefs.h b/stack/include/hcidefs.h
index 59771e8..b96e140 100644
--- a/stack/include/hcidefs.h
+++ b/stack/include/hcidefs.h
@@ -400,6 +400,9 @@
 #define HCI_CONTROLLER_DEBUG_INFO_OCF     (0x015B | HCI_GRP_VENDOR_SPECIFIC)
 /* SOC Logging OCF */
 #define HCI_VS_HOST_LOG_OPCODE    (0x0017 | HCI_GRP_VENDOR_SPECIFIC)
+#if (defined UNIFIED_SLEEP_WAKEUP && UNIFIED_SLEEP_WAKEUP == TRUE)
+#define HCI_VS_UNIFIED_WAKEUP_OPCODE    (0x006C| HCI_GRP_VENDOR_SPECIFIC)
+#endif
 
 /* VOIP Network Wifi OCF */
 #define HCI_VSC_VOIP_NETWORK_WIFI_OCF   (0x001C | HCI_GRP_VENDOR_SPECIFIC)
diff --git a/stack/include/smp_api.h b/stack/include/smp_api.h
index 6d77d7f..c661515 100644
--- a/stack/include/smp_api.h
+++ b/stack/include/smp_api.h
@@ -314,6 +314,19 @@ extern "C"
 *******************************************************************************/
 extern void SMP_Init(void);
 
+#ifndef ANDROID
+/*******************************************************************************
+**
+** Function         SMP_DeInit
+**
+** Description      This function de-initializes the SMP unit.
+**
+** Returns          void
+**
+*******************************************************************************/
+void SMP_DeInit(void);
+#endif
+
 /*******************************************************************************
 **
 ** Function         SMP_SetTraceLevel
diff --git a/stack/l2cap/l2c_ble.c b/stack/l2cap/l2c_ble.c
index 747e424..d204075 100644
--- a/stack/l2cap/l2c_ble.c
+++ b/stack/l2cap/l2c_ble.c
@@ -536,14 +536,15 @@ static void l2cble_start_conn_update (tL2C_LCB *p_lcb)
             }
             else
             {
-                l2cu_send_peer_ble_par_req (p_lcb, p_lcb->min_interval, p_lcb->max_interval,
+
+                l2cu_send_peer_ble_par_req (p_lcb, p_lcb->min_interval,p_lcb->max_interval,
                                             p_lcb->latency, p_lcb->timeout);
             }
             p_lcb->conn_update_mask &= ~L2C_BLE_NEW_CONN_PARAM;
             p_lcb->conn_update_mask |= L2C_BLE_NOT_DEFAULT_PARAM;
         }
     }
-
+#ifdef ANDROID
     /* Record the BLE connection update request. */
     if (p_lcb->conn_update_mask & L2C_BLE_UPDATE_PENDING) {
       bt_bdaddr_t bd_addr;
@@ -551,6 +552,7 @@ static void l2cble_start_conn_update (tL2C_LCB *p_lcb)
       btif_debug_ble_connection_update_request(bd_addr, min_conn_int, max_conn_int, slave_latency,
           supervision_tout);
     }
+#endif
 }
 
 /*******************************************************************************
@@ -584,12 +586,13 @@ void l2cble_process_conn_update_evt (UINT16 handle, UINT8 status,
     }
 
     l2cble_start_conn_update(p_lcb);
-
+#ifdef ANDROID
     /* Record the BLE connection update response. */
     bt_bdaddr_t bd_addr;
     bdcpy(bd_addr.address, p_lcb->remote_bd_addr);
     btif_debug_ble_connection_update_response(bd_addr, status, interval,
         latency, timeout);
+#endif
 
     L2CAP_TRACE_DEBUG("%s: conn_update_mask=%d", __func__, p_lcb->conn_update_mask);
 }
@@ -873,20 +876,18 @@ BOOLEAN l2cble_init_direct_conn (tL2C_LCB *p_lcb)
     UINT8 peer_addr_type = BLE_ADDR_PUBLIC;
     UINT8 own_addr_type = BLE_ADDR_PUBLIC;
 
-    L2CAP_TRACE_WARNING ("l2cble_init_direct_conn");
+    L2CAP_TRACE_WARNING ("l2cble_init_direct_conn ");
     /* There can be only one BLE connection request outstanding at a time */
     if (p_dev_rec == NULL)
     {
         L2CAP_TRACE_WARNING ("unknown device, can not initate connection");
         return(FALSE);
-    }
-
+    }    
     scan_int = (p_cb->scan_int == BTM_BLE_SCAN_PARAM_UNDEF) ? BTM_BLE_SCAN_FAST_INT : p_cb->scan_int;
     scan_win = (p_cb->scan_win == BTM_BLE_SCAN_PARAM_UNDEF) ? BTM_BLE_SCAN_FAST_WIN : p_cb->scan_win;
 
     peer_addr_type = p_lcb->ble_addr_type;
     memcpy(peer_addr, p_lcb->remote_bd_addr, BD_ADDR_LEN);
-
 #if ( (defined BLE_PRIVACY_SPT) && (BLE_PRIVACY_SPT == TRUE))
     own_addr_type = btm_cb.ble_ctr_cb.privacy_mode ? BLE_ADDR_RANDOM : BLE_ADDR_PUBLIC;
     if (p_dev_rec->ble.in_controller_list & BTM_RESOLVING_LIST_BIT)
@@ -896,7 +897,8 @@ BOOLEAN l2cble_init_direct_conn (tL2C_LCB *p_lcb)
 
         btm_ble_enable_resolving_list(BTM_BLE_RL_INIT);
         btm_random_pseudo_to_identity_addr(peer_addr, &peer_addr_type);
-    } else {
+        
+     } else {
         btm_ble_disable_resolving_list(BTM_BLE_RL_INIT, TRUE);
 
         // If we have a current RPA, use that instead.
@@ -905,7 +907,6 @@ BOOLEAN l2cble_init_direct_conn (tL2C_LCB *p_lcb)
         }
     }
 #endif
-
     if (!btm_ble_topology_check(BTM_BLE_STATE_INIT))
     {
         l2cu_release_lcb (p_lcb);
@@ -1183,17 +1184,19 @@ void l2cble_process_rc_param_request_evt(UINT16 handle, UINT16 int_min, UINT16 i
         p_lcb->timeout = timeout;
 
         /* if update is enabled, always accept connection parameter update */
-        if ((p_lcb->conn_update_mask & L2C_BLE_CONN_UPDATE_DISABLE) == 0)
+        /* BTSpec4.2 Section5.3 Procedure Collision Slave has to accept the Conn Update Request Always, 
+           Master Resolves Collision case*/
+        if ((((p_lcb->conn_update_mask & L2C_BLE_CONN_UPDATE_DISABLE) == 0)) || (p_lcb->link_role == HCI_ROLE_SLAVE))
         {
+            L2CAP_TRACE_EVENT ("L2CAP - LE In Slave Role , Accept Conn Param Update Request");
             btsnd_hcic_ble_rc_param_req_reply(handle, int_min, int_max, latency, timeout, 0, 0);
         }
-        else
+        else 
         {
             L2CAP_TRACE_EVENT ("L2CAP - LE - update currently disabled");
             p_lcb->conn_update_mask |= L2C_BLE_NEW_CONN_PARAM;
             btsnd_hcic_ble_rc_param_req_neg_reply (handle,HCI_ERR_UNACCEPT_CONN_INTERVAL);
         }
-
     }
     else
     {
diff --git a/stack/l2cap/l2c_main.c b/stack/l2cap/l2c_main.c
index 911ee50..10ae186 100644
--- a/stack/l2cap/l2c_main.c
+++ b/stack/l2cap/l2c_main.c
@@ -27,8 +27,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-
+#ifdef ANDROID
 #include <log/log.h>
+#endif
 
 #include "bt_target.h"
 #include "btm_int.h"
@@ -137,7 +138,9 @@ void l2c_rcv_acl_data (BT_HDR *p_msg)
     if (hci_len < L2CAP_PKT_OVERHEAD) {
         /* Must receive at least the L2CAP length and CID */
         L2CAP_TRACE_WARNING ("L2CAP - got incorrect hci header");
+#ifdef ANDROID
         android_errorWriteLog(0x534e4554, "34946955");
+#endif
         osi_free(p_msg);
         return;
     }
diff --git a/stack/l2cap/l2cap_client.c b/stack/l2cap/l2cap_client.c
index f8ddfd4..e9ca4a0 100644
--- a/stack/l2cap/l2cap_client.c
+++ b/stack/l2cap/l2cap_client.c
@@ -374,7 +374,7 @@ static void fragment_packet(l2cap_client_t *client, buffer_t *packet) {
   assert(packet != NULL);
 
   // TODO(sharvil): eliminate copy into BT_HDR.
-  BT_HDR *bt_packet = osi_malloc(buffer_length(packet) + L2CAP_MIN_OFFSET);
+  BT_HDR *bt_packet = osi_malloc(buffer_length(packet) + L2CAP_MIN_OFFSET +sizeof(BT_HDR));
   bt_packet->offset = L2CAP_MIN_OFFSET;
   bt_packet->len = buffer_length(packet);
   memcpy(bt_packet->data + bt_packet->offset, buffer_ptr(packet), buffer_length(packet));
@@ -388,7 +388,7 @@ static void fragment_packet(l2cap_client_t *client, buffer_t *packet) {
       break;
     }
 
-    BT_HDR *fragment = osi_malloc(client->remote_mtu + L2CAP_MIN_OFFSET);
+    BT_HDR *fragment = osi_malloc(client->remote_mtu + L2CAP_MIN_OFFSET + sizeof(BT_HDR));
     fragment->offset = L2CAP_MIN_OFFSET;
     fragment->len = client->remote_mtu;
     memcpy(fragment->data + fragment->offset, bt_packet->data + bt_packet->offset, client->remote_mtu);
diff --git a/stack/mcap/mca_cact.c b/stack/mcap/mca_cact.c
index ad1c1da..993e5c5 100644
--- a/stack/mcap/mca_cact.c
+++ b/stack/mcap/mca_cact.c
@@ -125,7 +125,7 @@ void mca_ccb_snd_req(tMCA_CCB *p_ccb, tMCA_CCB_EVT *p_data)
         p_ccb->p_tx_req = p_msg;
         if (!p_ccb->cong)
         {
-            BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU);
+            BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU + sizeof(BT_HDR));
 
             p_pkt->offset = L2CAP_MIN_OFFSET;
             p = p_start = (UINT8*)(p_pkt + 1) + L2CAP_MIN_OFFSET;
@@ -167,7 +167,7 @@ void mca_ccb_snd_rsp(tMCA_CCB *p_ccb, tMCA_CCB_EVT *p_data)
     tMCA_CCB_MSG *p_msg = (tMCA_CCB_MSG *)p_data;
     UINT8   *p, *p_start;
     BOOLEAN chk_mdl = FALSE;
-    BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU);
+    BT_HDR *p_pkt = (BT_HDR *)osi_malloc(MCA_CTRL_MTU+sizeof(BT_HDR));
 
     MCA_TRACE_DEBUG("%s cong=%d req=%d", __func__, p_ccb->cong, p_msg->op_code);
     /* assume that API functions verified the parameters */
diff --git a/stack/pan/pan_main.c b/stack/pan/pan_main.c
index 5c3a367..18f6b31 100644
--- a/stack/pan/pan_main.c
+++ b/stack/pan/pan_main.c
@@ -221,7 +221,39 @@ void pan_conn_ind_cb (UINT16 handle,
         BNEP_ConnectResp (handle, BNEP_CONN_FAILED_DST_UUID);
         return;
     }
-
+    
+   /* Check for valid interactions between the three PAN profile roles */	
+  /*	
+  * For reference, see Table 1 in PAN Profile v1.0 spec.	
+  * Note: the remote is the initiator.	
+  */
+  BOOLEAN is_valid_interaction = FALSE;	
+  switch (remote_uuid->uu.uuid16) {	
+    case UUID_SERVCLASS_NAP:	
+    case UUID_SERVCLASS_GN:	
+       if (local_uuid->uu.uuid16 == UUID_SERVCLASS_PANU)	
+       is_valid_interaction = TRUE;	
+       break;	
+    case UUID_SERVCLASS_PANU:	
+       is_valid_interaction = TRUE;	
+	break;	
+	}	
+   /*	
+   * Explicitly disable connections to the local PANU if the remote is	
+   * not PANU.	
+   */	
+   if ((local_uuid->uu.uuid16 == UUID_SERVCLASS_PANU) &&	
+      (remote_uuid->uu.uuid16 != UUID_SERVCLASS_PANU)) {	
+      is_valid_interaction = FALSE;	
+   }	
+   if (!is_valid_interaction) {	
+      PAN_TRACE_ERROR(	
+     "PAN Connection failed because of invalid PAN profile roles "	
+     "interaction: Remote UUID 0x%x Local UUID 0x%x",	
+     remote_uuid->uu.uuid16, local_uuid->uu.uuid16);	
+     BNEP_ConnectResp(handle, BNEP_CONN_FAILED_SRC_UUID);	
+     return;	
+   }
     /* Requested destination role is */
     if (local_uuid->uu.uuid16 == UUID_SERVCLASS_PANU)
         req_role = PAN_ROLE_CLIENT;
diff --git a/stack/sdp/sdp_server.c b/stack/sdp/sdp_server.c
index 15c2a77..0f6d65b 100644
--- a/stack/sdp/sdp_server.c
+++ b/stack/sdp/sdp_server.c
@@ -44,13 +44,23 @@
 #include "btif/include/btif_storage.h"
 #include "device/include/interop_config.h"
 #include <errno.h>
+#ifdef ANDROID
 #include <cutils/properties.h>
+#endif
 #include <hardware/bluetooth.h>
 
 #if SDP_SERVER_ENABLED == TRUE
 
 extern fixed_queue_t *btu_general_alarm_queue;
 
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+    extern enum a2dp_role active_a2dp_role;
+#else
+#ifndef ANDROID
+    extern BOOLEAN a2dp_snk_active;
+#endif
+#endif
+
 /* Maximum number of bytes to reserve out of SDP MTU for response data */
 #define SDP_MAX_SERVICE_RSPHDR_LEN      12
 #define SDP_MAX_SERVATTR_RSPHDR_LEN     10
@@ -210,7 +220,9 @@ BOOLEAN sdp_dev_blacklisted_for_avrcp15 (BD_ADDR addr)
 ***************************************************************************************/
 BOOLEAN sdp_fallback_avrcp_version (tSDP_ATTRIBUTE *p_attr, BD_ADDR remote_address)
 {
+#if (AV_BOTH_ROLES_ENABLED != TRUE)
     char a2dp_role[PROPERTY_VALUE_MAX] = "false";
+#endif
     if ((p_attr->id == ATTR_ID_BT_PROFILE_DESC_LIST) &&
         (p_attr->len >= SDP_PROFILE_DESC_LENGTH))
     {
@@ -226,8 +238,21 @@ BOOLEAN sdp_fallback_avrcp_version (tSDP_ATTRIBUTE *p_attr, BD_ADDR remote_addre
                          p_attr->value_ptr[PROFILE_VERSION_POSITION]);
                 return TRUE;
             }
+
+#if (AV_BOTH_ROLES_ENABLED == TRUE)
+            if(active_a2dp_role == A2DP_SOURCE){
+#else
+#ifdef ANDROID
             property_get("persist.service.bt.a2dp.sink", a2dp_role, "false");
+#else
+            //property_get_bt("persist.service.bt.a2dp.sink", a2dp_role, "false");
+            if ( TRUE == a2dp_snk_active )
+            {
+                strlcpy(a2dp_role,"true",5);
+            }
+#endif
             if (!strncmp("false", a2dp_role, 5)) {
+#endif
                 ver = sdp_get_stored_avrc_tg_version (remote_address);
                 if (ver != AVRC_REV_INVALID)
                 {
@@ -248,7 +273,11 @@ BOOLEAN sdp_fallback_avrcp_version (tSDP_ATTRIBUTE *p_attr, BD_ADDR remote_addre
                 }
                 else
                 {
+#ifdef ANDROID
+                    p_attr->value_ptr[PROFILE_VERSION_POSITION] = 0x03; // Update AVRCP ver as 1.3
+#else
                     p_attr->value_ptr[PROFILE_VERSION_POSITION] = 0x03; // Update AVRCP ver as 1.3
+#endif
                     SDP_TRACE_DEBUG("Device not stored, Change AVRCP Version = 0x%x",
                              p_attr->value_ptr[PROFILE_VERSION_POSITION]);
                     return TRUE;
@@ -323,9 +352,15 @@ BOOLEAN sdp_change_hfp_version (tSDP_ATTRIBUTE *p_attr, BD_ADDR remote_address)
             SDP_TRACE_DEBUG("%s: HF version is 1.7 for BD addr: %x:%x:%x",\
                            __func__, remote_address[0], remote_address[1], remote_address[2]);
             /* For PTS we should show AG's HFP version as 1.7 */
+#ifdef ANDROID
             if (is_blacklisted ||
                 (property_get("bt.pts.certification", value, "false") &&
                  strcmp(value, "true") == 0))
+#else
+            if (is_blacklisted ||
+                (property_get_bt("bt.pts.certification", value, "false") &&
+                 strcmp(value, "true") == 0))
+#endif
             {
                 p_attr->value_ptr[PROFILE_VERSION_POSITION] = 0x07; // Update HFP version as 1.7
                 SDP_TRACE_ERROR("SDP Change HFP Version = 0x%x",
@@ -497,7 +532,7 @@ static void process_service_search (tCONN_CB *p_ccb, UINT16 trans_num,
         }
         BE_STREAM_TO_UINT16 (cont_offset, p_req);
 
-        if (cont_offset != p_ccb->cont_offset)
+        if (cont_offset != p_ccb->cont_offset || num_rsp_handles < cont_offset)
         {
             sdpu_build_n_send_error (p_ccb, trans_num, SDP_INVALID_CONT_STATE,
                                      SDP_TEXT_BAD_CONT_INX);
diff --git a/stack/smp/p_256_ecc_pp.h b/stack/smp/p_256_ecc_pp.h
index fd3dc64..88dea00 100644
--- a/stack/smp/p_256_ecc_pp.h
+++ b/stack/smp/p_256_ecc_pp.h
@@ -26,7 +26,12 @@
 
 #include "p_256_multprecision.h"
 
+#if __x86_64__
+typedef unsigned int  DWORD;
+#else
 typedef unsigned long  DWORD;
+#endif
+
 
 typedef struct {
     DWORD x[KEY_LENGTH_DWORDS_P256];
diff --git a/stack/smp/p_256_multprecision.h b/stack/smp/p_256_multprecision.h
index 0d1a964..9f0a2a5 100644
--- a/stack/smp/p_256_multprecision.h
+++ b/stack/smp/p_256_multprecision.h
@@ -26,7 +26,11 @@
 #include "bt_types.h"
 
 /* Type definitions */
+#if __x86_64__
+typedef unsigned int  DWORD;
+#else
 typedef unsigned long  DWORD;
+#endif
 
 #define DWORD_BITS      32
 #define DWORD_BYTES     4
diff --git a/stack/smp/smp_api.c b/stack/smp/smp_api.c
index ddf9ba4..9324cf4 100644
--- a/stack/smp/smp_api.c
+++ b/stack/smp/smp_api.c
@@ -71,6 +71,25 @@ void SMP_Init(void)
         SMP_TRACE_ERROR ("%s PTS FAILURE MODE IN EFFECT (CASE %d)", __func__, smp_cb.cert_failure);
 }
 
+#ifndef ANDROID
+/*******************************************************************************
+**
+** Function         SMP_DeInit
+**
+** Description      This function de-initializes the SMP unit.
+**
+** Returns          void
+**
+*******************************************************************************/
+void SMP_DeInit(void)
+{
+    SMP_TRACE_EVENT ("%s", __FUNCTION__);
+
+    alarm_free(smp_cb.smp_rsp_timer_ent );
+    alarm_free(smp_cb.delayed_auth_timer_ent);
+    memset(&smp_cb, 0, sizeof(tSMP_CB));
+}
+#endif
 
 /*******************************************************************************
 **
diff --git a/stack/smp/smp_utils.c b/stack/smp/smp_utils.c
index 04e4713..7c1b57c 100644
--- a/stack/smp/smp_utils.c
+++ b/stack/smp/smp_utils.c
@@ -863,6 +863,7 @@ void smp_cb_cleanup(tSMP_CB   *p_cb)
     tSMP_CALLBACK   *p_callback = p_cb->p_callback;
     UINT8           trace_level = p_cb->trace_level;
 
+#ifdef ANDROID
     SMP_TRACE_EVENT("smp_cb_cleanup");
 
     alarm_free(p_cb->smp_rsp_timer_ent);
@@ -872,6 +873,21 @@ void smp_cb_cleanup(tSMP_CB   *p_cb)
     p_cb->trace_level = trace_level;
     p_cb->smp_rsp_timer_ent = alarm_new("smp.smp_rsp_timer_ent");
     p_cb->delayed_auth_timer_ent = alarm_new("smp.delayed_auth_timer_ent");
+#else
+    /* Cancel the timers instead of freeing, for Linux OS */
+    alarm_t * p_smp_rsp_tmr  = p_cb->smp_rsp_timer_ent;
+    alarm_t * p_smp_del_auth_tmr  = p_cb->delayed_auth_timer_ent;
+
+    SMP_TRACE_EVENT("smp_cb_cleanup");
+
+    alarm_cancel(p_cb->smp_rsp_timer_ent);
+    alarm_cancel(p_cb->delayed_auth_timer_ent);
+    memset(p_cb, 0, sizeof(tSMP_CB));
+    p_cb->p_callback = p_callback;
+    p_cb->trace_level = trace_level;
+    p_cb->smp_rsp_timer_ent = p_smp_rsp_tmr;
+    p_cb->delayed_auth_timer_ent = p_smp_del_auth_tmr;
+#endif
 }
 
 /*******************************************************************************
diff --git a/test/Makefile.am b/test/Makefile.am
new file mode 100644
index 0000000..9271701
--- /dev/null
+++ b/test/Makefile.am
@@ -0,0 +1,3 @@
+ACLOCAL_AMFLAGS = -I m4
+
+SUBDIRS = bluedroidtest
diff --git a/test/bluedroidtest/Makefile.am b/test/bluedroidtest/Makefile.am
new file mode 100644
index 0000000..0a3835e
--- /dev/null
+++ b/test/bluedroidtest/Makefile.am
@@ -0,0 +1,27 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99
+
+AM_CPPFLAGS= \
+        -I../../include \
+        -I../../stack/include \
+        -I../../../../hardware/libhardware/include  
+
+# HAL layer
+c_sources = \
+        bluedroidtest.c
+
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)
+bin_PROGRAMS = bdt
+bdt_CC = @CC@
+bdt_SOURCES = $(c_sources)
+bdt_CFLAGS = $(common_CFLAGS)
+bdt_LDFLAGS = $(Z_LIB)
+bdt_LDADD = -lhardware -lpthread -lm -ldl -lrt
+
diff --git a/test/bluedroidtest/bluedroidtest.c b/test/bluedroidtest/bluedroidtest.c
index 114ec0b..4c439ac 100644
--- a/test/bluedroidtest/bluedroidtest.c
+++ b/test/bluedroidtest/bluedroidtest.c
@@ -34,14 +34,18 @@
 #include <ctype.h>
 #include <fcntl.h>
 #include <sys/prctl.h>
-#include <sys/capability.h>
+
 
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <netdb.h>
-
+#ifdef ANDROID
+#include <sys/capability.h>
 #include <private/android_filesystem_config.h>
 #include <android/log.h>
+#else
+#include <stdarg.h>
+#endif
 
 #include <hardware/hardware.h>
 #include <hardware/bluetooth.h>
@@ -76,11 +80,11 @@ static bt_status_t status;
 static bluetooth_device_t* bt_device;
 
 const bt_interface_t* sBtInterface = NULL;
-
+#ifdef ANDROID
 static gid_t groups[] = { AID_NET_BT, AID_INET, AID_NET_BT_ADMIN,
                           AID_SYSTEM, AID_MISC, AID_SDCARD_RW,
                           AID_NET_ADMIN, AID_VPN};
-
+#endif
 /* Set to 1 when the Bluedroid stack is enabled */
 static unsigned char bt_enabled = 0;
 static int deviceCount;
@@ -121,7 +125,7 @@ static void bdt_shutdown(void)
 /*****************************************************************************
 ** Android's init.rc does not yet support applying linux capabilities
 *****************************************************************************/
-
+#ifdef ANDROID
 static void config_permissions(void)
 {
     struct __user_cap_header_struct header;
@@ -157,7 +161,7 @@ static void config_permissions(void)
     capset(&header, &cap[0]);
     setgroups(sizeof(groups)/sizeof(groups[0]), groups);
 }
-
+#endif
 
 
 /*****************************************************************************
@@ -210,7 +214,7 @@ static void hex_dump(char *msg, void *data, int size, int trunc)
     /* truncate */
     if(trunc && (size>32))
         size = 32;
-
+#ifdef ANDROID
     for(n=1;n<=size;n++) {
         if (n%16 == 1) {
             /* store address for this line */
@@ -243,7 +247,7 @@ static void hex_dump(char *msg, void *data, int size, int trunc)
         }
         p++; /* next byte */
     }
-
+#endif
     if (strlen(hexstr) > 0) {
         /* print rest of buffer if not empty */
         bdt_log("[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
@@ -400,7 +404,11 @@ static int create_cmdjob(char *cmd)
     job_cmd = malloc(strlen(cmd)+1); /* freed in job handler */
     if (job_cmd)
     {
+#ifdef ANDROID
         strlcpy(job_cmd, cmd, strlen(cmd)+1);
+#else
+        strncpy(job_cmd, cmd, strlen(cmd)+1);
+#endif
 
         if (pthread_create(&thread_id, NULL,
                        (void*)cmdjob_handler, (void*)job_cmd)!=0)
@@ -855,8 +863,9 @@ int main (int UNUSED argc, char UNUSED *argv[])
     int pid = -1;
     int enable_wait_count = 0;
     pthread_t discoveryThread;
-
+#ifdef ANDROID
     config_permissions();
+#endif
     bdt_log("\n:::::::::::::::::::::::::::::::::::::::::::::::::::");
     bdt_log(":: Bluedroid test app starting");
 
diff --git a/tools/Makefile.am b/tools/Makefile.am
new file mode 100644
index 0000000..76b1154
--- /dev/null
+++ b/tools/Makefile.am
@@ -0,0 +1,3 @@
+ACLOCAL_AMFLAGS = -I m4
+
+SUBDIRS = bdtool btsnoop_dump
diff --git a/tools/bdtool/Makefile.am b/tools/bdtool/Makefile.am
new file mode 100644
index 0000000..3c32736
--- /dev/null
+++ b/tools/bdtool/Makefile.am
@@ -0,0 +1,33 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99
+
+AM_CPPFLAGS= \
+        -I../inc/ \
+        -I../../include \
+        -I../../stack/include \
+        -I../../test/suite
+
+# HAL layer
+c_sources = \
+        adapter.c \
+        bdtool.c \
+        ../../test/suite/support/callbacks.c \
+        ../../test/suite/support/gatt.c \
+        ../../test/suite/support/hal.c \
+        ../../test/suite/support/pan.c
+
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)
+bin_PROGRAMS = net_bdtool
+net_bdtool_CC = @CC@
+net_bdtool_SOURCES = $(c_sources)
+net_bdtool_CFLAGS = $(common_CFLAGS)
+net_bdtool_LDFLAGS = $(Z_LIB)
+net_bdtool_LDADD = -ldl -lrt -lresolv ../../btcore/libbtcore.la \
+    ../../osi/libbtosi.la $(SYS_LIB)/libbtvendorhal.la
diff --git a/tools/btsnoop_dump/Makefile.am b/tools/btsnoop_dump/Makefile.am
new file mode 100644
index 0000000..33bcc7f
--- /dev/null
+++ b/tools/btsnoop_dump/Makefile.am
@@ -0,0 +1,20 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99
+
+# HAL layer
+c_sources = \
+        btsnoop_dump.c
+
+common_CFLAGS =  $(AM_CFLAGS) -fPIC -D_GNU_SOURCE
+
+library_includedir = $(pkgincludedir)
+bin_PROGRAMS = btsnoop
+btsnoop_CC = @CC@
+btsnoop_SOURCES = $(c_sources)
+btsnoop_CFLAGS = $(common_CFLAGS)
+btsnoop_LDADD = -ldl -lrt ../../osi/libbtosi.la
diff --git a/utils/Android.mk b/utils/Android.mk
index 4a83236..6818413 100644
--- a/utils/Android.mk
+++ b/utils/Android.mk
@@ -27,4 +27,8 @@ LOCAL_CFLAGS += $(bluetooth_CFLAGS)
 LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
 LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
 
+ifeq ($(BOARD_HAS_QCA_BT_ROME),true)
+LOCAL_CFLAGS += -DBT_SOC_TYPE_ROME
+endif
+
 include $(BUILD_STATIC_LIBRARY)
diff --git a/utils/Makefile.am b/utils/Makefile.am
new file mode 100644
index 0000000..519ec88
--- /dev/null
+++ b/utils/Makefile.am
@@ -0,0 +1,46 @@
+# sources and intermediate files are separated
+
+AM_CFLAGS = -Wall \
+        -Wundef \
+        -Wstrict-prototypes \
+        -Wno-trigraphs \
+        -std=c99 \
+        -DHAS_NO_BDROID_BUILDCFG
+
+AM_CPPFLAGS= \
+        -Iinclude \
+        -I../btcore/include \
+        -I../stack/include \
+        -I../utils/include \
+        -I../include \
+        -I../ \
+        -I$(bdroid_C_INCLUDES)
+
+if MDM_ROME
+AM_CFLAGS += -DBT_SOC_TYPE_ROME
+AM_CPPFLAGS += -DBT_SOC_TYPE_ROME
+else
+if MDM_PRONTO
+AM_CFLAGS += -DHCI_USE_MCT
+AM_CPPFLAGS += -DHCI_USE_MCT
+endif
+endif
+
+if MDM_CHEROKEE
+AM_CFLAGS += -DBT_SOC_TYPE_CHEROKEE
+AM_CPPFLAGS += -DBT_SOC_TYPE_CHEROKEE
+endif
+
+c_sources = \
+        src/bt_utils.c
+
+common_LDFLAGS = -lpthread -lresolv ../osi/libbtosi.la
+common_CFLAGS =  $(AM_CFLAGS) -fPIC
+
+library_includedir = $(pkgincludedir)
+lib_LTLIBRARIES = libbtutils.la
+libbtutils_la_CC = @CC@
+libbtutils_la_SOURCES = $(c_sources)
+libbtutils_la_CPPFLAGS =$(AM_CPPFLAGS)
+libbtutils_la_CFLAGS = $(common_CFLAGS)
+libbtutils_la_LDFLAGS = $(common_LDFLAGS) -static
diff --git a/utils/include/bt_utils.h b/utils/include/bt_utils.h
index 960a283..a6ae241 100644
--- a/utils/include/bt_utils.h
+++ b/utils/include/bt_utils.h
@@ -1,5 +1,13 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  *  Copyright (C) 2009-2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -57,6 +65,7 @@ typedef enum {
     BT_SOC_AR3K,
     BT_SOC_ROME,
     BT_SOC_CHEROKEE,
+    BT_SOC_ROME_USB,
     /* Add chipset type here */
     BT_SOC_RESERVED
 } bt_soc_type;
diff --git a/utils/src/bt_utils.c b/utils/src/bt_utils.c
index 6f0f205..de7c04f 100644
--- a/utils/src/bt_utils.c
+++ b/utils/src/bt_utils.c
@@ -1,5 +1,13 @@
 /******************************************************************************
  *
+ *  Copyright (c) 2017 Qualcomm Technologies, Inc.
+ *  All Rights Reserved.
+ *  Confidential and Proprietary - Qualcomm Technologies, Inc.
+ *
+ *  NOT A CONTRIBUTION
+ *  Apache license notifications and license are retained
+ *  for attribution purposes only.
+ *
  *  Copyright (C) 2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -35,10 +43,18 @@
 #include <stdlib.h>
 #include <sys/resource.h>
 #include <unistd.h>
-
+#ifdef ANDROID
 #include <utils/ThreadDefs.h>
 #include <cutils/sched_policy.h>
-
+#else
+//#include <sys/types.h>
+#include <sys/socket.h>
+//#include <string.h>
+#include <sys/un.h>
+//#include <sys/time.h>
+//#include <fcntl.h>
+#define SOCKETNAME  "/etc/bluetooth/btprop"
+#endif
 #include "bt_types.h"
 #include "btcore/include/module.h"
 #include "osi/include/compat.h"
@@ -81,12 +97,16 @@ static soc_type_node soc_type_entries[] = {
                            { BT_SOC_AR3K , "ath3k" },
                            { BT_SOC_ROME , "rome" },
                            { BT_SOC_CHEROKEE , "cherokee" },
+                           { BT_SOC_ROME_USB , "rome_usb" },
                            { BT_SOC_RESERVED , "" }
                                        };
 
 static list_t *iot_header_queue = NULL;
 #define MAX_LINE 2048
 #define MAX_ADDR_STR_LEN 9
+#ifndef ANDROID
+#define PROPERTY_VALUE_MAX 92
+#endif
 static pthread_mutex_t         iot_mutex_lock;
 /*******************************************************************************
 **  Type definitions for callback functions
@@ -101,10 +121,33 @@ static bt_soc_type soc_type;
 
 static void init_soc_type();
 
+#ifndef ANDROID
+static int bt_prop_socket;      /* This end of connection*/
+#endif
+
 static future_t *init(void) {
   int i;
   pthread_mutexattr_t lock_attr;
 
+#ifndef ANDROID
+  int len;    /* length of sockaddr */
+  struct sockaddr_un name;
+  if( (bt_prop_socket = socket(AF_UNIX, SOCK_STREAM, 0) ) < 0) {
+    perror("socket");
+    exit(1);
+  }
+  /*Create the address of the server.*/
+  memset(&name, 0, sizeof(struct sockaddr_un));
+  name.sun_family = AF_UNIX;
+  strncpy(name.sun_path, SOCKETNAME, sizeof(name.sun_path));
+  len = sizeof(name.sun_family) + strlen(name.sun_path);
+  /*Connect to the server.*/
+  if (connect(bt_prop_socket, (struct sockaddr *) &name, len) < 0){
+      perror("connect");
+      exit(1);
+  }
+#endif
+
   for(i = 0; i < TASK_HIGH_MAX; i++) {
     g_DoSchedulingGroupOnce[i] = PTHREAD_ONCE_INIT;
     g_DoSchedulingGroup[i] = TRUE;
@@ -121,9 +164,18 @@ static future_t *init(void) {
 static future_t *clean_up(void) {
   pthread_mutex_destroy(&gIdxLock);
   pthread_mutex_destroy(&iot_mutex_lock);
+#ifndef ANDROID
+  shutdown(bt_prop_socket, SHUT_RDWR);
+  close(bt_prop_socket);
+#endif
   return NULL;
 }
 
+//TODO: Fix this
+#ifndef ANDROID
+#define EXPORT_SYMBOL   __attribute__((visibility("default")))
+#endif
+
 EXPORT_SYMBOL const module_t bt_utils_module = {
   .name = BT_UTILS_MODULE,
   .init = init,
@@ -155,6 +207,54 @@ static void check_do_scheduling_group(void) {
     }
 }
 
+#ifndef ANDROID
+int property_get_bt(const char *key, char *value, const char *default_value)
+{
+   printf("property_get_bt");
+    LOG_INFO(LOG_TAG,"%s key (%s) Value (%s)",__func__,key,value);
+    LOG_ERROR(LOG_TAG,"%s key (%s) Value (%s)",__func__,key,value);
+    char prop_string[200] = {'\0'};
+    int ret, bytes_read = 0, i = 0;
+    ALOGI("property_get_bt: key(%s) has value: %s", key, value);
+    snprintf(prop_string, sizeof(prop_string), "get_property %s,", key);
+    ret = send(bt_prop_socket, prop_string, strlen(prop_string), 0);
+    memset(value, 0, sizeof(value));
+    do
+    {
+        bytes_read = recv(bt_prop_socket, &value[i], 1, 0);
+        if (bytes_read == 1)
+        {
+            if (value[i] == ',')
+            {
+                value[i] = '\0';
+                break;
+            }
+            i++;
+        }
+    } while(1);
+    ALOGD("property_get_bt: key(%s) has value: %s", key, value);
+    if (!i && default_value)
+    {
+        ALOGD("property_get_bt: Copied default =%s", default_value);
+        strncpy(value, default_value, strlen(default_value)+1);
+        return 1;
+    }
+    return 0;
+}
+
+/* property_set_bt: returns 0 on success, < 0 on failure
+*/
+int property_set_bt(const char *key, const char *value)
+{
+    char prop_string[200] = {'\0'};
+    int ret;
+    snprintf(prop_string, sizeof(prop_string), "set_property %s %s,", key, value);
+    ALOGD("property_set_bt: setting key(%s) to value: %s\n", key, value);
+    ret = send(bt_prop_socket, prop_string, strlen(prop_string), 0);
+    return 0;
+}
+#endif
+
 /*****************************************************************************
 **
 ** Function        raise_priority_a2dp
@@ -165,6 +265,7 @@ static void check_do_scheduling_group(void) {
 **
 *******************************************************************************/
 void raise_priority_a2dp(tHIGH_PRIORITY_TASK high_task) {
+#ifdef ANDROID
     int rc = 0;
     int tid = gettid();
     int priority = ANDROID_PRIORITY_AUDIO;
@@ -200,6 +301,7 @@ void raise_priority_a2dp(tHIGH_PRIORITY_TASK high_task) {
     if (setpriority(PRIO_PROCESS, tid, priority) < 0) {
         LOG_WARN(LOG_TAG, "failed to change priority tid: %d to %d", tid, priority);
     }
+#endif
 }
 
 /*****************************************************************************
@@ -214,6 +316,7 @@ void raise_priority_a2dp(tHIGH_PRIORITY_TASK high_task) {
 **
 *******************************************************************************/
 void adjust_priority_a2dp(int start) {
+#ifdef ANDROID
     int priority = start ? ANDROID_PRIORITY_URGENT_AUDIO : ANDROID_PRIORITY_AUDIO;
     int tid;
     int i;
@@ -229,6 +332,7 @@ void adjust_priority_a2dp(int start) {
             }
         }
     }
+#endif
 }
 
 /*****************************************************************************
@@ -788,7 +892,11 @@ bool add_iot_device(const char *filename, char* header,
         return false;
     }
     /* first copy the header */
+#ifdef ANDROID
     len = strlcpy(&line_start[index], header, strlen(header)+ 1);
+#else
+    len = strncpy(&line_start[index], header, strlen(header)+ 1);
+#endif
     index += len;
 
     line_start[index++] = '=';
@@ -808,8 +916,14 @@ bool add_iot_device(const char *filename, char* header,
         }
     }
     else if(method_type == METHOD_NAME) {
+#ifdef ANDROID
         len = strlcpy(&line_start[index], (const char*) device_details,
+		                       strlen((const char*)device_details) + 1);
+#else
+        len = strncpy(&line_start[index], (const char*) device_details,
                         strlen((const char*)device_details) + 1);
+#endif
+ 
         index += len;
     }
     /* append the new line characer at the end */
@@ -1099,19 +1213,32 @@ static void init_soc_type()
     ALOGI("init_soc_type");
 
     soc_type = BT_SOC_DEFAULT;
+#ifdef ANDROID
     ret = property_get("qcom.bluetooth.soc", bt_soc_type, NULL);
+//#else
+  //  ret = property_get_bt("qcom.bluetooth.soc", bt_soc_type, NULL);
     if (ret != 0) {
         int i;
-        ALOGI("qcom.bluetooth.soc set to %s\n", bt_soc_type);
+        ALOGI("qcom.bluetooth.soc get to %s\n", bt_soc_type);
         for ( i = BT_SOC_AR3K ; i < BT_SOC_RESERVED ; i++ )
         {
             char* soc_name = soc_type_entries[i].soc_name;
             if (!strcmp(bt_soc_type, soc_name)) {
                 soc_type = soc_type_entries[i].soc_type;
+                ALOGI("LEA_soc_type %d\n", soc_type);
                 break;
             }
         }
     }
+#endif
+#ifdef BT_SOC_TYPE_ROME
+    soc_type = BT_SOC_ROME;
+    return;
+#elif defined(BT_SOC_TYPE_CHEROKEE)
+    soc_type = BT_SOC_CHEROKEE;
+#endif
+   soc_type = BT_SOC_ROME_USB;
+   ALOGI("LEA_soc_type %d\n", soc_type);
 }
 
 /*****************************************************************************
@@ -1125,5 +1252,6 @@ static void init_soc_type()
 *******************************************************************************/
 bt_soc_type get_soc_type()
 {
+    ALOGI("get_soc_type %d\n", soc_type);
     return soc_type;
 }
diff --git a/vendor_libs/linux/Android.mk b/vendor_libs/linux/Android.mk
deleted file mode 100644
index c5b120d..0000000
--- a/vendor_libs/linux/Android.mk
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-#  Copyright (C) 2015 Intel Corporation
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at:
-#
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-#
-
-LOCAL_PATH := $(call my-dir)
-
-ifeq ($(BOARD_HAVE_BLUETOOTH_LINUX), true)
-
-# libbt-vendor shared library for target
-# ========================================================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-        bt_vendor_linux.c
-
-LOCAL_C_INCLUDES += \
-        $(LOCAL_PATH)/../../
-
-LOCAL_SHARED_LIBRARIES := \
-        libcutils
-
-LOCAL_MODULE := libbt-vendor
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS += $(bluetooth_CFLAGS)
-LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
-LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
-
-include $(BUILD_SHARED_LIBRARY)
-
-endif  # BOARD_HAVE_BLUETOOTH_LINUX
diff --git a/vendor_libs/linux/__Android.mk__ b/vendor_libs/linux/__Android.mk__
new file mode 100644
index 0000000..c5b120d
--- /dev/null
+++ b/vendor_libs/linux/__Android.mk__
@@ -0,0 +1,43 @@
+#
+#  Copyright (C) 2015 Intel Corporation
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at:
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+#
+
+LOCAL_PATH := $(call my-dir)
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_LINUX), true)
+
+# libbt-vendor shared library for target
+# ========================================================
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+        bt_vendor_linux.c
+
+LOCAL_C_INCLUDES += \
+        $(LOCAL_PATH)/../../
+
+LOCAL_SHARED_LIBRARIES := \
+        libcutils
+
+LOCAL_MODULE := libbt-vendor
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_CFLAGS += $(bluetooth_CFLAGS)
+LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
+LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif  # BOARD_HAVE_BLUETOOTH_LINUX
diff --git a/vendor_libs/test_vendor_lib/Android.mk b/vendor_libs/test_vendor_lib/Android.mk
deleted file mode 100644
index 3874ef2..0000000
--- a/vendor_libs/test_vendor_lib/Android.mk
+++ /dev/null
@@ -1,77 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-# test-vendor shared library for target
-# ========================================================
-include $(CLEAR_VARS)
-
-BT_DIR := $(TOP_DIR)system/bt
-
-LOCAL_SRC_FILES := \
-    src/bt_vendor.cc \
-    src/command_packet.cc \
-    src/dual_mode_controller.cc \
-    src/event_packet.cc \
-    src/hci_transport.cc \
-    src/packet.cc \
-    src/packet_stream.cc \
-    src/test_channel_transport.cc \
-    src/vendor_manager.cc
-
-# We pull in gtest because base/files/file_util.h, which is used to read the
-# controller properties file, needs gtest/gtest_prod.h.
-LOCAL_C_INCLUDES := \
-    $(LOCAL_PATH)/include \
-    $(BT_DIR) \
-    $(BT_DIR)/hci/include \
-    $(BT_DIR)/stack/include \
-    $(BT_DIR)/third_party/gtest/include
-
-LOCAL_SHARED_LIBRARIES := \
-    liblog \
-    libchrome
-
-LOCAL_CPP_EXTENSION := .cc
-LOCAL_MODULE := test-vendor
-LOCAL_MODULE_TAGS := optional
-LOCAL_MODULE_CLASS := SHARED_LIBRARIES
-
-LOCAL_CFLAGS += $(bluetooth_CFLAGS)
-LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
-LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
-
-include $(BUILD_SHARED_LIBRARY)
-
-# test-vendor unit tests for host
-# ========================================================
-ifeq ($(HOST_OS), linux)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-    src/command_packet.cc \
-    src/event_packet.cc \
-    src/hci_transport.cc \
-    src/packet.cc \
-    src/packet_stream.cc \
-    test/hci_transport_unittest.cc \
-    test/packet_stream_unittest.cc
-
-LOCAL_C_INCLUDES := \
-    $(LOCAL_PATH)/include \
-    $(BT_DIR) \
-    $(BT_DIR)/hci/include \
-    $(BT_DIR)/stack/include
-
-LOCAL_SHARED_LIBRARIES := \
-    liblog \
-    libchrome
-
-LOCAL_CPP_EXTENSION := .cc
-LOCAL_MODULE := test-vendor_test_host
-LOCAL_MODULE_TAGS := tests
-
-LOCAL_CFLAGS += $(bluetooth_CFLAGS)
-LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
-LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
-
-include $(BUILD_HOST_NATIVE_TEST)
-endif
diff --git a/vendor_libs/test_vendor_lib/__Android.mk__ b/vendor_libs/test_vendor_lib/__Android.mk__
new file mode 100644
index 0000000..3874ef2
--- /dev/null
+++ b/vendor_libs/test_vendor_lib/__Android.mk__
@@ -0,0 +1,77 @@
+LOCAL_PATH := $(call my-dir)
+
+# test-vendor shared library for target
+# ========================================================
+include $(CLEAR_VARS)
+
+BT_DIR := $(TOP_DIR)system/bt
+
+LOCAL_SRC_FILES := \
+    src/bt_vendor.cc \
+    src/command_packet.cc \
+    src/dual_mode_controller.cc \
+    src/event_packet.cc \
+    src/hci_transport.cc \
+    src/packet.cc \
+    src/packet_stream.cc \
+    src/test_channel_transport.cc \
+    src/vendor_manager.cc
+
+# We pull in gtest because base/files/file_util.h, which is used to read the
+# controller properties file, needs gtest/gtest_prod.h.
+LOCAL_C_INCLUDES := \
+    $(LOCAL_PATH)/include \
+    $(BT_DIR) \
+    $(BT_DIR)/hci/include \
+    $(BT_DIR)/stack/include \
+    $(BT_DIR)/third_party/gtest/include
+
+LOCAL_SHARED_LIBRARIES := \
+    liblog \
+    libchrome
+
+LOCAL_CPP_EXTENSION := .cc
+LOCAL_MODULE := test-vendor
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := SHARED_LIBRARIES
+
+LOCAL_CFLAGS += $(bluetooth_CFLAGS)
+LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
+LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
+
+include $(BUILD_SHARED_LIBRARY)
+
+# test-vendor unit tests for host
+# ========================================================
+ifeq ($(HOST_OS), linux)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+    src/command_packet.cc \
+    src/event_packet.cc \
+    src/hci_transport.cc \
+    src/packet.cc \
+    src/packet_stream.cc \
+    test/hci_transport_unittest.cc \
+    test/packet_stream_unittest.cc
+
+LOCAL_C_INCLUDES := \
+    $(LOCAL_PATH)/include \
+    $(BT_DIR) \
+    $(BT_DIR)/hci/include \
+    $(BT_DIR)/stack/include
+
+LOCAL_SHARED_LIBRARIES := \
+    liblog \
+    libchrome
+
+LOCAL_CPP_EXTENSION := .cc
+LOCAL_MODULE := test-vendor_test_host
+LOCAL_MODULE_TAGS := tests
+
+LOCAL_CFLAGS += $(bluetooth_CFLAGS)
+LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
+LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
+
+include $(BUILD_HOST_NATIVE_TEST)
+endif

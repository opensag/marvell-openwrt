diff --git a/Android.mk b/Android.mk
old mode 100644
new mode 100755
index 5ad79b6..4726372
--- a/Android.mk
+++ b/Android.mk
@@ -1,6 +1,7 @@
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
+#ifeq (0,1)   # dependency on system/bt/include logging.h change
 LOCAL_MODULE_TAGS := optional
 src_dirs:= src/org/codeaurora/bluetooth/btcservice \
            src/org/codeaurora/bluetooth/ftp \
@@ -29,3 +30,4 @@ include $(BUILD_PACKAGE)
 
 
 include $(call all-makefiles-under,$(LOCAL_PATH))
+#endif
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
old mode 100644
new mode 100755
index 6b2c6d5..ef797a6
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -50,6 +50,8 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     <uses-permission android:name="com.android.email.permission.READ_ATTACHMENT"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.WRITE_MEDIA_STORAGE" />
+    <uses-permission android:name="android.permission.ACCESS_NOTIFICATIONS" />
+    <uses-permission android:name="android.permission.MANAGE_NOTIFICATIONS"/>
     <application android:process="com.android.bluetooth">
         <uses-library android:name="com.quicinc.wbc"
             android:required="false" />
diff --git a/QLogging/Android.mk b/QLogging/Android.mk
index db46b74..42ee686 100644
--- a/QLogging/Android.mk
+++ b/QLogging/Android.mk
@@ -1,3 +1,4 @@
+
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
diff --git a/QLogging/jni/com_android_qlogging_sendIntent.cpp b/QLogging/jni/com_android_qlogging_sendIntent.cpp
index 1b4ccc9..9dbd556 100644
--- a/QLogging/jni/com_android_qlogging_sendIntent.cpp
+++ b/QLogging/jni/com_android_qlogging_sendIntent.cpp
@@ -48,6 +48,8 @@
 #define HCI_GRP_HOST_CONT_BASEBAND_CMDS (0x03 << 10)
 #define HCI_OPCODE_PACK(ogf, ocf) (unsigned short int)((ocf & 0x03ff)|(ogf << 10))
 #define HCI_RESET                       (0x0003 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
+#define PAYLOAD_DATA_SIZE               765
+#define PAYLOAD_LENGTH                  255
 
 namespace android{
 
@@ -55,10 +57,10 @@ static const bt_interface_t *sBluetoothInterface = NULL;
 static const btstacklog_interface_t *sBluetoothLogInterface = NULL;
 
 jint HAL_Load(){
-	jint err;
-	hw_module_t* BT_HW_module;
+        jint err;
+        hw_module_t* BT_HW_module;
 
-	err = hw_get_module(BT_HARDWARE_MODULE_ID,(hw_module_t const**)&BT_HW_module);
+        err = hw_get_module(BT_HARDWARE_MODULE_ID,(hw_module_t const**)&BT_HW_module);
 
         if (err == 0) {
             hw_device_t* stack;
@@ -97,6 +99,7 @@ static void setLogging(JNIEnv* env, jclass clazz,jstring jlog_layer, jint log_le
         else{
             uint8_t values[7] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06};
             const char *log_layer = env->GetStringUTFChars(jlog_layer, 0);
+            const char *vsc_data = env->GetStringUTFChars(jlog_layer, 0);
             if ( module == 3 )
             {
                 ALOGD("Setting SOC log levels.");
@@ -106,9 +109,11 @@ static void setLogging(JNIEnv* env, jclass clazz,jstring jlog_layer, jint log_le
                     set_level = 0xF;
                 else
                     set_level = values[log_level-1];
-
-                uint8_t array[3]={0x11,values[index],set_level};
-                sBluetoothInterface->hci_cmd_send(HCI_OPCODE_PACK(0x3F,0x17),array,3);
+                if ((index < 7) && (index >= 0))
+                {
+                    uint8_t array[3]={0x11,values[index],set_level};
+                    sBluetoothInterface->hci_cmd_send(HCI_OPCODE_PACK(0x3F,0x17),array,3);
+                }
             }
             else if( module == 4)
             {
@@ -138,17 +143,36 @@ static void setLogging(JNIEnv* env, jclass clazz,jstring jlog_layer, jint log_le
                     sBluetoothInterface->hci_cmd_send(HCI_OPCODE_PACK(0x3F,0x17),param,15);
                 }
             }
+            else if (module == 5)
+            {
+                ALOGD("Sending VS Commands.");
+                uint8_t vsc_data_t[PAYLOAD_LENGTH] = {0};
+                char str[PAYLOAD_DATA_SIZE] = {NULL};
+                strlcpy(str,vsc_data,strlen(vsc_data)+1);
+                int count_t = 0;
+                char* token_pointer;
+                char *tmp_token = NULL;
+                token_pointer = strtok_r(str, ",", &tmp_token);
+                while ((NULL != token_pointer) && (count_t < PAYLOAD_LENGTH))
+                {
+                    vsc_data_t[count_t] = (uint8_t)strtol(token_pointer,NULL,16);
+                    token_pointer = strtok_r(NULL, ",", &tmp_token);
+                    count_t++;
+                }
+                ALOGD("Total count:%d ",count_t );
+                sBluetoothInterface->hci_cmd_send(HCI_OPCODE_PACK(0x3F,log_level),vsc_data_t,count_t);
+            }
             else
             {
                 ALOGD("Setting stack log levels.");
-	        sBluetoothLogInterface->setLog(log_layer,log_level);
+                sBluetoothLogInterface->setLog(log_layer,log_level);
             }
         }
     }
 }
 
 static JNINativeMethod sMethods[] = {
-	{"setLogging", "(Ljava/lang/String;II)V", (void *) setLogging}
+    {"setLogging", "(Ljava/lang/String;II)V", (void *) setLogging}
 };
 
 int register_com_android_qlogging_sendIntent(JNIEnv* env)
diff --git a/QLogging/res/drawable/cursor.xml b/QLogging/res/drawable/cursor.xml
new file mode 100644
index 0000000..94bf538
--- /dev/null
+++ b/QLogging/res/drawable/cursor.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!--
+/**********************************************************************
+*
+* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*************************************************************************/
+-->
+
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" >
+    <size android:width="3dip" />
+    <solid android:color="#9C1919"/>
+</shape>
diff --git a/QLogging/res/drawable/error_border.xml b/QLogging/res/drawable/error_border.xml
new file mode 100644
index 0000000..6428386
--- /dev/null
+++ b/QLogging/res/drawable/error_border.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!--
+/**********************************************************************
+*
+* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*************************************************************************/
+-->
+
+<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" >
+    <solid android:color="#f20d3b" />
+    <corners android:radius="5dp" />
+    <stroke android:width="1dip" android:color="#9C1919"/>
+</shape>
diff --git a/QLogging/res/layout/activity_main.xml b/QLogging/res/layout/activity_main.xml
index 4ab7c73..2a87590 100644
--- a/QLogging/res/layout/activity_main.xml
+++ b/QLogging/res/layout/activity_main.xml
@@ -74,5 +74,15 @@
         android:text="@string/soc_text"
         android:padding="15dip"/>
 
+    <Button
+        android:id="@+id/m_vsc_button"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:layout_weight="1"
+        android:onClick="getOptions"
+        android:background="@drawable/border"
+        android:text="@string/m_vsc_text"
+        android:padding="15dip"/>
+
 </LinearLayout>
 
diff --git a/QLogging/res/layout/vendor_log_options.xml b/QLogging/res/layout/vendor_log_options.xml
new file mode 100644
index 0000000..3a33ed0
--- /dev/null
+++ b/QLogging/res/layout/vendor_log_options.xml
@@ -0,0 +1,139 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!--
+/*********************************************************************
+*
+* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+************************************************************************/
+-->
+
+
+    <LinearLayout
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
+        android:layout_width="match_parent"
+        android:orientation="vertical"
+        android:layout_height="match_parent"
+        tools:context=".Main">
+
+        <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:background="@drawable/error_border"
+            android:visibility="invisible"
+            android:id="@+id/error"
+            android:layout_below="@+id/vsc_button"
+            android:layout_centerInParent="true"/>
+        <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:background="@drawable/border_off"
+            android:id="@+id/textView"
+            android:text="@string/ogf_input"
+            android:layout_alignParentTop="true"
+            android:layout_weight="0.19"
+            android:layout_alignParentStart="true" />
+
+        <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:background="@drawable/border_off"
+            android:layout_weight="0.19"
+            android:id="@+id/textView2"
+            android:layout_alignParentTop="true"
+            android:text="@string/ocf_input"
+            android:layout_alignParentStart="true"
+            android:editable="true" />
+
+        <EditText
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:inputType="text"
+            android:background="@drawable/border"
+            android:textCursorDrawable="@drawable/cursor"
+            android:layout_weight="0.19"
+            android:id="@+id/ocfText"
+            android:maxLength="3"
+            android:layout_gravity="center_horizontal" />
+
+        <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:background="@drawable/border_off"
+            android:text="@string/data_input"
+            android:layout_weight="0.19"
+            android:id="@+id/textView3"
+            android:layout_below="@+id/textView"
+            android:layout_toStartOf="@+id/button"
+             />
+
+        <EditText
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:background="@drawable/border"
+            android:textCursorDrawable="@drawable/cursor"
+            android:inputType="textMultiLine"
+            android:lines="5"
+            android:maxLines="5"
+            android:minLines="2"
+            android:scrollbars="vertical"
+            android:gravity="top|left"
+            android:id="@+id/editText"
+            android:focusable="true"
+            android:layout_above="@+id/button"
+            android:layout_alignEnd="@+id/button" />
+
+        <Button
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:background="@drawable/border"
+            android:text="@string/raw_cmd"
+            android:id="@+id/vsc_button"
+            android:textAlignment="center"
+            android:layout_alignParentBottom="true"
+            android:layout_centerHorizontal="true"
+             />
+
+        <Button
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:background="@drawable/border"
+            android:text="@string/reset_cmd"
+            android:id="@+id/reset_button"
+            android:textAlignment="center"
+            android:layout_alignParentBottom="true"
+            android:layout_centerHorizontal="true"
+            android:layout_marginBottom="49dp" />
+    </LinearLayout>
diff --git a/QLogging/res/values/strings.xml b/QLogging/res/values/strings.xml
index d2c1670..22d80b5 100644
--- a/QLogging/res/values/strings.xml
+++ b/QLogging/res/values/strings.xml
@@ -40,6 +40,12 @@
     <string name="profile_text">Profiles</string>
     <string name="stack_text">Stack</string>
     <string name="soc_text">SOC</string>
+    <string name="m_vsc_text">Vendor Specific Command</string>
+    <string name="raw_cmd">SEND VS CMD</string>
+    <string name="reset_cmd">Reset</string>
+    <string name="data_input">DATA: 0x (Enter comma seprated value)</string>
+    <string name="ocf_input">OCF: 0x</string>
+    <string name="ogf_input">OGF: 0x3F</string>
 
     <string name="D">D</string>
     <string name="V">V</string>
diff --git a/QLogging/src/com/android/qlogging/Main.java b/QLogging/src/com/android/qlogging/Main.java
index 3e18166..5b6cac2 100644
--- a/QLogging/src/com/android/qlogging/Main.java
+++ b/QLogging/src/com/android/qlogging/Main.java
@@ -64,6 +64,7 @@ Class to handle the Main activity
     public final static int STACK_MODULE_ID = 2;
     public final static int SOC_MODULE_ID = 3;
     public final static int SOC_ALL_MODULE_ID = 4;
+    public final static int VSC_MODULE_ID = 5;
     public static int log_file_size = 100;
     public static int size_pos = 1;
 
@@ -214,17 +215,21 @@ Class to handle the Main activity
         switch (view.getId()) {
 
             case R.id.profile_button:
-                selected=PROFILE_MODULE_ID;
+                selected = PROFILE_MODULE_ID;
                 Log.v(TAG,"Profile button clicked");
                 break;
             case R.id.stack_button:
-                selected=STACK_MODULE_ID;
+                selected = STACK_MODULE_ID;
                 Log.v(TAG,"Stack button clicked");
                 break;
             case R.id.java_button:
-                selected=SOC_MODULE_ID;
+                selected = SOC_MODULE_ID;
                 Log.v(TAG,"SOC button clicked");
                 break;
+            case R.id.m_vsc_button:
+                selected = VSC_MODULE_ID;
+                Log.v(TAG,"VSC button clicked");
+                break;
         }
         intent.addFlags(selected);
         startActivity(intent);
diff --git a/QLogging/src/com/android/qlogging/VendorOptionView.java b/QLogging/src/com/android/qlogging/VendorOptionView.java
new file mode 100644
index 0000000..f9dd720
--- /dev/null
+++ b/QLogging/src/com/android/qlogging/VendorOptionView.java
@@ -0,0 +1,201 @@
+/*********************************************************************
+*
+* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+************************************************************************/
+
+package com.android.qlogging;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.View;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.widget.CompoundButton;
+import android.widget.RelativeLayout;
+import android.widget.Switch;
+import android.widget.TextView;
+import android.widget.EditText;
+import android.os.CountDownTimer;
+import android.widget.Button;
+import android.util.Log;
+
+public class VendorOptionView extends RelativeLayout {
+/*
+    Class to handle the profile View actions
+*/
+    private EditText edittext;
+    private EditText ocftext;
+    private Button tButton;
+    private Button resetButton;
+    private TextView tview_error;
+    private MalibuCountDownTimer countDownTimer;
+    private static boolean ocf_valid = false;
+    private static boolean payload_valid = false;
+    //Min OCF :0x000
+    private final int OCF_MIN_INT = 0;
+    //Max OCF :0x3FF
+    private final int OCF_MAX_INT = 1023;
+    private final int PAYLOAD_MAX = 255;
+    private final long startTime = 10 * 1000;
+    private final long interval = 1000;
+    private int optionSelected = getSecondoryOptions.selected;
+
+    public VendorOptionView(Context context,AttributeSet attributeSet) {
+        super(context, attributeSet);
+        Resources res = getResources();
+        int value = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 15, res.getDisplayMetrics());
+        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        View rootView =  inflater.inflate(R.layout.vendor_log_options, this,true);
+        tButton = (Button)rootView.findViewById(R.id.vsc_button);
+        resetButton = (Button)rootView.findViewById(R.id.reset_button);
+        edittext = (EditText)rootView.findViewById(R.id.editText);
+        ocftext = (EditText)rootView.findViewById(R.id.ocfText);
+        tview_error = (TextView)rootView.findViewById(R.id.error);
+        countDownTimer = new MalibuCountDownTimer(startTime, interval);
+
+
+        resetButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+            ocftext.setText(null);
+            edittext.setText(null);
+            tview_error.setVisibility(View.INVISIBLE);
+            }
+        });
+
+        // OnClick Listener
+        tButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                String vsc_edittext = edittext.getText().toString();
+                String ocf_edittext = "0x" + ocftext.getText().toString();
+                int ocf_int = 0;
+                int count = 0;
+                int payload = 0;
+                if(ocftext.getText().toString().matches("")) {
+                    tview_error.setVisibility(View.VISIBLE);
+                    tview_error.setText("Enter valid OCF.");
+                    ocftext.setText(null);
+                    return;
+                }
+                try {
+                    ocf_int = Integer.decode(ocf_edittext);
+                } catch (Exception e) {
+                    Log.d(Main.TAG,"OCF decode Exception" + e);
+                    tview_error.setVisibility(View.VISIBLE);
+                    tview_error.setText("Not Valid OCF:" + ocf_edittext);
+                    ocftext.setText(null);
+                    return;
+                }
+                // Check OCF value in 0x0000 - 0x03ff otherwise give error
+                if (ocf_int >= OCF_MIN_INT && ocf_int <= OCF_MAX_INT) {
+                    Log.d(Main.TAG,"Valid OCF command" + ocf_edittext);
+                    ocf_valid = true;
+                    tview_error.setVisibility(View.INVISIBLE);
+                } else {
+                    tview_error.setVisibility(View.VISIBLE);
+                    tview_error.setText("Not Valid OCF:" + ocf_edittext);
+                    ocftext.setText(null);
+                    return;
+                }
+                if (vsc_edittext.matches("") && ocf_valid) {
+                    Log.d(Main.TAG,"payload is empty");
+                    sendIntent.transmitIntent(getContext(), ocf_int, vsc_edittext, Main.VSC_MODULE_ID);
+                    tview_error.setVisibility(View.VISIBLE);
+                    tview_error.setText("VSC Sent");
+                    tButton.setEnabled(false);
+                    countDownTimer.start();
+                    return;
+                }
+                String [] vsc_command = vsc_edittext.split(",");
+                for ( int i = 0; i <= vsc_command.length - 1; i++) {
+                  String data_edittext = "0x" + vsc_command[i].toString();
+                    try {
+                        payload = Integer.decode(data_edittext);
+                    } catch (Exception e) {
+                        Log.d(Main.TAG,"payload decode Exception"+e);
+                        payload_valid = false;
+                        tview_error.setVisibility(View.VISIBLE);
+                        tview_error.setText("Not Valid Data");
+                        return;
+                    }
+
+                    if (payload <= PAYLOAD_MAX  && payload >=0) {
+                        payload_valid = true;
+                        count++;
+                    } else {
+                        payload_valid = false;
+                        tview_error.setVisibility(View.VISIBLE);
+                        tview_error.setText("Not Valid Data");
+                        return;
+                    }
+                }
+                Log.d(Main.TAG,"payload count:" + count);
+                if ( payload_valid && ocf_valid && count <= PAYLOAD_MAX ) {
+                    sendIntent.transmitIntent(getContext(), ocf_int, vsc_edittext, Main.VSC_MODULE_ID);
+                    tview_error.setVisibility(View.VISIBLE);
+                    tview_error.setText("VSC sent");
+                    tButton.setEnabled(false);
+                    countDownTimer.start();
+                } else {
+                    tview_error.setVisibility(View.VISIBLE);
+                    tview_error.setText("Data overflow");
+                }
+           }
+        });
+    }
+
+
+
+    public VendorOptionView(Context context){
+        this(context, null);
+    }
+
+    public class MalibuCountDownTimer extends CountDownTimer {
+        public  MalibuCountDownTimer(long startTime, long interval)
+        {
+            super(startTime, interval);
+        }
+        @Override
+        public void onTick(long millisUntilFinished) {
+            tButton.setText("Active after: " + (millisUntilFinished/1000));
+        }
+        @Override
+        public void onFinish() {
+            tButton.setEnabled(true);
+            tButton.setText("SEND VS CMD");
+        }
+    };
+}
diff --git a/QLogging/src/com/android/qlogging/getSecondoryOptions.java b/QLogging/src/com/android/qlogging/getSecondoryOptions.java
index bf8981e..b5aa0e8 100644
--- a/QLogging/src/com/android/qlogging/getSecondoryOptions.java
+++ b/QLogging/src/com/android/qlogging/getSecondoryOptions.java
@@ -42,6 +42,7 @@ import android.view.MenuItem;
 import android.widget.CheckBox;
 import android.widget.CompoundButton;
 import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
 import android.widget.Space;
 import android.widget.ScrollView;
 import android.widget.TextView;
@@ -62,6 +63,7 @@ public class getSecondoryOptions extends Activity{
     public static int selected=0;
     public static int init_soc = 0;
     public static LinearLayout lv;
+    public static RelativeLayout rl;
     public static ScrollView sv;
     public static String SOC_levels="";
     String mRome ="rome";
@@ -177,6 +179,13 @@ public class getSecondoryOptions extends Activity{
                     titlebarHeading = "SOC log levels";
                 }
                 break;
+
+            case Main.VSC_MODULE_ID:
+                Log.d(Main.TAG, "VSC button clicked");
+                titlebarHeading = "Send VS Command";
+                VendorOptionView vendorOptionView = new VendorOptionView (this);
+                lv.addView(vendorOptionView);
+            break;
         }
 
         try{
diff --git a/bt_logger/Android.mk b/bt_logger/Android.mk
new file mode 100644
index 0000000..e607fb0
--- /dev/null
+++ b/bt_logger/Android.mk
@@ -0,0 +1,16 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=     \
+    src/btsnoop_dump.c    \
+    src/bt_logger.c   \
+    src/bt_log_buffer.c
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/incl
+
+LOCAL_MODULE:= bt_logger
+
+LOCAL_SHARED_LIBRARIES += libcutils
+
+include $(BUILD_EXECUTABLE)
diff --git a/bt_logger/incl/bt_logger.h b/bt_logger/incl/bt_logger.h
new file mode 100644
index 0000000..1a6530e
--- /dev/null
+++ b/bt_logger/incl/bt_logger.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+******************************************************************************/
+
+#define SOCKET_NAME "btloggersock"
+#define MAX_SOCK_CONNECTIONS 4
+#define BT_LOGGER_BUFFER_LIMIT 4250000
+
+typedef struct bt_log_node
+{
+    char *log_str;
+    struct bt_log_node *nxt_node;
+} bt_log_node_t;
+
+typedef struct
+{
+    bt_log_node_t *head;
+    bt_log_node_t *tail;
+    size_t buff_size;
+    size_t max_buff_size;
+    unsigned short pending_pkt_len;
+    unsigned short saved_log_len;
+} bt_log_buffer_t;
+
+void start_snoop_logging();
+void stop_snoop_logging ();
+void pop_head_node(bt_log_buffer_t *log_list, bt_log_node_t **l_node);
+void free_node(bt_log_node_t *l_node);
+size_t append_recovered_data_to_tail(bt_log_buffer_t *log_list, char *buff);
+void create_log_node(bt_log_buffer_t *log_list, bt_log_node_t **ret_node);
+size_t add_data_to_node(bt_log_buffer_t *log_list, bt_log_node_t *l_node, char *l_data, int log_len);
+void add_node_to_list (bt_log_buffer_t *log_list, bt_log_node_t *log_node, size_t log_size);
+void init_list ( bt_log_buffer_t **list, size_t list_max_size );
diff --git a/bt_logger/src/bt_log_buffer.c b/bt_logger/src/bt_log_buffer.c
new file mode 100644
index 0000000..8dc7ab7
--- /dev/null
+++ b/bt_logger/src/bt_log_buffer.c
@@ -0,0 +1,160 @@
+/******************************************************************************
+Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+******************************************************************************/
+
+#define LOG_TAG "bt_logger_buffer"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <cutils/sockets.h>
+#include <sys/socket.h>
+#include <pthread.h>
+#include <netinet/in.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <utils/Log.h>
+#include "bt_logger.h"
+
+#define PACKET_LEN_STR 4
+
+void create_log_node(bt_log_buffer_t *log_list, bt_log_node_t **ret_node)
+{
+    bt_log_node_t *log_node = NULL;
+
+    if (log_list->buff_size > log_list->max_buff_size) {
+        pop_head_node(log_list, &log_node);
+        if (log_node) {
+            log_node->nxt_node = NULL;
+            free(log_node->log_str);
+            *ret_node = log_node;
+            return;
+        }
+    }
+
+    log_node = (bt_log_node_t*)calloc(1, sizeof(bt_log_node_t));
+
+    if (log_node == NULL) {
+        ALOGE("Allocation failed for bt_log_node_t, returning!");
+        return;
+    }
+
+    *ret_node = log_node;
+}
+
+size_t add_data_to_node(bt_log_buffer_t *log_list, bt_log_node_t *l_node, char *l_data, int log_len)
+{
+    char *log_msg;
+
+    log_msg = (char*)calloc(log_len + 1, sizeof(char));
+    if (log_msg == NULL) {
+        ALOGE("Allocation failed for log_msg, returning!");
+        return 0;
+    }
+
+    log_list->saved_log_len = strlcpy(log_msg, l_data, log_len + 1);
+    l_node->log_str = log_msg;
+
+    if (log_len > log_list->saved_log_len) {
+        log_list->pending_pkt_len = log_len - log_list->saved_log_len;
+    }
+
+    return ((log_len + 1) * sizeof(char));
+}
+
+void add_node_to_list(bt_log_buffer_t *log_list, bt_log_node_t *log_node, size_t log_size)
+{
+    if (log_list->head == NULL) {
+        log_list->head = log_node;
+        log_list->tail = log_node;
+        log_list->buff_size = log_size;
+    }else  {
+        log_list->tail->nxt_node = log_node;
+        log_list->tail = log_node;
+
+        if (log_list->buff_size < log_list->max_buff_size)
+            log_list->buff_size += log_size;
+    }
+}
+
+void init_list( bt_log_buffer_t **list, size_t list_max_size )
+{
+    bt_log_buffer_t *log_list = malloc(sizeof(bt_log_buffer_t));
+
+    if (log_list) {
+        log_list->head = NULL;
+        log_list->tail = NULL;
+        log_list->max_buff_size =  list_max_size;
+        log_list->buff_size =  0;
+        log_list->pending_pkt_len =  0;
+        log_list->saved_log_len =  0;
+        *list = log_list;
+    }else  {
+        ALOGE("Allocation failed for list creation");
+    }
+}
+
+
+size_t append_recovered_data_to_tail(bt_log_buffer_t *log_list, char *buff)
+{
+    size_t ret = 0;
+
+    if (log_list->pending_pkt_len) {
+        strlcpy(&log_list->tail->log_str[log_list->saved_log_len], buff,
+            log_list->pending_pkt_len + 1);
+        ret = log_list->pending_pkt_len;
+        log_list->pending_pkt_len = 0;
+    }
+    return ret;
+}
+
+void pop_head_node(bt_log_buffer_t *log_list, bt_log_node_t **l_node)
+{
+    if (log_list->head) {
+        *l_node = log_list->head;
+        log_list->head = log_list->head->nxt_node;
+
+        if (log_list->head == NULL)
+            log_list->tail = NULL;
+    }else  {
+        *l_node = NULL;
+    }
+}
+
+void free_node(bt_log_node_t *l_node)
+{
+    free(l_node->log_str);
+    free(l_node);
+    l_node = NULL;
+}
diff --git a/bt_logger/src/bt_logger.c b/bt_logger/src/bt_logger.c
new file mode 100644
index 0000000..d5cc3eb
--- /dev/null
+++ b/bt_logger/src/bt_logger.c
@@ -0,0 +1,467 @@
+/******************************************************************************
+Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+******************************************************************************/
+
+#define LOG_TAG "bt_logger"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <cutils/sockets.h>
+#include <sys/socket.h>
+#include <pthread.h>
+#include <netinet/in.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <utils/Log.h>
+#include <signal.h>
+#include <private/android_filesystem_config.h>
+#include <android/log.h>
+#include <cutils/log.h>
+
+#include "bt_logger.h"
+
+#define SOCKET_NAME "btloggersock"
+#define BTLOGGER_PATH "/data/media/0"
+#define VND_LOG_FILENAME "bt_vnd_log"
+#define MAX_LOG_FILES        (3)
+#define MAX_READ_LEN         (2048)
+#define MAX_FILE_NAME_SIZE   (100)
+#define PAYLOAD_OFFSET       (3)
+#define MAX_LOG_STR_LEN      (512)
+#define LEN_OFFSET           (1)
+#define TYPE_OFFSET          (0)
+
+// Re-run |fn| system call until the system call doesn't cause EINTR.
+#define BTLOG_NO_INTR(fn)  do {} while ((fn) == -1 && errno == EINTR)
+/*____________________________________________________________________
+    CONSTANTS
+   ____________________________________________________________________*/
+typedef enum  {
+    VENDOR_LOGGER_LOGS = 201,       // Signifies Packet containing Logger Log
+    GENERATE_VND_LOG_SIGNAL,        // Signifies command to generate logs
+    START_SNOOP_SIGNAL,
+    STOP_SNOOP_SIGNAL,
+    STOP_LOGGING_SIGNAL,
+} CommandTypes;
+
+/*____________________________________________________________________
+    VARIABLES
+   ____________________________________________________________________*/
+static int file_descriptor = -1, server_socket = -1;
+static int sock_client[MAX_SOCK_CONNECTIONS] = { -1 };
+fd_set sock_fds;
+static bt_log_buffer_t *log_list = NULL;
+static short int looper;
+static pthread_t dump_logs_t = -1;
+static unsigned char pending_dump = 0;
+
+/*____________________________________________________________________
+    FUNCTIONS
+   ____________________________________________________________________*/
+
+void listen_data(void);
+void process_incoming_data(bt_log_buffer_t *log_list, char *buff, int buff_len);
+void dump_logs();
+int process_packet(bt_log_buffer_t *log_list, char *l_data, short int pkt_len);
+void dump_log_to_logcat(void);
+
+int create_server_socket()
+{
+    FD_ZERO(&sock_fds);
+    BTLOG_NO_INTR(server_socket = socket(AF_LOCAL, SOCK_STREAM, 0));
+    if (server_socket < 0) {
+        ALOGE("%s, socket creation failed", __func__);
+        return -1;
+    }
+
+    FD_SET(server_socket, &sock_fds);
+
+    if (socket_local_server_bind(server_socket, SOCKET_NAME,
+                     ANDROID_SOCKET_NAMESPACE_ABSTRACT) < 0) {
+        ALOGE("%s, socket_local_server_bind failed: %s", __func__, strerror(errno));
+        return -1;
+    }
+
+    if (listen(server_socket, MAX_SOCK_CONNECTIONS) < 0) {
+        ALOGE("%s, listen failed", __func__);
+        close(server_socket);
+        return -1;
+    }
+    return 0;
+}
+
+static void SignalHandler(int sig)
+{
+    ALOGE("SignalHandler: Got the signal %d", sig);
+    pending_dump = 1;
+}
+
+int main(int argc, char * argv[])
+{
+    int i = 0;
+
+    ALOGE("main: logger process");
+    /* set the file creation mask to allow read/write */
+    umask(0111);
+
+    // initialize signal handler
+    signal(SIGUSR1, SignalHandler);
+
+    if (create_server_socket()) {
+        return -1;
+    }
+
+    ALOGE("main: socket created");
+    listen_data();
+
+    if (dump_logs_t != -1) {
+        pthread_join(dump_logs_t, NULL);
+    }
+    // TODO free all entries
+    close(server_socket);
+    for (i = 0; i < MAX_SOCK_CONNECTIONS; i++) {
+        if (sock_client[i] != -1) {
+            close(sock_client[i]);
+        }
+    }
+    return 0;
+}
+
+void listen_data(void)
+{
+    int max_fd = -1, retval, read_len, i, s_fd, sock_len;
+    struct sockaddr_un cliaddr;
+    socklen_t addrlen;
+    char buff[MAX_READ_LEN + 1];
+
+    looper = 1;
+    init_list(&log_list, BT_LOGGER_BUFFER_LIMIT);
+
+    if (!log_list) {
+        return;
+    }
+    while (looper) {
+
+        FD_ZERO(&sock_fds);
+
+        FD_SET(server_socket, &sock_fds);
+        max_fd = server_socket;
+
+        if (pending_dump) {
+            dump_logs();
+            pending_dump = 0;
+        }
+
+        for (i = 0; i < MAX_SOCK_CONNECTIONS; i++) {
+            s_fd = sock_client[i];
+            if (s_fd > 0) {
+                FD_SET(s_fd, &sock_fds);
+                if (s_fd > max_fd)
+                    max_fd = s_fd;
+            }
+        }
+
+        retval = select(max_fd + 1, &sock_fds, NULL, NULL, NULL);
+        if ( retval < 0 ) {
+            if (errno != EINTR) {
+                ALOGE("%s, Select exit with error: %s", __func__, strerror(errno));
+                goto cleanup;
+            }else  {
+                continue;
+            }
+        }
+
+        if (FD_ISSET(server_socket, &sock_fds)) {
+            int new_client;
+            addrlen = sizeof(cliaddr);
+            BTLOG_NO_INTR(new_client = accept(server_socket, (struct sockaddr*)&cliaddr, &addrlen));
+            if (new_client == -1) {
+                if (errno == EINVAL || errno == EBADF) {
+                    ALOGE("%s, Logger Process: Error while connecting to client: %s", __func__, strerror(errno));
+                    break;
+                }
+                // print error here
+                continue;
+            }
+            for (i = 0; i < MAX_SOCK_CONNECTIONS; i++) {
+                if (sock_client[i] == -1) {
+                    ALOGE("%s, Logger Process: Client socket connected %d", __func__, new_client);
+                    sock_client[i] = new_client;
+                    if (new_client > max_fd)
+                        max_fd = new_client;
+                    break;
+                }
+            }
+            if ( i == MAX_SOCK_CONNECTIONS) {
+                close(new_client);
+            }
+            continue;
+        }
+
+        for (i = 0; i < MAX_SOCK_CONNECTIONS; i++) {
+            s_fd = sock_client[i];
+            if (FD_ISSET(s_fd, &sock_fds)) {
+                BTLOG_NO_INTR(read_len = recv(s_fd, buff, MAX_READ_LEN, 0));
+                if ( read_len > 0) { // comment : intr error code
+                    process_incoming_data(log_list, buff, read_len);
+                }else  {
+                    ALOGE("%s, Error Reading Data", __func__);
+                    close(s_fd);
+                    sock_client[i] = -1;
+                    dump_log_to_logcat();
+                    looper = 0;
+                }
+            }
+        }
+    }
+
+ cleanup:
+    return;
+}
+
+int process_packet(bt_log_buffer_t *log_list, char *l_data, short int pkt_len)
+{
+    int ret = 0;
+
+    // process pending data if any
+
+    switch (l_data[TYPE_OFFSET]) {
+    case VENDOR_LOGGER_LOGS:
+    {
+        unsigned short int log_len;
+        bt_log_node_t *log_node = NULL;
+        size_t log_size;
+
+        if(pkt_len < PAYLOAD_OFFSET) {
+            ALOGE("Logger Process: Invalid packet with no length field");
+            break;
+        }
+
+        log_len = *(( unsigned short*)(&l_data[LEN_OFFSET]));
+        if (log_len == 0 || log_len > MAX_LOG_STR_LEN) {
+            ALOGE("Logger Process: log_len = %d, returning", log_len);
+            break;
+        }
+
+        create_log_node(log_list, &log_node);
+        if (!log_node)
+            break;
+
+        log_size = add_data_to_node(log_list, log_node, &l_data[PAYLOAD_OFFSET], log_len);
+        // handle the error cases
+        if (!log_size) {
+            if (log_node)
+                free(log_node);
+            break;
+        }
+
+        add_node_to_list(log_list, log_node, log_size);
+
+        ret = log_len + PAYLOAD_OFFSET;
+    }
+    break;
+
+    case GENERATE_VND_LOG_SIGNAL:
+        dump_logs();
+        ret = 1;
+        break;
+
+    case START_SNOOP_SIGNAL:
+        start_snoop_logging();
+        ret = 1;
+        break;
+
+    case STOP_SNOOP_SIGNAL:
+        stop_snoop_logging();
+        ret = 1;
+        break;
+
+    case STOP_LOGGING_SIGNAL:
+        looper = 0;
+        ret = 1;
+        break;
+    }
+    return ret;
+}
+
+void process_incoming_data(bt_log_buffer_t *log_list, char *buff, int buff_len)
+{
+    int proc_len = 0;
+
+    buff[buff_len] = '\0';
+
+    proc_len = append_recovered_data_to_tail(log_list, buff);
+
+    while (buff_len > proc_len) {
+        int len = 0;
+        len = process_packet(log_list, &buff[proc_len], buff_len - proc_len);
+
+        if (len == 0) {
+            ALOGE("Error saving packet, buff = %s", buff);
+            break;
+        }
+
+        proc_len += len;
+    }
+}
+
+int vnd_log_file_name(char *log_file_name)
+{
+    struct tm *tmp;
+    time_t t;
+    char time_string[64];
+    struct DIR* p_dir;
+    struct dirent* p_dirent;
+    unsigned short int vndlog_file_count = 0, old_file_index = 0;
+    char file_name[MAX_LOG_FILES][MAX_FILE_NAME_SIZE];
+
+    p_dir = opendir(BTLOGGER_PATH);
+    if (p_dir == NULL) {
+        ALOGE("Unable to open the Dir %s", BTLOGGER_PATH);
+        return -1;
+    }
+
+    while ((p_dirent = readdir(p_dir)) != NULL) {
+        short int ret;
+
+        if ((ret = strncmp(p_dirent->d_name, VND_LOG_FILENAME, strlen(VND_LOG_FILENAME))) == 0) {
+            vndlog_file_count++;
+        }
+
+        if (vndlog_file_count > MAX_LOG_FILES) {
+            ALOGE("Error More than %d BT vnd log files found, ABORT!", MAX_LOG_FILES);
+            return -1;
+        }else if (!ret) {
+            strlcpy(file_name[vndlog_file_count - 1], p_dirent->d_name, MAX_FILE_NAME_SIZE);
+            if (old_file_index != (vndlog_file_count - 1) && strncmp(file_name[vndlog_file_count - 1], file_name[old_file_index], MAX_FILE_NAME_SIZE) < 0) {
+                old_file_index = vndlog_file_count - 1;
+            }
+        }
+    }
+    closedir(p_dir);
+
+    if (vndlog_file_count == MAX_LOG_FILES) {
+        char del_file[MAX_FILE_NAME_SIZE];
+        snprintf(del_file, MAX_FILE_NAME_SIZE, BTLOGGER_PATH "/%s", file_name[old_file_index]);
+        ALOGE("Deleting old log file %s", del_file);
+        unlink(del_file);
+    }
+
+    t = time(NULL);
+    tmp = localtime(&t);
+    if (tmp == NULL) {
+        ALOGE("Error : get localtime");
+        return -1;
+    }
+
+    if (strftime(time_string, 64, "%Y%m%d%H%M%S", tmp) == 0) {
+        ALOGE("Error : strftime :");
+        return -1;
+    }
+    snprintf(log_file_name, MAX_FILE_NAME_SIZE, BTLOGGER_PATH "/%s%s.txt", VND_LOG_FILENAME, time_string);
+    return 0;
+}
+
+void *log_dump_thread(void *param)
+{
+    int fd = -1, ret = -1;
+    bt_log_node_t *l_node = NULL;
+    char file_name[MAX_FILE_NAME_SIZE];
+    bt_log_buffer_t * log_list = (bt_log_buffer_t*)param;
+
+    if (!log_list || log_list->head == NULL) {
+        ALOGE("No Log to Dump to file");
+        goto exit;
+        return NULL;
+    }
+
+    if (vnd_log_file_name(file_name)) {
+        ALOGE("Error in creating file name");
+        goto exit;
+        return NULL;
+    }
+
+    BTLOG_NO_INTR(fd = open(file_name, \
+                O_WRONLY | O_CREAT | O_TRUNC, \
+                S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH));
+
+    if (fd < -1) {
+        ALOGE("Unable to open log file");
+    }
+    ALOGE("Writing logs to file");
+
+    while (log_list->head) {
+        pop_head_node(log_list, &l_node);
+        BTLOG_NO_INTR(ret = write(fd, l_node->log_str, strlen(l_node->log_str)));
+        BTLOG_NO_INTR(ret = write(fd, "\n", 1));
+        free_node(l_node);
+    }
+
+    free(log_list);
+    close(fd);
+ exit:
+    dump_logs_t = -1;
+    return NULL;
+}
+
+void dump_logs()
+{
+    if (dump_logs_t != -1) {
+        ALOGE("Dump thread is already running, return");
+        return;
+    }
+    if (pthread_create(&dump_logs_t, NULL, log_dump_thread, ( void*)log_list)) {
+        ALOGE("ERROR creating log dump thread");
+    }else  {
+        init_list(&log_list, BT_LOGGER_BUFFER_LIMIT);
+    }
+}
+
+void dump_log_to_logcat()
+{
+    bt_log_node_t *l_node = NULL;
+
+    if (!log_list || log_list->head == NULL) {
+        ALOGE("No Log to Dump to file");
+        return;
+    }
+
+    while (log_list->head) {
+        pop_head_node(log_list, &l_node);
+        ALOGE("%s", l_node->log_str);
+        free_node(l_node);
+    }
+    free(log_list);
+}
diff --git a/bt_logger/src/btsnoop_dump.c b/bt_logger/src/btsnoop_dump.c
new file mode 100644
index 0000000..93f20f4
--- /dev/null
+++ b/bt_logger/src/btsnoop_dump.c
@@ -0,0 +1,404 @@
+/******************************************************************************
+Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+******************************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <pthread.h>
+#include <stdbool.h>
+
+#include <private/android_filesystem_config.h>
+#include <android/log.h>
+
+#include <cutils/log.h>
+
+#define MAX_FILE_SIZE 1024*1024*20
+
+#define LOGD0(t,s) __android_log_write(ANDROID_LOG_DEBUG, t, s)
+
+static int file_descriptor = -1;
+uint32_t file_size = 0;
+pthread_t snoop_client_tid = -1;
+int btsnoop_socket = -1;
+
+#define LOCAL_SOCKET_NAME "bthcitraffic"
+#define BTSNOOP_PATH "/data/media/0"
+#define BTSOOP_PORT 8872
+
+//#define __SNOOP_DUMP_DBG__
+
+static void snoop_log(const char *fmt_str, ...)
+{
+    static char buffer[1024];
+    va_list ap;
+
+    va_start(ap, fmt_str);
+    vsnprintf(buffer, 1024, fmt_str, ap);
+    va_end(ap);
+
+    LOGD0("btsnoop_dump: ", buffer);
+}
+
+int btsnoop_file_name (char file_name[256])
+{
+    struct tm *tmp;
+    time_t t;
+    char time_string[64];
+
+    t = time(NULL);
+    tmp = localtime(&t);
+    if (tmp == NULL)
+    {
+        snoop_log("Error : get localtime");
+        return -1;
+    }
+
+    if (strftime(time_string, 64, "%Y%m%d%H%M%S", tmp) == 0)
+    {
+        snoop_log("Error : strftime :");
+        return -1;
+    }
+    snprintf(file_name, 256, BTSNOOP_PATH"/hci_snoop%s.cfa", time_string);
+    return 0;
+}
+
+int snoop_open_file (void)
+{
+    char file_name[2][256];
+    int snoop_files_found = 0;
+    struct DIR* p_dir;
+    struct dirent* p_dirent;
+
+    p_dir = opendir(BTSNOOP_PATH);
+    if(p_dir == NULL)
+    {
+        snoop_log("snoop_log_open: Unable to open the Dir entry\n");
+        file_descriptor = -1;
+        return -1;
+    }
+    while ((p_dirent = readdir(p_dir)) != NULL)
+    {
+        int ret;
+
+        if ((ret = strncmp(p_dirent->d_name, "hci_snoop", strlen("hci_snoop"))) == 0)
+        {
+            snoop_files_found++;
+        }
+        if (snoop_files_found > 2)
+        {
+            snoop_log("snoop_log_open: Error : More than two snoop files : Abort");
+            file_descriptor = -1;
+            return -1;
+        }
+        else if (ret == 0)
+        {
+            strlcpy(file_name[snoop_files_found - 1], p_dirent->d_name, 256);
+#ifdef __SNOOP_DUMP_DBG__
+            snoop_log("snoop_log_open: snoop file found : %s", file_name[snoop_files_found - 1]);
+#endif //__SNOOP_DUMP_DBG__
+        }
+    }
+    closedir(p_dir);
+    if (snoop_files_found == 2)
+    {
+        char del_file[256];
+
+        /* Delete the oldest File */
+        if (strncmp(file_name[0], file_name[1], 256) < 0)
+        {
+            snprintf(del_file, 256, BTSNOOP_PATH"/%s", file_name[0]);
+#ifdef __SNOOP_DUMP_DBG__
+            snoop_log("snoop_log_open: old file to delete : %s", del_file);
+#endif //__SNOOP_DUMP_DBG__
+            unlink(del_file);
+        }
+        else
+        {
+            snprintf(del_file, 256, BTSNOOP_PATH"/%s", file_name[1]);
+#ifdef __SNOOP_DUMP_DBG__
+            snoop_log("snoop_log_open: old file to delete : %s", del_file);
+#endif //__SNOOP_DUMP_DBG__
+            unlink(del_file);
+        }
+    }
+
+    if (btsnoop_file_name(file_name[0]) != 0)
+    {
+        snoop_log("snoop_log_open: error : could not get snoop file name !!");
+        return -1;
+    }
+
+    snoop_log("snoop_log_open: new file : %s", file_name[0]);
+    file_descriptor = open(file_name[0], \
+                              O_WRONLY|O_CREAT|O_TRUNC, \
+                              S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH);
+    if (file_descriptor == -1)
+    {
+        snoop_log("snoop_log_open: Unable to open snoop log file\n");
+        file_descriptor = -1;
+        return -1;
+    }
+
+    file_size = 0;
+    write(file_descriptor, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
+    return 0;
+}
+
+int snoop_connect_to_source (void)
+{
+    struct sockaddr_un serv_addr;
+
+    int ret, retry_count = 0, addr_len;
+
+    snoop_log("snoop_connect_to_source :");
+    /* Create Socket to connect to BT Traffic source*/
+    btsnoop_socket = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (btsnoop_socket < 0)
+    {
+        snoop_log("Can't create client socket : %s\n", strerror(errno));
+        return -1;
+    }
+    else
+    {
+        memset(&serv_addr, 0, sizeof(serv_addr));
+        serv_addr.sun_family = AF_LOCAL;
+        strlcpy(&serv_addr.sun_path[1], LOCAL_SOCKET_NAME, strlen(LOCAL_SOCKET_NAME) + 1);
+        addr_len =  strlen(LOCAL_SOCKET_NAME) + 1;
+        addr_len += sizeof(serv_addr.sun_family);
+        do
+        {
+            ret = connect(btsnoop_socket, &serv_addr, addr_len);
+            if (ret < 0)
+            {
+                snoop_log("Can't connect to BT traffic source : %s\n",strerror(errno));
+                retry_count++;
+                sleep (1);
+            }
+        } while((ret < 0) && (retry_count < 10));
+
+        if (ret < 0)
+        {
+            close(btsnoop_socket);
+            return -1;
+        }
+
+        snoop_log("Connected to bthcitraffic : sock fd : %d", btsnoop_socket);
+        return btsnoop_socket;
+    }
+}
+
+int read_block (int sock, unsigned char *pBuf, int len)
+{
+    int bytes_recv = 0, ret;
+    do
+    {
+#ifdef __SNOOP_DUMP_DBG__
+        snoop_log("read_block : waiting to read");
+#endif //__SNOOP_DUMP_DBG__
+
+        ret = recv(sock, &pBuf[bytes_recv], len - bytes_recv, 0);
+#ifdef __SNOOP_DUMP_DBG__
+        snoop_log("read_block : read returned %d", ret);
+#endif //__SNOOP_DUMP_DBG__
+        if ( (ret == -1) && (errno != EAGAIN) )
+        {
+            bytes_recv = ret;
+            snoop_log("Error Packet header : Connection Closed : %s\n", strerror(errno));
+            break;
+        }
+        else if (ret == 0)
+        {
+            snoop_log("Disconnected from bthcitraffic : Exiting...");
+            close (sock);
+            break;
+        }
+        bytes_recv += ret;
+    } while(bytes_recv < len);
+
+#ifdef __SNOOP_DUMP_DBG__
+    snoop_log("bytes read = %d", bytes_recv);
+#endif //__SNOOP_DUMP_DBG__
+    return bytes_recv;
+}
+
+static unsigned char read_buf[1200];
+
+int snoop_process (int sk)
+{
+    int bytes_recv = 0;
+    struct stat st;
+    uint32_t sizeoffile = 0, length;
+
+    if (file_descriptor == -1)
+    {
+        if (snoop_open_file() != 0)
+        {
+            return -1;
+        }
+    }
+
+/*
+    24 Bytes snoop Header
+    Initial 4 bytes have the length of the HCI packet
+    Read 8 bytes which have orignal length and included length
+*/
+    bytes_recv = read_block (sk, &read_buf[0], 8);
+    if ((bytes_recv == 0) || (bytes_recv == -1))
+    {
+        snoop_log("Error in reading the Header : ");
+        return -1;
+    }
+
+    length = read_buf[0] << 24 | read_buf[1] << 16 | read_buf[2] << 8 | read_buf[3];
+
+#if 1
+#ifdef __SNOOP_DUMP_DBG__
+    snoop_log("Length of Frame %ld : byte %0x %0x %0x %0x", length,
+        read_buf[0], read_buf[1], read_buf[2], read_buf[3]);
+
+    snoop_log("File Size = %d", file_size);
+#endif //__SNOOP_DUMP_DBG__
+
+    if (file_size > MAX_FILE_SIZE)
+    {
+        if (file_descriptor != -1)
+        {
+            close(file_descriptor);
+            file_descriptor = -1;
+            if (snoop_open_file() != 0)
+            {
+                return -1;
+            }
+        }
+    }
+#endif
+
+/*
+    Read rest of snoop header(16 Bytes) and HCI Packet
+*/
+    bytes_recv = read_block (sk, &read_buf[8], length + 16);
+    if ((bytes_recv == 0) || (bytes_recv == -1))
+    {
+        snoop_log("Error reading snoop packet : ");
+        return -1;
+    }
+
+    file_size += (bytes_recv + 8);
+
+    write(file_descriptor, read_buf, bytes_recv + 8);
+
+    return 0;
+}
+
+void *snoop_dump_thread( void *context)
+{
+    int sk, ret, bytes_recv;
+
+    snoop_log ("snoop_dump_thread starting");
+
+    sk = snoop_connect_to_source();
+
+/*
+       16 Bytes : Read and discard snoop file header
+*/
+    bytes_recv = read_block (sk, &read_buf[0], 16);
+    if ((bytes_recv == 0) || (bytes_recv == -1))
+    {
+        snoop_log("Error in reading the snoop file Header : ");
+        exit(0);
+    }
+
+    if (snoop_open_file() != 0)
+    {
+        exit(0);
+    }
+
+    if (sk != -1)
+    {
+        do
+        {
+            ret = snoop_process(sk);
+        } while(ret != -1);
+    }
+
+    snoop_log("snoop_dump_thread  terminated");
+    return NULL;
+}
+
+void start_snoop_logging ()
+{
+    bool snoop_thread_valid = false;
+
+    snoop_log("starting snoop logging");
+    snoop_thread_valid = (pthread_create(&snoop_client_tid, NULL, snoop_dump_thread, NULL) == 0);
+
+    if (!snoop_thread_valid) {
+        snoop_log("pthread_create failed: %s", strerror(errno));
+    } else {
+        snoop_log(" snoop_dump_thread is initialized");
+    }
+}
+
+static void close_fd(int *fd) {
+  if (*fd != -1) {
+    close(*fd);
+    *fd = -1;
+  }
+}
+
+void snoop_thread_cleanup()
+{
+  close_fd(&file_descriptor);
+  if (btsnoop_socket != -1) {
+    shutdown(btsnoop_socket, SHUT_RDWR);
+    close_fd(&btsnoop_socket);
+  }
+}
+
+void stop_snoop_logging ()
+{
+  if ( snoop_client_tid != -1)
+  {
+    snoop_log(" stop_snoop_logging is called");
+    snoop_thread_cleanup();
+    pthread_join(snoop_client_tid, NULL);
+    snoop_client_tid = -1;
+  }
+}
diff --git a/btconfig/Android.mk b/btconfig/Android.mk
new file mode 100644
index 0000000..c8c02af
--- /dev/null
+++ b/btconfig/Android.mk
@@ -0,0 +1,20 @@
+#ifeq ($(BOARD_HAVE_BLUETOOTH),true)
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_C_INCLUDES := system/bt/hci/include
+
+LOCAL_SRC_FILES:= \
+              btconfig.c
+
+LOCAL_MULTILIB := 32
+LOCAL_MODULE_TAGS := debug optional
+LOCAL_MODULE :=btconfig
+
+LOCAL_SHARED_LIBRARIES += libcutils   \
+                          libutils    \
+                          libdl
+
+include $(BUILD_EXECUTABLE)
+#endif
diff --git a/btconfig/Makefile b/btconfig/Makefile
new file mode 100644
index 0000000..5dfdb7c
--- /dev/null
+++ b/btconfig/Makefile
@@ -0,0 +1,11 @@
+CC := gcc
+
+all: btconfig
+
+btconfig: btconfig.c
+	$(CC) -Wall -g btconfig.c -o btconfig
+	#	cp btconfig /usr/bin
+clean:
+	rm btconfig
+	rm /usr/bin/btconfig
+
diff --git a/btconfig/btconfig.c b/btconfig/btconfig.c
new file mode 100644
index 0000000..fcf20a6
--- /dev/null
+++ b/btconfig/btconfig.c
@@ -0,0 +1,7543 @@
+/*
+ * Copyright (c) 2013,2016 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of The Linux Foundation nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <dlfcn.h>
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <linux/un.h>
+#include <sys/time.h>
+#include <linux/types.h>
+#include <endian.h>
+#include <byteswap.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <stdbool.h>
+
+#ifdef ANDROID
+#include <cutils/properties.h>
+#include <termios.h>
+#include "bt_vendor_lib.h"
+#else
+#include <sys/termios.h>
+#include <sys/ioctl.h>
+#include <limits.h>
+#endif
+
+#include "btconfig.h"
+#include "masterblaster.h"
+
+
+#define PRONTO_SOC TRUE
+#define QCA_DEBUG TRUE
+#define Inquiry_Complete_Event  0x01
+
+#define WDS_SOCK "wdssock"
+
+static char prop[100] = {0};
+static char soc_type[100] = {0};
+static bool nopatch = true;
+static int g_rome_ver = 0;
+bool is_qca_transport_uart = false;
+
+#ifdef ANDROID
+static bt_vendor_interface_t * p_btf=NULL;
+#endif
+void baswap(bdaddr_t *dst, const bdaddr_t *src)
+{
+	register unsigned char *d = (unsigned char *) dst;
+	register const unsigned char *s = (const unsigned char *) src;
+	register int i;
+
+	for (i = 0; i < 6; i++)
+		d[i] = s[5-i];
+}
+
+int bachk(const char *str)
+{
+	if (!str)
+		return -1;
+
+	if (strlen(str) != 17)
+		return -1;
+
+	while (*str) {
+		if (!isxdigit(*str++))
+			return -1;
+
+		if (!isxdigit(*str++))
+			return -1;
+
+		if (*str == 0)
+			break;
+
+		if (*str++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+int ba2str(const bdaddr_t *ba, char *str)
+{
+	return snprintf(str, 18,"%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+			ba->b[5], ba->b[4], ba->b[3], ba->b[2], ba->b[1], ba->b[0]);
+}
+
+int str2ba(const char *str, bdaddr_t *ba)
+{
+	bdaddr_t b;
+	int i;
+
+	if (bachk(str) < 0) {
+		memset(ba, 0, sizeof(*ba));
+		return -1;
+	}
+
+	for (i = 0; i < 6; i++, str += 3)
+		b.b[i] = strtol(str, NULL, 16);
+
+	baswap(ba, &b);
+
+	return 0;
+}
+
+/* Redefine a small buffer for our simple text config files */
+#undef BUFSIZ
+#define BUFSIZ 128
+
+ssize_t
+getline(char ** __restrict buf, size_t * __restrict buflen,
+		FILE * __restrict fp)
+{
+	size_t bytes, newlen;
+	char *newbuf, *p;
+
+	if (buf == NULL || buflen == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (*buf == NULL)
+		*buflen = 0;
+
+	bytes = 0;
+	do {
+		if (feof(fp))
+			break;
+		if (*buf == NULL || bytes != 0) {
+			newlen = *buflen + BUFSIZ;
+			newbuf = realloc(*buf, newlen);
+			if (newbuf == NULL)
+				return -1;
+			*buf = newbuf;
+			*buflen = newlen;
+		}
+		p = *buf + bytes;
+		memset(p, 0, BUFSIZ);
+		if (fgets(p, BUFSIZ, fp) == NULL)
+			break;
+		bytes += strlen(p);
+	} while (bytes == 0 || *(*buf + (bytes - 1)) != '\n');
+	if (bytes == 0)
+		return -1;
+	return bytes;
+}
+
+#ifdef QCA_DEBUG
+static int qca_debug_dump(uint8_t *cmd, int size)
+{
+	int i;
+
+	printf("dump : ");
+	for (i = 0; i < size; i++)
+		printf(" %02x", cmd[i]);
+	printf("\n");
+
+	return 0;
+}
+#endif
+
+/* Global Variables */
+//static int Patch_Count = 0;
+static BOOL CtrlCBreak = FALSE;
+bdaddr_t BdAddr;
+/* Function Declarations */
+static void LoadPSHeader(UCHAR *HCI_PS_Command,UCHAR opcode,int length,int index);
+static BOOL SU_LERxTest(int uart_fd, UCHAR channel);
+static BOOL SU_LETxTest(int uart_fd, UCHAR channel, UCHAR length, UCHAR payload);
+static void usage(void);
+static int writeHciCommand(int uart_fd, uint16_t ogf, uint16_t ocf, uint8_t plen, UCHAR *buf);
+static int MemBlkRead(int uart_fd, UINT32 Address,UCHAR *pBuffer, UINT32 Length);
+static int Dut(int uart_fd);
+static int ReadAudioStats(int uart_fd);
+static int ReadGlobalDMAStats(int uart_fd);
+static int ResetGlobalDMAStats(int uart_fd);
+static int ReadTpcTable(int uart_fd);
+static int ReadHostInterest(int uart_fd,tBtHostInterest *pHostInt);
+static int ReadMemoryBlock(int uart_fd, int StartAddress,UCHAR *pBufToWrite, int Length );
+static int WriteMemoryBlock(int uart_fd, int StartAddress,UCHAR *pBufToWrite, int Length );
+static int write_otpRaw(int uart_fd, int address, int length, UCHAR *data);
+static int read_otpRaw(int uart_fd, int address, int length, UCHAR *data);
+static void dumpHex(UCHAR *buf, int length, int col);
+static void sig_term(int sig);
+static UCHAR LEMode = 0;
+
+int read_hci_event(int fd, unsigned char* buf, int size);
+int set_speed(int fd, struct termios *ti, int speed);
+
+static struct option main_options[] = {
+	{ "help",	0, 0, 'h' },
+	{ "soc",	1, 0, 's' },
+	{ "initialize",	0, 0, 'i' },
+	{ 0, 0, 0, 0 }
+};
+
+int connect_to_wds_server()
+{
+    struct sockaddr_un serv_addr;
+    int sock, ret = -1, i, addr_len;
+
+    sock = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (sock < 0) {
+        printf("%s, client socket creation failed: %s\n", __func__, strerror(errno));
+        return -1;
+    }
+
+    memset(&serv_addr, 0, sizeof(serv_addr));
+    serv_addr.sun_family = AF_LOCAL;
+    strlcpy(&serv_addr.sun_path[1], WDS_SOCK, strlen(WDS_SOCK) + 1);
+    addr_len =  strlen(WDS_SOCK) + 1;
+    addr_len += sizeof(serv_addr.sun_family);
+
+    ret = connect(sock, (struct sockaddr*)&serv_addr, addr_len);
+    if (ret < 0) {
+        printf("%s, failed to connect to WDS server: %s\n", __func__, strerror(errno));
+        close(sock);
+        return -1;
+    }
+
+    printf("%s, Connected to WDS server, socket fd: %d\n", __func__, sock);
+    return sock;
+}
+
+unsigned int uGetInputDataFormat(char **str, struct ST_PS_DATA_FORMAT *pstFormat)
+{
+	char *pCharLine = *str;
+	if(pCharLine[0] != '[') {
+		pstFormat->eDataType = eHex;
+		pstFormat->bIsArray = TRUE;
+		return TRUE;
+	}
+	switch(pCharLine[1]) {
+		case 'H':
+		case 'h':
+			if(pCharLine[2]==':') {
+				if((pCharLine[3]== 'a') || (pCharLine[3]== 'A')) {
+					if(pCharLine[4] == ']') {
+						pstFormat->eDataType = eHex;
+						pstFormat->bIsArray = TRUE;
+						//pCharLine += 5;
+						*str += 5;
+						return TRUE;
+					}
+					else {
+						printf("\nuGetInputDataFormat - Invalid Data Format \r\n"); //[H:A
+						return FALSE;
+					}
+				}
+				if((pCharLine[3]== 'S') || (pCharLine[3]== 's')) {
+					if(pCharLine[4] == ']') {
+						pstFormat->eDataType = eHex;
+						pstFormat->bIsArray = FALSE;
+						//pCharLine += 5;
+						*str += 5;
+						//printf("\nDEBUG H-1:%s\n",pCharLine);
+						return TRUE;
+					}
+					else {
+						printf("\nuGetInputDataFormat - Invalid Data Format \r\n"); //[H:A
+						return FALSE;
+					}
+				}
+				else if(pCharLine[3] == ']') {         //[H:]
+					pstFormat->eDataType = eHex;
+					pstFormat->bIsArray = TRUE;
+					//pCharLine += 4;
+					*str += 4;
+					return TRUE;
+				}
+				else {                            //[H:
+					printf("\nuGetInputDataFormat - Invalid Data Format \r\n");
+					return FALSE;
+				}
+			}
+			else if(pCharLine[2]==']') {    //[H]
+				pstFormat->eDataType = eHex;
+				pstFormat->bIsArray = TRUE;
+				//pCharLine += 3;
+				*str += 5;
+				return TRUE;
+			}
+			else {                      //[H
+				printf("\nuGetInputDataFormat - Invalid Data Format \r\n");
+				return FALSE;
+			}
+			break;
+
+		case 'A':
+		case 'a':
+			if(pCharLine[2]==':') {
+				if((pCharLine[3]== 'h') || (pCharLine[3]== 'H')) {
+					if(pCharLine[4] == ']') {
+						pstFormat->eDataType = eHex;
+						pstFormat->bIsArray = TRUE;
+						//pCharLine += 5;
+						*str += 5;
+						return TRUE;
+					}
+					else {
+						printf("\nuGetInputDataFormat - Invalid Data Format \r\n"); //[A:H
+						return FALSE;
+					}
+				}
+				else if(pCharLine[3]== ']') {         //[A:]
+					pstFormat->eDataType = eHex;
+					pstFormat->bIsArray = TRUE;
+					//pCharLine += 4;
+					*str += 5;
+					return TRUE;
+				}
+				else {                            //[A:
+					printf("\nuGetInputDataFormat - Invalid Data Format \r\n");
+					return FALSE;
+				}
+			}
+			else if(pCharLine[2]==']') {    //[H]
+				pstFormat->eDataType = eHex;
+				pstFormat->bIsArray = TRUE;
+				//pCharLine += 3;
+				*str += 5;
+				return TRUE;
+			}
+			else {                      //[H
+				printf("\nuGetInputDataFormat - Invalid Data Format \r\n");
+				return FALSE;
+
+			}
+			break;
+
+		case 'S':
+		case 's':
+			if(pCharLine[2]==':') {
+				if((pCharLine[3]== 'h') || (pCharLine[3]== 'H')) {
+					if(pCharLine[4] == ']') {
+						pstFormat->eDataType = eHex;
+						pstFormat->bIsArray = TRUE;
+						//pCharLine += 5;
+						*str += 5;
+						return TRUE;
+					}
+					else {
+						printf("\nuGetInputDataFormat - Invalid Data Format \r\n");//[A:H
+						return FALSE;
+					}
+				}
+				else if(pCharLine[3]== ']') {         //[A:]
+					pstFormat->eDataType = eHex;
+					pstFormat->bIsArray = TRUE;
+					//pCharLine += 4;
+					*str += 5;
+					return TRUE;
+				}
+				else {                            //[A:
+					printf("\nuGetInputDataFormat - Invalid Data Format \r\n");
+					return FALSE;
+				}
+			}
+			else if(pCharLine[2]==']') {    //[H]
+				pstFormat->eDataType = eHex;
+				pstFormat->bIsArray = TRUE;
+				//pCharLine += 3;
+				*str += 5;
+				return TRUE;
+			}
+			else {                      //[H
+				printf("\nuGetInputDataFormat - Invalid Data Format \r\n");
+				return FALSE;
+			}
+			break;
+
+		default:
+			printf("\nuGetInputDataFormat - Invalid Data Format \r\n");
+			return FALSE;
+	}
+}
+
+unsigned int uReadDataInSection(char *pCharLine, struct ST_PS_DATA_FORMAT stPS_DataFormat)
+{
+	if(stPS_DataFormat.eDataType == eHex) {
+		if(stPS_DataFormat.bIsArray == TRUE) {
+			//Not implemented
+			printf("\nNO IMP\n");
+			return (0x0FFF);
+		}
+		else {
+			//printf("\nDEBUG H-2 %d\n",strtol(pCharLine, NULL, 16));
+			return (strtol(pCharLine, NULL, 16));
+		}
+	}
+	else {
+		//Not implemented
+		printf("\nNO IMP-1\n");
+		return (0x0FFF);
+	}
+}
+
+static void LoadPSHeader(UCHAR *HCI_PS_Command,UCHAR opcode,int length,int index) {
+
+	HCI_PS_Command[0]= opcode;
+	HCI_PS_Command[1]= (index & 0xFF);
+	HCI_PS_Command[2]= ((index>>8) & 0xFF);
+	HCI_PS_Command[3] = length;
+}
+
+/* HCI functions that require open device
+ * dd - Device descriptor returned by hci_open_dev. */
+
+int hci_send_cmd(int uart_fd, uint16_t ogf, uint16_t ocf, uint8_t plen, void *param)
+{
+	uint8_t type = 0x01; //HCI_COMMAND_PKT
+	uint8_t hci_command_buf[256] = {0};
+	uint8_t * p_buf = &hci_command_buf[0];
+	uint8_t head_len = 3;
+	hci_command_hdr *ch;
+
+	if( is_qca_transport_uart || (!strcasecmp(soc_type, "300x"))) {  // cherokee/rome/ar3002/qca3003 uart
+		*p_buf++ = type;
+		head_len ++;
+	}
+
+	ch = (void*)p_buf;
+	ch->opcode = htobs(HCI_OPCODE_PACK(ogf, ocf));
+	ch->plen = plen;
+	p_buf += HCI_COMMAND_HEADER_SIZE;
+
+	if(plen) {
+		memcpy(p_buf, (uint8_t*) param, plen);
+	}
+
+#ifdef QCA_DEBUG
+	printf("SEND -> ");
+	qca_debug_dump(hci_command_buf, plen+head_len);
+#endif
+
+	if(write(uart_fd, hci_command_buf, plen + head_len) < 0) {
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * Read an HCI event from the given file descriptor.
+ */
+int read_hci_event(int fd, unsigned char* buf, int size)
+{
+	int remain, r;
+	int count = 0;
+
+	if (size <= 0)
+		return -1;
+
+	/* The first byte identifies the packet type. For HCI event packets, it
+	 * should be 0x04, so we read until we get to the 0x04. */
+	while (1) {
+		r = read(fd, buf, 1);
+		if (r <= 0)
+			return -1;
+		if (buf[0] == 0x04) {
+			break;
+		}
+	}
+	count++;
+
+	/* The next two bytes are the event code and parameter total length. */
+	while (count < 3) {
+		r = read(fd, buf + count, 3 - count);
+		if (r <= 0)
+			return -1;
+		count += r;
+	}
+
+	/* Now we read the parameters. */
+	if (buf[2] < (size - 3))
+		remain = buf[2];
+	else
+		remain = size - 3;
+
+	while ((count - 3) < remain) {
+		r = read(fd, buf + count, remain - (count - 3));
+		if (r <= 0)
+			return -1;
+		count += r;
+	}
+
+	return count;
+}
+
+int read_event_modified(int fd, unsigned char* buf, int to)
+{
+	int r,size;
+	int count = 0;
+
+	UNUSED(to);
+	if( is_qca_transport_uart ||(!strcasecmp(soc_type, "300x"))){
+		/* The first byte identifies the packet type. For HCI event packets, it
+		 * should be 0x04, so we read until we get to the 0x04. */
+		r = read(fd, buf, 1);
+		if(r<=0 || buf[0] != 4)  return -1;
+		//count++;
+	}
+
+	while (count < 2) {
+		r = read(fd, buf + count, 2 - count);
+		if (r <= 0)
+			return -1;
+		count += r;
+	}
+
+	if (buf[1] == 0){
+		printf("Zero len , invalid \n");
+		return -1;
+	}
+	size = buf[1] + 2;
+	/* Now we read the parameters. */
+	while (count  < size ) {
+		//printf("size =%d, count=%d , size-count= %d \n", size, count, size-count);
+		r = read(fd, buf + count, size-count);
+		if (r <= 0)
+		{
+			printf("read error \n");
+			return -1;
+		}
+		count += r;
+	}
+
+	//printf("\n*************Data read begin ************* \n");
+	//for (i=0 ; i< size ; i++)
+	//	printf("[%02x]", buf[i]);
+	//printf("\n*************Data read end **************\n");
+
+#if DEBUG
+	// debugging purpose only. to get more packets after [04][10][01][02]
+	count = 0;
+	int timer = 0;
+	unsigned char dbuf[MAX_EVENT_SIZE];
+	memset(dbuf, 0, MAX_EVENT_SIZE);
+	while (timer < 30) {
+		r = read(fd, dbuf, 1);
+		if (r <= 0)
+			return -1;
+
+		if (dbuf[0] == 0x04){
+			printf("\n************ Debug begin ************* \n");
+			for(count; count < 2; count+=r){
+				printf("count: %d\n", count);
+				r = read(fd, dbuf + count, 2 - count);
+				printf("[%02x]", dbuf[count]);
+				if (r <= 0)
+					return -1;
+			}
+			while(count < dbuf[1] + 2){
+				r = read(fd, dbuf + count, dbuf[1] - count);
+				count += r;
+			}
+		}
+		count = 0;
+		for(count; count < dbuf[1] + 2; count++)
+			printf("[%02x]", dbuf[count]);
+		printf("\n************Debug end ************* \n");
+		sleep(3);
+		timer += 3;
+	}
+
+#endif		/* The next two bytes are the event code and parameter total length. */
+
+	return count;
+}
+
+int read_incoming_events(int fd, unsigned char* buf, int to){
+	int r,size;
+	int count = 0;
+
+	UNUSED(to);
+	do{
+		if( is_qca_transport_uart || (!strcasecmp(soc_type, "300x"))){
+			// for cherokee/rome/ar3002/qca3003-uart, the 1st byte are packet type, should always be 4
+			r = read(fd, buf, 1);
+			if  (r<=0 || buf[0] != 4)  return -1;
+                }
+		/* The next two bytes are the event code and parameter total length. */
+		while (count < 2) {
+			r = read(fd, buf + count, 2 - count);
+			if (r <= 0)
+			{
+				printf("read error \n");
+				return -1;
+			}
+			count += r;
+		}
+
+
+		if (buf[1] == 0)
+		{
+			printf("Zero len , invalid \n");
+			return -1;
+		}
+		size = buf[1];
+
+		/* Now we read the parameters. */
+		while (count  < size ) {
+			r = read(fd, buf + count, size);
+			if (r <= 0)
+			{
+				printf("read error :size = %d\n",size);
+				return -1;
+			}
+			count += r;
+		}
+
+		switch (buf[0])
+		{
+			int j=0;
+			case 0x0f:
+			printf("Command Status Received\n");
+			for (j=0 ; j< buf[1] + 2 ; j++)
+				printf("[%x]", buf[j]);
+			printf("\n");
+			if(buf[2] == 0x02)
+			{
+				printf("\nUnknown connection identifier");
+				return 0;
+			}
+			memset(buf , 0, MAX_EVENT_SIZE);
+			count = 0; size =0;
+			break;
+
+			case 0x02:
+			printf("INQ RESULT EVENT RECEIVED \n");
+			for (j=0 ; j< buf[1] + 2 ; j++)
+				printf("[%x]", buf[j]);
+			printf("\n");
+			memset(buf , 0, MAX_EVENT_SIZE);
+			count = 0; size =0;
+			break;
+			case 0x01:
+			printf("INQ COMPLETE EVENT RECEIVED\n");
+			printf("\n");
+			memset(buf , 0, MAX_EVENT_SIZE);
+			count = 0; size =0;
+			return 0;
+			case 0x03:
+			if(buf[2] == 0x00)
+				printf("CONNECTION COMPLETE EVENT RECEIVED WITH HANDLE: 0x%02x%02x \n",buf[4],buf[3]);
+			else
+				printf("CONNECTION COMPLETE EVENT RECEIVED WITH ERROR CODE 0x%x \n",buf[2]);
+			for (j=0 ; j< buf[1] + 2 ; j++)
+				printf("[%x]", buf[j]);
+			printf("\n");
+			memset(buf , 0, MAX_EVENT_SIZE);
+			count = 0; size =0;
+			return 0;
+			case 0x05:
+			printf("DISCONNECTION COMPLETE EVENT RECEIVED WITH REASON CODE: 0x%x \n",buf[5]);
+			for (j=0 ; j< buf[1] + 2 ; j++)
+				printf("[%x]", buf[j]);
+			printf("\n");
+			memset(buf , 0, MAX_EVENT_SIZE);
+			count = 0; size =0;
+			return 0;
+			default:
+			printf("Other event received, Breaking\n");
+#ifdef QCA_DEBUG
+			printf("RECV <- ");
+			qca_debug_dump(buf, buf[1] + 2);
+#else
+			for (j=0 ; j< buf[1] + 2 ; j++)
+				printf("[%x]", buf[j]);
+			printf("\n");
+#endif
+			memset(buf , 0, MAX_EVENT_SIZE);
+			count = 0; size =0;
+			return 0;
+		}
+
+		/* buf[1] should be the event opcode
+		 * buf[2] shoudl be the parameter Len of the event opcode
+		 */
+	}while (1);
+
+	return count;
+}
+
+static int writeHciCommand(int uart_fd, uint16_t ogf, uint16_t ocf, uint8_t plen, UCHAR *buf){
+	int count;
+
+	printf("HCI Command: ogf 0x%02x, ocf 0x%04x, plen %d\n", ogf, ocf, plen);
+	if (hci_send_cmd(uart_fd, ogf, ocf, plen, buf) < 0) {
+		perror("Send failed");
+		exit(EXIT_FAILURE);
+	}
+	sleep(0.4);
+	count = read_hci_event(uart_fd, buf, MAX_EVENT_SIZE);
+	if (count < 0) {
+		printf("Read failed");
+		return count;
+	}
+
+#ifdef QCA_DEBUG
+	printf("RECV <- ");
+	qca_debug_dump(buf, count);
+#endif
+	return count;
+}
+
+static int MemBlkRead(int uart_fd,UINT32 Address,UCHAR *pBuffer, UINT32 Length){
+	UINT32         Size, ByteLeft;
+	UCHAR          *pData,*pTemp=pBuffer;
+	int TempVal;
+
+	TempVal = (Length % 4);
+	if (TempVal !=0) {
+		Length = Length + (4- (Length%4));
+	}
+	ByteLeft = Length;
+	while (ByteLeft > 0)
+	{
+		Size = (ByteLeft > MEM_BLK_DATA_MAX) ? MEM_BLK_DATA_MAX : ByteLeft;
+		pData = (UCHAR *) malloc(Size + 6);
+		if(!pData){
+			printf("bt MemBlkRead: allocation failed! \n");
+			return -1;
+		}
+		pData[0]= 0x00;//depot/esw/projects/azure/AR3001_3_0/src/hci/Hci_Vsc_Proc.c
+		pData[1]= (Address & 0xFF);
+		pData[2]= ((Address >> 8) & 0xFF);
+		pData[3]= ((Address >> 16) & 0xFF);
+		pData[4]= ((Address >> 24) & 0xFF);
+		pData[5]= Size;
+		writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_MEMOP,6,pData);
+		if(pData[5]!= 0){
+			printf("\nwrite memory command failed due to reason 0x%X\n",pData[5]);
+			free(pData);
+			return FALSE;
+		}
+		if ((read(uart_fd, pData,MAX_EVENT_SIZE)) < 0) {
+			perror("Read failed");
+			exit(EXIT_FAILURE);
+		}
+
+		if(pData[3]!=3) {
+			perror("Read failed");
+			exit(EXIT_FAILURE);
+		}
+		memcpy(pTemp,(pData+4),Size);
+		pTemp+=Size;
+		ByteLeft -= Size;
+		Address += Size;
+		free(pData);
+	}
+	return TRUE;
+}
+
+static int Dut(int uart_fd){
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if (is_qca_transport_uart) {
+		memset(&buf,0,MAX_EVENT_SIZE);
+		buf[0] = 0; // Not required
+		// OGF_HOST_CTL
+		// OCF_WRITE_AUTHENTICATION_ENABLE
+		writeHciCommand(uart_fd, 0x03, 0x0020, 1, buf);
+		if(buf[6] != 0){
+			printf("\nWrite authentication enable command failed due to reason 0x%X\n",buf[6]);
+			return FALSE;
+		}
+
+		memset(&buf,0,MAX_EVENT_SIZE);
+		buf[0] = 0; // Not required
+		// OGF_HOST_CTL
+		// OCF_WRITE_ENCRYPTION_MODE
+		writeHciCommand(uart_fd, 0x03, 0x0022, 1, buf);
+		if(buf[6] != 0){
+			printf("\nWrite encryption mode command failed due to reason 0x%X\n",buf[6]);
+			return FALSE;
+		}
+
+		memset(&buf,0,MAX_EVENT_SIZE);
+		buf[0] = 0x02; // connection setup
+                buf[1] = 0x00; // return responses from all devices during the inquiry process
+		buf[2] = 0x02; // allow connections from a device with specific BD_ADDR
+		// OGF_HOST_CTL
+		// OCF_SET_EVENT_FILTER
+		writeHciCommand(uart_fd, 0x03, 0x0005, 3, buf);
+		if(buf[6] != 0){
+			printf("\nWrite set_event_filter command failed due to reason 0x%X\n",buf[6]);
+			return FALSE;
+		}
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 3; //All scan enabled
+	// OGF_HOST_CTL
+	// OCF_WRITE_SCAN_ENABLE
+	writeHciCommand(uart_fd, 0x03, 0x001A, 1, buf);
+	if(buf[6] != 0){
+		printf("\nWrite scan mode command failed due to reason 0x%X\n",buf[6]);
+		return FALSE;
+	}
+
+	//sleep(1);
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	//OGF_TEST_CMD
+	//OCF_ENABLE_DEVICE_UNDER_TEST_MODE
+	writeHciCommand(uart_fd, 0x06, 0x0003, 0, buf);
+	if(buf[6] != 0){
+		printf("\nDUT mode command failed due to reason 0x%X\n",buf[6]);
+		return FALSE;
+	}
+
+#ifndef PRONTO_SOC
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 0; //SEQN Track enable =0
+	// HCI_VENDOR_CMD_OGF
+	// OCF_TEST_MODE_SEQN_TRACKING
+	writeHciCommand(uart_fd, 0x3F, 0x0018, 1, buf);
+	if(buf[6] != 0){
+		printf("\nTest Mode seqn Tracking failed due to reason 0x%X\n",buf[6]);
+		return FALSE;
+	}
+#endif
+	return TRUE;
+}
+
+
+void Audio_DumpStats(tAudioStat *AudioStats)
+{
+	printf("\n\n");
+	printf("    Audio Statistics\n");
+	printf(">RxCmplt:                 %d\n",AudioStats->RxCmplt);
+	printf(">TxCmplt:                 %d\n",AudioStats->TxCmplt);
+	printf(">RxSilenceInsert:         %d\n",AudioStats->RxSilenceInsert);
+	printf(">RxAirPktDump:            %d\n",AudioStats->RxAirPktDump);
+	printf(">MaxPLCGenInterval:       %d\n",AudioStats->MaxPLCGenInterval);
+	printf(">RxAirPktStatusGood:      %d\n",AudioStats->RxAirPktStatusGood);
+	printf(">RxAirPktStatusError:     %d\n",AudioStats->RxAirPktStatusError);
+	printf(">RxAirPktStatusLost:      %d\n",AudioStats->RxAirPktStatusLost);
+	printf(">RxAirPktStatusPartial:   %d\n",AudioStats->RxAirPktStatusPartial);
+	printf(">SampleMin:               %d\n",AudioStats->SampleMin);
+	printf(">SampleMax:               %d\n",AudioStats->SampleMax);
+	printf(">SampleCounter:           %d\n",AudioStats->SampleCounter);
+	printf("\n\n");
+
+	memset((UCHAR *)AudioStats, 0, sizeof(tAudioStat));
+	AudioStats->SampleMax =SHRT_MIN;
+	AudioStats->SampleMin =SHRT_MAX;
+}
+
+static int ReadAudioStats(int uart_fd){
+
+	tBtHostInterest HostInt;
+	tAudioStat Stats;
+
+	ReadHostInterest(uart_fd, &HostInt);
+	if(!HostInt.AudioStatAddr || (HostInt.Version < 0x0300)){
+		printf("\nAudio Stat not present\n");
+		return FALSE;
+	}
+	ReadMemoryBlock(uart_fd,HostInt.AudioStatAddr,(UCHAR *)&Stats,sizeof(tAudioStat));
+	Audio_DumpStats(&Stats);
+	return TRUE;
+}
+
+void BRM_DumpStats(tBRM_Stats *Stats)
+{
+	printf("\n  Link Controller Voice DMA Statistics\n");
+	printf("  %22s: %u\n", "VoiceTxDmaIntrs", Stats->VoiceTxDmaIntrs);
+	printf("  %22s: %u\n", "VoiceTxPktAvail", Stats->VoiceTxPktAvail);
+	printf("  %22s: %u\n", "VoiceTxPktDumped", Stats->VoiceTxPktDumped);
+	printf("  %22s: %u\n", "VoiceTxErrors", Stats->VoiceTxErrorIntrs);
+	printf("  %22s: %u\n", "VoiceTxDmaErrors", Stats->VoiceTxDmaErrorIntrs);
+	printf("  %22s: %u\n", "VoiceTxSilenceInserts", Stats->VoiceTxDmaSilenceInserts);
+	printf("\n");
+	printf("  %22s: %u\n", "VoiceRxDmaIntrs", Stats->VoiceRxDmaIntrs);
+	printf("  %22s: %u\n", "VoiceRxGoodPkts", Stats->VoiceRxGoodPkts);
+	printf("  %22s: %u\n", "VoiceRxPktDumped", Stats->VoiceRxPktDumped);
+	printf("  %22s: %u\n", "VoiceRxErrors", Stats->VoiceRxErrorIntrs);
+	printf("  %22s: %u\n", "VoiceRxCRC", Stats->VoiceRxErrCrc);
+	printf("  %22s: %u\n", "VoiceRxUnderOverFlow", Stats->VoiceRxErrUnderOverFlow);
+	printf("\n");
+	printf("  %22s: %u\n", "SchedOnVoiceError", Stats->SchedOnVoiceError);
+	printf("  %22s: %u\n", "VoiceTxReapOnError", Stats->VoiceTxReapOnError);
+	printf("  %22s: %u\n", "VoiceRxReapOnError", Stats->VoiceRxReapOnError);
+	printf("  %22s: %u\n", "VoiceSchedulingError", Stats->VoiceSchedulingError);
+
+	printf("\n  Link Controller ACL DMA Statistics\n");
+	printf("  %22s: %u\n", "DmaIntrs", Stats->DmaIntrs);
+	printf("  %22s: %u\n", "ErrWrongLlid", Stats->ErrWrongLlid);
+	printf("  %22s: %u\n", "ErrL2CapLen", Stats->ErrL2CapLen);
+	printf("  %22s: %u\n", "ErrUnderOverFlow", Stats->ErrUnderOverFlow);
+	printf("  %22s: %u\n", "RxBufferDumped", Stats->RxBufferDumped);
+	printf("  %22s: %u\n", "ErrWrongLmpPktType", Stats->ErrWrongLmpPktType);
+	printf("  %22s: %u\n", "ErrWrongL2CapPktType", Stats->ErrWrongL2CapPktType);
+	printf("  %22s: %u\n", "IgnoredPkts", Stats->IgnoredPkts);
+	printf("\n");
+	printf("  %22s: %u\n", "Data TxBuffers", Stats->DataTxBuffers);
+	printf("  %22s: %u\n", "Data RxBuffers", Stats->DataRxBuffers);
+	printf("  %22s: %u\n", "LMP TxBuffers", Stats->LmpTxBuffers);
+	printf("  %22s: %u\n", "LMP RxBuffers", Stats->LmpRxBuffers);
+	printf("  %22s: %u\n", "HEC Errors", Stats->HecFailPkts);
+	printf("  %22s: %u\n", "CRC Errors", Stats->CrcFailPkts);
+
+	// Buffer Management
+	printf("\n  Buffer Management Statistics\n");
+	printf("  %22s: %u\n", "CtrlErrNoLmpBufs", Stats->CtrlErrNoLmpBufs);
+
+	printf("\n  Sniff Statistics\n");
+	printf("  %22s: %u\n", "SniffSchedulingError", Stats->SniffSchedulingError);
+	printf("  %22s: %u\n", "SniffIntervalNoCorr", Stats->SniffIntervalNoCorr);
+
+	// Other stats
+	printf("\n  Other Statistics\n");
+	printf("  %22s: %u\n", "ForceOverQosJob", Stats->ForceOverQosJob);
+	//printf("  %22s: %u\n", "Temp 1", Stats->Temp1);
+	//printf("  %22s: %u\n", "Temp 2", Stats->Temp2);
+
+	// Test Mode Stats
+	printf("\n  Test Mode Statistics\n");
+	printf("  %22s: %u\n", "TestModeDroppedTxPkts", Stats->TestModeDroppedTxPkts);
+	printf("  %22s: %u\n", "TestModeDroppedLmps", Stats->TestModeDroppedLmps);
+
+	// Error Stats
+	printf("\n  General Error Statistics\n");
+	printf("  %22s: %u\n", "TimePassedIntrs", Stats->TimePassedIntrs);
+	printf("  %22s: %u\n", "NoCommandIntrs", Stats->NoCommandIntrs);
+}
+
+static int ReadGlobalDMAStats(int uart_fd){
+	tBtHostInterest	HostInt;
+	tBRM_Stats  Stats;
+
+	ReadHostInterest(uart_fd, &HostInt);
+	if(!HostInt.GlobalDmaStats || (HostInt.Version < 0x0100)){
+		printf("\nGlobal DMA stats not present\n");
+		return FALSE;
+	}
+	ReadMemoryBlock(uart_fd,HostInt.GlobalDmaStats,(UCHAR *)&Stats,sizeof(tBRM_Stats));
+	BRM_DumpStats(&Stats);
+	return TRUE;
+}
+
+static int ResetGlobalDMAStats(int uart_fd){
+	tBtHostInterest	HostInt;
+	tBRM_Stats  Stats;
+
+	ReadHostInterest(uart_fd, &HostInt);
+	if(!HostInt.GlobalDmaStats || (HostInt.Version < 0x0100)){
+		printf("\nGlobal DMA stats not present\n");
+		return FALSE;
+	}
+	memset(&Stats,0,sizeof(Stats));
+	printf("\nHarry\n");
+	WriteMemoryBlock(uart_fd,HostInt.GlobalDmaStats,(UCHAR *)&Stats,sizeof(tBRM_Stats));
+	printf("\nDMA stattestics has been reset\n");
+	return TRUE;
+}
+
+static int ReadTpcTable(int uart_fd){
+	tBtHostInterest	HostInt;
+	tPsSysCfgTransmitPowerControlTable  TpcTable;
+	int i;
+
+	ReadHostInterest(uart_fd, &HostInt);
+	if(!HostInt.TpcTableAddr || (HostInt.Version < 0x0100)){
+		printf("\nTPC table not present\n");
+		return FALSE;
+	}
+	ReadMemoryBlock(uart_fd,HostInt.TpcTableAddr,(UCHAR *)&TpcTable,sizeof(TpcTable));
+	for(i=0;i< TpcTable.NumOfEntries; i++){
+		printf("Level [%d] represents %3d dBm\n",i,TpcTable.t[i].TxPowerLevel);
+	}
+	return TRUE;
+}
+
+static const char *reset_help =
+"Usage:\n"
+"\n reset\n";
+
+static void cmd_reset(int uart_fd, int argc, char **argv){
+	int Length = 0;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if(argv) UNUSED(argv);
+	if(argc > 1) {
+		printf("\n%s\n",reset_help);
+		return;
+	}
+
+	memset(&buf,0,sizeof(buf));
+	Length = 0;
+
+	// OGF_HOST_CTL 0x03
+	// OCF_RESET 0x0003
+	writeHciCommand(uart_fd, HCI_CMD_OGF_HOST_CTL, HCI_CMD_OCF_RESET, Length, buf);
+	if(buf[6] != 0){
+		printf("\nError: HCI RESET failed due to reason 0x%X\n",buf[6]);
+		return;
+	}else{
+		printf("\nHCI Reset Pass");
+	}
+	printf("\nReset Done\n");
+}
+static const char *rba_help =
+"Usage:\n"
+"\n rba\n";
+
+static void cmd_rba(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int iRet;
+
+	if(argv) UNUSED(argv);
+	if(argc > 1){
+		printf("\n%s\n",rba_help);
+		return;
+	}
+	memset(&buf,0,MAX_EVENT_SIZE);
+
+	iRet = writeHciCommand(uart_fd, HCI_CMD_OGF_INFO_PARAM, HCI_CMD_OCF_READ_BD_ADDR, 0, buf);
+	printf("iRet: %d\n", iRet);
+	if(iRet>=MAX_EVENT_SIZE){
+		printf("\nread buffer size overflowed  %d\n", iRet);
+		return;
+	}
+	if(buf[6] != 0){
+		printf("\nread bdaddr command failed due to reason 0x%X\n",buf[6] );
+		return;
+	}
+	printf("\nBD ADDRESS: \n");
+	int i;
+	for(i=iRet-1;i > 7;i--){
+		printf("%02X:",buf[i]);
+	}
+	printf("%02X\n\n",buf[7]);
+}
+
+static const char *dtx_help =
+"Usage:\n"
+"\n dtx\n";
+
+static void cmd_dtx(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if(argv) UNUSED(argv);
+	if(argc > 1){
+		printf("\n%s\n",dtx_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_DISABLE_TX, 0, buf);
+	if(buf[6] != 0){
+		printf("\nDisable TX command failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	else {
+		printf("\nDisable TX command passed\n");
+	}
+}
+
+static const char *ssm_help =
+"Usage:\n"
+"\n ssm [0|1]\n"
+"\nExample:\n"
+"\tssm 0\t(Sleep disabled)\n"
+"\tssm 1\t(Sleep enabled)\n";
+
+static void cmd_ssm(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if(argc != 2){
+		printf("\n%s\n",ssm_help);
+		return;
+	}
+
+	if(atoi(argv[1]) > 1){
+		printf("\nInvalid sleep mode :%d\n",atoi(argv[1]));
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = atoi(argv[1]);;
+
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE, 1, buf);
+	if(buf[6] != 0){
+		printf("\nSet sleep mode command failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	else {
+		printf("\nSet sleep mode command passed\n");
+	}
+}
+
+static const char *wba_help =
+"Usage:\n"
+"\n wba <bdaddr>\n"
+"\nExample:\n"
+"\n wba 00:03:ff:56:23:89\n";
+
+static void cmd_wba(int uart_fd, int argc, char **argv){
+	bdaddr_t bdaddr;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if(argc < 2){
+		printf("\n%s\n",wba_help);
+		return;
+	}
+
+	str2ba(argv[1],&bdaddr);
+	if((strlen(argv[1]) < 17)||(strlen(argv[1]) > 17)){
+		printf("\nInvalid BD address : %s\n",argv[1]);
+		printf("\n%s\n",wba_help);
+		return;
+	}
+	LoadPSHeader(buf,PS_WRITE,BD_ADDR_SIZE,BD_ADDR_PSTAG);
+	int i,j=0;
+	for(i= 0,j=4;i< BD_ADDR_SIZE;i++,j++){
+		buf[j] = bdaddr.b[i];
+	}
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS,BD_ADDR_SIZE + PS_COMMAND_HEADER, buf);
+	if (buf[6] != 0) {
+		printf("\nWrite BD address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	memset(&buf,0,sizeof(buf));
+	writeHciCommand(uart_fd, HCI_CMD_OGF_HOST_CTL, HCI_CMD_OCF_RESET, 0, buf);
+	if (buf[6] != 0) {
+		printf("\nError: HCI RESET failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	memset(&buf,0,sizeof(buf));
+	writeHciCommand(uart_fd, HCI_CMD_OGF_INFO_PARAM, HCI_CMD_OCF_READ_BD_ADDR, 0, buf);
+	if (buf[6] != 0) {
+		printf("\nError: read bdaddr command failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	printf("\nBD address changed successfully\n");
+}
+
+static const char *edutm_help =
+"Usage:\n"
+"\n edutm\n";
+
+static void cmd_edutm(int uart_fd, int argc, char **argv){
+	if(argv) UNUSED(argv);
+        if(argc > 1){
+	        printf("\n%s\n",edutm_help);
+                return;
+	}
+	/*
+	   Patch_Count = 20;
+	   for(i=0; i < Patch_Count; i++){
+	   RamPatch[i].Len = MAX_BYTE_LENGTH;
+	   memset(&RamPatch[i].Data,0,MAX_BYTE_LENGTH);
+	   }
+	   printf("\nCMD DUT MODE\n");
+	 */
+	if(!Dut(uart_fd)){
+		return;
+	}
+	printf("\nDevice is in test mode ...\n");
+	return;
+}
+
+
+static int ReadMemorySmallBlock(int uart_fd, int StartAddress,UCHAR *pBufToWrite, int Length ){
+	UCHAR *pData;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	pData = (UCHAR *) malloc(Length + 6);
+	if(!pData){
+		printf("bt ReadMemorySmallBlock: allocation failed! \n");
+		return -1;
+	}
+	memset(pData,0,Length+6);
+	pData[0]= 0x00;  //Memory Read Opcode
+	pData[1]= (StartAddress & 0xFF);
+	pData[2]= ((StartAddress >> 8) & 0xFF);
+	pData[3]= ((StartAddress >> 16) & 0xFF);
+	pData[4]= ((StartAddress >> 24) & 0xFF);
+	pData[5]= Length;
+
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_MEMOP,Length+6,pData);
+	if(pData[6]!= 0){
+		printf("\nwrite memory command failed due to reason 0x%X\n",pData[6]);
+		free(pData);
+		return FALSE;
+	}
+	/*int plen =0;
+	  do{
+	  plen = read(uart_fd, buf,MAX_EVENT_SIZE);
+	  if (plen < 0) {
+	  free(pData);
+	  perror("Read failed");
+	  exit(EXIT_FAILURE);
+	  }
+	  }while (buf[HCI_EVENT_HEADER_SIZE] != DEBUG_EVENT_TYPE_MEMBLK);*/
+	memset(buf,0,MAX_EVENT_SIZE);
+	read_event_modified(uart_fd, buf, 0);
+
+	memcpy(pBufToWrite,(buf+HCI_EVENT_HEADER_SIZE+1),Length);
+	free(pData);
+	return TRUE;
+}
+
+static int ReadMemoryBlock(int uart_fd, int StartAddress, UCHAR *pBufToWrite, int Length ){
+
+	int ModResult,i;
+
+	if(Length > MEM_BLK_DATA_MAX){
+		ModResult = Length % MEM_BLK_DATA_MAX;
+		for(i=0;i < (Length - ModResult);i += MEM_BLK_DATA_MAX) {
+			ReadMemorySmallBlock(uart_fd, (StartAddress + i),(pBufToWrite + i), MEM_BLK_DATA_MAX);
+		}
+		if(ModResult){
+			ReadMemorySmallBlock(uart_fd, (StartAddress + i),(pBufToWrite + i), ModResult);
+		}
+	}
+	else{
+
+		ReadMemorySmallBlock(uart_fd, StartAddress, pBufToWrite, Length);
+	}
+	return TRUE;
+}
+
+static int WriteMemorySmallBlock(int uart_fd, int StartAddress,UCHAR *pBufToWrite, int Length ){
+	UCHAR *pData;
+
+	if(pBufToWrite) UNUSED(pBufToWrite);
+	printf("\nStart Address:%x Length:%x  %x\n",StartAddress,Length,MEM_BLK_DATA_MAX);
+	/*if(Length <= MEM_BLK_DATA_MAX)
+	  return FALSE; */
+	pData = (UCHAR *) malloc(Length + 6);
+	if(!pData){
+		printf("bt WriteMemorySmallBlock: allocation failed! \n");
+		return -1;
+	}
+	memset(pData,0,Length+6);
+	pData[0]= 0x01;  //Write Read Opcode
+	pData[1]= (StartAddress & 0xFF);
+	pData[2]= ((StartAddress >> 8) & 0xFF);
+	pData[3]= ((StartAddress >> 16) & 0xFF);
+	pData[4]= ((StartAddress >> 24) & 0xFF);
+	pData[5]= Length;
+
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_MEMOP,Length+6,pData);
+	if(pData[6]!= 0){
+		printf("\nwrite memory command failed due to reason 0x%X\n",pData[6]);
+		free(pData);
+		return FALSE;
+	}
+	free(pData);
+	return TRUE;
+}
+
+
+static int WriteMemoryBlock(int uart_fd, int StartAddress,UCHAR *pBufToWrite, int Length ){
+
+	int ModResult,i;
+
+	if(Length > MEM_BLK_DATA_MAX){
+		ModResult = Length % MEM_BLK_DATA_MAX;
+		for(i=0;i < (Length - ModResult);i += MEM_BLK_DATA_MAX) {
+			WriteMemorySmallBlock(uart_fd, (StartAddress + i),(pBufToWrite + i), MEM_BLK_DATA_MAX);
+		}
+		if(ModResult){
+			WriteMemorySmallBlock(uart_fd, (StartAddress + i),(pBufToWrite + i), ModResult);
+		}
+	}
+	else{
+
+		WriteMemorySmallBlock(uart_fd, StartAddress, pBufToWrite, Length);
+	}
+	return TRUE;
+}
+
+
+static int ReadHostInterest(int uart_fd, tBtHostInterest *pHostInt){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int iRet;
+	int HostInterestAddress;
+	memset(&buf,0,MAX_EVENT_SIZE);
+	iRet = writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_HOST_INTEREST, 0, buf);
+	if(iRet < 4 || iRet>=MAX_EVENT_SIZE){
+		printf("\nread buffer size overflowed  %d\n", iRet);
+		return FALSE;
+	}
+	if(buf[6] != 0){
+		printf("\nhost interest command failed due to reason 0x%X\n",buf[6]);
+		return FALSE;
+	}
+	HostInterestAddress = buf[iRet-1];
+	HostInterestAddress = ((HostInterestAddress << 8)|buf[iRet-2]);
+	HostInterestAddress = ((HostInterestAddress << 8)|buf[iRet-3]);
+	HostInterestAddress = ((HostInterestAddress << 8)|buf[iRet-4]);
+	ReadMemoryBlock(uart_fd, HostInterestAddress,(UCHAR*)pHostInt, sizeof(tBtHostInterest));
+
+	if(pHostInt->MagicNumber != HI_MAGIC_NUMBER){
+		if((pHostInt->MagicNumber != 0xFBAD)|| (pHostInt->Version != 0xDECA))
+			return 0;
+	}
+	return TRUE;
+}
+
+static int contRxAtGivenChannel(int uart_fd, UCHAR *pString){
+	int Address, Mask, Reg, RxFreq;
+	UCHAR buf[MAX_EVENT_SIZE];
+	//1. Disable all scans and set intervals and scan windows eually
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 0; //All scan disabled
+	// OGF_HOST_CTL	 0x03
+	// OCF_WRITE_SCAN_ENABLE 0x001A
+	writeHciCommand(uart_fd, 0x03, 0x001A, 1, buf);
+	if(buf[6] != 0){
+		printf("\nWrite scan mode command failed due to reason 0x%X\n",buf[6]);
+		return 0;
+	}
+	short int inq_scan = 0x1000;
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = (inq_scan&0xFF);
+	buf[1] = ((inq_scan >> 8)& 0xFF);
+	buf[2] = (inq_scan&0xFF);
+	buf[3] = ((inq_scan >> 8)& 0xFF);
+	// OGF_HOST_CTL	 0x03
+	// OCF_WRITE_INQ_ACTIVITY 0x001E
+	writeHciCommand(uart_fd, 0x03, 0x001E, 4, buf);
+	if(buf[6] != 0){
+		printf("\nWrite inquiry scan activity command failed due to reason 0x%X\n",buf[6]);
+		return 0;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = (inq_scan&0xFF);
+	buf[1] = ((inq_scan >> 8)& 0xFF);
+	buf[2] = (inq_scan&0xFF);
+	buf[3] = ((inq_scan >> 8)& 0xFF);
+	// OGF_HOST_CTL	 0x03
+	// OCF_WRITE_PAGE_ACTIVITY 0x001C
+	writeHciCommand(uart_fd, 0x03, 0x001C, 4, buf);
+	if(buf[6] != 0){
+		printf("\nWrite page scan activity command failed due to reason 0x%X\n",buf[6]);
+		return 0;
+	}
+	//2. Disbable AGC
+	Address = LC_JTAG_MODEM_REGS_ADDRESS + AGC_BYPASS_ADDRESS;
+	Mask = AGC_BYPASS_ENABLE_MASK;
+	Reg = AGC_BYPASS_ENABLE_SET(1);
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = (Address & 0xFF);
+	buf[1] = ((Address >>8) & 0xFF);
+	buf[2] = ((Address>>16) & 0xFF);
+	buf[3] = ((Address>>24) & 0xFF);
+	buf[4] = 0x04;  //Memory width
+	buf[5] = (Reg & 0xFF);
+	buf[6] = ((Reg >> 8) & 0xFF);
+	buf[7] = ((Reg >> 16) & 0xFF);
+	buf[8] = ((Reg >> 24) & 0xFF);
+	buf[9] = (Mask & 0xFF);
+	buf[10] = ((Mask >>8) & 0xFF);
+	buf[11] = ((Mask>>16) & 0xFF);
+	buf[12] = ((Mask>>24) & 0xFF);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite to AGC bypass register failed due to reason 0x%X\n",buf[6]);
+		return 0;
+	}
+	// 3. Disable frequency hoping and set rx frequency
+	//RxFreq = (int)(pString); BEN: using pointer address is meaningless
+	RxFreq = (int)(*pString);
+
+	Address = LC_DEV_PARAM_CTL_ADDRESS;
+	Mask = LC_DEV_PARAM_CTL_FREQ_HOP_EN_MASK |
+		LC_DEV_PARAM_CTL_RX_FREQ_MASK     |
+		LC_DEV_PARAM_CTL_WHITEN_EN_MASK;
+	Reg = LC_DEV_PARAM_CTL_RX_FREQ_SET(RxFreq);
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = (Address & 0xFF);
+	buf[1] = ((Address >>8) & 0xFF);
+	buf[2] = ((Address>>16) & 0xFF);
+	buf[3] = ((Address>>24) & 0xFF);
+	buf[4] = 0x04;  //Memory width
+	buf[5] = (Reg & 0xFF);
+	buf[6] = ((Reg >> 8) & 0xFF);
+	buf[7] = ((Reg >> 16) & 0xFF);
+	buf[8] = ((Reg >> 24) & 0xFF);
+	buf[9] = (Mask & 0xFF);
+	buf[10] = ((Mask >>8) & 0xFF);
+	buf[11] = ((Mask>>16) & 0xFF);
+	buf[12] = ((Mask>>24) & 0xFF);
+
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite to Rx Freq register failed due to reason 0x%X\n",buf[6]);
+		return 0;
+	}
+	// 4. Enable page scan only (Note: the old way puts device into inq scan mode only ???)
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 2; //Page scan enabled
+	// OGF_HOST_CTL	 0x03
+	// OCF_WRITE_SCAN_ENABLE 0x001A
+	writeHciCommand(uart_fd, 0x03, 0x001A, 1, buf);
+	if(buf[6] != 0){
+		printf("\nPage scan enable command failed due to reason 0x%X\n",buf[6]);
+		return 0;
+	}
+	// 5. Increase correlator
+	Address = LC_JTAG_MODEM_REGS_ADDRESS + CORR_PARAM1_ADDRESS;
+	Mask = CORR_PARAM1_TIM_THR_MASK;
+	Reg = CORR_PARAM1_TIM_THR_SET(0x3f);
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = (Address & 0xFF);
+	buf[1] = ((Address >>8) & 0xFF);
+	buf[2] = ((Address>>16) & 0xFF);
+	buf[3] = ((Address>>24) & 0xFF);
+	buf[4] = 0x04;  //Memory width
+	buf[5] = (Reg & 0xFF);
+	buf[6] = ((Reg >> 8) & 0xFF);
+	buf[7] = ((Reg >> 16) & 0xFF);
+	buf[8] = ((Reg >> 24) & 0xFF);
+	buf[9] = (Mask & 0xFF);
+	buf[10] = ((Mask >>8) & 0xFF);
+	buf[11] = ((Mask>>16) & 0xFF);
+	buf[12] = ((Mask>>24) & 0xFF);
+
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite to Correlator register failed due to reason 0x%X\n",buf[6]);
+		return 0;
+	}
+
+	return TRUE;
+}
+static const char *cwrx_help =
+"Usage:\n"
+"\n cwrx <Channel>\n";
+
+static void cmd_cwrx(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR channel;
+	BOOL Ok = TRUE;
+	if(argc != 2){
+		printf("\n%s\n",cwrx_help);
+		return;
+	}
+
+	channel = atoi(argv[1]);
+	if(channel > 78 ){
+		printf("\nPlease enter channel 0-78!\n");
+		return;
+	}
+
+	// Disable sleep mode
+	memset(&buf,0,sizeof(buf));
+	buf[0] = 0;
+	writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+	if(buf[6] != 0){
+		printf("\nError: Sleep mode failed due to reason 0x%X\n",buf[6]);
+		Ok = 0;
+	}
+	printf (" Continuoux Rx at channel %d\n",channel);
+	Ok = contRxAtGivenChannel(uart_fd, &channel);
+
+	// All modes come here
+	if (Ok) {
+		printf (" Continuoux Rx at channel %d Done...\n",channel);
+	}
+	else {
+		printf ("\nERROR ---> Could not enter continuous Rx mode\n");
+	}
+}
+
+int OCFRXTestMode(int uart_fd, tBRM_Control_packet *MasterBlaster, UCHAR SkipRxSlot)
+{
+	BOOL Ok = TRUE;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	memset(&buf,0,sizeof(buf));
+	buf[0] = 0;
+	writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+	if(buf[6] != 0) {
+		printf ("\nERROR ---> Could not disable sleep mode\n");
+		return -1;
+	}
+	Ok = Dut(uart_fd);
+	if (!Ok) {
+		printf("\nERROR ---> Could not enter DUT mode\n");
+		return -1;
+	}
+	printf(".");
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = eBRM_TestMode_Rx;
+	buf[1] = MasterBlaster->testCtrl.Packet;
+	buf[2] = MasterBlaster->testCtrl.DataLen & 0xFF;
+	buf[3] = ((MasterBlaster->testCtrl.DataLen>>8) & 0xFF);
+	buf[4] = MasterBlaster->testCtrl.HopMode;
+	buf[5] = MasterBlaster->testCtrl.TxFreq;
+	buf[6] = MasterBlaster->testCtrl.Power;
+	buf[7] = MasterBlaster->testCtrl.RxFreq;
+	buf[8] = MasterBlaster->bdaddr[0];
+	buf[9] = MasterBlaster->bdaddr[1];
+	buf[10] = MasterBlaster->bdaddr[2];
+	buf[11] = MasterBlaster->bdaddr[3];
+	buf[12] = MasterBlaster->bdaddr[4];
+	buf[13] = MasterBlaster->bdaddr[5];
+	buf[14] = SkipRxSlot;
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_RX_TESTER, 15, buf);
+	if (buf[6] != 0) {
+		printf("\nRx Tester command failed due to reason 0x%X\n",buf[6]);
+		printf("\nERROR --> Could not enable master blaster mode\n");
+		Ok = 0;
+		return MB_NO_TEST;
+	}
+	printf(" rx test is in progress. Press 's' to stop the test\n");
+	return MB_RX_TEST;
+}
+
+int OCFTXTestMode(int uart_fd, tBRM_Control_packet *MasterBlaster, UCHAR SkipRxSlot)
+{
+	BOOL Ok = TRUE;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	memset(&buf,0,sizeof(buf));
+	buf[0] = 0;
+	writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+	if(buf[6] != 0) {
+		printf ("\nERROR ---> Could not disable sleep mode\n");
+		return -1;
+	}
+
+	printf (".");
+	Ok = Dut(uart_fd);
+	if (!Ok) {
+		printf("\nERROR ---> Could not enter DUT mode\n");
+		return -1;
+	}
+
+	printf(".");
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = MasterBlaster->testCtrl.Mode;
+	buf[1] = MasterBlaster->testCtrl.Packet;
+	buf[2] = MasterBlaster->testCtrl.DataLen & 0xFF;
+	buf[3] = ((MasterBlaster->testCtrl.DataLen>>8) & 0xFF);
+	buf[4] = MasterBlaster->testCtrl.HopMode;
+	buf[5] = MasterBlaster->testCtrl.TxFreq;
+	buf[6] = MasterBlaster->testCtrl.Power;
+	buf[7] = MasterBlaster->testCtrl.RxFreq;
+	buf[8] = MasterBlaster->bdaddr[0];
+	buf[9] = MasterBlaster->bdaddr[1];
+	buf[10] = MasterBlaster->bdaddr[2];
+	buf[11] = MasterBlaster->bdaddr[3];
+	buf[12] = MasterBlaster->bdaddr[4];
+	buf[13] = MasterBlaster->bdaddr[5];
+	buf[14] = SkipRxSlot;
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_TX_TESTER, 15, buf);
+	if (buf[6] != 0) {
+		printf("\nTx Tester command failed due to reason 0x%X\n",buf[6]);
+		printf("\nERROR --> Could not enable master blaster mode\n");
+		return MB_NO_TEST;
+	}
+	printf(" tx test is in progress. Press 's' to stop the test\n");
+	return MB_TX_TEST;
+}
+
+int OCFContTXTestMode(int uart_fd, tBRM_Control_packet *MasterBlaster)
+{
+	BOOL Ok = TRUE;
+	UCHAR buf[MAX_EVENT_SIZE];
+	int address, width, value, mask;
+
+	memset(&buf,0,sizeof(buf));
+	buf[0] = 0;
+	writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+	if(buf[6] != 0) {
+		printf ("\nERROR ---> Could not disable sleep mode\n");
+		return -1;
+	}
+
+	Ok = Dut(uart_fd);
+	if (!Ok) {
+		printf("\nERROR ---> Could not enter DUT mode\n");
+		return -1;
+	}
+
+	/* Enable master blaster mode */
+	printf(".");
+	/*
+	   if (CW_Single_Tone == MasterBlaster.ContTxType)
+	   setContTxType = Cont_Tx_Raw_1MHz;
+	   else
+	   setContTxType = MasterBlaster.ContTxType;
+	 */
+	memset(&buf, 0, MAX_EVENT_SIZE);
+	buf[0] = MasterBlaster->testCtrl.Mode ;
+	buf[1] = MasterBlaster->testCtrl.Packet;
+	buf[2] = MasterBlaster->testCtrl.DataLen & 0xFF;
+	buf[3] = ((MasterBlaster->testCtrl.DataLen>>8) & 0xFF);
+	buf[4] = MasterBlaster->ContTxType;
+	buf[5] = MasterBlaster->testCtrl.TxFreq;
+	buf[6] = MasterBlaster->testCtrl.Power;
+	buf[7] = MasterBlaster->testCtrl.RxFreq;
+	buf[8] = MasterBlaster->bdaddr[0];
+	buf[9] = MasterBlaster->bdaddr[1];
+	buf[10] = MasterBlaster->bdaddr[2];
+	buf[11] = MasterBlaster->bdaddr[3];
+	buf[12] = MasterBlaster->bdaddr[4];
+	buf[13] = MasterBlaster->bdaddr[5];
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_CONT_TX_TESTER, 14, buf);
+	if(buf[6] != 0){
+		printf("\nContinious Tx Tester command failed due to reason 0x%X\n",buf[6]);
+		return MB_NO_TEST;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	address = 0x00022914;
+	value = 0x00200000;
+	mask = 0x00200000;
+	width = 4;
+	buf[0] = (address & 0xFF);
+	buf[1] = ((address >>8) & 0xFF);
+	buf[2] = ((address>>16) & 0xFF);
+	buf[3] = ((address>>24) & 0xFF);
+	buf[4] = width;  //Memory width
+	buf[5] = (value & 0xFF);
+	buf[6] = ((value >> 8) & 0xFF);
+	buf[7] = ((value >> 16) & 0xFF);
+	buf[8] = ((value >> 24) & 0xFF);
+	buf[9] = (mask & 0xFF);
+	buf[10] = ((mask >>8) & 0xFF);
+	buf[11] = ((mask>>16) & 0xFF);
+	buf[12] = ((mask>>24) & 0xFF);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return MB_NO_TEST;
+	}
+	return MB_CONT_TX_TEST;
+}
+
+int OCFContRXTestMode(int uart_fd, tBRM_Control_packet *MasterBlaster)
+{
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	memset(&buf,0,sizeof(buf));
+	buf[0] = 0;
+	writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+	if(buf[6] != 0) {
+		printf ("\nERROR ---> Could not disable sleep mode\n");
+		return -1;
+	}
+
+	UCHAR RxFreq = MasterBlaster->testCtrl.RxFreq;
+	contRxAtGivenChannel(uart_fd, &RxFreq);
+	return MB_CONT_RX_TEST;
+}
+
+static const char *cmdline_help =
+	"\n<BTConfig command v.1.2>"
+	"\n1. Usage for TX and Con TX:"
+	"\n btconfig cmdline [TestMode|DataPattern|PacketType|DataLen|HopMode|TxFreq|Power|RxFreq"
+	"\n [TestMode]"
+	"\n		MB_NO_TEST : stop to transmit"
+	"\n		MB_RX_TEST : reserve feature"
+	"\n		MB_TX_TEST : TX mode"
+	"\n		MB_CONT_RX_TEST : reserve feature"
+	"\n		MB_CONT_TX_TEST : continuous TX"
+	"\n		MB_LE_RX_TEST : reserve feature"
+	"\n		MB_LE_TX_TEST : LE TX mode"
+	"\n [DataPattern]"
+	"\n		0 : eBRM_TestMode_Pause"
+	"\n		1 : eBRM_TestMode_TX_0"
+	"\n		2 : eBRM_TestMode_TX_1"
+	"\n		3 : eBRM_TestMode_TX_1010"
+	"\n		4 : eBRM_TestMode_TX_PRBS"
+	"\n		5 : eBRM_TestMode_Loop_ACL"
+	"\n		6 : eBRM_TestMode_Loop_SCO"
+	"\n		7 : eBRM_TestMode_Loop_ACL_No_Whitening"
+	"\n		8 : eBRM_TestMode_Loop_SCO_No_Whitening"
+	"\n		9 : eBRM_TestMode_TX_11110000"
+	//"\n		10: eBRM_TestMode_Rx"
+
+	//"\n		255 : eBRM_TestMode_Exit"
+
+	"\n [PacketType] DM1,DH1,DM3,DH3,DM5,DM5,2-DH1,2-DH3,2-DH5,3-DH1,3-DH3,3-DH5"
+	"\n [DataLen] length of data"
+	"\n [HopMode]"
+	"\n	0 => DISABLE"
+	"\n	1 => ENABLE"
+	"\n	fixed to 0 for Continuous TX(1 MHz tone)"
+	"\n [TxFreq] 0~78(0=2402 MHz, 39=2441MHz, 78=2480MHz)"
+	"\n [Power] 1 ~ 8"
+	"\n		1 : -20 dbm"
+	"\n		2 : -16 dbm"
+	"\n		3 : -12 dbm"
+	"\n		4 : -8 dbm"
+	"\n		5 : -4 dbm"
+	"\n		6 : 0 dbm"
+	"\n		7 : 4 dbm"
+	"\n		8 : 8 dbm"
+	"\n [RxFreq] 0 ~ 78 (0=2402 MHz, 39=2441MHz, 78=2480MHz)"
+	"\nExample:"
+	"\tbtconfig cmdline MB_TX_TEST 4 DM1 100 0 39 0 39\t"
+	"\n		TX Mode|DataPattern = PRBS|DM1|length=100 bytes|Hop OFF|TX ch=39|power=-20dbm|RX ch=39"
+	"\tbtconfig cmdline MB_CONT_TX_TEST 3 DM1 100 0 39 8 39\t"
+	"\n		CONT TX Mode|DataPattern=1010|DM1|length=100bytes|Cont TX ON|TX ch=39|power=8dbm|RX ch=39"
+	"\n\n2. Usage for LE TX:"
+	"\n btconfig cmdline [TestMode|DataPattern|DataLen|TxFreq|"
+	"\n [TestMode]"
+	"\n		MB_LE_TX_TEST : LE TX mode"
+	"\n [DataPattern] data pattern from 0 to 7"
+	"\n	0 => PRBS9"
+	"\n	1 => 11110000"
+	"\n	2 => 10101010"
+	"\n	3 => PRBS15"
+	"\n	4 => 11111111"
+	"\n	5 => 00000000"
+	"\n	6 => 00001111"
+	"\n	7 => 01010101"
+	"\n [DataLen] 0 to 37 bytes"
+	"\n [TxFreq] 0 ~ 39"
+	"\nExample:"
+	"\n btconfig cmdline MB_LE_TX_TEST 0 30 20"
+	"\n		LE TX mode|DataPattern=PRBS9|length=30bytes|TX ch=20"
+	"\n\n3. Usage for STOP/INITIAL TX:"
+	"\n btconfig cmdline [TestMode]"
+	"\nExample:"
+	"\tbtconfig cmdline MB_NO_TEST\t";
+
+//add by Austin for automatic manufacture tool
+
+static void cmdline(int uart_fd, int argc, char **argv){
+	int iRet,address,width,value,mask;
+	bdaddr_t bdaddr;
+	tBRM_Control_packet MasterBlaster;
+	UCHAR SkipRxSlot;
+	UCHAR buf[HCI_MAX_EVENT_SIZE];
+	BOOL TestEnabled = 0,Ok = TRUE;
+	UINT8 setContTxType;
+	tBtHostInterest HostInt;
+	fd_set master, read_fds;
+	//struct timeval timeout;
+	char BdAddr[18];
+
+	printf("\nrunning command line");
+	if(argc < 2){
+		printf("\n%s\n",cmdline_help);
+		return;
+	}
+
+	memset(&buf,0,HCI_MAX_EVENT_SIZE);
+	iRet = writeHciCommand(uart_fd, HCI_CMD_OGF_INFO_PARAM, HCI_CMD_OCF_READ_BD_ADDR, 0, buf);
+	if (buf[6] != 0) {
+		printf("\nread bdaddr command failed due to reason 0x%X",buf[6]);
+		return;
+	}else{
+		printf("\nread bdaddr command successfully");
+	}
+
+	int i,j;
+	char bda[18];
+	for (i=iRet-1,j=0;i>7;i--,j+=3) {
+		snprintf(&bda[j],sizeof(bda[j]),"%X",((buf[i]>>4)&0xFF));
+		snprintf(&bda[j+1],sizeof(bda[j+1]),"%X",(buf[i]&0x0F));
+		bda[j+2]=':';
+	}
+	snprintf(&bda[15],sizeof(bda[15]),"%X",((buf[7]>>4)&0xFF));
+	snprintf(&bda[16],sizeof(bda[16]),"%X",(buf[7]&0x0F));
+	bda[17] ='\0';
+	str2ba(bda,&bdaddr);
+	printf("\nBDAddr = %s",bda);
+
+	InitMasterBlaster(&MasterBlaster, &bdaddr, &SkipRxSlot);
+#ifndef DUMP_DEBUG
+
+	Ok = ReadHostInterest(uart_fd, &HostInt);
+	if(Ok) {
+		if (HostInt.TpcTableAddr && (HostInt.Version >= 0x0100)) {
+			Ok = ReadMemoryBlock(uart_fd, HostInt.TpcTableAddr, (UCHAR *)&TpcTable, sizeof(TpcTable));
+			MasterBlaster.testCtrl.Power = TpcTable.NumOfEntries - 1;
+		}
+	}
+	if(!Ok) {
+		printf ("\nCould not load TPC table.");
+		sleep (2);
+		Ok = TRUE;
+	}
+#endif
+
+	FD_ZERO(&master);
+	FD_ZERO(&read_fds);
+	FD_SET(0, &master);
+
+	//======================
+
+	//disable Sleep Mode
+
+	//======================
+
+	memset(&buf,0,sizeof(buf));
+	buf[0] = 0;		//disable Sleep mode
+
+	iRet = writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+	if(buf[6] != 0) {
+		printf("\nError: Sleep mode failed due to reason 0x%X",buf[6]);
+	}else{
+		printf("\nDisable Sleep mode successfully");
+	}
+
+	//======================
+
+	//Enable TX Mode
+
+	//======================
+
+	if (strcmp("MB_TX_TEST", argv[1]) == 0){
+		if(argc < 9){
+			printf("\n%s\n",cmdline_help);
+			return;
+		}
+		printf("\nEnable TX Mode\n");
+
+		//==================================
+
+		// check it is under test mode
+
+		//==================================
+
+		Ok = Dut(uart_fd);
+		if (!Ok) {
+			printf("\nERROR ---> Could not enter DUT mode\n");
+		}
+
+		memset(&buf,0,HCI_MAX_EVENT_SIZE);
+
+		buf[0] = atoi(argv[2]);		//Data Pattern
+
+		if (strcmp("DM1", argv[3]) == 0)		//PacketType
+
+			buf[1] = 0x03;
+		else if (strcmp("DH1", argv[3]) == 0)
+			buf[1] = 0x04;
+		else if (strcmp("DM3", argv[3]) == 0)
+			buf[1] = 0x0A;
+		else if (strcmp("DH3", argv[3]) == 0)
+			buf[1] = 0x0B;
+		else if (strcmp("DM5", argv[3]) == 0)
+			buf[1] = 0x0E;
+		else if (strcmp("DH5", argv[3]) == 0)
+			buf[1] = 0x0F;
+		else if (strcmp("2-DH1", argv[3]) == 0)
+			buf[1] = 0x24;
+		else if (strcmp("2-DH3", argv[3]) == 0)
+			buf[1] = 0x2A;
+		else if (strcmp("2-DH5", argv[3]) == 0)
+			buf[1] = 0x2E;
+		else if (strcmp("3-DH1", argv[3]) == 0)
+			buf[1] = 0x28;
+		else if (strcmp("3-DH3", argv[3]) == 0)
+			buf[1] = 0x2B;
+		else if (strcmp("3-DH5", argv[3]) == 0)
+			buf[1] = 0x2F;
+		buf[2] = (atoi(argv[4]) & 0xFF);		//DataLen
+
+		buf[3] = (atoi(argv[4])>>8 & 0xFF);		//DataLen
+
+		buf[4] = atoi(argv[5]);		//HopMode
+
+		buf[5] = atoi(argv[6]);		//TxFreq
+
+		buf[6] = atoi(argv[7]);		//Power
+
+		buf[7] = atoi(argv[8]);		//RxFreq
+
+		buf[8] = MasterBlaster.bdaddr[0];
+		buf[9] = MasterBlaster.bdaddr[1];
+		buf[10] = MasterBlaster.bdaddr[2];
+		buf[11] = MasterBlaster.bdaddr[3];
+		buf[12] = MasterBlaster.bdaddr[4];
+		buf[13] = MasterBlaster.bdaddr[5];
+		buf[14] = SkipRxSlot;
+
+		ba2str((const bdaddr_t *)MasterBlaster.bdaddr, BdAddr);
+
+		if (strcmp("0", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Pause |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("1", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=all 0 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("2", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=all 1 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("3", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=1010 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("4", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=PRBS |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("5", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_ACL |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("6", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_SCO |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("7", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_ACL_No_Whitening |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("8", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_SCO_No_Whitening |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("9", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=11110000 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+
+		iRet = writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_TX_TESTER, 15, buf);
+		if (buf[6] != 0) {
+			printf("\nTx Tester command failed due to reason 0x%X",buf[6]);
+			printf("\nERROR --> Could not enable master blaster mode");
+			TestEnabled = MB_NO_TEST;
+			Ok = 0;
+		} else {
+			printf("\ntx test is in progress. Press type 'btconfig cmdline MB_NO_TEST' to stop the test");
+			TestEnabled = MB_TX_TEST;
+		}
+	}
+	//===========================
+
+	//Enable Continuous TX Mode
+
+	//===========================
+
+	else if (strcmp("MB_CONT_TX_TEST", argv[1]) == 0){
+		if(argc < 9){
+			printf("\n%s\n",cmdline_help);
+			return;
+		}
+		printf("\nEnable Continuous TX Mode");
+
+		Ok = Dut(uart_fd);
+		if (!Ok)
+			printf("\nERROR ---> Could not enter DUT mode");
+
+		/* Enable master blaster mode */
+		if (CW_Single_Tone == MasterBlaster.ContTxType)
+			setContTxType = Cont_Tx_Raw_1MHz;
+		else
+			setContTxType = MasterBlaster.ContTxType;
+
+		memset(&buf, 0, HCI_MAX_EVENT_SIZE);
+		buf[0] = atoi(argv[2]);		//Data Pattern
+
+		if (strcmp("DM1", argv[3]) == 0)		//PacketType
+
+			buf[1] = 0x03;
+		else if (strcmp("DH1", argv[3]) == 0)
+			buf[1] = 0x04;
+		else if (strcmp("DM3", argv[3]) == 0)
+			buf[1] = 0x0A;
+		else if (strcmp("DH3", argv[3]) == 0)
+			buf[1] = 0x0B;
+		else if (strcmp("DM5", argv[3]) == 0)
+			buf[1] = 0x0E;
+		else if (strcmp("DH5", argv[3]) == 0)
+			buf[1] = 0x0F;
+		else if (strcmp("2-DH1", argv[3]) == 0)
+			buf[1] = 0x24;
+		else if (strcmp("2-DH3", argv[3]) == 0)
+			buf[1] = 0x2A;
+		else if (strcmp("2-DH5", argv[3]) == 0)
+			buf[1] = 0x2E;
+		else if (strcmp("3-DH1", argv[3]) == 0)
+			buf[1] = 0x28;
+		else if (strcmp("3-DH3", argv[3]) == 0)
+			buf[1] = 0x2B;
+		else if (strcmp("3-DH5", argv[3]) == 0)
+			buf[1] = 0x2F;
+		buf[2] = (atoi(argv[4]) & 0xFF);//DataLen
+
+		buf[3] = (atoi(argv[4])>>8 & 0xFF);//DataLen
+
+		buf[4] = atoi(argv[5]);//Continuous TX which is fixed to "Cont_Tx_Raw_1MHz"
+
+		buf[5] = atoi(argv[6]);//TxFreq
+
+		buf[6] = atoi(argv[7]);//Power
+
+		buf[7] = atoi(argv[8]);//RxFreq
+
+		buf[8] = MasterBlaster.bdaddr[0];
+		buf[9] = MasterBlaster.bdaddr[1];
+		buf[10] = MasterBlaster.bdaddr[2];
+		buf[11] = MasterBlaster.bdaddr[3];
+		buf[12] = MasterBlaster.bdaddr[4];
+		buf[13] = MasterBlaster.bdaddr[5];
+		ba2str((const bdaddr_t *)MasterBlaster.bdaddr, BdAddr);
+
+		if (strcmp("0", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Pause |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("1", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=all 0 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("2", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=all 1 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("3", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=1010 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("4", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=PRBS |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("5", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_ACL |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("6", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_SCO |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("7", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_ACL_No_Whitening |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("8", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=Loop_SCO_No_Whitening |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+		if (strcmp("9", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=11110000 |PacketType=%s | DataLen=%d | HopMode=%d | TxFreq=%d | Power level=%d | RxFreq=%d | BdAddr=0x%s", argv[1], argv[3], atoi(argv[4]), buf[4], buf[5], buf[6], buf[7], BdAddr);
+
+		iRet = writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_CONT_TX_TESTER, 14, buf);
+		if(buf[6] != 0){
+			printf("\nContinious Tx Tester command failed due to reason 0x%X",buf[6]);
+			Ok = FALSE;
+		} else
+			Ok = TRUE;
+		memset(&buf,0,HCI_MAX_EVENT_SIZE);
+		address = 0x00022914;
+		value = 0x00200000;
+		mask = 0x00200000;
+		width = 4;
+		buf[0] = (address & 0xFF);
+		buf[1] = ((address >>8) & 0xFF);
+		buf[2] = ((address>>16) & 0xFF);
+		buf[3] = ((address>>24) & 0xFF);
+		buf[4] = width;  //Memory width
+
+		buf[5] = (value & 0xFF);
+		buf[6] = ((value >> 8) & 0xFF);
+		buf[7] = ((value >> 16) & 0xFF);
+		buf[8] = ((value >> 24) & 0xFF);
+		buf[9] = (mask & 0xFF);
+		buf[10] = ((mask >>8) & 0xFF);
+		buf[11] = ((mask>>16) & 0xFF);
+		buf[12] = ((mask>>24) & 0xFF);
+		iRet = writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_WRITE_MEMORY, 13, buf);
+		if(buf[6] != 0){
+			printf("\nWrite memory address failed due to reason 0x%X",buf[6]);
+			Ok = FALSE;
+		} else
+			Ok = TRUE;
+			TestEnabled = MB_CONT_TX_TEST;
+		if (Ok) {
+			printf("\nContinuous Test is in progress. Press type 'btconfig cmdline MB_NO_TEST' to stop the test");
+		} else {
+			printf("\nERROR ---> Could not enable master blaster mode");
+			TestEnabled = MB_NO_TEST;
+		}
+	}
+	//======================
+
+	//Enable LE TX Mode
+
+	//======================
+
+	else if (strcmp("MB_LE_TX_TEST", argv[1]) == 0){
+		if(argc < 5){
+			printf("\n%s\n",cmdline_help);
+			return;
+		}
+		printf("\nEnable LE TX Mode");
+
+		buf[0] = atoi(argv[2]);//Data Pattern
+
+		buf[2] = atoi(argv[3]);//Data Length
+
+		buf[5] = atoi(argv[4]);//TX Freq
+
+
+		if (strcmp("0", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=PRBS9 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+		else if (strcmp("1", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=11110000 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+		else if (strcmp("2", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=10101010 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+		else if (strcmp("3", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=PRBS15 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+		else if (strcmp("4", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=11111111 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+		else if (strcmp("5", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=00000000 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+		else if (strcmp("6", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=00001111 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+		else if (strcmp("7", argv[2]) == 0)
+			printf("\nTestMode=%s | DataPattern=01010101 | DataLen=%s | TxFreq=%s", argv[1], argv[3], argv[4]);
+
+		//BOOL SU_LETxTest(int dev_id, UCHAR channel, UCHAR length, UCHAR payload);
+
+		Ok = SU_LETxTest(uart_fd, buf[5], buf[2], buf[0]);
+
+		if (Ok) {
+			printf("\nLE Test is in progress. Press type 'btconfig cmdline MB_NO_TEST' to stop the test");
+			TestEnabled = MB_LE_TX_TEST;
+		} else {
+			printf("\nERROR ---> Could not enable master blaster mode");
+			TestEnabled = MB_NO_TEST;
+		}
+	}
+	//=========================
+
+	//Stop to transmit package
+
+	//=========================
+
+	else if (strcmp("MB_NO_TEST", argv[1]) == 0){
+		if(argc > 2){
+			printf("\n%s\n",cmdline_help);
+			return;
+		}
+		printf("\nStop to transmit package");
+
+		//================================================
+
+		//set BT to Sleep mode which is default setting
+
+		//================================================
+
+		memset(&buf,0,HCI_MAX_EVENT_SIZE);
+		buf[0] = 1;
+		iRet = writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+		if(buf[6] != 0) {
+				printf("\nError: Sleep mode failed due to reason 0x%X",buf[6]);
+		}else{
+			printf("\nEnable Sleep mode successfully");
+		}
+
+		//=================================================================
+
+		//send "HCI Reset" command to terminate the package transmission
+
+		//=================================================================
+
+		memset(&buf,0,sizeof(buf));
+		iRet = writeHciCommand(uart_fd, HCI_CMD_OGF_HOST_CTL, HCI_CMD_OCF_RESET, 0, buf);
+		if (buf[6] != 0) {
+			printf("\nError: HCI RESET failed due to reason 0x%X",buf[6]);
+			Ok = FALSE;
+		} else
+			Ok = TRUE;
+		if (!Ok) {
+			printf ("\nERROR ---> Could not stop test mode");
+		}
+		TestEnabled = MB_NO_TEST;
+	}else{
+		printf("\nWrong command");
+	}
+
+	UNUSED(TestEnabled);
+	UNUSED(setContTxType);
+	printf("\nDone\n");
+}
+
+static const char *mb_help = "Usage:\n\n mb\n";
+
+static void cmd_mb(int uart_fd, int argc, char **argv){
+	printf("Enter master blaster mode\n");
+
+	int FieldNum,iRet,iDataSize, fdmax, k, l, i, j;
+	bdaddr_t bdaddr;
+	tBRM_Control_packet MasterBlaster;
+	UCHAR	SkipRxSlot;
+	UCHAR buf[MAX_EVENT_SIZE];
+	char FieldAlias;
+	BOOL TestEnabled = 0, Ok = TRUE;
+	tBtHostInterest	HostInt;
+	fd_set master, read_fds;
+	uint32_t m_BerTotalBits, m_BerGoodBits;
+	uint8_t m_pattern[16];
+	uint16_t m_pPatternlength;
+	struct timeval timeout;
+	int bytesRead = 0;
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	iRet = writeHciCommand(uart_fd, HCI_CMD_OGF_INFO_PARAM, HCI_CMD_OCF_READ_BD_ADDR, 0, buf);
+	if (buf[6] != 0) {
+		printf("\nread bdaddr command failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	char bda[18];
+	for (i = iRet-1, j=0; i>7; i--,j+=3) {
+		snprintf(&bda[j],sizeof(bda[j]),"%X",((buf[i]>>4)&0xFF));
+		snprintf(&bda[j+1],sizeof(bda[j+1]),"%X",(buf[i]&0x0F));
+		bda[j+2] = ':'; 
+	}
+	snprintf(&bda[15],sizeof(bda[15]),"%X",((buf[7]>>4)&0xFF));
+	snprintf(&bda[16],sizeof(bda[16]),"%X",(buf[7]&0x0F));
+	bda[17] ='\0';
+	str2ba(bda,&bdaddr);
+	InitMasterBlaster(&MasterBlaster, &bdaddr, &SkipRxSlot);
+#ifndef DUMP_DEBUG
+	Ok = ReadHostInterest(uart_fd,&HostInt);
+	if(Ok) {
+		if (HostInt.TpcTableAddr && (HostInt.Version >= 0x0100)) {
+			Ok = ReadMemoryBlock(uart_fd, HostInt.TpcTableAddr, (UCHAR *)&TpcTable, sizeof(TpcTable));
+			MasterBlaster.testCtrl.Power = TpcTable.NumOfEntries - 1;
+		}
+	}
+	if(!Ok){
+		printf ("\nCould not load TPC table.\n");
+		sleep (2);
+		Ok = TRUE;
+	}
+#endif
+#ifdef DEBUG
+	int x = 0;
+	for(x ; x < argc; x++)
+		printf("@@@ %s ", argv[x]);
+	printf("\n");
+#endif
+
+	if (is_qca_transport_uart) {
+		printf("\nCannot support MB mode on %s\n",soc_type);
+		return;
+	}
+
+	if (argv[1] && !strncmp(argv[1],"cmd",3)) {
+		MasterBlaster.testCtrl.Power = atoi(argv[2]);
+		MasterBlaster.testCtrl.RxFreq = atoi(argv[3]);
+		MasterBlaster.testCtrl.TxFreq = atoi(argv[3]);
+		for (i = 0; i < (int)(sizeof(PacketTypeOption)/sizeof(tMasterBlasterOption)); ++i)
+		{
+			printf("%s %s\n",argv[4],PacketTypeOption[i].Name);
+			if (!strcmp(argv[4],PacketTypeOption[i].Name)) {
+				MasterBlaster.testCtrl.Packet = PacketTypeOption[i].Value;
+				MasterBlaster.testCtrl.DataLen = MaxDataLenOption[i];
+				printf("%s %s\n",argv[4],PacketTypeOption[i].Name);
+				break;
+			}
+		}
+		if (!strncmp(argv[5],"Tx",2)) {
+			OCFTXTestMode(uart_fd, &MasterBlaster, SkipRxSlot);
+			printf("Tx\n");
+		}
+		else if (!strncmp(argv[5],"Rx",2)) {
+			OCFRXTestMode(uart_fd, &MasterBlaster, SkipRxSlot);
+			printf("Rx\n");
+		}
+		getchar();
+		memset(&buf,0,sizeof(buf));
+		// OGF_HOST_CTL 0x03
+		// OCF_RESET 0x0003
+		writeHciCommand(uart_fd, 0x03, 0x0003,0,buf);
+		if (buf[6] != 0) {
+			printf("\nError: HCI RESET failed due to reason 0x%X\n",buf[6]);
+		}
+		return;
+	}
+	else if (argc > 1) {
+		printf("\n%s\n", mb_help);
+		return;
+	}
+
+	PrintMasterBlasterMenu (&MasterBlaster);
+	m_BerGoodBits = 0;
+	m_BerTotalBits = 0;
+	m_pattern[0] = 0x0f;
+	m_pPatternlength = 1;
+
+	FD_ZERO(&master);
+	FD_ZERO(&read_fds);
+	FD_SET(0, &master);
+	FD_SET(uart_fd, &master);
+	fdmax = uart_fd;
+
+	printf("Enter master blaster loop\n");
+	while (1) {
+		read_fds = master;
+		timeout.tv_sec = 5;
+		timeout.tv_usec = 0;
+		iRet = select(fdmax+1, &read_fds, NULL, NULL, &timeout);
+		if (iRet == -1) {
+			perror("cmd_mb select() error!");
+			goto exits_mb;
+		}
+		if (iRet == 0) continue;
+
+		for(i = 0; i <= fdmax; i++) {
+			if(FD_ISSET(i, &read_fds)) {
+				if (i==0) {// input
+					scanf("%s",buf);
+					FieldAlias = (char)buf[0];
+					FieldNum = CheckField(MasterBlaster, &FieldAlias);
+					if (FieldNum == INVALID_MASTERBLASTER_FIELD) {
+						printf ("\nERROR ---> Invalid command. Try again.\n");
+						printf ("mb>");
+						continue;
+					}
+
+					if (!strncmp(&FieldAlias, MasterBlasterMenu[EXX].Alias, 1)) {
+						printf("\nExit the Master Blaster Mode without reset\n");
+						goto exits_mb;
+					}
+
+					// if the test is in rx and the key is neither 'd' nor 'g', then stop the test, renew the option, and procced
+					// if the test is in tx and the key is not 'e', then stop the test, renew the option, and procced
+					// if the test is in (LE) continuous rx/tx and the key is not 'j' , then stop the test, renew the option, and procced
+					if (((TestEnabled == MB_RX_TEST) &&
+					     strncmp(&FieldAlias, MasterBlasterMenu[RX].Alias, 1) &&
+					     strncmp(&FieldAlias, MasterBlasterMenu[GB].Alias, 1)) ||
+
+					    ((TestEnabled == MB_TX_TEST) &&
+					     strncmp(&FieldAlias, MasterBlasterMenu[TX].Alias, 1)) ||
+
+					    ((TestEnabled == MB_CONT_RX_TEST || TestEnabled == MB_CONT_TX_TEST ||
+					      TestEnabled == MB_LE_RX_TEST || TestEnabled == MB_LE_TX_TEST) &&
+					     (strncmp(&FieldAlias, MasterBlasterMenu[EN].Alias, 1)))) {
+						printf (" ... Please wait ...");
+						if (MasterBlaster.ContTxMode) {
+							memset(&buf,0,MAX_EVENT_SIZE);
+							buf[0] = 255;
+							writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_CONT_TX_TESTER, 14, buf);
+							if(buf[6] != 0) {
+								printf("\nContinious Tx Tester command failed due to reason 0x%X\n",buf[6]);
+								Ok = 0;
+							} else
+								Ok = TRUE;
+						}
+
+						memset(&buf,0,sizeof(buf));
+						// The default setting is sleep mode enabled
+						buf[0] = 1;
+						iRet = writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+						if(buf[6] != 0) {
+							printf("\nError: Sleep mode failed due to reason 0x%X\n",buf[6]);
+						}
+
+						// OGF_HOST_CTL 0x03
+						// OCF_RESET 0x0003
+						memset(&buf, 0, sizeof(buf));
+						writeHciCommand(uart_fd,0x03,0x0003,0,buf);
+						if (buf[6] != 0) {
+							printf("\nError: HCI RESET failed due to reason 0x%X\n",buf[6]);
+							Ok = FALSE;
+						} else
+							Ok = TRUE;
+						if (!Ok) {
+							printf ("\nERROR ---> Could not stop test mode\n");
+						} else if (!strncmp(&FieldAlias, MasterBlasterMenu[RX].Alias, 1) ||
+							   !strncmp(&FieldAlias, MasterBlasterMenu[TX].Alias, 1) ||
+							   ((TestEnabled != MB_NO_TEST) &&
+							    (!strncmp(&FieldAlias, MasterBlasterMenu[CR].Alias, 1) ||
+							     !strncmp(&FieldAlias, MasterBlasterMenu[CT].Alias, 1) ||
+							     !strncmp(&FieldAlias, MasterBlasterMenu[LR].Alias, 1) ||
+							     !strncmp(&FieldAlias, MasterBlasterMenu[LT].Alias, 1))) ||
+							   !strncmp(&FieldAlias, MasterBlasterMenu[EN].Alias, 1)) {
+							TestEnabled = MB_NO_TEST;
+						}
+						sleep(1);
+					}
+					if (!strncmp(&FieldAlias,MasterBlasterMenu[EX].Alias,1)){// Exit
+						TestEnabled = MB_NO_TEST;
+						printf ("\n Exit ..\n");
+						goto exits_mb;
+					} else if (!strncmp(&FieldAlias,MasterBlasterMenu[ST].Alias,1)) {// Stop Test
+						TestEnabled = MB_NO_TEST;
+						PrintMasterBlasterMenu (&MasterBlaster);
+						continue;
+					} else if (!strncmp(&FieldAlias,MasterBlasterMenu[GB].Alias,1)) {// get BER
+						printf("\n\tGoodBits %d, total is %d\n", m_BerGoodBits, m_BerTotalBits);
+						printf("mb>\n");
+						continue;
+					} else if (!strncmp(&FieldAlias,MasterBlasterMenu[PO].Alias,1)) {// set Power
+						MasterBlasterMenu[FieldNum].pFunc (&MasterBlaster, (tMasterBlasterOption*)&FieldAlias);
+					} else if (!MasterBlasterMenu[FieldNum].pFunc (&MasterBlaster, MasterBlasterMenu[FieldNum].Options)) {
+						printf ("\nERROR ---> Invalid option. Try again.\n");
+						printf ("mb>");
+						continue;
+					}
+					PrintMasterBlasterMenu(&MasterBlaster);
+
+					// Enable RX test mode
+					if ((!strncmp(&FieldAlias, MasterBlasterMenu[RX].Alias, 1) &&
+					     (TestEnabled == MB_NO_TEST)) ||
+					    (strncmp(&FieldAlias, MasterBlasterMenu[RX].Alias, 1) &&
+					     (TestEnabled == MB_RX_TEST))) {
+						iRet = OCFRXTestMode(uart_fd, &MasterBlaster, SkipRxSlot);
+						if (iRet != -1)
+							TestEnabled = iRet;
+						printf("mb>");
+						continue;
+					} else if ((!strncmp(&FieldAlias, MasterBlasterMenu[RX].Alias, 1)) && (TestEnabled == MB_RX_TEST)) {
+						printf(" rx test is in progress. Press 's' to stop the test\n");
+						printf("mb>");
+						continue;
+					}
+
+					// Enable TX test mode
+					if ((!strncmp(&FieldAlias, MasterBlasterMenu[TX].Alias, 1) &&
+					     (TestEnabled == MB_NO_TEST)) ||
+					    (strncmp(&FieldAlias, MasterBlasterMenu[TX].Alias, 1) &&
+					     (TestEnabled == MB_TX_TEST))) {
+						// Disable sleep mode
+						printf (".");
+						Ok = TRUE;
+						iRet = OCFTXTestMode(uart_fd, &MasterBlaster, SkipRxSlot);
+						if (iRet != -1)
+							TestEnabled = iRet;
+						printf("mb>");
+						continue;
+					} else if ((!strncmp(&FieldAlias, MasterBlasterMenu[TX].Alias, 1)) && TestEnabled == MB_TX_TEST) {
+						printf(" tx test is in progress. Press 's' to stop the test\n");
+						printf("mb>");
+						continue;
+					}
+
+					/* Enable (LE) continuous tx/rx test modes */
+					if (((!strncmp(&FieldAlias, MasterBlasterMenu[EN].Alias, 1)) &&
+					     (TestEnabled == MB_NO_TEST)) ||
+					    (strncmp(&FieldAlias, MasterBlasterMenu[EN].Alias, 1) &&
+					     (TestEnabled == MB_CONT_RX_TEST ||
+					      TestEnabled == MB_CONT_TX_TEST ||
+					      TestEnabled == MB_LE_RX_TEST ||
+					      TestEnabled == MB_LE_TX_TEST))) {
+
+						if (MasterBlaster.ContTxMode == ENABLE) {
+							printf(".");
+							iRet = OCFContTXTestMode(uart_fd, &MasterBlaster);
+							if (iRet != -1) {
+								TestEnabled = iRet;
+							}
+							printf("mb>");
+							continue;
+						} else if (MasterBlaster.ContRxMode == ENABLE) {
+							printf(".");
+							iRet = OCFContRXTestMode(uart_fd, &MasterBlaster);
+							if (iRet != -1) {
+								TestEnabled = iRet;
+							}
+							printf("mb>");
+							continue;
+						}
+
+						// Disable sleep mode
+						printf (".");
+						Ok = TRUE;
+						memset(&buf,0,sizeof(buf));
+						buf[0] = 0;
+						writeHciCommand(uart_fd,HCI_VENDOR_CMD_OGF,OCF_SLEEP_MODE,1,buf);
+						if (buf[6] != 0) {
+							printf("\nError: Sleep mode failed due to reason 0x%X\n",buf[6]);
+							Ok = 0;
+						}
+
+						if (!Ok) {
+							printf ("\nERROR ---> Could not disable sleep mode\n");
+							printf ("mb>");
+							continue;
+						}
+
+						/*  LE Rx Mode */
+						if (MasterBlaster.LERxMode == ENABLE) {
+							Ok = SU_LERxTest(uart_fd, MasterBlaster.testCtrl.RxFreq);
+							TestEnabled = MB_LE_RX_TEST;
+						} else if (MasterBlaster.LETxMode == ENABLE) {
+							Ok = SU_LETxTest(uart_fd, MasterBlaster.testCtrl.TxFreq, MasterBlaster.testCtrl.DataLen,
+									 MasterBlaster.LETxParms.PktPayload);
+							TestEnabled = MB_LE_TX_TEST;
+						}
+						if (Ok) {
+							printf("Test is in progress. Press 's' to stop the test\n");
+						} else {
+							printf("\nERROR ---> Could not enable master blaster mode\n");
+							TestEnabled = MB_NO_TEST;
+						}
+						printf("mb>");
+						continue;
+					} else if ((!strncmp(&FieldAlias, MasterBlasterMenu[EN].Alias, 1)) && TestEnabled) {
+						printf (" Test mode is in progress. Press 's' to stop the test\n");
+						printf ("mb>");
+						continue;
+					}
+				}
+				else if (i == uart_fd) {
+					bytesRead += read(i, buf, sizeof(buf)-bytesRead);
+					if (buf[0] != 0x02) {
+						printf("OUT OF SYNC\n");
+						iRet = bytesRead;
+						bytesRead = 0;
+						continue;
+					}
+					if (bytesRead < (buf[3] | (buf[4] << 8)) &&
+					    bytesRead < (int)sizeof(buf)) {
+						printf("read %d bytes, reading more\n", bytesRead);
+						continue;
+					} else {
+						iRet = bytesRead;
+						bytesRead = 0;
+					}
+
+					iDataSize = iRet - 5;
+					printf("b[0]=%2x\tb[1]=%2x\tb[2]=%2x\tb[3]=%2x\tb[4]=%2x\n",
+					       buf[0],buf[1],buf[2],buf[3],buf[4]);
+					printf("first:%x,nbyte:%d, packet:%d, pattern:%x\n",
+					       buf[0], iRet, (uint16_t)(buf[3] | (buf[4] << 8)), buf[5]);
+
+					if (buf[0] == 0x2) {        // ACL data
+						m_BerTotalBits = m_BerTotalBits + iDataSize * 8;
+						if (iDataSize > MAX_EVENT_SIZE - 9)
+							iDataSize = MAX_EVENT_SIZE - 9;
+						for(j=0,l=0;j<iDataSize;j++,l++) {
+							if (l == m_pPatternlength)
+								l = 0;
+							for(k=0;k<8;k++) {
+								// Austin 0916,
+								// change initial offset from 8 to 5
+								if((m_pattern[l]&(1<<k)) == (buf[5+j]&(1<<k)))
+									m_BerGoodBits++;
+							}
+							printf("byte#:%d, bytet:%x, pattern:%x\n", l, buf[5+j], m_pattern[l]);
+						}
+					}
+				}
+			}
+		}
+	}
+exits_mb:
+
+	return;
+}
+/*
+   static void cmd_gid(int uart_fd, int argc, char **argv){
+   printf("\nFeature not implemented\n");
+   }
+ */
+static const char *wsm_help =
+"Usage:\n"
+"\n wsm [0|1|2|3]\n"
+"\nExample:\n"
+"\twsm 0\t(Scan disabled)\n"
+"\twsm 1\t(Inquiry scan enabled)\n"
+"\twsm 2\t(Page scan enabled)\n"
+"\twsm 3\t(Inquiry and Page scan enabled)\n";
+
+static void cmd_wsm(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	if(argc < 2){
+		printf("\n%s\n",wsm_help);
+		return;
+	}
+	if(atoi(argv[1]) > 3){
+		printf("\nInvalid scan mode :%d\n",atoi(argv[1]));
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = atoi(argv[1]);
+	// OGF_HOST_CTL	 0x03
+	// OCF_WRITE_SCAN_ENABLE 0x001A
+	writeHciCommand(uart_fd, 0x03, 0x001A, 1, buf);
+	if(buf[6] != 0){
+		printf("\nWrite scan mode command failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	printf("\nScan Mode set to :%d\n",atoi(argv[1]));
+}
+
+static void dumpHex(UCHAR *buf, int length, int col)
+{
+	int i;
+	for (i = 0; i < length; i++) {
+		printf("0x%02x ", buf[i]);
+		if (((i+1) % col) == 0 && i != 0)
+			printf("\n");
+	}
+	if (((i+1) % col) != 0) printf("\n");
+}
+
+static void ReverseHexString(char *pStr)
+{
+	int i, j;
+	char temp;
+	int len = strlen(pStr);
+
+	for (i = 0; pStr[i] == ' ' || pStr[i] == '\t'; i++);
+
+	if (pStr[i] == '0' && pStr[i+1] == 'x')
+		i += 2;
+
+	for (j = len - 1; i < j - 2; i += 2, j -= 2) {
+		temp = pStr[i];
+		pStr[i] = pStr[j - 1];
+		pStr[j - 1] = temp;
+		temp = pStr[i + 1];
+		pStr[i + 1] = pStr[j];
+		pStr[j] = temp;
+	}
+}
+
+static void GetByteSeq(UCHAR *pDst, UCHAR *pSrc, int Size)
+{
+	UCHAR LowNibble, Nibble = 0;
+	UCHAR *pLastHex;
+	UCHAR *pStr = pSrc;
+
+	while (*pStr == ' ' || *pStr == '\t') pStr++;
+
+	if ((pStr[0] == '0') && (pStr[1] == 'x'))
+		pStr += 2;
+
+	pLastHex = pStr - 1;
+	while (IS_HEX(*(pLastHex + 1)))
+		pLastHex++;
+
+	LowNibble = 0;
+
+	while (Size > 0) {
+		if (pStr <= pLastHex) {
+			Nibble = CONV_HEX_DIGIT_TO_VALUE(*pStr);
+			pStr++;
+		} else {
+			Nibble = 0;
+		}
+
+		if (LowNibble) {
+			*pDst |= (UCHAR)(Nibble & 0x0F);
+			LowNibble = 0;
+			pDst++;
+			Size--;
+		} else {
+			*pDst = (UCHAR)((Nibble << 4) & 0xF0);
+			LowNibble = 1;
+		}
+	}
+}
+
+unsigned int GetUInt(char **ppLine, unsigned int DefaultValue)
+{
+	char *pStr = *ppLine;
+	unsigned int Value = 0;
+
+	// Is it a hex value?
+	if ((*pStr == '0') && (*(pStr+1) == 'x'))
+	{
+		// We have a hex value
+
+		pStr += 2;
+
+		while (IS_HEX(*pStr))
+		{
+			Value = CONV_HEX_DIGIT_TO_VALUE(*pStr) + (Value*16);
+			pStr++;
+		}
+
+	}
+	else if (IS_DIGIT(*pStr))
+	{
+		// We have a decimal value
+		while (IS_DIGIT(*pStr))
+		{
+			Value = CONV_DEC_DIGIT_TO_VALUE(*pStr) + (Value*10);
+			pStr++;
+		}
+	}
+	else
+	{
+		// We don't have a value at all - return default value
+		return DefaultValue;
+	}
+
+	// Update the BtString ptr
+	*ppLine = pStr;
+	return Value;
+}
+
+static const char *mbr_help =
+"Usage:\n"
+"\n mbr <address> <length> \n"
+"\n Example \n"
+"\n mbr 0x00004FFC 10 \n"
+"\n mbr 0x00004FFC 0x10 \n";
+
+static void cmd_mbr(int uart_fd, int argc, char **argv){
+
+	UCHAR buf[MAX_EVENT_SIZE*20];
+
+	if(argc != 3){
+		printf("\n%s\n",mbr_help);
+		return;
+	}
+
+	int length = GetUInt(&(argv[2]),0);
+	int address  = GetUInt(&(argv[1]),0);
+
+	if ((address == 0) || (length==0)){
+		return;
+	}
+	memset(&buf,0,MAX_EVENT_SIZE*20);
+	if(!MemBlkRead(uart_fd,address,buf, length)) {
+		printf("\nmemory bulk read command failed\n");
+		return;
+	}
+	printf("\ndata: \n");
+	int i;
+	for(i=0;i < length;i+=4){
+		printf("%08X: ",address+i);
+		printf("%08X",*((int*)(buf+i)));
+		printf("\n");
+	}
+	printf("\n");
+}
+
+static const char *psr_help =
+"Usage:\n"
+"\n psr \n";
+
+static void cmd_psr(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	if(argv) UNUSED(argv);
+	if(argc > 1){
+		printf("\n%s\n",psr_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	LoadPSHeader(buf,PS_RESET,0,0);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS,PS_COMMAND_HEADER+2, buf);
+	if(buf[7] != 0){ /* Check for status */
+		printf("\n PS Reset failed\n");
+		return;
+	}
+	printf("PS reset done\n");
+}
+
+static const char *rpst_help =
+"Usage:\n"
+"\n rpst <tag id> <tag length> \n"
+"\n Example:\n"
+"\n rpst 1 6 \n";
+
+static void cmd_rpst(int uart_fd, int argc, char **argv){
+	int iRet;
+	UCHAR buf[MAX_EVENT_SIZE];
+	int tag_id,tag_len,i,j;
+	if(argc != 3){
+		printf("\n%s\n",rpst_help);
+		return;
+	}
+	memset(&buf,0,MAX_EVENT_SIZE);
+	tag_id = GetUInt(&(argv[1]),0);
+	tag_len = GetUInt(&(argv[2]),0);
+	LoadPSHeader(buf,PS_READ,tag_len,tag_id);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, PS_COMMAND_HEADER, buf);
+	if(buf[6] != 0){
+		printf("\n read PS tag failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	iRet = read(uart_fd,&buf,MAX_EVENT_SIZE);
+	if(iRet < 0){
+		printf("\n read PS tag failed\n");
+		return;
+	}
+	printf("\nTag ID :%X\nTag Length:%X\nTag Data:\n",tag_id,tag_len);
+	for(i=4,j=1;i<iRet;i++,j++){
+		printf("%02X ",buf[i]);
+		if(j%16 == 0)
+			printf("\n");
+	}
+	printf("\n\n");
+}
+static const char *wpst_help =
+"Usage:\n"
+"\n wpst <tag id> <tag length> <tag data>\n"
+"\n Example:\n"
+"\n wpst 1 6 00 03 F4 55 AB 77 \n";
+
+static void cmd_wpst(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int tag_id,tag_len,i;
+	if(argc < 4){
+		printf("\n%s\n",wpst_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	tag_id = GetUInt(&(argv[1]),0);
+	tag_len = GetUInt(&(argv[2]),0);
+	if(argc < tag_len+3){
+		printf("\n Tag Data is less than Tag Length\n");
+		return;
+	}
+	LoadPSHeader(buf,PS_WRITE,tag_len,tag_id);
+	for(i=0;i<tag_len;i++){
+		buf[i+4] = strtol(argv[i+3], NULL, 16);
+	}
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, PS_COMMAND_HEADER + tag_len, buf);
+	if(buf[6] != 0){
+		printf("\n Write PS tag failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+}
+
+static const char *setam_help =
+"Usage:\n"
+"\nsetam <storage medium> <access mode>\n"
+"\nstorage medium: 0-RAM  1-EEPROM\n"
+"\naccess mode: 0-Read-only 1-Write-only 2-Read-Write 3- Disabled\n"
+"\nExample:\n"
+"\nsetam 0 3\n";
+static void cmd_setam(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int medium,mode;
+	if(argc !=3){
+		printf("\n%s\n",setam_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	medium = GetUInt(&(argv[1]),0);
+	mode = GetUInt(&(argv[2]),0);
+	LoadPSHeader(buf,PS_SET_ACCESS_MODE,mode,medium);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, PS_COMMAND_HEADER, buf);
+	if(buf[6] != 0){
+		printf("\nSet Access mode failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	printf("\nAccess mode changed successfully!\n");
+}
+
+static const char *setap_help =
+"Usage:\n"
+"\nsetap <storage medium> <priority>\n"
+"\nstorage medium: 0-RAM  1-EEPROM\n"
+"\npriority: #Highest number corresponds to highest priority\n"
+"\nExample:\n"
+"\nsetap 0 1\n";
+
+static void cmd_setap(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int medium,priority;
+	if(argc !=3){
+		printf("\n%s\n",setap_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	medium = GetUInt(&(argv[1]),0);
+	priority = GetUInt(&(argv[2]),0);
+	LoadPSHeader(buf,PS_SET_ACCESS_MODE,priority,medium);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, PS_COMMAND_HEADER, buf);
+	if(buf[6] != 0){
+		printf("\nSet Access priority failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	printf("\nPriority changed successfully!\n");
+}
+
+static const char *rpsraw_help =
+"Usage:\n"
+"\n rpsraw <offset> <length> \n"
+"\n Example:\n"
+"\n rpsraw 0x012c 10\n";
+static void cmd_rpsraw(int uart_fd, int argc, char **argv){
+	int iRet;
+	UCHAR buf[MAX_EVENT_SIZE];
+	int offset,len,i,j;
+	if(argc != 3){
+		printf("\n%s\n",rpsraw_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	offset = GetUInt(&(argv[1]),0);
+	len = GetUInt(&(argv[2]),0);
+	LoadPSHeader(buf,PS_READ_RAW,len,offset);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, PS_COMMAND_HEADER, buf);
+	if(buf[6] != 0){
+		printf("\n read PS raw failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	iRet = read(uart_fd,&buf,MAX_EVENT_SIZE);
+	if(iRet < 0){
+		printf("\n read PS raw failed\n");
+		return;
+	}
+	printf("\nOffset :%X\nLength:%X\nData:\n",offset,len);
+
+	for(i=4,j=1;i<iRet;i++,j++){
+		printf("%02X ",buf[i]);
+		if(j%16 == 0)
+			printf("\n");
+	}
+	printf("\n\n");
+
+}
+static const char *wpsraw_help =
+"Usage:\n"
+"\n wpsraw <offset> <length> <data>\n"
+"\n Example:\n"
+"\n wpsraw 0x012C 6 00 03 F4 55 AB 77 \n";
+
+static void cmd_wpsraw(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int offset,len,i;
+	if(argc < 4){
+		printf("\n%s\n",wpsraw_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	offset = GetUInt(&(argv[1]),0);
+	len = GetUInt(&(argv[2]),0);
+	if(argc < len+3){
+		printf("\nData is less than Length\n");
+		return;
+	}
+	LoadPSHeader(buf,PS_WRITE_RAW,len,offset);
+	for(i=0;i<len;i++){
+		buf[i+4] = strtol(argv[i+3], NULL, 16);
+	}
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, PS_COMMAND_HEADER + len, buf);
+	if(buf[6] != 0){
+		printf("\n Write PS tag failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+}
+
+static const char *peek_help =
+"\nUsage:"
+"\npeek <address> <width>\n"
+"\nExample:\n"
+"\npeek 0x00004FFC 5\n";
+static void cmd_peek(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int address,width,value;
+	if(argc < 2){
+		printf("\n%s\n",peek_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	address = GetUInt(&(argv[1]),0);
+	if(argc == 3)
+		width = GetUInt(&(argv[2]),0x4);
+	else
+		width = 4;
+
+	buf[0] = (address & 0xFF);
+	buf[1] = ((address >>8) & 0xFF);
+	buf[2] = ((address>>16) & 0xFF);
+	buf[3] = ((address>>24) & 0xFF);
+	buf[4] = (UCHAR)width;  //Memory width
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_READ_MEMORY, 5, buf);
+	if(buf[6] != 0){
+		printf("\nRead Memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	value = buf[10];
+	value = ((value << 8) | buf[9]);
+	value = ((value << 8) | buf[8]);
+	value = ((value << 8) | buf[7]);
+	printf("\n0x%X : 0x%X \n",address,value);
+
+}
+
+static const char *cwtx_help =
+"\nUsage:"
+"\ncwtx <channel number>\n"
+"\nExample:\n"
+"\ncwtx 40"
+"\n\n";
+
+static void cmd_cwtx(int uart_fd, int argc, char **argv){
+	int Length = 0;
+	UCHAR buf[MAX_EVENT_SIZE];
+	int channel;
+	if(argc != 2){
+		printf("\n%s\n",cwtx_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	channel = atoi(argv[1]);
+	if(channel > 78 || channel < 0){
+		printf("\nPlease enter channel 0-78!\n");
+		return;
+	}
+	memset(&buf,0,MAX_EVENT_SIZE);
+	// OGF_HOST_CTL	 0x03
+	// OCF_RESET 0x0003
+	writeHciCommand(uart_fd, 0x03,0x0003,Length,buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 0x80;
+	buf[1] = 0x20;
+	buf[2] = 0x02;
+	buf[3] = 0x00;
+	buf[4] = 0x04;
+	buf[5] = 0xFF;
+	buf[6] = 0x08;
+	buf[7] = 0xC0;
+	buf[8] = 0x00;
+	buf[9] = 0xFF;
+	buf[10] = 0xFF;
+	buf[11] = 0xFF;
+	buf[12] = 0xFF;
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	/* hcitool cmd 0x3F 0x06 0x34 0x20 0x02 0x00 0x04 0x88 0xA0 0x00 0x02 0xFF 0xFF 0xFF 0xFF */
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 0x34;
+	buf[1] = 0x20;
+	buf[2] = 0x02;
+	buf[3] = 0x00;
+	buf[4] = 0x04;
+	buf[5] = 0x88;
+	buf[6] = 0xA0;
+	buf[7] = 0x00;
+	buf[8] = 0x02;
+	buf[9] = 0xFF;
+	buf[10] = 0xFF;
+	buf[11] = 0xFF;
+	buf[12] = 0xFF;
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	/* hcitool cmd 0x3F 0x06 0x28 0x20 0x02 0x00 0x04 0x00 0x90 0x05 0x20 0xFF 0xFF 0xFF 0xFF */
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 0x28;
+	buf[1] = 0x20;
+	buf[2] = 0x02;
+	buf[3] = 0x00;
+	buf[4] = 0x04;
+	buf[5] = 0x00;
+	buf[6] = 0x90;
+	buf[7] = 0x05;
+	buf[8] = 0x20;
+	buf[9] = 0xFF;
+	buf[10] = 0xFF;
+	buf[11] = 0xFF;
+	buf[12] = 0xFF;
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	/* hcitool cmd 0x3F 0x06 0x7C 0x08 0x02 0x00 0x04 0x01 0x00 0x00 0x4B 0xFF 0xFF 0xFF 0xFF */
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 0x7C;
+	buf[1] = 0x08;
+	buf[2] = 0x02;
+	buf[3] = 0x00;
+	buf[4] = 0x04;
+	buf[5] = 0x01;
+	buf[6] = 0x00;
+	buf[7] = 0x00;
+	buf[8] = 0x4B;
+	buf[9] = 0xFF;
+	buf[10] = 0xFF;
+	buf[11] = 0xFF;
+	buf[12] = 0xFF;
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+
+	/* hcitool cmd 0x3F 0x06 0x00 0x08 0x02 0x00 0x04 $number 0x00 0x00 0x00 0xFF 0xFF 0xFF 0xFF */
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = 0x00;
+	buf[1] = 0x08;
+	buf[2] = 0x02;
+	buf[3] = 0x00;
+	buf[4] = 0x04;
+	buf[5] = (UCHAR)channel; /* Num */
+	buf[6] = 0x00;
+	buf[7] = 0x00;
+	buf[8] = 0x00;
+	buf[9] = 0xFF;
+	buf[10] = 0xFF;
+	buf[11] = 0xFF;
+	buf[12] = 0xFF;
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF,OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	printf("\nEntering continuous wave Tx on channel %d\n",channel);
+
+}
+
+
+static const char *poke_help =
+"\nUsage:"
+"\npoke <address> <value> <mask> <width>\n"
+"\nExample:\n"
+"\npoke 0x580000 0x22005FF 0xFFFFFFFF 4"
+"\n\n";
+
+static void cmd_poke(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	int address,width,value,mask;
+	if(argc < 2){
+		printf("\n%s\n",poke_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	address = GetUInt(&(argv[1]),0);
+	value = GetUInt(&(argv[2]),0);
+	printf("\nARGC :%d\n",argc);
+	if(argc < 4)
+		mask = 0xffffffff;
+	else
+		mask = GetUInt(&(argv[3]),0xFFFFFFFF);
+	if(argc < 5)
+		width = 4;
+	else
+		width = GetUInt(&(argv[4]),0x4);
+	buf[0] = (address & 0xFF);
+	buf[1] = ((address >>8) & 0xFF);
+	buf[2] = ((address>>16) & 0xFF);
+	buf[3] = ((address>>24) & 0xFF);
+	buf[4] = width;  //Memory width
+	buf[5] = (value & 0xFF);
+	buf[6] = ((value >> 8) & 0xFF);
+	buf[7] = ((value >> 16) & 0xFF);
+	buf[8] = ((value >> 24) & 0xFF);
+	buf[9] = (mask & 0xFF);
+	buf[10] = ((mask >>8) & 0xFF);
+	buf[11] = ((mask>>16) & 0xFF);
+	buf[12] = ((mask>>24) & 0xFF);
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_WRITE_MEMORY, 13, buf);
+	if(buf[6] != 0){
+		printf("\nWrite memory address failed due to reason 0x%X\n",buf[6]);
+		return;
+	}
+	printf("\nPoke successful!\n");
+}
+
+
+
+static const char *dump_help =
+"\nUsage:"
+"\ndump audio - Display Audio statistics\n"
+"\ndump dma- Display DMA statistics\n"
+"\ndump dma r - Display and Reset DMA statistics\n"
+"\ndump tpc - Dump TPC tables\n"
+"\nExample:\n"
+"\ndump audio"
+"\ndump dma"
+"\ndump dma r"
+"\ndump tpc"
+"\n";
+
+
+static void cmd_dump(int uart_fd, int argc, char **argv){
+
+	if(argc < 2){
+		printf("\n%s\n",dump_help);
+		return;
+	}
+
+	if(!strncmp(argv[1],"audio",5)){
+		ReadAudioStats(uart_fd);
+	}
+	else if(!strncmp(argv[1],"dma",3)){
+		ReadGlobalDMAStats(uart_fd);
+		if(argc == 3 && !strncmp(argv[2],"r",1)){
+			ResetGlobalDMAStats(uart_fd);
+		}
+	}
+	else if(!strncmp(argv[1],"tpc",3)){
+		ReadTpcTable(uart_fd);
+	}
+	else{
+		printf("\nInvalid option");
+		printf("\n%s\n",dump_help);
+	}
+
+	return;
+}
+
+static const char *rafh_help =
+"\nUsage:"
+"\nrafh <connection handle>\n"
+"\nExample:\n"
+"\nrafh 0x15"
+"\n\n";
+
+static void cmd_rafh(int uart_fd, int argc, char **argv){
+	int iRet;
+	UCHAR buf[MAX_EVENT_SIZE];
+	short int handle;
+
+	if(argc < 2){
+		printf("\n%s\n",rafh_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	handle = GetUInt(&(argv[1]),0);
+	buf[0] = (handle & 0xFF);
+	buf[1] = ((handle >>8) & 0xFF);
+	// OGF_STATUS_PARAM 0x05
+	// OCF_READ_AFH_MAP 0x0006
+	iRet = writeHciCommand(uart_fd, 0x05,0x0006, 2, buf);
+	if(iRet>=MAX_EVENT_SIZE){
+		printf("\nread buffer size overflowed  %d\n", iRet);
+		return;
+	}
+	if(buf[6] != 0){
+		printf("\nRead AFH failed due to reason :0x%X\n",buf[6]);
+		return;
+	}
+
+	if(buf[9] == 0)
+		printf(" AFH is disabled");
+	else
+		printf(" AFH is enabled");
+
+	handle = (buf[7] | (buf[8] << 8));
+	printf("\n AFH chaneel classification for handle: 0x%X",handle);
+	int i;
+	printf("\n Channel Classification Map :");
+	for(i=iRet-1; i>9 ; i--){
+		printf("%X",buf[i]);
+	}
+	printf("\n");
+
+}
+
+static const char *safh_help =
+"\nUsage:"
+"\nsafh <host channel classification>\n"
+"\nExample:\n"
+"\nsafh 0x7FFFFFFFFFFFFFFFFFFF"
+"\n\n";
+
+static void cmd_safh(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if(argc < 2){
+		printf("\n%s\n",safh_help);
+		return;
+	}
+	int i,j;
+	i = strlen(argv[1]);
+	if(i > 20 || i < 20){
+		printf("\n%s\n",safh_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	const char *map = argv[1];
+	char byte[3];
+	int data;
+	for (i = 0,j=9; i < 20 ; i+=2,j--) {
+		memcpy(byte,&map[i],2);
+		byte[2] = '\0';
+		data = strtol(byte, NULL, 16);
+		buf[j] = (data & 0xFF);
+	}
+	// OGF_HOST_CTL	 0x03
+	// OCF_SET_AFH_CLASSIFICATION 0x003F
+	writeHciCommand(uart_fd, 0x03,0x003F,10, buf);
+	if(buf[6] != 0){
+		printf("\nSet AFH failed due to reason :0x%X\n",buf[6]);
+		return;
+	}
+	printf("\nSet AFH successful!\n");
+}
+
+static const char *wotp_help =
+"\nUsage:"
+"\nwotp <address> <data> [length=1]\n"
+"\nExample:\n"
+"\nwotp 0x15 0x2020 2"
+"\n\n";
+
+static void cmd_wotp(int uart_fd, int argc, char **argv)
+{
+	UINT32 address, length;
+
+	if (argc < 3) {
+		printf("\n%s\n", wotp_help);
+		return;
+	}
+	if (argc == 4)
+		length = GetUInt(&argv[3], 1);
+	else
+		length = 1;
+	address = GetUInt(&argv[1], 0xffffffff);
+	if (address == 0xffffffff) {
+		printf("\n%s\n", wotp_help);
+		return;
+	}
+	ReverseHexString(argv[2]);
+	if (!write_otpRaw(uart_fd, address, length, (UCHAR *)argv[2]))
+		printf("Write to OTP sucessful!\n");
+}
+
+static int write_otpRaw(int uart_fd, int address, int length, UCHAR *data)
+{
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	memset(&buf, 0, MAX_EVENT_SIZE);
+	buf[0] = 0x12;/* write RAW OTP */
+	buf[1] = address & 0xFF;/* PS tag */
+	buf[2] = (address >> 8) & 0xFF;
+	buf[3] = length;/* Entry Size */
+	GetByteSeq(buf + 4, data, 244);/* Entry Data */
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, 244 + PS_COMMAND_HEADER, buf);
+	if (buf[6] != 0) {
+		printf("\nWrite to OTP failed due to reason :0x%X\n", buf[6]);
+		return buf[6];
+	}
+	return 0;
+}
+
+static const char *rotp_help =
+"\nUsage:"
+"\nrotp <address> [length=1]\n"
+"\nExample:\n"
+"\nrotp 0x15 2"
+"\n\n";
+
+static void cmd_rotp(int uart_fd, int argc, char **argv)
+{
+	UINT32 address, length;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if (argc < 2) {
+		printf("\n%s\n", rotp_help);
+		return;
+	}
+	if (argc == 3)
+		length = GetUInt(&argv[2], 1);
+	else
+		length = 1;
+	address = GetUInt(&argv[1], 0xffffffff);
+	if (address == 0xffffffff) {
+		printf("\n%s\n", rotp_help);
+		return;
+	}
+	if (!read_otpRaw(uart_fd, address, length, buf))
+		dumpHex(buf, length, 8);
+}
+
+static int read_otpRaw(int uart_fd, int address, int length, UCHAR *data)
+{
+	int plen;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	memset(&buf, 0, MAX_EVENT_SIZE);
+	buf[0] = 0x11;/* read OTP */
+	buf[1] = address & 0xFF;/* PS tag */
+	buf[2] = (address >> 8) & 0xFF;
+	buf[3] = length;/* Entry Size */
+	buf[4] = 0x00;	/* Entry Data */
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_PS, 244 + PS_COMMAND_HEADER, buf);
+	if (buf[6] != 0) {
+		printf("\nRead from OTP failed due to reason :0x%X\n", buf[6]);
+		return buf[6];
+	}
+	do {
+		plen = read(uart_fd, buf, MAX_EVENT_SIZE);
+		if (plen < 0) {
+			perror("Read OTP error\n");
+			exit(EXIT_FAILURE);
+		}
+	} while (buf[HCI_EVENT_HEADER_SIZE] != DEBUG_EVENT_TYPE_PS);
+	memcpy(data, buf + HCI_EVENT_HEADER_SIZE + 1, length);
+	return 0;
+}
+
+static int SU_GetId(int uart_fd, char *pStr, tSU_RevInfo *pRetRevInfo)
+{
+	tSU_RevInfo RevInfo;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	RevInfo.RomVersion = 0x99999999;
+	RevInfo.BuildVersion = 0x99999999;
+	RevInfo.RadioFormat = 0xffff;
+	RevInfo.SysCfgFormat = 0xffff;
+
+	if(pStr) UNUSED(pStr);
+	memset(buf, 0, MAX_EVENT_SIZE);
+
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_READ_VERSION, 0, buf);
+	if (buf[6] != 0) {
+		printf("\nRead version failed due to reason :0x%X\n", buf[6]);
+		return buf[6];
+	}
+	RevInfo.RomVersion = buf[7] + (buf[8]<<8) + (buf[9]<<16) + (buf[10]<<24);
+	RevInfo.BuildVersion = buf[11] + (buf[12]<<8) + (buf[13]<<16) + (buf[14]<<24);
+
+	memcpy(pRetRevInfo, &RevInfo, sizeof(tSU_RevInfo));
+
+	return 0;
+}
+
+/*static const char *otp_help =
+  "\nUsage:"
+  "\notp [dump|imp|exp|test|rpid|wpid|rvid|wvid|rba|wba|hid|cpw|cpw|pwridx|ledo] [file]\n"
+  "\notp wba <BdAddr>:\n"
+  "\n\n";
+ */
+
+static void cmd_otp(int uart_fd, int argc, char **argv)
+{
+	UCHAR buf[512], format[16];
+	FILE *pF = NULL;
+	UINT32 data;
+	int i;
+
+	if (argc == 1 || !strcmp(argv[1], "dump")) {
+		printf("dump:\n");
+		for (i = 0; i < 4; i++) {
+			if (read_otpRaw(uart_fd, 128 * i, 128, &buf[128*i])) {
+				printf("read failed\n");
+				return;
+			}
+		}
+		dumpHex(buf, 512, 8);
+	} else if (!strcmp(argv[1], "test")) {
+		printf("test:\n");
+		printf("To be continue.\n");
+	} else if (!strcmp(argv[1], "imp")) {
+		if (argc < 3 || !*argv[2]) {
+			printf("Import file content into OTP. File name is required\n");
+			return;
+		}
+		printf("Import from %s into OTP:\n", argv[2]);
+		if (!(pF = fopen(argv[2], "rb"))) {
+			printf("Open file failed\n");
+			return;
+		}
+		fread(&buf[0], sizeof(buf), 1, pF);
+		fclose(pF);
+		for (i = 0; i < 512; i += 4) {
+			data = buf[i];
+			data <<= 8;
+			data += buf[i+1];
+			data <<= 8;
+			data += buf[i+2];
+			data <<= 8;
+			data += buf[i+3];
+			snprintf((char *)&format, sizeof(format), "0x%08x", data);
+			if (write_otpRaw(uart_fd, i, 4, (UCHAR *)format)) {
+				printf("Failed!(%d)\n", i);
+				return;
+			}
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "exp")) {
+		for (i = 0; i < 4; i++) {
+			if (read_otpRaw(uart_fd, 128 * i, 128, &buf[128*i])) {
+
+				printf("Failed\n");
+				return;
+			}
+		}
+		if (argc < 3 || !*argv[2] || (!(pF = fopen(argv[2], "wb")))) {
+			/* export the content to the screen */
+			dumpHex(buf, 512, 8);
+		} else {
+			/* export the content to the file */
+			fwrite(&buf[0], sizeof(buf), 1, pF);
+			fclose(pF);
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "ledo")) {
+		int opendrain;
+		tSU_RevInfo RevInfo;
+		memset((void*)&RevInfo, 0, sizeof(tSU_RevInfo));
+		if (SU_GetId(uart_fd, NULL, &RevInfo))
+			return;
+
+		printf("RomVer:%02X.%02X.%02X.%02X \n", (UINT8)((RevInfo.RomVersion >> (8*3)) & 0xff),
+				(UINT8)((RevInfo.RomVersion >> (8*2)) & 0xff),
+				(UINT8)((RevInfo.RomVersion >> 8) & 0xff),
+				(UINT8)(RevInfo.RomVersion & 0xff));
+		if (((UINT8)((RevInfo.RomVersion >> (8*3)) & 0xff) == 0x01) &&
+				((UINT8)((RevInfo.RomVersion >> (8*2)) & 0xff) == 0x02) &&
+				((UINT8)((RevInfo.RomVersion >> 8) & 0xff) == 0x02) &&
+				((UINT8)(RevInfo.RomVersion & 0xff) == 0x00)) {
+			UINT8 LedValue[] = {0xCE, 0xDA, 0x04, 0x0C, 0x58,
+				0x04, 0x05, 0x06, 0xff, 0x50,
+				0x40, 0x01, 0x24, 0x08, 0x00,
+				0x00};
+			for (opendrain = 112; opendrain < 128; opendrain++) {
+				if (write_otpRaw(uart_fd, opendrain, 1, &LedValue[opendrain-112])) {
+					printf("Failed\n");
+					return;
+				}
+			}
+			printf("OTP led opendrain done\n");
+		} else {
+			printf("Wrong RomVer\n");
+		}
+	} else if (!strcmp(argv[1], "cpw")) {
+		UINT32 cin_value = 0, cout_value = 0;
+		char tempStr[8];
+
+		if (argc < 3) {
+			printf("\n Enter cin_value : ");
+			scanf("%d", &cin_value);
+		} else
+			cin_value = GetUInt(&argv[2], 0);
+		if (cin_value > 128) {
+			printf("Invalid cin_value = %d\n", cin_value);
+			return;
+		}
+		if (argc < 4) {
+			printf("\n Enter cout_value : ");
+			scanf("%d", &cout_value);
+		} else
+			cout_value = GetUInt(&argv[3], 0);
+		if (cout_value > 128) {
+			printf("Invalid cout_value = %d\n", cout_value);
+			return;
+		}
+		if (cout_value & 0x01) cin_value += 0x80;
+		snprintf(tempStr, sizeof(tempStr), "0x%02x", cin_value);
+		if (write_otpRaw(uart_fd, 4, 1, (UCHAR *)tempStr)) {
+			printf("CapTune Error\n");
+			return;
+		}
+		snprintf(tempStr, sizeof(tempStr), "0x%02x", cout_value >> 1);
+		if (write_otpRaw(uart_fd, 5, 1, (UCHAR *)tempStr)) {
+			printf("CapTune Error\n");
+			return;
+		}
+		snprintf(tempStr, sizeof(tempStr), "0x40");
+		if (write_otpRaw(uart_fd, 5, 1, (UCHAR *)tempStr)) {
+			printf("CapTune Error\n");
+			return;
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "pwridx")) {
+		char tempStr[8];
+		snprintf(tempStr, sizeof(tempStr), "0x02");
+		if (write_otpRaw(uart_fd, 21, 1, (UCHAR *)tempStr)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "hid")) {
+		char tempStr[8];
+		UINT32 value = 0;
+		if (argc < 3 || !*argv[2]) {
+			printf("\n Enter HID value(0|1) : ");
+			scanf("%d", &value);
+		} else
+			value = GetUInt(&argv[2], 0);
+		if (value != 0 && value != 1) {
+			printf("\n Error: Syntax \"otp hid 0x00|0x01\"\n");
+			return;
+		}
+		snprintf(tempStr, sizeof(tempStr), "0x%02x", value);
+		if (write_otpRaw(uart_fd, 12, 1, (UCHAR *)tempStr)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "wpid")) {
+		UINT32 offset = 134;
+		size_t len = 0;
+		char pid[8] = {0};
+		char *ofs = NULL;
+		printf("\n Enter OTP_PID_OFFSET(default 134) : ");
+		getline(&ofs, &len, stdin);
+		if(!ofs){
+			printf("Error: ofs is NULL !\n");
+			return;
+		}
+		sscanf(ofs, "%d", &offset);
+		if (ofs) free(ofs);
+		memset(pid, 0, sizeof(pid));
+		if (argc < 3 || !*argv[2]) {
+			printf("\n Enter PID : ");
+			fgets((char *)pid, 7, stdin);
+		} else
+			strlcpy((char *)pid, argv[2], 7);
+		len = strlen(pid) - 1;
+		if (pid[len] == '\n' || pid[len] == '\r')
+			pid[len] = 0;
+		ReverseHexString(pid);
+		if (write_otpRaw(uart_fd, offset, 4, (UCHAR *)pid)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "rpid")) {
+		UINT32 offset = 134;
+		size_t len = 0;
+		UCHAR Data[2];
+		char *ofs = NULL;
+		printf("\n Enter OTP_PID_OFFSET(default 134) : ");
+		getline(&ofs, &len, stdin);
+		if(!ofs){
+			printf("Failed! getline return NULL ofs!\n");
+			return;
+		}
+		sscanf(ofs, "%d", &offset);
+		if (ofs) free(ofs);
+		if (read_otpRaw(uart_fd, offset, 2, Data)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("The OTP PID is 0x%02x%02x\n", Data[1], Data[0]);
+	} else if (!strcmp(argv[1], "wvid")) {
+		UINT32 offset = 136;
+		size_t len = 0;
+		char vid[8] = {0};
+		char *ofs = NULL;
+		printf("\n Enter OTP_VID_OFFSET(default 136) : ");
+		getline(&ofs, &len, stdin);
+		if(!ofs){
+			printf("Failed! getline return NULL ofs!\n");
+			return;
+		}
+		sscanf(ofs, "%d", &offset);
+		if (ofs) free(ofs);
+		memset(vid, 0, sizeof(vid));
+		if (argc < 3 || !*argv[2]) {
+			printf("\n Enter VID : ");
+			fgets(vid, 8, stdin);
+		} else
+			strlcpy(vid, argv[2], 7);
+		len = strlen(vid) - 1;
+		if (vid[len] == '\n' || vid[len] == '\r')
+			vid[len] = 0;
+		ReverseHexString(vid);
+		if (write_otpRaw(uart_fd, offset, 2, (UCHAR *)vid)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "rvid")) {
+		UINT32 offset = 136;
+		size_t len = 0;
+		char *ofs = NULL;
+		UCHAR Data[2];
+		printf("\n Enter OTP_VID_OFFSET(default 136) : ");
+		getline(&ofs, &len, stdin);
+		if(!ofs){
+			printf("Failed! getline return NULL ofs!\n");
+			return;
+		}
+		sscanf(ofs, "%d", &offset);
+		if (ofs) free(ofs);
+		if (read_otpRaw(uart_fd, offset, 2, Data)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("The OTP VID is 0x%02x%02x\n", Data[1], Data[0]);
+	} else if (!strcmp(argv[1], "wba")) {
+		UINT32 offset = 128;
+		size_t len = 0;
+		char bdaddr[16] = {0};
+		char *ofs = NULL;
+		printf("\n Enter OTP_BDA_OFFSET(default 128) : ");
+		getline(&ofs, &len, stdin);
+		if(!ofs){
+			printf("Failed! getline return NULL ofs!\n");
+			return;
+		}
+		sscanf(ofs, "%d", &offset);
+		if (ofs) free(ofs);
+		memset(bdaddr, 0, sizeof(bdaddr));
+		if (argc < 3 || !*argv[2]) {
+			printf("\n Enter BDADDR : ");
+			fgets(bdaddr, 16, stdin);
+		} else
+			strlcpy(bdaddr, argv[2], 15);
+		len = strlen(bdaddr) - 1;
+		if (bdaddr[len] == '\n' || bdaddr[len] == '\r')
+			bdaddr[len] = 0;
+		ReverseHexString(bdaddr);
+		if (write_otpRaw(uart_fd, offset, 6, (UCHAR *)bdaddr)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("Done\n");
+	} else if (!strcmp(argv[1], "rba")) {
+		UINT32 offset = 128;
+		size_t len = 0;
+		char *ofs = NULL;
+		UCHAR Data[6];
+		printf("\n Enter OTP_BDA_OFFSET(default 128) : ");
+		getline(&ofs, &len, stdin);
+		if(!ofs){
+			printf("Failed! getline return NULL ofs!\n");
+			return;
+		}
+		sscanf(ofs, "%d", &offset);
+		if (ofs) free(ofs);
+		if (read_otpRaw(uart_fd, offset, 6, Data)) {
+			printf("Failed\n");
+			return;
+		}
+		printf("The OTP BDADDR is 0x%02x%02x%02x%02x%02x%02x\n",
+				Data[5], Data[4], Data[3], Data[2], Data[1], Data[0]);
+	}
+}
+
+
+static void cmd_plb(int uart_fd, int argc, char **argv)
+{
+	int enable;
+	UCHAR buf[MAX_EVENT_SIZE];
+	if (argc < 2)
+		enable = 1;
+	else
+		enable = GetUInt(&argv[1], 1);
+
+	memset(buf, 0, MAX_EVENT_SIZE);
+	buf[0] = 0x09;/* audio commmand opcode */
+	buf[4] = (enable == 0) ? 0x00 : 0x01;/* audio command param */
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_AUDIO_CMD, 8, buf);
+	if (buf[6] != 0) {
+		printf("\nError in setting PCM CODEC loopback :0x%X\n", buf[6]);
+		return;
+	}
+	printf("\nPCM CODEC loopback is %s\n", (enable == 0) ? "OFF" : "ON");
+
+}
+
+
+static void cmd_psw(int uart_fd, int argc, char **argv)
+{
+	int enable, freq;
+	UCHAR buf[MAX_EVENT_SIZE];
+	if (argc < 2) {
+		enable = 1;
+		freq = 440;
+	}
+	else if (argc < 3) {
+		printf("aa\n");
+		enable = GetUInt(&argv[1], 1);
+		freq = 440;
+	} else {
+		enable = GetUInt(&argv[1], 1);
+		freq = GetUInt(&argv[2], 440);
+	}
+	if (freq > 3700) {
+		printf("Invalid frequency. It should be in the range of 0 to 3700\n");
+		return;
+	}
+
+	memset(buf, 0, MAX_EVENT_SIZE);
+	buf[0] = 0x0a;/* audio command opcode */
+	buf[4] = (enable == 0) ? 0x00 : 0x01;/* audio command param */
+	buf[5] = 0x00;
+	buf[6] = freq & 0xff;
+	buf[7] = (freq >> 8) & 0xff;
+
+	writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, OCF_AUDIO_CMD, 8, buf);
+	if (buf[6] != 0) {
+		printf("\nError in running PCM sine wave playback :0x%X\n", buf[6]);
+
+		return;
+	}
+	printf("PCM CODEC PCM sine wave playback is %s\n", (enable == 0) ? "OFF" : "ON");
+
+}
+
+static const char *lert_help=
+"\nUsage:"
+"\nlert <rx_channel>\n"
+"\nlert 30 \n"
+"\n\n";
+
+static void cmd_lert(int uart_fd, int argc, char **argv)
+{
+	UCHAR channel;
+	if (argc < 2) {
+		printf("\n%s\n", lert_help);
+		return;
+	}
+	channel = (UCHAR)GetUInt(&argv[1], 0);
+
+	SU_LERxTest(uart_fd, channel);
+
+}
+
+static BOOL SU_LERxTest(int uart_fd, UCHAR channel)
+{
+	UCHAR buf[MAX_EVENT_SIZE];
+	int channel_val = channel;
+	if (channel_val < MB_MIN_FREQUENCY_LE || channel_val > MB_MAX_FREQUENCY_LE) {
+		printf("Invalid rx channel_val. It should be in the range of %d to %d\n",
+				MB_MIN_FREQUENCY_LE, MB_MAX_FREQUENCY_LE);
+		return FALSE;
+	}
+
+	memset(buf, 0, MAX_EVENT_SIZE);
+	buf[0] = channel_val;/* rx_channel */
+	// OGF_LE_CTL 0x08
+	// OCF_LE_RECEIVER_TEST 0x001D
+	writeHciCommand(uart_fd, 0x08, 0x001D, 1, buf);
+	if (buf[6] != 0) {
+		printf("\nError in putting the device into LE RX mode\n");
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static const char *lett_help=
+"\nUsage:"
+"\nlett <rx_channel> <length> <packet_payload>\n"
+"\nlett 30 30 5\n"
+"\n\n";
+
+static void cmd_lett(int uart_fd, int argc, char **argv)
+{
+	UCHAR channel, length, payload;
+	if (argc < 4) {
+		printf("\n%s\n", lett_help);
+		return;
+	}
+	channel = (UCHAR)GetUInt(&argv[1], 0);
+	length = (UCHAR)GetUInt(&argv[2], 0);
+	payload = (UCHAR)GetUInt(&argv[3], 0);
+
+
+	SU_LETxTest(uart_fd, channel, length, payload);
+
+}
+
+static BOOL SU_LETxTest(int uart_fd, UCHAR channel, UCHAR length, UCHAR payload)
+{
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	int channel_val = channel;
+	int length_val = length;
+	if (channel_val < MB_MIN_FREQUENCY_LE || channel_val > MB_MAX_FREQUENCY_LE) {
+		printf("Invalid tx channel. It should be in the range of %d to %d\n",
+				MB_MIN_FREQUENCY_LE, MB_MAX_FREQUENCY_LE);
+		return FALSE;
+	}
+	if (length_val < MB_MIN_DATALEN_LE || length_val > MB_MAX_DATALEN_LE) {
+		printf("Invalid data length_val. It should be in the range of %d to %d\n",
+				MB_MIN_DATALEN_LE, MB_MAX_DATALEN_LE);
+		return FALSE;
+	}
+	if (payload > 7) {
+		printf("Invalid packet payload. It should be in the range of 0 to 7\n");
+		return FALSE;
+	}
+
+	memset(buf, 0, MAX_EVENT_SIZE);
+	buf[0] = channel_val;/* tx_channel */
+	buf[1] = length_val;/* length of test data */
+	buf[2] = payload;/* packet payload */
+	// OGF_LE_CTL 0x08
+	// OCF_LE_TRANSMITTER_TEST 0x001E
+	writeHciCommand(uart_fd, 0x08, 0x001E, 3, buf);
+	if (buf[6] != 0) {
+		printf("\nError in putting the device into LE TX mode\n");
+		return FALSE;
+	}
+	return TRUE;
+}
+
+
+static void cmd_lete(int uart_fd, int argc, char **argv)
+{
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	UNUSED(argc);
+	if(argv) UNUSED(argv);
+	memset(buf, 0, MAX_EVENT_SIZE);
+	// OGF_LE_CTL 0x08
+	// OCF_LE_TEST_END 0x001F
+	writeHciCommand(uart_fd, 0x08, 0x001F, 0, buf);
+	if (buf[6] != 0) {
+		printf("\nError in ending LE test\n");
+		return;
+	}
+	printf("Number of packets = %d\n", buf[7] | (buf[8] << 8));
+
+}
+
+#if 0
+static const char *tputs_help =
+"\nUsage:"
+"\ntput-s [BD_Addr] [Judgment value] Logfile times"
+"\ntput-s 11:22:33:44:55:66 150 log.txt 10"
+"\n\n";
+
+
+static void CalculateTput(int uart_fd, UINT16 hci_handle, char *filename, double threshold, int tx_size)
+{
+	time_t start, checkbreak;
+	UCHAR buf[1009];
+	FILE *fp = NULL;
+	int aclnum = 8;
+	int retval;
+	unsigned long sentnum = 0;
+	double TimeResult = 0;
+	fd_set rfds;
+	struct timeval tv1, tv2, timeout;
+	unsigned long long start_utime, end_utime, time_diff;
+	unsigned long long throughput;
+
+	start = time(NULL);
+	gettimeofday(&tv1, NULL);
+	start_utime = tv1.tv_sec*1000000 + tv1.tv_usec;
+	while (sentnum < 1024 * tx_size) {
+		while (aclnum > 0) {
+			aclnum--;
+			buf[0] = 0x02; // HCI_ACLDATA_PKT 0x02
+			/* ACL packet header */
+			buf[1] = hci_handle & 0xFF;
+			buf[2] = ((hci_handle >> 8) & 0x0E);
+			buf[3] = 1004 & 0xff;
+			buf[4] = (1004 >> 8) & 0xff;
+			/* L2CAP packet header */
+			buf[5] = 1000 & 0xff;
+			buf[6] = (1000 >> 8) & 0xff;
+			buf[7] = 0x40 & 0xff;
+			buf[8] = 0;
+
+			memset(buf+9, sentnum++, 1000);
+			while (write(uart_fd, (const void *)buf, 1009) < 0) {
+				if (errno == EAGAIN || errno == EINTR)
+					continue;
+				perror("HCI send packet failed");
+				exit(EXIT_FAILURE);
+			}
+		}
+		timeout.tv_sec = 5;
+		timeout.tv_usec = 0;
+
+		FD_ZERO(&rfds);
+		FD_SET(uart_fd, &rfds);
+		retval = select(uart_fd+1, &rfds, NULL, NULL, &timeout);
+		if (retval == -1) {
+			perror("select()");
+			exit(EXIT_FAILURE);
+		} else if (retval) {
+			/* Data is available now */
+			ssize_t plen;
+			UCHAR buffer[64];
+			int i;
+			plen = read(uart_fd, buffer, 64);
+			if (plen < 0) {
+				perror("HCI read buffer failed");
+				exit(EXIT_FAILURE);
+			}
+			for (i = 0; i < buffer[HCI_EVENT_HEADER_SIZE]; i++)
+				aclnum += (buffer[HCI_EVENT_HEADER_SIZE+(i+1)*2+1] | (buffer[HCI_EVENT_HEADER_SIZE+(i+1)*2+2] << 8));
+		}
+		checkbreak = time(NULL);
+		if ((checkbreak - start) >= 300) break;
+	}
+	gettimeofday(&tv2, NULL);
+	end_utime = tv2.tv_sec*1000000 + tv2.tv_usec;
+	time_diff = end_utime - start_utime;
+	throughput = time_diff/1000;
+	throughput = (sentnum * 1000)/throughput;
+	printf("Transfer Completed! throughput [%0d KB/s]", (int)throughput);
+	printf(" result [%s]\n", threshold > throughput ? " Fail " : " Pass ");
+	if (filename && *filename)
+		fp = fopen(filename, "at+");
+	if (fp) {
+		fprintf(fp, "Transfer Completed! throughput [%.0f KB/s]", TimeResult);
+		fprintf(fp, " result [%s]\n", threshold > TimeResult ? " Fail " : " Pass ");
+		fclose(fp);
+	}
+}
+#endif
+
+static void cmd_tputs(int uart_fd, int argc, char **argv)
+{
+	if(argv) UNUSED(argv);
+	UNUSED(argc);
+	UNUSED(uart_fd);
+
+#if 0
+	int j, iRet, loop = 1, tx_test_size = 1;
+	UINT16 Ps_EntrySize = 0;
+	UINT16 hci_handle = 0;
+	double threshold = 0.0;
+	char *filename = NULL;
+	struct sigaction sa;
+	FILE *fp = NULL;
+	bdaddr_t bdaddr;
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR Ps_Data[MAX_EVENT_SIZE];
+	UINT16 *pPs_Data;
+	BOOL Ok = FALSE;
+	char timeString[9] = {0};
+	char dateString[15] = {0};
+	time_t current_time;
+	struct tm *time_info;
+	tSU_RevInfo RevInfo;
+
+	if (argc < 3) {
+		printf("\n%s\n", tputs_help);
+		return;
+	}
+
+	if (str2ba(argv[1],&bdaddr)) {
+		printf("\nPlease input valid bdaddr.\n");
+		return;
+	}
+	threshold = atof(argv[2]);
+	if (!threshold) {
+		printf("\nPlease input valid throughput threshold.\n");
+		return;
+	}
+	if (argc > 3)
+		filename = strdup(argv[3]);
+	if (argc > 4)
+		loop = GetUInt(&argv[4], 1);
+	if (argc > 5)
+		tx_test_size = GetUInt(&argv[5],1);
+
+	CtrlCBreak = FALSE;
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_handler = sig_term;
+	sigaction(SIGTERM, &sa, NULL);
+	sigaction(SIGINT, &sa, NULL);
+	PSInit(uart_fd);
+	memset(buf, 0, sizeof(buf));
+	iRet = writeHciCommand(uart_fd, OGF_HOST_CTL, OCF_RESET, 0, buf);
+	if (buf[6] != 0) {
+		printf("Error: HCI RESET failed.\n");
+		return;
+	}
+	sleep(1);
+	for (j = 0; j < loop; j++) {
+		int i = 0;
+		if (!j) sleep(1);
+		printf("\n-----------------------------------");
+		printf("\nTimes %d/%d\n", j + 1, loop);
+
+		time(&current_time);
+		time_info = localtime(&current_time);
+		strftime(timeString, sizeof(timeString), "%H %M %S", time_info);
+		strftime(dateString, sizeof(dateString), "%b %d %Y", time_info);
+		if (j == 0) {
+			if (filename && *filename)
+				fp = fopen(filename, "at+");
+			if (fp != NULL)
+				fprintf(fp, "\n[%s %s] \nCMD : TPUT-S %s %f %s %d\n",
+						dateString, timeString, argv[1], threshold, filename, loop);
+			/* SFLAGS FW */
+			Ok = PSOperations(uart_fd, PS_GET_LENGTH, PSTAG_RF_TEST_BLOCK_START, (UINT32 *)&Ps_EntrySize);
+			if (Ok) {
+				Ps_Data[0] = Ps_EntrySize & 0xff;
+				Ps_Data[1] = (Ps_EntrySize >> 8) & 0xff;
+				Ok = PSOperations(uart_fd, PS_READ, PSTAG_RF_TEST_BLOCK_START, (UINT32 *)&Ps_Data);
+				if (Ok) {
+					pPs_Data = (UINT16 *)&Ps_Data[0];
+					if (*pPs_Data == BT_SOC_INIT_TOOL_START_MAGIC_WORD) {
+						RevInfo.RadioFormat = *(pPs_Data + 1);
+						RevInfo.RadioContent = *(pPs_Data + 2);
+					}
+				}
+			}
+
+			/* Get syscfg info */
+			Ok = PSOperations(uart_fd, PS_GET_LENGTH, PSTAG_SYSCFG_PARAM_TABLE0, (UINT32 *)&Ps_EntrySize);
+			if (Ok) {
+				Ps_Data[0] = Ps_EntrySize & 0xff;
+				Ps_Data[1] = (Ps_EntrySize >> 8) & 0xff;
+				Ok = PSOperations(uart_fd, PS_READ, PSTAG_SYSCFG_PARAM_TABLE0, (UINT32 *)&Ps_Data);
+				if (Ok) {
+					pPs_Data = (UINT16 *)&Ps_Data[0];
+					if (*pPs_Data == 0xC1C1) {
+						RevInfo.SysCfgFormat = *(pPs_Data + 1);
+						RevInfo.SysCfgContent = *(pPs_Data + 2);
+					}
+
+				}
+			}
+
+			if (RevInfo.SysCfgFormat != 0xff) {
+				printf("SysCfg -    Format:  %d.%d\n",((RevInfo.SysCfgFormat >> 4) & 0xfff), (RevInfo.SysCfgFormat & 0xf));
+				printf("            Content: %d\n", RevInfo.SysCfgContent);
+				if (fp) {
+					fprintf(fp, "SysCfg -    Format:  %d.%d\n",((RevInfo.SysCfgFormat >> 4) & 0xfff),
+							(RevInfo.SysCfgFormat & 0xf));
+					fprintf(fp, "            Content: %d\n", RevInfo.SysCfgContent);
+				}
+			} else {
+				printf("SysCfg - N/A\n");
+				if(fp)
+					fprintf(fp, "SysCfg - N/A\n");
+			}
+
+			/* bd addr */
+			memset(&buf, 0, sizeof(buf));
+			iRet = writeHciCommand(uart_fd, OGF_INFO_PARAM, HCI_CMD_OCF_READ_BD_ADDR, 0, buf);
+			if (buf[6] != 0) {
+				printf("\nCould not read the BD_ADDR (time out)\n");
+			} else {
+				char temp[16] = {0};
+				memset(temp, 0, sizeof(temp));
+				snprintf(temp, sizeof(temp), "%02X%02X%02X%02X%02X%02X", buf[iRet-1], buf[iRet-2],
+						buf[iRet-3], buf[iRet-4], buf[iRet-5], buf[iRet-6]);
+				printf("\nLocal BDAddress : 0x%s\n", temp);
+				if (fp)
+					fprintf(fp, "Local BDAddress : 0x%s\n", temp);
+			}
+
+			if (fp) {
+				fclose(fp);
+				fp = NULL;
+			}
+		}
+		printf("Sending packages to 0x%s\n", argv[1]);
+		while (i++ < 3) {
+			iRet = hci_create_connection(uart_fd, &bdaddr, 0xCC18, 0, 0, &hci_handle, 0);
+			if (!iRet || CtrlCBreak) break;
+		}
+
+		if (iRet) {
+			if (filename && *filename) {
+				fp = fopen(filename, "at+");
+				if (fp) {
+					fprintf(fp, "Transfer Failed! \n");
+					fclose(fp);
+					fp = NULL;
+				}
+			}
+			printf("Transfer Failed! \n");
+			CtrlCBreak = TRUE;
+
+			return;
+		}
+		CalculateTput(uart_fd, hci_handle, filename, threshold, tx_test_size);
+
+		hci_disconnect(uart_fd, hci_handle, 0, 30);
+
+		if (CtrlCBreak) break;
+	}
+	CtrlCBreak = TRUE;
+#endif
+}
+
+static void cmd_tputr(int uart_fd, int argc, char **argv)
+{
+	ssize_t plen;
+	UINT16 hci_handle = 0;
+	UCHAR buf[MAX_EVENT_SIZE];
+	struct sigaction sa;
+
+	UNUSED(argc);
+	if(argv) UNUSED(argv);
+	CtrlCBreak = FALSE;
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_handler = sig_term;
+	sigaction(SIGTERM, &sa, NULL);
+	sigaction(SIGINT, &sa, NULL);
+	memset(buf, 0, sizeof(buf));
+	// OGF_HOST_CTL 0x03
+	// OCF_RESET 0x0003
+	writeHciCommand(uart_fd, 0x03, 0x0003, 0, buf);
+	if (buf[6] != 0) {
+		printf("Error: HCI RESET failed.\n");
+		return;
+	}
+	sleep(1);
+	memset(buf, 0, sizeof(buf));
+	buf[0] = 0x02;
+	// OGF_HOST_CTL 0x03
+	// OCF_WRITE_SCAN_ENABLE 0x001A
+	writeHciCommand(uart_fd, 0x03, 0x001A, 1, buf);
+	if (buf[6] != 0) {
+		printf("Error: Write scan failed\n");
+		return;
+	}
+	printf("Start listening ...\n");
+	do {
+		plen = read(uart_fd, buf, MAX_EVENT_SIZE);
+		if (plen < 0) {
+			printf("reading failed...\n");
+			if (errno == EAGAIN || errno == EINTR) continue;
+			else {
+				perror("HCI read failed");
+				exit(EXIT_FAILURE);
+			}
+		}
+		// EVT_CONN_REQUEST 0x04
+		if (buf[1] == 0x04) {
+			int i, j;
+			ssize_t plen = 0;
+			printf("Connection come in\n");
+			for (i = 0, j = 3; i < BD_ADDR_SIZE; i++, j++)
+				buf[i] = buf[j];
+			buf[BD_ADDR_SIZE] = 0x01;
+			// OGF_LINK_CTL 0x01
+			// OCF_ACCEPT_CONN_REQ 0x0009
+			if (hci_send_cmd(uart_fd, 0x01, 0x0009, 7, buf)) {
+				printf("Accept connection error\n");
+				return;
+			}
+			do {
+				plen = read(uart_fd, buf, MAX_EVENT_SIZE);
+				if (plen < 0) {
+					perror("Read failed");
+					exit(EXIT_FAILURE);
+				}
+				// EVT_CONN_COMPLETE 0x03
+			} while (buf[1] != 0x03);
+			if (buf[3] == 0) {
+				printf("Connection up\n");
+			} else {
+				printf("Connection failed\n");
+			}
+			hci_handle = (buf[4] | (buf[5] << 8)) & 0x0EFF;
+			// EVT_DISCONN_COMPLETE 0x05
+		} else if (buf[1] == 0x05) {
+			UINT16 hdl = buf[4] | (buf[5] << 8);
+			printf("Disconnect...\n");
+			if (hdl == hci_handle) {
+				break;
+			}
+		} else if (CtrlCBreak) {
+			printf("CtrlBreak...\n");
+			break;
+		}
+	} while (plen >= 0);
+	CtrlCBreak = TRUE;
+
+}
+
+int sock_recv(int sockid, unsigned char *buf, int buflen)
+{
+	int recvbytes;
+	recvbytes = recv(sockid, buf, buflen, 0);
+	if (recvbytes == 0) {
+		printf("Connection close!? zero bytes received\n");
+		return -1;
+	} else if (recvbytes > 0) {
+		return recvbytes;
+	}
+	return -1;
+}
+
+int sock_send(int sockid, unsigned char *buf, int bytes)
+{
+	int cnt;
+	unsigned char* bufpos = buf;
+	while (bytes) {
+		cnt = write(sockid, bufpos, bytes);
+		if (cnt != bytes)
+			printf("cnt:%d,bytes:%d\n",cnt, bytes);
+
+		if (!cnt) {
+			break;
+		}
+		if (cnt == -1) {
+			if (errno == EINTR) {
+				continue;
+			} else {
+				return -1;
+			}
+		}
+
+		bytes -= cnt;
+		bufpos += cnt;
+	}
+	return (bufpos - buf);
+}
+
+static void cmd_btagent(int uart_fd, int argc, char **argv)
+{
+	int i, j, k, l, iRet, rx_enable, iDataSize;
+	uint32_t m_BerTotalBits, m_BerGoodBits;
+	uint8_t m_pattern[16];
+	uint16_t m_pPatternlength;
+	int port = BT_PORT;
+	struct sigaction sa;
+	unsigned char buf[1024];
+	struct timeval timeout;
+
+	/* master file descriptor list */
+	fd_set master;
+	fd_set read_fds;
+
+	/* server address */
+	struct sockaddr_in serveraddr;
+
+	int fdmax;
+
+	/* listening socket descriptor */
+	int listener = -1;
+
+	/* newly accept()ed socket descriptor */
+	int newfd = -1;
+
+	int nbytes;
+
+	/* for setsockopt() SO_REUSEADDR, below */
+	int yes = 1;
+
+	socklen_t addrlen;
+
+	if (argc > 1)
+		port = atoi(argv[1]);
+	if (port == 0)
+		port = BT_PORT;
+	else if (port < 0 || port >65534) {
+		perror("\nERROR: Invalid port number\n");
+		return;
+	}
+
+	CtrlCBreak = FALSE;
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_handler = sig_term;
+	sigaction(SIGTERM, &sa, NULL);
+	sigaction(SIGINT, &sa, NULL);
+
+	/* clear the master and temp sets */
+	FD_ZERO(&master);
+	FD_ZERO(&read_fds);
+
+	/* get the listener */
+	if((listener = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
+		perror("Server-socket() error lol!");
+		return;
+	}
+
+	if(setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, (char *)&yes, sizeof(int)) == -1) {
+		perror("Server-setsockopt() error lol!");
+		close(listener);
+		return;
+	}
+
+	if(setsockopt(listener, IPPROTO_TCP, TCP_NODELAY, (char *)&yes, sizeof(int)) == -1) {
+		perror("Server-setsockopt() error TCP_NODELAY\n");
+		close(listener);
+		return;
+	}
+
+	/* bind */
+	serveraddr.sin_family = AF_INET;
+	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	serveraddr.sin_port = htons(port);
+	memset(&(serveraddr.sin_zero), 0, 8);
+
+	if(bind(listener, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) == -1) {
+		perror("Server-bind() error lol!");
+		close(listener);
+		return;
+	}
+
+	/* listen */
+	if(listen(listener, 10) == -1) {
+		perror("Server-listen() error lol!");
+		close(listener);
+		return;
+	}
+
+	/* add the listener to the master set */
+	FD_SET(listener, &master);
+
+	/* add hci handler to the master set */
+	FD_SET(uart_fd, &master);
+
+	FD_SET(0, &master);
+	/* keep track of the biggest file descriptor */
+	fdmax = listener;
+	if (uart_fd > listener) fdmax = uart_fd;
+
+	printf("Start BtAgent, press 'q' to exit.\n");
+
+	rx_enable = 0;
+	m_BerGoodBits = 0;
+	m_BerTotalBits = 0;
+	m_pattern[0] = 0x0f;
+	m_pPatternlength = 1;
+
+	while (1) {
+		read_fds = master;
+		timeout.tv_sec = 5;
+		timeout.tv_usec = 0;
+		iRet = select(fdmax+1, &read_fds, NULL, NULL, &timeout);
+		if (iRet == -1) {
+			perror("Server-select() error lol!");
+			if (newfd > 0) close(newfd);
+			close(listener);
+			goto exits;
+		}
+		if (CtrlCBreak) break;
+		if (iRet == 0) continue;
+
+		/*run through the existing connections looking for data to be read*/
+		for(i = 0; i <= fdmax; i++) {
+			if(FD_ISSET(i, &read_fds)) {
+
+				if(i == 0) {
+					printf("Shutting down btagent\n");
+					iRet = getchar();
+					if (iRet == 'q') goto exits;
+					continue;
+				}
+
+				if(i == listener) {
+					/* handle new connections */
+					addrlen = sizeof(struct sockaddr_in);
+					if((newfd = accept(listener, (struct sockaddr *)&serveraddr, &addrlen)) == -1) {
+						perror("Server-accept() error lol!");
+						goto exits;
+					}
+					else {
+						printf("Server-accept() is OK...%d\n",newfd);
+						FD_SET(newfd, &master); /* add to master set */
+						if(newfd > fdmax)
+							fdmax = newfd;
+					}
+				}
+				else if (i == newfd) {
+					/* handle data from a client */
+					if((nbytes = sock_recv(i, buf, sizeof(buf))) < 0) {
+						/* got error or connection closed by client */
+						close(i);
+						/* remove from master set */
+						FD_CLR(i, &master);
+					}
+					else {
+
+						for (j=0; j<nbytes; j++)
+							printf("%x ",buf[j]);
+						printf("\n");
+						if (buf[0] == 0x7) {	// BTAGENT_CMD_EVENT
+							if (buf[3] == 0x01) {	// BTAGENT_CMD_EVENT_GETBER
+								buf[11] = (m_BerTotalBits & 0xff000000) >> 24;
+								buf[10] = (m_BerTotalBits & 0xff0000) >> 16;
+								buf[9] = (m_BerTotalBits & 0xff00) >> 8;
+								buf[8] = m_BerTotalBits & 0xff;
+								buf[7] = (m_BerGoodBits & 0xff000000) >> 24;
+								buf[6] = (m_BerGoodBits & 0xff0000) >> 16;
+								buf[5] = (m_BerGoodBits & 0xff00) >> 8;
+								buf[4] = m_BerGoodBits & 0xff;
+								buf[3] = 1;// BTAGENT_CMD_EVENT_GETBER
+								buf[2] = 0;
+								buf[1] = 9;
+								buf[0] = 7;
+								sock_send(newfd, buf, 9+3);
+								usleep(2000);
+							}
+							else if (buf[3] == 0x02) {// BTAGENT_CMD_EVENT_PATTERN
+								m_pPatternlength = (uint16_t)(buf[1] | (buf[2] << 8));
+								m_pPatternlength --;
+								if (m_pPatternlength > 16) m_pPatternlength = 16;
+								memcpy(m_pattern,&buf[4],m_pPatternlength);
+								printf("PatternLength:%d,%x\n",m_pPatternlength,buf[4]);
+							}
+							continue;
+						}
+
+						if (rx_enable == 1) {
+							if ((buf[4] == 0x03) && (buf[5] == 0x0c))
+								rx_enable = 0;
+						}
+						write(uart_fd, &buf[3], nbytes - 3);
+					}
+				}
+				else if (i == uart_fd) {
+					nbytes = read(uart_fd, &buf[3], sizeof(buf) - 3);
+					iDataSize = nbytes - 6;
+					//		    printf("nbyte:%d, packet:%d, pattern:%x\n",nbytes, (uint16_t)(buf[6] | (buf[7] << 8)), buf[8]);
+					if (buf[3] == 0x2) {	// ACL data
+						if (rx_enable) {
+							m_BerTotalBits = m_BerTotalBits + iDataSize * 8;
+							for(j=0,l=0;j<iDataSize;j++,l++) {
+								if (l == m_pPatternlength) l = 0;
+								for(k=0;k<8;k++){
+									if((m_pattern[l]&(1<<k)) == (buf[8+j]&(1<<k)))
+										m_BerGoodBits++;
+								}
+							}
+						}
+					}
+					else {
+						if ((buf[7] == 0x5b) && (buf[8] == 0xfc)) {// Rx start CMD's event
+							rx_enable = 1;
+							m_BerTotalBits = 0;
+							m_BerGoodBits = 0;
+						}
+						buf[2] = 0;
+						buf[1] = (uint16_t)nbytes;
+						buf[0] = 3;
+						if (newfd > 0) {
+							sock_send(newfd, buf, nbytes+3);
+							usleep(2000);
+						}
+					}
+				}
+			}
+		}
+	}
+exits:
+
+	if (listener > 0) close(listener);
+	if (newfd > 0) close(newfd);
+	printf("Total:%d,Good:%d\n",m_BerTotalBits, m_BerGoodBits);
+}
+
+/* SMD cmds */
+static const char *hciinq_help =
+"Usage:\n"
+"\n hciinq\n";
+
+static void cmd_hciinq(int uart_fd, int argc, char **argv){
+	int iRet, i;
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR resultBuf[MAX_EVENT_SIZE];
+	unsigned long val32;
+
+	if(argc < 2) {
+		printf("\n%s\n",hciinq_help);
+		return;
+	}
+
+	printf( "inq command ++ argc = %d argv = %s %s %s %s %s \n", argc,argv[1],argv[2] ,argv[3] ,argv[4] ,argv[5]  );
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	// INQUIRY_CP_SIZE 5
+	for (i = 1; i <= 5; i++)
+	{
+		UCHAR *tmp;
+		val32 = strtol ((char*)argv[i], NULL, 16);
+		tmp = ((unsigned char*)&val32);
+		buf[i-1] = *tmp;
+	}
+
+	// OGF_LINK_CTL 0x01
+	// OCF_INQUIRY 0x0001
+	// INQUIRY_CP_SIZE 5
+	iRet = hci_send_cmd( uart_fd, 0x01, 0x0001, 5, buf);
+
+	printf("\nINQUIRY: \n");
+	memset(&resultBuf,0,MAX_EVENT_SIZE);
+	if (!iRet)
+		read_incoming_events(uart_fd, resultBuf, 0);
+
+	printf("\n");
+}
+
+static const char *hciinqcnl_help =
+"Usage:\n"
+"\n hciinqcnl\n";
+
+static void cmd_hciinqcnl(int uart_fd, int argc, char **argv){
+	UCHAR buf[MAX_EVENT_SIZE];
+	if(argv) UNUSED(argv);
+	if(argc > 1){
+		printf("\n%s\n",hciinqcnl_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	// OGF_LINK_CTL 0x01
+	// OCF_INQUIRY_CANCEL 0x0002
+	writeHciCommand(uart_fd, 0x01, 0x0002, 0, buf);
+	if(buf[6] != 0){
+		printf("\nError: Inquiry cancel failed due to the reason 0X%X\n", buf[6]);
+		return;
+	}
+	printf("\nINQUIRY CANCEL\n");
+}
+
+static const char *hcisetevtflt_help =
+"Usage:\n"
+"\n hcisetevtflt\n";
+
+static void cmd_hcisetevtflt(int uart_fd, int argc, char **argv){
+	int i;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if(argc < 2){
+		printf("\n%s\n",hcisetevtflt_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	// SET_EVENT_FLT_CP_SIZE 2
+	for (i = 0; i < 2; i++)
+		buf[i] = atoi(argv[i + 1]);
+	// OGF_HOST_CTL 0x03
+	// OCF_SET_EVENT_FLT 0x0005
+	writeHciCommand(uart_fd, 0x03, 0x0005,
+			2, buf);
+	if(buf[6] != 0){
+		printf("\nError: Set Event Filter failed due to the reason 0X%X\n", buf[6]);
+		return;
+	}
+	printf("\nSet Event Filter\n");
+}
+
+static const char *pinconntest_help =
+"Usage:\n"
+"\n pinconntest\n";
+
+static void cmd_pinconntest(int uart_fd, int argc, char **argv){
+	int iRet;
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR resultBuf[MAX_EVENT_SIZE];
+	unsigned long val32;
+	if(argc < 2){
+		printf("\n%s\n",pinconntest_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	UCHAR *tmp ;
+	val32 = strtol ((char*)argv[1], NULL, 16);
+	tmp = ((unsigned char*)&val32);
+	buf[0] =*tmp;
+	iRet = hci_send_cmd(uart_fd, HCI_VENDOR_CMD_OGF, 0x0C, 1, buf);
+
+	printf("\nPIN CONNECTIVITY TEST: \n");
+	memset(&resultBuf,0,MAX_EVENT_SIZE);
+	if (!iRet)
+		read_incoming_events(uart_fd, resultBuf, 0);
+
+	printf("\n");
+}
+
+static const char *conntest_help =
+"Usage:\n"
+"\n conn < bdaddress >\n";
+
+static void cmd_createconnection(int uart_fd, int argc, char **argv){
+	int iRet, i,j;
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR resultBuf[MAX_EVENT_SIZE];
+	bdaddr_t bdaddr;
+	uint16_t clk_offset;
+	uint8_t role, pscan_rep_mode;
+	unsigned char ptype[2] = {0x18 , 0xcc};
+
+	pscan_rep_mode = 0; 	// R0
+	clk_offset = 0;
+	role = 0x01;		// Master/Slave
+
+	if(argc < 2){
+		printf("\n%s\n",conntest_help);
+		return;
+	}
+	str2ba(argv[1],&bdaddr);
+	if((strlen(argv[1]) < 17)||(strlen(argv[1]) > 17)){
+		printf("\nInvalid BD address : %s\n",argv[1]);
+		printf("\n%s\n",wba_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+
+	for(i= 0,j=0; i< BD_ADDR_SIZE;i++,j++){
+		buf[j] = bdaddr.b[i];
+	}
+	buf[6] = ptype[0];
+	buf[7] = ptype[1];
+	buf[8] = pscan_rep_mode;
+	buf[9] = 0x00; // reserved
+	buf[10] = (clk_offset & 0xFF);
+	buf[11] = ((clk_offset >> 8) & 0xFF);
+	buf[12] = role;
+
+	// OGF_LINK_CTL 0x01
+	// OCF_CREATE_CONN 0x0005
+	iRet = hci_send_cmd( uart_fd, 0x01, 0x0005,13 , buf);
+	printf("\n Connect test \n");
+	for(i = 0; i < 1;i++){
+		printf("%02X:",buf[i]);
+	}
+
+	memset(&resultBuf,0,MAX_EVENT_SIZE);
+	if (!iRet)
+		read_incoming_events(uart_fd, resultBuf, 0);
+}
+
+static const char *disc_help =
+"Usage:\n"
+"\n disc <handle in 2 octets Hex><reason in hex>";
+
+static void cmd_disc(int uart_fd, int argc, char **argv){
+	int iRet;
+	unsigned long val32;
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR resultBuf[MAX_EVENT_SIZE];
+	if(argc < 3){
+		printf("\n%s\n",disc_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	val32 = strtol ((char*)argv[1], NULL, 16);
+	buf[0] = val32 & 0xff ;
+	buf[1] = (val32 & 0xff00) >>8;
+	val32 = strtol ((char*)argv[2], NULL, 16);
+	buf[2] = *(UCHAR *)&val32;
+	printf("\nHCI_Disconnect: Handle :%s Reason Code: 0x%x\n",argv[1],buf[2]);
+	// OGF_LINK_CTL 0x01
+	// OCF_DISCONNECT 0x0006
+	iRet = hci_send_cmd(uart_fd, 0x01, 0x0006 ,3 , buf);
+
+
+	memset(&resultBuf,0,MAX_EVENT_SIZE);
+	if (!iRet)
+		read_incoming_events(uart_fd, resultBuf, 0);
+
+	printf("\n");
+}
+
+static const char *venspeccmd_help =
+"Usage:\n"
+"\n venspeccmd [3|6]\n";
+
+static void cmd_venspeccmd(int uart_fd, int argc, char **argv){
+	int iRet,i;
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR resultBuf[MAX_EVENT_SIZE];
+	unsigned long val32;
+	if(argc < 2){
+		printf("\n%s\n",venspeccmd_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	for (i = 1; i < argc; i++)
+	{
+		UCHAR *tmp;
+		val32 = strtol ((char*)argv[i], NULL, 16);
+                tmp = ((unsigned char*)&val32);
+		buf[i-1] = *tmp;
+	}
+
+	iRet = hci_send_cmd( uart_fd, HCI_VENDOR_CMD_OGF, 0x00, i-1, buf);
+
+        printf("Vendor Specific command\n");
+	memset(&resultBuf,0,MAX_EVENT_SIZE);
+	if (!iRet)
+		read_incoming_events(uart_fd, resultBuf, 0);
+	printf("\n");
+}
+
+static const char *rawcmd_help =
+"Usage:\n"
+"\n rawcmd ogf ocf <bytes> \n";
+
+static void cmd_rawcmd(int uart_fd, int argc, char **argv){
+	int iRet,i,j;
+	UCHAR buf[MAX_EVENT_SIZE];
+	UCHAR resultBuf[MAX_EVENT_SIZE];
+	uint16_t ogf, ocf;
+	unsigned long val32;
+	unsigned char *pval8;
+
+	if(argc < 2){
+		printf("\n%s\n",rawcmd_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+
+	val32 = strtol((char*)argv[1], NULL, 16);
+	pval8 = ((unsigned char*)&val32);
+	ogf = (unsigned short)*pval8;
+
+	val32 = strtol((char*)argv[2], NULL, 16);
+	pval8 = ((unsigned char*)&val32);
+	ocf = (unsigned short)*pval8;
+
+	for (i = 3; i < argc; i++)
+	{
+		UCHAR *tmp;
+		val32 = strtol ((char*)argv[i], NULL, 16);
+		tmp = ((unsigned char*)&val32);
+		buf[i-3] = *tmp;
+	}
+
+	printf("RAW HCI command: ogf 0x%x ocf 0x%x\n Params: ", ogf, ocf);
+
+	for (j = 0; j < i-3; j++) {
+		printf("0x%x ", buf[j]);
+	}
+	printf("\n");
+
+	iRet = hci_send_cmd( uart_fd, ogf, ocf, i-3, buf);
+
+	memset(&resultBuf,0,MAX_EVENT_SIZE);
+	if (!iRet)
+		read_incoming_events(uart_fd, resultBuf, 0);
+	printf("\n");
+}
+
+static const char *hciinvcmd1_help =
+"Usage:\n"
+"\n hciinvcmd1\n";
+
+static void cmd_hciinvcmd1(int uart_fd, int argc, char **argv){
+	int iRet;
+	UCHAR buf[MAX_EVENT_SIZE];
+
+	if(argc > 1){
+		printf("\n%s\n",hciinvcmd1_help);
+		return;
+	}
+
+	memset(&buf,0,MAX_EVENT_SIZE);
+	buf[0] = atoi(argv[1]);
+	iRet = writeHciCommand(uart_fd, HCI_VENDOR_CMD_OGF, 0x00, 1, buf);
+	if(iRet>=MAX_EVENT_SIZE){
+		printf("\nread buffer size overflowed  %d\n", iRet);
+		return;
+	}
+	if(buf[6] != 0){
+		printf("\nError: Invalid HCI cmd due to the reason 0X%X\n", buf[6]);
+		return;
+	}
+	printf("\nINVALID HCI COMMAND: \n");
+	int i;
+	for(i=iRet-1;i > 6;i--){
+		printf("%02X:",buf[i]);
+	}
+	printf("%2X\n\n",buf[6]);
+}
+
+/* EOF SMD cmds */
+static void sig_term(int sig)
+{
+	UNUSED(sig);
+	if (CtrlCBreak) return;
+	CtrlCBreak = TRUE;
+}
+
+static struct {
+	char *cmd;
+	char *cmd_option;
+	void (*func)(int uart_fd, int argc, char **argv);
+	char *doc;
+} command[] = {
+	{ "reset","      ",   cmd_reset,    "Reset Target"                },
+	{ "rba","       ",  cmd_rba,    "Read BD Address"                },
+	{ "wba","<bdaddr> ",   cmd_wba,    "Write BD Address"                },
+	{ "edutm","       ",  cmd_edutm,    "Enter DUT Mode"                },
+	{ "wsm","<mode>  ",   cmd_wsm,    "Write Scan Mode"                },
+	{ "mb","       ",   cmd_mb,    "Enter Master Blaster Mode"                },
+	{ "mbr","<address> <length>  ",   cmd_mbr,    "Block memory read"                },
+	{ "peek","<address> <width>  ",   cmd_peek,    "Read Value of an Address"                },
+	{ "poke","<address> <value> <mask> <width>  ",   cmd_poke,    "Write Value to an Address"                },
+	{ "cwtx","<channel number> ",   cmd_cwtx,    "Enter Continuous wave Tx"                },
+	{ "cwrx","<channel number> ",   cmd_cwrx,    "Enter Continuous wave Rx"                },
+	{ "rpst","<length> <id>  ",   cmd_rpst,    "Read PS Tag"                },
+	{ "wpst","<length> <id> <data> ",   cmd_wpst,    "Write PS Tag"                },
+	{ "psr","       ",   cmd_psr,    "PS Reset"                },
+	{ "setap","<storage medium> <priority>",   cmd_setap,    "Set Access Priority"                },
+	{ "setam","<storage medium> <access mode>",   cmd_setam,    "Set Access Mode"               },
+	{ "rpsraw","<offset> <length>  ",   cmd_rpsraw,    "Read Raw PS"                },
+	{ "wpsraw","<offset> <length>  <data>",   cmd_wpsraw,    "Write Raw PS"                },
+	{ "ssm","<disable|enable>         ", cmd_ssm, "Set Sleep Mode"      },
+	{ "dtx","         ", cmd_dtx, "Disable TX"      },
+	{ "dump","<option>         ", cmd_dump, "Display Host Controller Information"      },
+	{ "rafh","<connection handle>         ", cmd_rafh, "Read AFH channel Map"      },
+	{ "safh","<channel classification>         ", cmd_safh, "Set AFH Host Channel Classification"      },
+	{ "wotp", "<address> <data> [length=1]", cmd_wotp, "Write Length (default 1) bytes of Data to OTP started at Address"      },
+	{ "rotp", "<address> [length=1]", cmd_rotp, "Read Length (default 1) bytes of Data to OTP started at Address"},
+	{ "otp", "[dump|imp|exp|test|rpid|wpid|rvid|wvid|rba|wba|hid|cpw|pwridx|ledo] [file]; opt wba <BdAddr>",
+		cmd_otp, "Misc OTP operation: dump/import otp content; imp file content into otp; test otp; otp wba <BdAddr>"},
+	{ "plb", "[1|0]", cmd_plb, "Enable/disable PCM CODEC loopback"},
+	{ "psw", "[1|0] [Frequency]", cmd_psw, "Enable/disable PCM sine wave playback at frequency (0..3700)"},
+	{ "lert", "<rx_channel>", cmd_lert, "Put unit in LE RX mode at rx_channel (0..39)"},
+	{ "lett", "<tx_channel> <length> <packet_payload>", cmd_lett, "Put unit in LE TX mode at tx_channel (0..39) with packet of given length (0..37) and packet_payload"},
+	{ "lete", "        ", cmd_lete, "End LE test"},
+	{ "tput-s", "[BD_Addr] [Judgment value] Logfile times data_size", cmd_tputs, "Throughput test - sender side"},
+	{ "tput-r", "        ", cmd_tputr, "Throughput test - receiver side"},
+	{ "btagent","<port number>", cmd_btagent, "BT Agent for IQFact" },
+	{ "pinconntest", "        ", cmd_pinconntest, "Pin Connectivity Test"},
+	{ "hciinq", "        ", cmd_hciinq, "Inquiry start"},
+	{ "hciinqcnl", "        ", cmd_hciinqcnl, "Inquiry Cancel"},
+	{ "hcisetevtflt", "        ", cmd_hcisetevtflt, "Set Event Filter"},
+	{ "conn", "        ", cmd_createconnection, "ACL Connection Test" },
+	{ "venspeccmd", "  ", cmd_venspeccmd, "Vendor Specific Command"},
+	{ "disc", "  ", cmd_disc, "HCI disconnect Command"},
+	{ "hciinvcmd1", "        ", cmd_hciinvcmd1, "Invalid HCI Command"},
+	{ "rawcmd", "    ", cmd_rawcmd, "RAW HCI Command ex) rawcmd ogf ocf <bytes>"},
+	{ "cmdline","<port number>", cmdline, "command line for Enable TX test mode" },
+	{ NULL, NULL, NULL, NULL }
+};
+/*
+   { "get_id",   cmd_gid,    "Get Chip Identification Number"                },
+ */
+static void usage(void)
+{
+	int i;
+
+	printf("btconfig - BTCONFIG Tool ver %s\n", VERSION);
+	if(is_qca_transport_uart){
+		printf("Usage:\n"
+				"\tbtconfig [options] <command> [command parameters]\n");
+	} else {
+		printf("Usage:\n"
+				"\tbtconfig [options] <tty> <speed> <command> [command parameters]\n");
+	}
+	printf("Options:\n"
+			"\t--help\tDisplay help\n"
+			"\t--soc\tController type: rome or 300x\n"
+			"\t--initialize\tRun rampatch download\n");
+	if(is_qca_transport_uart){ // this parameter is not needed for ROME/CHEROKEE
+		printf("tty:\n"
+				"\t/dev/ttyHS1\n");
+	}
+	printf("Commands:\n");
+	for (i = 0; command[i].cmd; i++)
+		printf("\t%-8s %-40s\t%s\n", command[i].cmd,command[i].cmd_option,command[i].doc);
+	printf("\n"
+			"For more information on the usage of each command use:\n"
+			"\tbtconfig <command> --help\n" );
+}
+
+struct ps_cfg_entry {
+	uint32_t id;
+	uint32_t len;
+	uint8_t *data;
+};
+
+struct ps_entry_type {
+	unsigned char type;
+	unsigned char array;
+};
+
+struct ps_cfg_entry ps_list[MAX_TAGS];
+
+static void load_hci_ps_hdr(uint8_t *cmd, uint8_t ps_op, int len, int index)
+{
+	hci_command_hdr *ch = (void *)cmd;
+
+	ch->opcode = htobs(HCI_OPCODE_PACK(HCI_VENDOR_CMD_OGF,
+				HCI_PS_CMD_OCF));
+	ch->plen = len + PS_HDR_LEN;
+	cmd += HCI_COMMAND_HEADER_SIZE;
+
+	cmd[0] = ps_op;
+	cmd[1] = index;
+	cmd[2] = index >> 8;
+	cmd[3] = len;
+}
+
+/*
+ * Send HCI command and wait for command complete event.
+ * The event buffer has to be freed by the caller.
+ */
+static int send_hci_cmd_sync(int dev, uint8_t *cmd, int len, uint8_t **event)
+{
+	int count;
+	uint8_t *hci_event;
+	uint8_t pkt_type = 0x01; // HCI_COMMAND_PKT;
+
+	if (len == 0)
+		return len;
+
+#ifdef QCA_DEBUG
+	printf("SEND -> ");
+	qca_debug_dump(cmd, len);
+#endif
+
+	if (write(dev, &pkt_type, 1) != 1)
+		return -EILSEQ;
+	if (write(dev, (unsigned char *)cmd, len) != len)
+		return -EILSEQ;
+
+	hci_event = (uint8_t *)malloc(PS_EVENT_LEN);
+	if (!hci_event)
+		return -ENOMEM;
+
+	count = read_hci_event(dev, (unsigned char *)hci_event, PS_EVENT_LEN);
+	if (count < 0) {
+		free(hci_event);
+		return -EILSEQ;
+	}
+
+#ifdef QCA_DEBUG
+	printf("RECV <- ");
+	qca_debug_dump(hci_event, count);
+#endif
+
+	*event = hci_event;
+	return count;
+
+}
+
+static int read_ps_event(uint8_t *event, uint16_t ocf)
+{
+	hci_event_hdr *eh;
+	uint16_t opcode = htobs(HCI_OPCODE_PACK(HCI_VENDOR_CMD_OGF, ocf));
+
+	eh = (hci_event_hdr*) (event + 1);
+	event += HCI_EVENT_HEADER_SIZE;
+
+	// EVT_CMD_COMPLETE 0x0E
+	if (eh->evt == 0x0E) {
+		evt_cmd_complete *cc = (void *)event;
+
+		// EVT_CMD_COMPLETE_SIZE 3
+		event += 3;
+
+		//printf("cc->opcode: %04x\n", cc->opcode);
+		//printf("opcode: %04x\n", opcode);
+		//printf("event[0]: %02x\n", event[0]);
+
+		if (cc->opcode == opcode && event[0] == HCI_EV_SUCCESS)
+			return 0;
+		else
+			return -EILSEQ;
+	}
+
+	printf("read_ps_cmd_complete_fails\n");
+	return -EILSEQ;
+}
+
+static int write_cmd(int fd, uint8_t *buffer, int len)
+{
+	uint8_t *event = NULL;
+	int err;
+
+	err = send_hci_cmd_sync(fd, buffer, len, &event);
+	if (err < 0 || !event){
+		if(event) free(event);
+		event = NULL;
+		return err;
+	}
+
+	err = read_ps_event(event, HCI_PS_CMD_OCF);
+
+	free(event);
+	event = NULL;
+	return err;
+}
+
+/* Sends PS commands using vendor specficic HCI commands */
+static int write_ps_cmd(int fd, uint8_t opcode, uint32_t ps_param)
+{
+	uint8_t cmd[HCI_MAX_CMD_SIZE];
+	uint32_t i;
+
+	switch (opcode) {
+		case ENABLE_PATCH:
+			load_hci_ps_hdr(cmd, opcode, 0, 0x00);
+
+			if (write_cmd(fd, cmd, HCI_PS_CMD_HDR_LEN) < 0)
+				return -EILSEQ;
+			break;
+
+		case PS_RESET:
+			load_hci_ps_hdr(cmd, opcode, PS_RESET_PARAM_LEN, 0x00);
+
+			cmd[7] = 0x00;
+			cmd[PS_RESET_CMD_LEN - 2] = ps_param & PS_ID_MASK;
+			cmd[PS_RESET_CMD_LEN - 1] = (ps_param >> 8) & PS_ID_MASK;
+
+			if (write_cmd(fd, cmd, PS_RESET_CMD_LEN) < 0)
+				return -EILSEQ;
+			break;
+
+		case PS_WRITE:
+			for (i = 0; i < ps_param; i++) {
+				load_hci_ps_hdr(cmd, opcode, ps_list[i].len,
+						ps_list[i].id);
+
+				memcpy(&cmd[HCI_PS_CMD_HDR_LEN], ps_list[i].data,
+						ps_list[i].len);
+
+				if (write_cmd(fd, cmd, ps_list[i].len +
+							HCI_PS_CMD_HDR_LEN) < 0)
+					return -EILSEQ;
+			}
+			break;
+	}
+
+	return 0;
+}
+
+#define __is_delim(ch) ((ch) == ':')
+#define MAX_PREAMBLE_LEN 4
+
+/* Parse PS entry preamble of format [X:X] for main type and subtype */
+static int get_ps_type(char *ptr, int index, char *type, char *sub_type)
+{
+	int i;
+	int delim = FALSE;
+
+	if (index > MAX_PREAMBLE_LEN)
+		return -EILSEQ;
+
+	for (i = 1; i < index; i++) {
+		if (__is_delim(ptr[i])) {
+			delim = TRUE;
+			continue;
+		}
+
+		if (isalpha(ptr[i])) {
+			if (delim == FALSE)
+				(*type) = toupper(ptr[i]);
+			else
+				(*sub_type) = toupper(ptr[i]);
+		}
+	}
+
+	return 0;
+}
+
+#define ARRAY   'A'
+#define STRING  'S'
+#define DECIMAL 'D'
+#define BINARY  'B'
+
+#define PS_HEX           0
+#define PS_DEC           1
+
+static int get_input_format(char *buf, struct ps_entry_type *format)
+{
+	char *ptr = NULL;
+	char type = '\0';
+	char sub_type = '\0';
+
+	format->type = PS_HEX;
+	format->array = TRUE;
+
+	if (strstr(buf, "[") != buf)
+		return 0;
+
+	ptr = strstr(buf, "]");
+	if (!ptr)
+		return -EILSEQ;
+
+	if (get_ps_type(buf, ptr - buf, &type, &sub_type) < 0)
+		return -EILSEQ;
+
+	/* Check is data type is of array */
+	if (type == ARRAY || sub_type == ARRAY)
+		format->array = TRUE;
+
+	if (type == STRING || sub_type == STRING)
+		format->array = FALSE;
+
+	if (type == DECIMAL || type == BINARY)
+		format->type = PS_DEC;
+	else
+		format->type = PS_HEX;
+
+	return 0;
+}
+
+#define UNDEFINED 0xFFFF
+
+static unsigned int read_data_in_section(char *buf, struct ps_entry_type type)
+{
+	char *ptr = buf;
+
+	if (!buf)
+		return UNDEFINED;
+
+	if (buf == strstr(buf, "[")) {
+		ptr = strstr(buf, "]");
+		if (!ptr)
+			return UNDEFINED;
+
+		ptr++;
+	}
+
+	if (type.type == PS_HEX && type.array != TRUE)
+		return strtol(ptr, NULL, 16);
+
+	return UNDEFINED;
+}
+
+struct tag_info {
+	unsigned section;
+	unsigned line_count;
+	unsigned char_cnt;
+	unsigned byte_count;
+};
+
+static inline int update_char_count(const char *buf)
+{
+	char *end_ptr;
+
+	if (strstr(buf, "[") == buf) {
+		end_ptr = strstr(buf, "]");
+		if (!end_ptr)
+			return 0;
+		else
+			return (end_ptr - buf) + 1;
+	}
+
+	return 0;
+}
+
+/* Read PS entries as string, convert and add to Hex array */
+static void update_tag_data(struct ps_cfg_entry *tag,
+		struct tag_info *info, const char *ptr)
+{
+	char buf[3];
+
+	buf[2] = '\0';
+
+	strlcpy(buf, &ptr[info->char_cnt], 2);
+	tag->data[info->byte_count] = strtol(buf, NULL, 16);
+	info->char_cnt += 3;
+	info->byte_count++;
+
+	strlcpy(buf, &ptr[info->char_cnt], 2);
+	tag->data[info->byte_count] = strtol(buf, NULL, 16);
+	info->char_cnt += 3;
+	info->byte_count++;
+}
+
+#define PS_UNDEF   0
+#define PS_ID      1
+#define PS_LEN     2
+#define PS_DATA    3
+
+#define PS_MAX_LEN         500
+#define ENTRY_PER_LINE     16
+
+#define __check_comment(buf) (((buf)[0] == '/') && ((buf)[1] == '/'))
+#define __skip_space(str)      while (*(str) == ' ') ((str)++)
+
+static int ath_parse_ps(FILE *stream)
+{
+	char buf[LINE_SIZE_MAX + 1];
+	char *ptr;
+	uint8_t tag_cnt = 0;
+	uint8_t tagPlatformConfig = 0;
+	int16_t byte_count = 0;
+	struct ps_entry_type format;
+	struct tag_info status = { 0, 0, 0, 0 };
+
+	do {
+		int read_count;
+		struct ps_cfg_entry *tag;
+
+		ptr = fgets(buf, LINE_SIZE_MAX, stream);
+		if (!ptr)
+			break;
+
+		__skip_space(ptr);
+		if (__check_comment(ptr))
+			continue;
+
+		/* Lines with a '#' will be followed by new PS entry */
+		if (ptr == strstr(ptr, "#")) {
+			if (status.section != PS_UNDEF) {
+				return -EILSEQ;
+			} else {
+				status.section = PS_ID;
+				continue;
+			}
+		}
+
+		tag = &ps_list[tag_cnt];
+
+		switch (status.section) {
+			case PS_ID:
+				if (get_input_format(ptr, &format) < 0)
+					return -EILSEQ;
+
+				tag->id = read_data_in_section(ptr, format);
+				if (tag->id == 0x21) /* Platform Config */
+					tagPlatformConfig = 1;
+				status.section = PS_LEN;
+				break;
+
+			case PS_LEN:
+				if (get_input_format(ptr, &format) < 0)
+					return -EILSEQ;
+
+				byte_count = read_data_in_section(ptr, format);
+				if (byte_count > PS_MAX_LEN)
+					return -EILSEQ;
+
+				tag->len = byte_count;
+				tag->data = (uint8_t *)malloc(byte_count);
+
+				status.section = PS_DATA;
+				status.line_count = 0;
+				break;
+
+			case PS_DATA:
+				if (status.line_count == 0)
+					if (get_input_format(ptr, &format) < 0)
+						return -EILSEQ;
+
+				__skip_space(ptr);
+
+				status.char_cnt = update_char_count(ptr);
+
+				read_count = (byte_count > ENTRY_PER_LINE) ?
+					ENTRY_PER_LINE : byte_count;
+
+				if (format.type == PS_HEX && format.array == TRUE) {
+					while (read_count > 0) {
+						update_tag_data(tag, &status, ptr);
+						read_count -= 2;
+					}
+
+					if (tagPlatformConfig == 1) {
+						tagPlatformConfig = 0;
+						tag->data[0] &= 0x7f;
+					}
+
+					if (byte_count > ENTRY_PER_LINE)
+						byte_count -= ENTRY_PER_LINE;
+					else
+						byte_count = 0;
+				}
+
+				status.line_count++;
+
+				if (byte_count == 0)
+					memset(&status, 0x00, sizeof(struct tag_info));
+
+				if (status.section == PS_UNDEF)
+					tag_cnt++;
+
+				if (tag_cnt == MAX_TAGS)
+					return -EILSEQ;
+				break;
+		}
+	} while (ptr);
+
+	return tag_cnt;
+}
+
+#define MAX_PATCH_CMD 244
+struct patch_entry {
+	int16_t len;
+	uint8_t data[MAX_PATCH_CMD];
+};
+
+#define SET_PATCH_RAM_ID	0x0D
+#define SET_PATCH_RAM_CMD_SIZE	11
+#define ADDRESS_LEN		4
+static int set_patch_ram(int dev, char *patch_loc, int len)
+{
+	int err;
+	uint8_t cmd[20];
+	int i, j;
+	char loc_byte[3];
+	uint8_t *event = NULL;
+	uint8_t *loc_ptr = &cmd[7];
+	UNUSED(len);
+	if (!patch_loc)
+		return -1;
+
+	loc_byte[2] = '\0';
+
+	load_hci_ps_hdr(cmd, SET_PATCH_RAM_ID, ADDRESS_LEN, 0);
+
+	for (i = 0, j = 3; i < 4; i++, j--) {
+		loc_byte[0] = patch_loc[0];
+		loc_byte[1] = patch_loc[1];
+		loc_ptr[j] = strtol(loc_byte, NULL, 16);
+		patch_loc += 2;
+	}
+
+	err = send_hci_cmd_sync(dev, cmd, SET_PATCH_RAM_CMD_SIZE, &event);
+	if (err < 0 || !event){
+		if(event) free(event);
+		event = NULL;
+		return err;
+	}
+
+	err = read_ps_event(event, HCI_PS_CMD_OCF);
+
+	free(event);
+	event = NULL;
+	return err;
+}
+
+#define PATCH_LOC_KEY    "DA:"
+#define PATCH_LOC_STRING_LEN    8
+static int ps_patch_download(int fd, FILE *stream)
+{
+	char byte[3];
+	char ptr[MAX_PATCH_CMD + 1];
+	int byte_cnt;
+	int patch_count = 0;
+	char patch_loc[PATCH_LOC_STRING_LEN + 1];
+
+	byte[2] = '\0';
+
+	while (fgets(ptr, MAX_PATCH_CMD, stream)) {
+		if (strlen(ptr) <= 1)
+			continue;
+		else if (strstr(ptr, PATCH_LOC_KEY) == ptr) {
+			strlcpy(patch_loc, &ptr[sizeof(PATCH_LOC_KEY) - 1],
+					PATCH_LOC_STRING_LEN);
+			if (set_patch_ram(fd, patch_loc, sizeof(patch_loc)) < 0)
+				return -1;
+		} else if (isxdigit(ptr[0]))
+			break;
+		else
+			return -1;
+	}
+
+	byte_cnt = strtol(ptr, NULL, 16);
+
+	while (byte_cnt > 0) {
+		int i;
+		uint8_t cmd[HCI_MAX_CMD_SIZE];
+		struct patch_entry patch;
+
+		if (byte_cnt > MAX_PATCH_CMD)
+			patch.len = MAX_PATCH_CMD;
+		else
+			patch.len = byte_cnt;
+
+		for (i = 0; i < patch.len; i++) {
+			if (!fgets(byte, 3, stream))
+				return -1;
+
+			patch.data[i] = strtoul(byte, NULL, 16);
+		}
+
+		load_hci_ps_hdr(cmd, WRITE_PATCH, patch.len, patch_count);
+		memcpy(&cmd[HCI_PS_CMD_HDR_LEN], patch.data, patch.len);
+
+		if (write_cmd(fd, cmd, patch.len + HCI_PS_CMD_HDR_LEN) < 0)
+			return -1;
+
+		patch_count++;
+		byte_cnt = byte_cnt - MAX_PATCH_CMD;
+	}
+
+	if (write_ps_cmd(fd, ENABLE_PATCH, 0) < 0)
+		return -1;
+
+	return patch_count;
+}
+
+static int ps_config_download(int fd, int tag_count)
+{
+	if (write_ps_cmd(fd, PS_RESET, PS_RAM_SIZE) < 0)
+		return -1;
+
+	if (tag_count > 0)
+		if (write_ps_cmd(fd, PS_WRITE, tag_count) < 0)
+			return -1;
+	return 0;
+}
+
+static void get_ps_file_name(uint32_t devtype, uint32_t rom_version,
+		char *path)
+{
+	char *filename;
+
+	if (devtype == ROM_DEV_TYPE)
+		filename = PS_ASIC_FILE;
+	else
+		filename = PS_FPGA_FILE;
+
+	snprintf(path, MAXPATHLEN, "%s%x/%s", FW_PATH_AR, rom_version, filename);
+}
+
+static void get_patch_file_name(uint32_t dev_type, uint32_t rom_version,
+		uint32_t build_version, char *path)
+{
+	if (rom_version == FPGA_ROM_VERSION && dev_type != ROM_DEV_TYPE &&
+			dev_type != 0 && build_version == 1)
+		path[0] = '\0';
+	else
+		snprintf(path, MAXPATHLEN, "%s%x/%s",
+				FW_PATH_AR, rom_version, PATCH_FILE);
+}
+
+#define VERIFY_CRC   9
+#define PS_REGION    1
+#define PATCH_REGION 2
+
+static int get_ath3k_crc(int dev)
+{
+	uint8_t cmd[7];
+	uint8_t *event = NULL;
+	int err;
+
+	load_hci_ps_hdr(cmd, VERIFY_CRC, 0, PS_REGION | PATCH_REGION);
+
+	err = send_hci_cmd_sync(dev, cmd, sizeof(cmd), &event);
+	if (err < 0 || !event){
+		if(event) free(event);
+		event = NULL;
+		return err;
+	}
+
+	/* Send error code if CRC check patched */
+	if (read_ps_event(event, HCI_PS_CMD_OCF) >= 0)
+		err = -EILSEQ;
+
+	free(event);
+	event = NULL;
+	return err;
+}
+
+#define DEV_REGISTER      0x4FFC
+#define GET_DEV_TYPE_OCF  0x05
+
+static int get_device_type(int dev, uint32_t *code)
+{
+	uint8_t cmd[8];
+	uint8_t *event = NULL;
+	uint32_t reg;
+	int err;
+	uint8_t *ptr = cmd;
+	hci_command_hdr *ch = (void *)cmd;
+
+	ch->opcode = htobs(HCI_OPCODE_PACK(HCI_VENDOR_CMD_OGF,
+				GET_DEV_TYPE_OCF));
+	ch->plen = 5;
+	ptr += HCI_COMMAND_HEADER_SIZE;
+
+	ptr[0] = (uint8_t)DEV_REGISTER;
+	ptr[1] = (uint8_t)((DEV_REGISTER >> 8)&0xFF);
+	ptr[2] = (uint8_t)((DEV_REGISTER >> 16)&0xFF);
+	ptr[3] = (uint8_t)((DEV_REGISTER >> 24)&0xFF);
+	ptr[4] = 0x04;
+
+	err = send_hci_cmd_sync(dev, cmd, sizeof(cmd), &event);
+	if (err < 0 || !event){
+		if(event) free(event);
+		event = NULL;
+		return err;
+	}
+
+	err = read_ps_event(event, GET_DEV_TYPE_OCF);
+	if (err < 0)
+		goto cleanup;
+
+	reg = event[10];
+	reg = (reg << 8) | event[9];
+	reg = (reg << 8) | event[8];
+	reg = (reg << 8) | event[7];
+	*code = reg;
+
+cleanup:
+	free(event);
+	event = NULL;
+	return err;
+}
+
+static int read_ath3k_version(int pConfig, uint32_t *rom_version,
+		uint32_t *build_version)
+{
+	uint8_t cmd[3];
+	uint8_t *event = NULL;
+	int err;
+	int status;
+	hci_command_hdr *ch = (void *)cmd;
+
+	ch->opcode = htobs(HCI_OPCODE_PACK(HCI_VENDOR_CMD_OGF,
+				OCF_READ_VERSION));
+	ch->plen = 0;
+
+	err = send_hci_cmd_sync(pConfig, cmd, sizeof(cmd), &event);
+	if (err < 0 || !event){
+		if(event)  free(event);
+		event = NULL;
+		return err;
+	}
+
+	err = read_ps_event(event, OCF_READ_VERSION);
+	if (err < 0)
+		goto cleanup;
+
+	status = event[10];
+	status = (status << 8) | event[9];
+	status = (status << 8) | event[8];
+	status = (status << 8) | event[7];
+	*rom_version = status;
+
+	status = event[14];
+	status = (status << 8) | event[13];
+	status = (status << 8) | event[12];
+	status = (status << 8) | event[11];
+
+	*build_version = status;
+
+cleanup:
+	free(event);
+	event = NULL;
+	return err;
+}
+
+static void convert_bdaddr(char *str_bdaddr, char *bdaddr)
+{
+	char bdbyte[3];
+	char *str_byte = str_bdaddr;
+	int i, j;
+	int colon_present = 0;
+
+	if (strstr(str_bdaddr, ":"))
+		colon_present = 1;
+
+	bdbyte[2] = '\0';
+
+	/* Reverse the BDADDR to LSB first */
+	for (i = 0, j = 5; i < 6; i++, j--) {
+		bdbyte[0] = str_byte[0];
+		bdbyte[1] = str_byte[1];
+		bdaddr[j] = strtol(bdbyte, NULL, 16);
+
+		if (colon_present == 1)
+			str_byte += 3;
+		else
+			str_byte += 2;
+	}
+}
+
+static int write_bdaddr(int pConfig, char *bdaddr)
+{
+	uint8_t *event = NULL;
+	int err;
+	uint8_t cmd[13];
+	uint8_t *ptr = cmd;
+	hci_command_hdr *ch = (void *)cmd;
+
+	memset(cmd, 0, sizeof(cmd));
+
+	ch->opcode = htobs(HCI_OPCODE_PACK(HCI_VENDOR_CMD_OGF,
+				HCI_PS_CMD_OCF));
+	ch->plen = 10;
+	ptr += HCI_COMMAND_HEADER_SIZE;
+
+	ptr[0] = 0x01;
+	ptr[1] = 0x01;
+	ptr[2] = 0x00;
+	ptr[3] = 0x06;
+
+	convert_bdaddr(bdaddr, (char *)&ptr[4]);
+
+	err = send_hci_cmd_sync(pConfig, cmd, sizeof(cmd), &event);
+	if (err < 0 || !event){
+		if(event)  free(event);
+		event = NULL;
+		return err;
+	}
+	err = read_ps_event(event, HCI_PS_CMD_OCF);
+
+	free(event);
+	event = NULL;
+
+	return err;
+}
+
+static void write_bdaddr_from_file(int rom_version, int fd)
+{
+	FILE *stream;
+	char bdaddr[PATH_MAX];
+	char bdaddr_file[PATH_MAX];
+
+	snprintf(bdaddr_file, MAXPATHLEN, "%s%x/%s",
+			FW_PATH_AR, rom_version, BDADDR_FILE);
+
+	stream = fopen(bdaddr_file, "r");
+	if (!stream)
+		return;
+
+	if (fgets(bdaddr, PATH_MAX - 1, stream))
+		write_bdaddr(fd, bdaddr);
+
+	fclose(stream);
+}
+
+static int ath_ps_download(int fd)
+{
+	int err = 0;
+	int tag_count = 0;
+	int patch_count = 0;
+	uint32_t rom_version = 0;
+	uint32_t build_version = 0;
+	uint32_t dev_type = 0;
+	char patch_file[PATH_MAX];
+	char ps_file[PATH_MAX];
+	FILE *stream;
+
+	if (nopatch) {
+		printf("patch sequences\t\tSKIP\n");
+		err = 0;
+		goto download_cmplete;
+	}
+
+	/*
+	 * Verfiy firmware version. depending on it select the PS
+	 * config file to download.
+	 */
+	if (get_device_type(fd, &dev_type) < 0) {
+		err = -1;
+		goto download_cmplete;
+	}
+	printf("dev_type \t\t0x%x\n", dev_type);
+
+	if (read_ath3k_version(fd, &rom_version, &build_version) < 0) {
+		err = -2;
+		goto download_cmplete;
+	}
+	printf("dev_version \t\trom: 0x%x build: 0x%x\n", rom_version, build_version);
+
+	/* Do not download configuration if CRC passes */
+	if (get_ath3k_crc(fd) < 0) {
+		err = 0;
+		goto download_cmplete;
+	}
+	printf("crc \t\t\tsuccess\n");
+
+	get_ps_file_name(dev_type, rom_version, ps_file);
+	get_patch_file_name(dev_type, rom_version, build_version, patch_file);
+
+	printf("PS file : \t\t%s\n", ps_file);
+	printf("PATCH file : \t\t%s\n", patch_file);
+
+	stream = fopen(ps_file, "r");
+
+	if (!stream) {
+		printf("firmware file open error:%s, ver:%x\n",ps_file, rom_version);
+		if (rom_version == 0x1020201)
+			err = 0;
+		else
+			err = -3;
+		goto download_cmplete;
+	}
+	else {
+		tag_count = ath_parse_ps(stream);
+		fclose(stream);
+	}
+
+	if (tag_count < 0) {
+		err = -4;
+		goto download_cmplete;
+	}
+
+	/*
+	 * It is not necessary that Patch file be available,
+	 * continue with PS Operations if patch file is not available.
+	 */
+	if (patch_file[0] == '\0')
+		err = 0;
+
+	stream = fopen(patch_file, "r");
+	if (!stream)
+		err = 0;
+	else {
+		patch_count = ps_patch_download(fd, stream);
+		fclose(stream);
+
+		if (patch_count < 0) {
+			err = -5;
+			goto download_cmplete;
+		}
+	}
+
+	err = ps_config_download(fd, tag_count);
+
+download_cmplete:
+	printf("download_cmplete;\terr: %d\n", err);
+	if (!err)
+		write_bdaddr_from_file(rom_version, fd);
+
+	return err;
+}
+
+static int uart_speed(int s)
+{
+	switch (s) {
+		case 9600:
+			return B9600;
+		case 19200:
+			return B19200;
+		case 38400:
+			return B38400;
+		case 57600:
+			return B57600;
+		case 115200:
+			return B115200;
+		case 230400:
+			return B230400;
+		case 460800:
+			return B460800;
+		case 500000:
+			return B500000;
+		case 576000:
+			return B576000;
+		case 921600:
+			return B921600;
+		case 1000000:
+			return B1000000;
+		case 1152000:
+			return B1152000;
+		case 1500000:
+			return B1500000;
+		case 2000000:
+			return B2000000;
+#ifdef B2500000
+		case 2500000:
+			return B2500000;
+#endif
+		case 3000000:
+			return B3000000;
+#ifdef B3500000
+		case 3500000:
+			return B3500000;
+#endif
+#ifdef B4000000
+		case 4000000:
+			return B4000000;
+#endif
+		default:
+			return B57600;
+	}
+}
+
+int set_speed(int fd, struct termios *ti, int speed)
+{
+	if (cfsetospeed(ti, uart_speed(speed)) < 0)
+		return -errno;
+
+	if (cfsetispeed(ti, uart_speed(speed)) < 0)
+		return -errno;
+
+	if (tcsetattr(fd, TCSANOW, ti) < 0)
+		return -errno;
+
+	//tcflush(fd, TCIOFLUSH);
+	return 0;
+}
+
+static int set_cntrlr_baud(int fd, int speed)
+{
+	int baud, count;
+	struct timespec tm = { 0, 500000 };
+	unsigned char cmd[MAX_CMD_LEN], rsp[MAX_EVENT_SIZE];
+	unsigned char *ptr = cmd + 1;
+	hci_command_hdr *ch = (void *)ptr;
+
+	cmd[0] = 0x01; //HCI_COMMAND_PKT;
+
+	/* set controller baud rate to user specified value */
+	ptr = cmd + 1;
+	ch->opcode = htobs(HCI_OPCODE_PACK(HCI_VENDOR_CMD_OGF,
+				HCI_CHG_BAUD_CMD_OCF));
+	ch->plen = 2;
+	ptr += HCI_COMMAND_HEADER_SIZE;
+
+	baud = speed/100;
+	ptr[0] = (char)baud;
+	ptr[1] = (char)(baud >> 8);
+
+#ifdef QCA_DEBUG
+	printf("SEND -> ");
+	qca_debug_dump(cmd, WRITE_BAUD_CMD_LEN);
+#endif
+
+	//if (!local) {
+		if (write(fd, cmd, WRITE_BAUD_CMD_LEN) != WRITE_BAUD_CMD_LEN) {
+			perror("Failed to write change baud rate command");
+			return -ETIMEDOUT;
+		}
+
+		nanosleep(&tm, NULL);
+	//}
+
+	/* Change local UART baudrate */
+	//if (qca_set_speed(fd, ti, speed) < 0) {
+	//	fprintf(stderr, "Can't set host baud rate");
+	//	return -EPROTO;
+	//}
+
+	//tcflush(fd, TCIOFLUSH);
+
+	//if (!local) {
+		count = read_hci_event(fd, rsp, sizeof(rsp));
+
+		if (count < 0) {
+			printf("Failed to read event after changing baud rate\n");
+			return -ETIMEDOUT;
+		}
+	//}
+
+#ifdef QCA_DEBUG
+	printf("RECV <- ");
+	qca_debug_dump(rsp, count);
+#endif
+
+	return 0;
+}
+
+
+
+/* Initialize SMD driver */
+static int wcn_init_smd(char *dev)
+{
+	int retry = 0;
+	struct termios term;
+	int fd = -1;
+
+	fd = open(dev, (O_RDWR | O_NOCTTY));
+
+	while ((-1 == fd) && (retry < 3)) {
+		perror("Cannot open device. Retry after 2 seconds");
+		usleep(2000000);
+		fd = open(dev, (O_RDWR | O_NOCTTY));
+		retry++;
+	}
+
+	if (-1 == fd) {
+		perror("Cannot open device, will exit");
+		return -1;
+	}
+
+	usleep(500000);
+
+	if (tcflush(fd, TCIOFLUSH) < 0) {
+		perror("Cannot flush device");
+		close(fd);
+		return -1;
+	}
+
+	if (tcgetattr(fd, &term) < 0) {
+		perror("Error while getting attributes");
+		close(fd);
+		return -1;
+	}
+
+	cfmakeraw(&term);
+	term.c_cflag |= (CRTSCTS | CLOCAL);
+
+	if (tcsetattr(fd, TCSANOW, &term) < 0) {
+		perror("Error while getting attributes");
+		close(fd);
+		return -1;
+	}
+
+	printf("Done intiailizing fd = %s \n", dev);
+	return fd;
+}
+
+static uint8_t qca_get_baudrate(uint32_t speed)
+{
+	switch(speed) {
+	case 9600:
+		return QCA_BAUDRATE_9600;
+	case 19200:
+		return QCA_BAUDRATE_19200;
+	case 38400:
+		return QCA_BAUDRATE_38400;
+	case 57600:
+		return QCA_BAUDRATE_57600;
+	case 115200:
+		return QCA_BAUDRATE_115200;
+	case 230400:
+		return QCA_BAUDRATE_230400;
+	case 460800:
+		return QCA_BAUDRATE_460800;
+	case 500000:
+		return QCA_BAUDRATE_500000;
+	case 921600:
+		return QCA_BAUDRATE_921600;
+	case 1000000:
+		return QCA_BAUDRATE_1000000;
+	case 2000000:
+		return QCA_BAUDRATE_2000000;
+	case 3000000:
+		return QCA_BAUDRATE_3000000;
+	case 3500000:
+		return QCA_BAUDRATE_3500000;
+	default:
+		return QCA_BAUDRATE_AUTO;
+	}
+}
+
+static int qca_vs_read_event(uint8_t *rsp, int size)
+{
+	uint32_t product_id, soc_id;
+	uint16_t patch_ver, rome_ver;
+
+	if(rsp[1] != EVT_VENDOR && rsp[1] != EVT_CMD_COMPLETE) {
+		fprintf(stderr, "Fail to receive HCI Vendor Specific event\n");
+		return -EIO;
+	}
+
+	UNUSED(size);
+	printf("Parameter Length: 0x%x\n", rsp[2]);
+	printf("Command Response: 0x%x\n", rsp[3]);
+	printf("Response Type: 0x%x\n", rsp[4]);
+
+	/* check the status of the operation */
+	switch (rsp[3]) {
+	case EDL_CMD_REQ_RES_EVT:
+		switch (rsp[4]) {
+		case EDL_PATCH_VER_RES_EVT:
+		case EDL_APP_VER_RES_EVT:
+			product_id = *(uint32_t*)le32toh(rsp + 5);
+			patch_ver = *(uint16_t*)le16toh(rsp + 9);
+			rome_ver = *(uint16_t*)le16toh(rsp + 11);
+			soc_id = *(uint32_t*)le32toh(rsp + 13);
+
+			printf("\t Current Product ID\t\t: 0x%08x\n",
+			       product_id);
+			printf("\t Current Patch Version\t\t: 0x%04x\n",
+			       patch_ver);
+			printf("\t Current ROM Build Version\t: 0x%04x\n",
+			       rome_ver);
+			printf("\t Current SOC Version\t\t: 0x%08x\n",
+			       soc_id);
+
+			/* ROME chipset Version can be decided by patch and SOC
+			 * Version, combination with upper 2 bytes from soc
+	                 * and lower 2 bytes from patch will be used
+			 */
+			g_rome_ver = (soc_id << 16) | (rome_ver & 0x0000ffff);
+			break;
+
+		case EDL_TVL_DNLD_RES_EVT:
+		case EDL_CMD_EXE_STATUS_EVT:
+			if (rsp[5] != HCI_CMD_SUCCESS) {
+				fprintf(stderr, "Fail to download packet %d\n",
+					rsp[5]);
+				return -EIO;
+			}
+			break;
+
+		default:
+			return -EIO;
+		}
+		break;
+
+	case EDL_SET_BAUDRATE_RSP_EVT:
+		if (rsp[4] != BAUDRATE_CHANGE_SUCCESS) {
+			fprintf(stderr, "Set Baudrate request failed 0x%x\n",
+				rsp[5]);
+			return -EIO;
+
+		}
+		break;
+
+	case EDL_NVM_ACCESS_CODE_EVT:
+		break;
+
+	default:
+		fprintf(stderr, "Not a valid status\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int qca_set_speed(int fd, struct termios *ti, uint32_t speed)
+{
+	if (cfsetospeed(ti, uart_speed(speed)) < 0)
+		return -errno;
+
+	if (cfsetispeed(ti, uart_speed(speed)) < 0)
+		return -errno;
+
+	/* don't change speed until last write done */
+	if (tcsetattr(fd, TCSADRAIN, ti) < 0)
+		return -errno;
+
+	return 0;
+}
+
+static int qca_set_baudrate(int fd, int flags, uint32_t speed, struct termios *ti, bool local)
+{
+	uint8_t cmd[] = { HCI_COMMAND_PKT, 0x48, 0xfc, 0x01, 0x00 };
+	uint8_t resp[HCI_MAX_EVENT_SIZE];
+	int count;
+
+	if (speed > 3000000)
+		return -EINVAL;
+
+	printf("Set Controller UART speed to %d\n", speed);
+
+	cmd[4] = qca_get_baudrate(speed);
+
+	if (flags & FLOW_CTL) {
+		/* disable flow control while changing speed */
+		ti->c_cflag |= (CLOCAL|CREAD);
+		ti->c_cflag &= ~CRTSCTS;
+		if (tcsetattr(fd, TCSANOW, ti) < 0) {
+			fprintf(stderr, "Can't set port settings");
+			return -EPROTO;
+		}
+	}
+
+	/* Send Vendor Specific command to set UART baudrate to chipset */
+	if (!local && write(fd, cmd, 5) != 5) {
+		fprintf(stderr, "Failed to write update baudrate command\n");
+		return -EIO;
+	}
+
+	/* Change local UART baudrate */
+	if (qca_set_speed(fd, ti, speed) < 0) {
+		fprintf(stderr, "Can't set host baud rate");
+		return -EPROTO;
+	}
+
+	if (flags & FLOW_CTL) {
+		/* flow on after changing local uart baudrate */
+		ti->c_cflag |= (CLOCAL|CREAD);
+		ti->c_cflag |= CRTSCTS;
+		if (tcsetattr(fd, TCSANOW, ti) < 0) {
+			fprintf(stderr, "Can't set port settings");
+			return -EPROTO;
+		}
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	/* check for response from the chipset */
+	if (!local) {
+		count = read_hci_event(fd, resp, HCI_MAX_EVENT_SIZE);
+		if (count < 0)
+			return -EIO;
+
+		if (qca_vs_read_event(resp, count) < 0)
+			return -EPROTO;
+
+		/* number of command complete event */
+		if (read_hci_event(fd, resp, HCI_MAX_EVENT_SIZE) < CC_MIN_SIZE) {
+			fprintf(stderr, "Failed to update baudrate, "
+				"invalid HCI event\n");
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static int qca_reset_req(int fd)
+{
+	uint8_t cmd[] = { HCI_COMMAND_PKT, 0x03, 0x0C, 0x00 };
+	uint8_t rsp[HCI_MAX_EVENT_SIZE];
+	int err;
+
+	printf("HCI Reset\n");
+
+	err = write(fd, cmd, sizeof(cmd));
+	if (err != sizeof(cmd)) {
+		fprintf(stderr, "Send failed with ret value %d\n", err);
+		return -1;
+	}
+
+	err = read_hci_event(fd, rsp, HCI_MAX_EVENT_SIZE);
+	if (err < 7) {
+		fprintf(stderr, "Failed to reset, invalid HCI event\n");
+		return -1;
+	}
+
+	if (rsp[4] != cmd[1] || rsp[5] != cmd[2] || rsp[6] != HCI_CMD_SUCCESS) {
+		fprintf(stderr, "Failed to reset, command failure\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int qca_vs_send_cmd(int fd, uint8_t *cmd, uint8_t *rsp, int size)
+{
+	int ret, count;
+
+#ifdef QCA_DEBUG
+	printf("SEND -> ");
+	qca_debug_dump(cmd, size);
+#endif
+	ret = write(fd, cmd, size);
+	if (ret != size) {
+		fprintf(stderr, "Send failed with ret %d\n", ret);
+		return -1;
+	}
+
+	/* check for response from the chipset */
+	count = read_hci_event(fd, rsp, HCI_MAX_EVENT_SIZE);
+	if (count < 0)
+		return -1;
+
+#ifdef QCA_DEBUG
+	printf("RECV <- ");
+	qca_debug_dump(rsp, count);
+#endif
+	ret = qca_vs_read_event(rsp, count);
+	if (ret < 0)
+		return -1;
+
+	return count;
+}
+
+static void frame_hci_pkt(uint8_t *cmd, int eld_cmd, uint8_t *data, int size)
+{
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = HCI_PATCH_CMD_OCF & 0xff;
+	cmd[2] = HCI_VENDOR_CMD_OGF << 2 | HCI_PATCH_CMD_OCF >> 8;
+	cmd[3] = size;
+	cmd[4] = eld_cmd;
+
+	switch(eld_cmd) {
+	case EDL_PATCH_VER_REQ_CMD:
+		printf("Sending EDL_PATCH_VER_REQ_CMD\n");
+		break;
+
+	case EDL_PATCH_TLV_REQ_CMD:
+		printf("Sending EDL_PATCH_TLV_REQ_CMD\n");
+		/* parameter total length */
+		cmd[3] = size + 2; // adding size of eld_cmd & length
+		/* TLV segment length */
+		cmd[5] = size;
+		/* put data */
+		memcpy(cmd + 6, data, size);
+		break;
+
+	default:
+		fprintf(stderr, "Unknown EDL CMD\n");
+		break;
+	}
+
+	return;
+}
+
+static int qca_rome_patch_ver_req(int fd)
+{
+	int size, err;
+	uint8_t cmd[HCI_MAX_CMD_SIZE];
+	uint8_t rsp[HCI_MAX_EVENT_SIZE];
+
+	/* Generate packet to read chipset version */
+	frame_hci_pkt(cmd, EDL_PATCH_VER_REQ_CMD, 0,
+			      EDL_PATCH_CMD_LEN);
+	/* size of length: CMD + opcode + len */
+	size = 4 + EDL_PATCH_CMD_LEN;
+
+	/* Send HCI command to controller */
+	err = qca_vs_send_cmd(fd, cmd, rsp, size);
+	if (err < 0) {
+		fprintf(stderr, "Failed to read version of soc (%x)\n",
+			err);
+		return err;
+	}
+
+	/* Command complete event */
+	err = read_hci_event(fd, rsp, HCI_MAX_EVENT_SIZE);
+	if (err < 7) {
+		fprintf(stderr, "Failed to read, invalid HCI event\n");
+		return -1;
+	}
+
+#ifdef QCA_DEBUG
+	printf("RECV <- ");
+	qca_debug_dump(rsp, 10);
+#endif
+	return 0;
+}
+
+static int qca_tlv_dnld_segment(int fd, int idx, int seg_size, uint8_t *data,
+				bool wt_evt)
+{
+	int size, err;
+	uint8_t cmd[HCI_MAX_CMD_SIZE];
+	uint8_t rsp[HCI_MAX_EVENT_SIZE];
+
+	printf("Download segment no %d size %d\n", idx, seg_size);
+
+	/* Frame the HCI CMD PKT to be sent to controller */
+	frame_hci_pkt(cmd, EDL_PATCH_TLV_REQ_CMD, data, seg_size);
+	/* total size of packet: cmd + opcode + len + cmd[3] */
+	size = 4 + cmd[3];
+
+	err = qca_vs_send_cmd(fd, cmd, rsp, size);
+	if (err < 0) {
+		fprintf(stderr, "Failed to send patch payload to soc %x\n",
+			err);
+		return err;
+	}
+
+	if (wt_evt) {
+		err = read_hci_event(fd, rsp, HCI_MAX_EVENT_SIZE);
+		if (err < 0) {
+			fprintf(stderr, "Failed to download patch segment %d\n",
+				idx);
+			return err;
+		}
+#ifdef QCA_DEBUG
+		printf("RECV <- ");
+		qca_debug_dump(rsp, 10);
+#endif
+	}
+
+	printf("Succeed downloading segment %d\n", idx);
+
+	return 0;
+}
+
+static int qca_tlv_dnld_req(int fd, struct patch_data *pdata)
+{
+	int total_segment, remain_size;
+	int err, w_cmd, i;
+	uint8_t *buffer;
+
+	if (!pdata)
+		return -EINVAL;
+
+	total_segment = pdata->len / MAX_SIZE_PER_TLV_SEGMENT;
+	remain_size = (pdata->len < MAX_SIZE_PER_TLV_SEGMENT)? pdata->len :
+		      pdata->len % MAX_SIZE_PER_TLV_SEGMENT;
+
+	printf("Total size %ld, total segment num %d, remain size %d\n",
+	       pdata->len, total_segment, remain_size);
+
+	for (i = 0; i < total_segment; i++) {
+		// Last patch segment does not generate command_complete event
+		if (pdata->type == TLV_TYPE_PATCH && !remain_size &&
+		    i+1 == total_segment)
+			w_cmd = false;
+		else
+			w_cmd = true;
+
+		buffer = pdata->data + i * MAX_SIZE_PER_TLV_SEGMENT;
+		err = qca_tlv_dnld_segment(fd, i, MAX_SIZE_PER_TLV_SEGMENT,
+					   buffer, w_cmd);
+		if (err < 0)
+			return -EIO;
+	}
+
+	if (remain_size) {
+		// Last patch segment does not generate command_complete event
+		if (pdata->type == TLV_TYPE_PATCH)
+			w_cmd = false;
+		else
+			w_cmd = true;
+
+		buffer = pdata->data + total_segment * MAX_SIZE_PER_TLV_SEGMENT;
+		err = qca_tlv_dnld_segment(fd, total_segment, remain_size,
+					   buffer, w_cmd);
+		if (err < 0)
+			return -EIO;
+	}
+
+	return 0;
+}
+
+static void qca_print_file_data(int type, uint8_t *file_data)
+{
+	uint8_t *data;
+	int i, idx, length, tlv;
+	uint16_t tag_id, tag_len;
+
+	data = file_data;
+
+	printf("===================================================\n");
+	tlv = *(uint32_t*)le32toh(data);
+	printf("TLV Type\t\t : 0x%x\n", tlv & 0x000000ff);
+	length = (tlv >> 8) & 0x00ffffff;
+	printf("Length\t\t\t : %d bytes \n", length);
+	data += sizeof(uint32_t);
+
+	switch (type) {
+	case TLV_TYPE_PATCH:
+		printf("Total Length\t\t : %d bytes\n",
+		       *(uint32_t*)le32toh(data));
+		data += sizeof(uint32_t);
+		printf("Patch Data Length\t : %d bytes\n",
+		       *(uint32_t*)le32toh(data));
+		data += sizeof(uint32_t);
+		printf("Signing Format Version\t : 0x%x\n", *(char*)data);
+		data += sizeof(uint8_t);
+		printf("Signature Algorithm\t : 0x%x\n", *(char*)data);
+		data += sizeof(uint8_t);
+		printf("Reserved\t\t : 0x%x\n", *(uint16_t*)le16toh(data));
+		data += sizeof(uint16_t);
+		printf("Product ID\t\t : 0x%04x\n", *(uint16_t*)le16toh(data));
+		data += sizeof(uint16_t);
+		printf("Rom Build Version\t : 0x%04x\n",
+		       *(uint16_t*)le16toh(data));
+		data += sizeof(uint16_t);
+		printf("Patch Version\t\t : 0x%04x\n",
+		       *(uint16_t*)le16toh(data));
+		data += sizeof(uint16_t);
+		printf("Reserved\t\t : 0x%x\n", *(uint16_t*)le16toh(data));
+		data += sizeof(uint16_t);
+		printf("Patch Entry Address\t : 0x%x\n",
+		       *(uint32_t*)le32toh(data));
+		break;
+
+	case TLV_TYPE_NVM:
+		idx = 0;
+		do {
+			tag_id = *(uint16_t*)le16toh(data);
+			data += sizeof(uint16_t);
+			tag_len = *(uint16_t*)le16toh(data);
+			data += sizeof(uint16_t);
+
+			// skip tag pointer & ex_flag; 4 bytes each
+			data += 8;
+
+			printf("TAG ID\t\t : %d\n", tag_id);
+			printf("TAG Length\t\t : %d\n", tag_len);
+			printf("TAG Data\t\t : ");
+
+			switch (tag_id) {
+				case 17: // HCI Transport Layer Parameters
+					// Disable Software Inband Sleep
+					data[0] &= 0x7F;
+					break;
+
+				case 27: // Sleep Enable Mask
+					// Disable deep sleep mode
+					data[0] &= 0xFE;
+					break;
+			}
+
+			for (i = 0; i < tag_len; i++, data++)
+				printf("%.02x ", *data);
+			printf("\n");
+
+			idx += (sizeof(uint16_t) + sizeof(uint16_t) + 8 +
+			       tag_len);
+		} while (idx < length);
+		break;
+
+	default:
+		printf("unknown TLV type %d\n", type);
+		break;
+	}
+
+	printf("===================================================\n");
+
+	return;
+}
+
+static int qca_get_tlv_file(char *path, struct patch_data *pdata)
+{
+	FILE *stream;
+	int read_size, ret = 0;
+
+	printf("file open %s\n", path);
+
+	if (!path || !pdata)
+		return -EINVAL;
+
+	stream = fopen(path, "r");
+	if (!stream)
+		return -EIO;
+
+	/* get file size */
+	fseek(stream, 0, SEEK_END);
+	pdata->len = ftell(stream);
+	rewind(stream);
+
+	pdata->data = (uint8_t *)malloc(pdata->len);
+	if (!pdata->data) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* copy file into allocated buffer*/
+	read_size = fread(pdata->data, 1, pdata->len, stream);
+
+	if (read_size != pdata->len) {
+		printf("read file size %d not matched with actual size %ld\n",
+		       read_size, pdata->len);
+		ret = -EILSEQ;
+		goto done;
+	}
+
+	qca_print_file_data(pdata->type, pdata->data);
+
+done:
+	if (stream)
+		fclose(stream);
+
+	if (ret < 0 && pdata->data)
+	{
+		free(pdata->data);
+		pdata->data = NULL;
+	}
+
+	return ret;
+}
+
+static int qca_download_tlv_file(int fd, uint8_t type, char *file_name)
+{
+	struct patch_data data;
+	int ret = 0;
+
+	data.type = type;
+	data.data = NULL;
+	ret = qca_get_tlv_file(file_name, &data);
+	if (ret < 0) {
+		fprintf(stderr, "fail to get patch %s %d\n", file_name, ret);
+		goto done;
+	}
+
+	ret = qca_tlv_dnld_req(fd, &data);
+	if (ret < 0) {
+		fprintf(stderr, "fail to download %s %d\n", file_name, ret);
+		goto done;
+	}
+
+done:
+	if (data.data)
+		free(data.data);
+
+	return ret;
+}
+
+int qca_rome_init(int fd, int flags, int speed, struct termios *ti)
+{
+	char patch_name[NAME_MAX], nvm_name[NAME_MAX];
+	int err;
+
+	printf("qca_rome_init\n");
+
+	/* Change baudrate from 115.2kbps to High Speed UART */
+	err = qca_set_baudrate(fd, flags, speed, ti, nopatch);
+	if (err < 0)
+		return -1;
+
+	/* Get ROME version information */
+	err = qca_rome_patch_ver_req(fd);
+	if (err < 0 || g_rome_ver == 0) {
+		fprintf(stderr, "Fail to get ROME version 0x%x\n", err);
+		return -1;
+	}
+
+	printf("ROME controller version 0x%08x \n", g_rome_ver);
+
+	snprintf(patch_name, NAME_MAX, "%s/rampatch_%08x.bin",
+		 FW_PATH_ROME, g_rome_ver);
+	snprintf(nvm_name, NAME_MAX, "%s/nvm_%08x.bin",
+		 FW_PATH_ROME, g_rome_ver);
+
+	if (nopatch) {
+		printf("patch sequences\t\tSKIP\n");
+		return 0;
+	}
+
+	/* Download rampatch file */
+	err = qca_download_tlv_file(fd, TLV_TYPE_PATCH, patch_name);
+	if (err < 0)
+		return -1;
+
+	/* Download NVM file */
+	err = qca_download_tlv_file(fd, TLV_TYPE_NVM, nvm_name);
+	if (err < 0)
+		return -1;
+
+	/* Perform HCI reset */
+	err = qca_reset_req(fd);
+	if (err < 0)
+		return -1;
+
+	return 0;
+}
+/*
+ * Atheros AR300x specific initialization and configuration file
+ * download
+ */
+int ath3k_init(int fd, int flags, int speed, int init_speed, char *bdaddr,
+	       struct termios *ti)
+{
+	int r;
+	int err = 0;
+	struct timespec tm = { 0, 500000 };
+	unsigned char cmd[MAX_CMD_LEN], rsp[MAX_EVENT_SIZE];
+	unsigned char *ptr = cmd + 1;
+	hci_command_hdr *ch = (void *)ptr;
+
+	UNUSED(flags);
+	cmd[0] = 0x01; //HCI_COMMAND_PKT;
+
+	/* set both controller and host baud rate to maximum possible value */
+	printf("ath3k_init_set_baud, speed=%d, init_speed=%d\n", speed, init_speed);
+	err = set_cntrlr_baud(fd, speed);
+	if (err < 0)
+		return err;
+	printf("set_cntrlr_baud\t\tsuccess\n");
+
+	err = set_speed(fd, ti, speed);
+	if (err < 0) {
+		perror("Can't set required baud rate");
+		return err;
+	}
+	printf("set_speed %d\tdone\n", speed);
+
+	/* Download PS and patch */
+	r = ath_ps_download(fd);
+	if (r < 0) {
+		perror("Failed to Download configuration");
+		err = -ETIMEDOUT;
+		goto failed;
+	}
+
+	/* Write BDADDR */
+	if (bdaddr) {
+		ch->opcode = htobs(HCI_OPCODE_PACK(HCI_VENDOR_CMD_OGF,
+					HCI_PS_CMD_OCF));
+		ch->plen = 10;
+		ptr += HCI_COMMAND_HEADER_SIZE;
+
+		ptr[0] = 0x01;
+		ptr[1] = 0x01;
+		ptr[2] = 0x00;
+		ptr[3] = 0x06;
+		str2ba(bdaddr, (bdaddr_t *)(ptr + 4));
+
+		if (write(fd, cmd, WRITE_BDADDR_CMD_LEN) !=
+				WRITE_BDADDR_CMD_LEN) {
+			perror("Failed to write BD_ADDR command\n");
+			err = -ETIMEDOUT;
+			goto failed;
+		}
+
+		if (read_hci_event(fd, rsp, sizeof(rsp)) < 0) {
+			perror("Failed to set BD_ADDR\n");
+			err = -ETIMEDOUT;
+			goto failed;
+		}
+	}
+
+	/* Send HCI Reset */
+	cmd[1] = 0x03; // OCF_RESET
+	cmd[2] = 0x0C;
+	cmd[3] = 0x00;
+
+	r = write(fd, cmd, 4);
+	if (r != 4) {
+		err = -ETIMEDOUT;
+		goto failed;
+	}
+
+	nanosleep(&tm, NULL);
+	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0) {
+		err = -ETIMEDOUT;
+		goto failed;
+	}
+
+	err = set_cntrlr_baud(fd, speed);
+	if (err < 0)
+		return err;
+
+failed:
+	if (err < 0) {
+		set_cntrlr_baud(fd, init_speed);
+		set_speed(fd, ti, init_speed);
+	}
+	//sleep(2);
+	return err;
+}
+
+/* Initialize UART driver */
+static int init_uart(char *dev, int user_specified_speed)
+{
+	struct termios ti;
+	int fd, err;
+	unsigned long flags = 0;
+
+	fd = open(dev, O_RDWR | O_NOCTTY);
+	if (fd < 0) {
+		perror("Can't open serial port");
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (tcgetattr(fd, &ti) < 0) {
+		perror("Can't get port settings");
+		return -1;
+	}
+
+	cfmakeraw(&ti);
+
+	ti.c_cflag |= CLOCAL;
+	ti.c_cflag |= CRTSCTS;
+
+	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+		perror("Can't set port settings");
+		close(fd);
+		return -1;
+	}
+
+	/* Set initial baudrate */
+	if (set_speed(fd, &ti, 115200) < 0) {
+		perror("Can't set initial baud rate");
+		close(fd);
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+
+	if (ioctl(fd, TIOCMGET, &flags) < 0) {
+		perror("TIOCMGET failed in init\n");
+		close(fd);
+		return -1;
+	}
+
+	flags |= TIOCM_RTS;
+	if (ioctl(fd, TIOCMSET, &flags) < 0) {
+		perror("TIOCMSET failed in init: HW Flow-on error\n");
+		close(fd);
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+
+	/*char cmd[5], rsp[PS_EVENT_LEN];
+	int r, err;
+	struct timespec tm = { 0, 5000000 };
+
+	// Send reset to poke SOC
+	cmd[1] = 0x3F; // OCF_RESET
+	cmd[2] = 0x1E;
+	cmd[3] = 0x00;
+	r = write(fd, cmd, 4);
+	nanosleep(&tm, NULL);
+	if (r != 4) {
+		err = -ETIMEDOUT;
+		return -1;
+	}
+*/
+	//sleep(1);
+
+//	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0) {
+//		err = -ETIMEDOUT;
+		// Firmware not ready, reconfig baud & download firmware
+	if (!strcasecmp(soc_type, "rome")) {
+		err = qca_rome_init(fd, flags, user_specified_speed, &ti);
+		if (err < 0) {
+			close(fd);
+			return -1;
+		}
+		printf("\n==== The initialization of QCA61x4 is succeed ====\n\n");
+	} else if (!strcasecmp(soc_type, "300x")) {
+		err = ath3k_init(fd, flags, user_specified_speed,115200, NULL, &ti);
+		if (err < 0) {
+			close(fd);
+			return -1;
+		}
+		printf("\n==== The initialization of ATH3K is succeed ====\n\n");
+	}
+
+	return fd;
+}
+
+void disable_soc_logging(int fd)
+{
+	int iRet;
+	UCHAR resultBuf[MAX_EVENT_SIZE];
+	if (!strcasecmp(soc_type, "smd")){
+		    UCHAR buf[5] = {(unsigned char)0x10, (unsigned char)0x02,( unsigned char)0x0,(unsigned char) 0x0,( unsigned char)0x01 };
+			iRet = hci_send_cmd( fd, HCI_VENDOR_CMD_OGF, 0x17, 5, buf);
+		}
+	else if (!strcasecmp(soc_type, "cherokee")){
+			UCHAR buf[2] = {(unsigned char)0x14, (unsigned char)0x0};
+			iRet = hci_send_cmd( fd, HCI_VENDOR_CMD_OGF, 0x17, 2, buf);
+		}
+	else
+		return;
+	printf("sending command to disable logging\n");
+
+	memset(&resultBuf,0,MAX_EVENT_SIZE);
+	if (!iRet)
+		   read_incoming_events( fd, resultBuf, 0);
+	printf("\n");
+}
+
+int main(int argc, char *argv[])
+{
+	int opt, i, min_para = 2;
+	static int fd = -1;
+
+	while ((opt=getopt_long(argc, argv, "hs:n", main_options, NULL)) != -1) {
+		switch (opt) {
+			case 'h':
+				usage();
+				exit(0);
+			case 's':
+				strcpy(soc_type, optarg);
+				continue;
+			case 'i':
+				nopatch = false;
+				continue;
+		}
+	}
+
+#ifdef ANDROID
+	property_get("ro.qualcomm.bt.hci_transport", prop, NULL);
+	property_get("qcom.bluetooth.soc", soc_type, NULL);
+#endif
+
+	if((!strcasecmp(soc_type, "rome")) || (!strcasecmp(soc_type, "cherokee")))
+		is_qca_transport_uart = true;
+
+	if(is_qca_transport_uart)  min_para = 1;
+
+	argc -= optind;
+	argv += optind;
+	optind = 0;
+
+	if (argc < min_para) {
+		usage();
+		exit(0);
+	}
+
+	if (!strcasecmp(prop, "smd")) {
+		printf("SOC is WCN\n");
+
+		fd = wcn_init_smd(argv[optind]);
+	        // skip interface entry
+	        argv += 1;
+	        argc -= 1;
+	} else if (is_qca_transport_uart){
+		if(!strcasecmp(soc_type, "rome"))
+			printf("SOC is ROME\n");
+		else
+			printf("SOC is CHEROKEE\n");
+#ifdef ANDROID
+		fd = connect_to_wds_server();
+		if(fd < 0) {
+			perror("connection to WDS server failed");
+			exit(1);
+		}
+#else
+		if ((fd = init_uart(argv[optind], ((atoi(argv[optind+1]) != 115200) ? 3000000 : atoi(argv[optind+1])) )) < 0) {
+			perror("Device is not available");
+			exit(1);
+		}
+
+		//Move to next argv if <speed> inputed.
+		if (atoi(argv[optind+1]) >= 115200)
+		{
+			argv +=1;
+			argc -=1;
+		}
+#endif
+	} else {
+		strcpy(soc_type, "300x");
+		printf("SOC is AR300x\n");
+
+		//btconfig [options] <tty> <speed> <command> [command parameters]
+		//<speed> uses default 115200 if no buadrate inputed. Should no need to have Max speed detection.
+		if ((fd = init_uart(argv[optind], ((atoi(argv[optind+1]) < 115200) ? 115200 : atoi(argv[optind+1])) )) < 0) {
+			perror("Device is not available");
+			exit(1);
+		}
+
+		//Move to next argv if <speed> inputed.
+		if (atoi(argv[optind+1]) >= 115200)
+		{
+			argv +=1;
+			argc -=1;
+		}
+	}
+
+	disable_soc_logging(fd);
+
+	for (i = 0; command[i].cmd; i++) {
+		if (strcmp(command[i].cmd, argv[0]))
+			continue;
+		command[i].func(fd, argc, argv);
+		break;
+	}
+	close(fd);
+	return 0;
+}
+
+
+// MAster BLaster fucntions
+tMasterBlasterField MasterBlasterMenu[] =
+{
+	{"ContRxMode", "n", "toggle coNtinuous Rx", 0,                     ContRxModeOption,   SetMasterBlasterContRxMode},
+	{"ContTxMode", "c", "toggle Continuous Tx", 0,                     ContTxModeOption,   SetMasterBlasterContTxMode},
+	{"LERxMode",   "q", "toggle LE Rx mode",    0,                     ContRxModeOption,   SetMasterBlasterLERxMode},
+	{"LETxMode",   "w", "toggle LE Tx mode",    0,                     ContTxModeOption,   SetMasterBlasterLETxMode},
+	{"LETxPktPayload", "y", "set LE Tx packet payload", 0,             LETxPktPayloadOption, SetMasterBlasterLETxPktPayload},
+	{"ContTxType", "u", "toggle continUous Tx Type", Cont_Tx_Raw_1MHz, ContTxTypeOption,   SetMasterBlasterContTxType},
+	{"TestMode",   "m", "toggle test Mode",     eBRM_TestMode_TX_1010, TestModeOption,     SetMasterBlasterTestMode},
+	{"HopMode",    "h", "toggle Hop mode",      0,                     HopModeOption,      SetMasterBlasterHopMode},
+	{"TxFreq",     "t", "set Tx freq",          39,                    NULL,               SetMasterBlasterTxFreq},
+	{"RxFreq",     "r", "set Rx freq",          39,                    NULL,               SetMasterBlasterRxFreq},
+	{"PacketType", "p", "toggle Packet type",   TxTest_PktType_DH1,    PacketTypeOption,   SetMasterBlasterPacketType},
+	{"DataLen",    "l", "set data Length",      15,                    NULL,               SetMasterBlasterDataLen},
+	{"Power",      "o", "toggle pOwer",         9,                     NULL,               SetMasterBlasterPower},
+	{"BdAddr",     "a", "set bdAddr",           0,                     NULL,               SetMasterBlasterBdAddr},
+	{"SetBERType", "k", "set BER type",         eBRM_BERMode_ALL_DATA, BERPacketTypeOption,SetMasterBlasterBERType},
+	{"GetBER",     "g", "get BER type",         0,                     NULL,               SetMasterBlasterNothing},
+	{"EnableRxTest", "d", "Enable rx test mode", 0,                    NULL,               SetMasterBlasterNothing},
+	{"EnableTxTest", "e", "Enable tx test mode", 0,                    NULL,               SetMasterBlasterNothing},
+	{"EnableTest", "j", "Start test mode",      0,                     NULL,               SetMasterBlasterNothing},
+	{"StopTest",   "s", "Stop test mode",       0,                     NULL,               SetMasterBlasterNothing},
+	{"Exit",       "x", "eXit",                 0,                     NULL,               SetMasterBlasterNothing},
+	{"ExitWithoutReset", "b", "Exit without reset", 0,                 NULL,               SetMasterBlasterNothing},
+};
+
+tPsSysCfgTransmitPowerControlTable  TpcTable;
+
+//----------------------------------------------------------------------------
+
+void InitMasterBlaster (tBRM_Control_packet *MasterBlaster, bdaddr_t *BdAddr, UCHAR *SkipRxSlot)
+{
+	*SkipRxSlot = 0x01;
+	MasterBlaster->testCtrl.Mode     = MasterBlasterMenu[TM].Default;
+	MasterBlaster->testCtrl.HopMode  = MasterBlasterMenu[HM].Default;
+	MasterBlaster->testCtrl.Packet   = MasterBlasterMenu[PT].Default;
+	MasterBlaster->testCtrl.TxFreq   = MasterBlasterMenu[TF].Default;
+	MasterBlaster->testCtrl.RxFreq   = MasterBlasterMenu[RF].Default;
+	MasterBlaster->testCtrl.Power    = MasterBlasterMenu[PO].Default;
+	MasterBlaster->testCtrl.DataLen  = MasterBlasterMenu[DL].Default;
+	MasterBlaster->ContTxMode        = MasterBlasterMenu[CT].Default;
+	MasterBlaster->ContTxType        = MasterBlasterMenu[CX].Default;
+	MasterBlaster->ContRxMode        = MasterBlasterMenu[CR].Default;
+	MasterBlaster->BERType           = MasterBlasterMenu[SB].Default;
+	MasterBlaster->LERxMode          = MasterBlasterMenu[LR].Default;
+	MasterBlaster->LETxMode          = MasterBlasterMenu[LT].Default;
+	MasterBlaster->LETxParms.PktPayload = MasterBlasterMenu[LTM].Default;
+	memcpy(MasterBlaster->bdaddr,&BdAddr->b[0],6);
+
+	TpcTable.NumOfEntries = 0;
+}
+
+//----------------------------------------------------------------------------
+
+int CheckField (tBRM_Control_packet MasterBlaster, char *FieldAlias)
+{
+	if (((!strncmp(FieldAlias,MasterBlasterMenu[HM].Alias,1)) && MasterBlaster.ContTxMode) ||
+			(((!strncmp(FieldAlias,MasterBlasterMenu[TF].Alias,1)) || (!strncmp(FieldAlias,MasterBlasterMenu[RF].Alias,1))) && MasterBlaster.testCtrl.HopMode == 1) ||
+			((!strncmp(FieldAlias,MasterBlasterMenu[CX].Alias,1)) && MasterBlaster.ContTxMode == 0))
+	{
+		return INVALID_MASTERBLASTER_FIELD;
+	}
+	unsigned int i;
+	for (i = 0; i < sizeof(MasterBlasterMenu)/sizeof(tMasterBlasterField); ++i)
+	{
+		if (!strncmp(FieldAlias,MasterBlasterMenu[i].Alias,1))
+		{
+			return i;
+		}
+	}
+
+	return INVALID_MASTERBLASTER_FIELD;
+}
+
+//----------------------------------------------------------------------------
+
+int GetTestModeOptionIndex (int Value)
+{
+	unsigned int i;
+	for (i = 0; i < sizeof(TestModeOption)/sizeof(tMasterBlasterOption); ++i)
+	{
+		if (Value == TestModeOption[i].Value)
+		{
+			return i;
+		}
+	}
+	// assert (0);
+	return -1;
+}
+
+//----------------------------------------------------------------------------
+
+int GetPacketTypeOptionIndex (int Value)
+{
+	unsigned int i;
+	for (i = 0; i < sizeof(PacketTypeOption)/sizeof(tMasterBlasterOption); ++i)
+	{
+		if (Value == PacketTypeOption[i].Value)
+		{
+			return i;
+		}
+	}
+	//assert (0);
+	return -1;
+}
+
+//----------------------------------------------------------------------------
+
+void PrintMasterBlasterMenu(tBRM_Control_packet *MasterBlaster)
+{
+	unsigned int i;
+	printf ("\n---------- Master Blaster Mode ----------\n\n");
+	for (i = 0; i < sizeof(MasterBlasterMenu)/sizeof(tMasterBlasterField); ++i)
+	{
+		if (((i == HM || i == RF) && (MasterBlaster->ContTxMode == ENABLE)) ||
+				((i == TF || i == RF) && (MasterBlaster->testCtrl.HopMode == 1)) ||
+				((i == CX) && (MasterBlaster->ContTxMode == DISABLE)) ||
+				((i == CX || i == HM || i == TF || i == PT || i == DL || i == PO || i == BA) &&
+				 (MasterBlaster->ContRxMode == ENABLE)))
+		{
+			continue;
+		}
+
+		printf ("\t%s - %s\n", MasterBlasterMenu[i].Alias, MasterBlasterMenu[i].Usage);
+	}
+	printf ("\n-----------------------------------------\n\n");
+
+	char BdAddr[18];
+	//strcpy(MasterBlaster.bdaddr,BdAddr);
+
+	printf ("ContRxMode: %s\n", ContRxModeOption[MasterBlaster->ContRxMode].Name);
+	printf ("ContTxMode: %s\n", ContTxModeOption[MasterBlaster->ContTxMode].Name);
+	printf ("LERxMode: %s\n", ContTxModeOption[MasterBlaster->LERxMode].Name);
+	printf ("LETxMode: %s\n", ContTxModeOption[MasterBlaster->LETxMode].Name);
+
+	// LE Rx mode
+	if (MasterBlaster->LERxMode == ENABLE)
+	{
+		if (MasterBlaster->testCtrl.RxFreq > MB_MAX_FREQUENCY_LE)
+			MasterBlaster->testCtrl.RxFreq = MB_MAX_FREQUENCY_LE;
+		printf("RxFreq:     %d\n", MasterBlaster->testCtrl.RxFreq);
+	}
+	// LE Tx mode
+	if (MasterBlaster->LETxMode == ENABLE)
+	{
+		if (MasterBlaster->testCtrl.DataLen > MB_MAX_DATALEN_LE)
+			MasterBlaster->testCtrl.DataLen = MB_MAX_DATALEN_LE;
+		printf("TxFreq:     %d\n", MasterBlaster->testCtrl.TxFreq);
+		printf("DataLen:    %d\n", MasterBlaster->testCtrl.DataLen);
+		printf("PktPayload: %s\n", LETxPktPayloadOption[MasterBlaster->LETxParms.PktPayload].Name);
+	}
+	// Continous Rx mode
+	else if (MasterBlaster->ContRxMode == ENABLE)
+	{
+		printf ("BER Type: %s\n",BERPacketTypeOption[MasterBlaster->BERType].Name);
+		printf ("RxFreq:     %d\n", MasterBlaster->testCtrl.RxFreq);
+	}
+	// Continous Tx mode and Tx test mode
+	else
+	{
+		printf ("BER Type: %s\n",BERPacketTypeOption[MasterBlaster->BERType].Name);
+		if (MasterBlaster->ContTxMode == ENABLE)
+		{
+			printf ("ContTxType: %s\n", ContTxTypeOption[MasterBlaster->ContTxType].Name);
+			if (ContTxTypeOption[MasterBlaster->ContTxType].Value != CW_Single_Tone){
+				int index = GetTestModeOptionIndex(MasterBlaster->testCtrl.Mode);
+				if(index < 0)   printf("Unable to find the matching Test Mode! %d \n", MasterBlaster->testCtrl.Mode);
+				else printf ("TestMode:   %s\n", TestModeOption[index].Name);
+			}
+			printf ("TxFreq:     %d\n", MasterBlaster->testCtrl.TxFreq);
+		}
+		else
+		{
+			int index = GetTestModeOptionIndex(MasterBlaster->testCtrl.Mode);
+			if(index < 0)   printf("Unable to find the matching Test Mode! %d \n", MasterBlaster->testCtrl.Mode);
+			else printf ("TestMode:   %s\n", TestModeOption[index].Name);
+			printf ("HopMode:    %s\n", HopModeOption[MasterBlaster->testCtrl.HopMode].Name);
+
+			if (MasterBlaster->testCtrl.HopMode == 0)
+			{
+				printf ("TxFreq:     %d\n", MasterBlaster->testCtrl.TxFreq);
+				printf ("RxFreq:     %d\n", MasterBlaster->testCtrl.RxFreq);
+			}
+		}
+		if (TpcTable.NumOfEntries > 0)
+		{
+			printf ("Power:      Step = %d/%d; Level = %d dBm\n", MasterBlaster->testCtrl.Power+1,
+					TpcTable.NumOfEntries, TpcTable.t[MasterBlaster->testCtrl.Power].TxPowerLevel);
+		}
+		else
+		{
+			printf ("Power:      Step = Max; Level = N/A\n");
+		}
+		if ((MasterBlaster->ContTxMode == ENABLE && ContTxTypeOption[MasterBlaster->ContTxType].Value == Cont_Tx_Regular) ||
+				(MasterBlaster->ContTxMode == DISABLE))
+		{
+			int index = GetPacketTypeOptionIndex(MasterBlaster->testCtrl.Packet);
+			if(index < 0){
+				printf("Unable to find the matching Packet Type Option Index! %d \n", MasterBlaster->testCtrl.Packet);
+				return;
+			}
+			printf ("PacketType: %s\n", PacketTypeOption[index].Name);
+			printf ("DataLen:    %d\n", MasterBlaster->testCtrl.DataLen);
+		}
+		if (ContTxTypeOption[MasterBlaster->ContTxType].Value != CW_Single_Tone) {//for single tone, no bdaddr
+			ba2str((const bdaddr_t *)MasterBlaster->bdaddr, BdAddr);
+			printf ("BdAddr:     0x%s\n\n",BdAddr);
+		}
+	}
+	printf ("\nmb>\n");
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterTestMode(tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = (int)MasterBlaster->testCtrl.Mode;
+
+	if (ToggleOption (&Value, Option, TestModeOption,
+				sizeof(TestModeOption)/sizeof(tMasterBlasterOption), TM,1))
+	{
+		MasterBlaster->testCtrl.Mode = (UCHAR)Value;
+		// Enable continous Tx should disable continous Rx
+		MasterBlaster->ContRxMode = DISABLE;
+		MasterBlaster->ContTxMode = DISABLE;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterHopMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = (int)MasterBlaster->testCtrl.HopMode;
+
+	if (ToggleOption (&Value, Option, HopModeOption,
+				sizeof(HopModeOption)/sizeof(tMasterBlasterOption), HM,1))
+	{
+		MasterBlaster->testCtrl.HopMode = (UCHAR)Value;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterTxFreq (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	//char Buffer[20];
+	tMasterBlasterOption NewValue;
+	int LoopCount = 4;
+	int Value = (int)MasterBlaster->testCtrl.TxFreq;
+	int MaxFreq = LEMode ? MB_MAX_FREQUENCY_LE : MB_MAX_FREQUENCY;
+	int MinFreq = LEMode ? MB_MIN_FREQUENCY_LE : MB_MIN_FREQUENCY;
+
+	UNUSED(Option);
+	while (--LoopCount > 0)
+	{
+		printf ("\n   Enter Tx frequency (%d..%d): ", MinFreq, MaxFreq);
+		scanf("%d",&NewValue.Value);
+		//    fgets(NewValue,3,stdin);
+		if (MinMaxOption (&Value, &NewValue, MinFreq, MaxFreq))
+		{
+			MasterBlaster->testCtrl.TxFreq = (UCHAR)Value;
+			return TRUE;
+		}
+		else if (LoopCount > 1)
+		{
+			printf ("\n   ERROR ---> Invalid Tx frequency.\n");
+		}
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterRxFreq (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	tMasterBlasterOption NewValue;
+	int LoopCount = 4;
+	int Value = (int)MasterBlaster->testCtrl.RxFreq;
+	int MaxFreq = LEMode ? MB_MAX_FREQUENCY_LE : MB_MAX_FREQUENCY;
+	int MinFreq = LEMode ? MB_MIN_FREQUENCY_LE : MB_MIN_FREQUENCY;
+
+	UNUSED(Option);
+	while (--LoopCount > 0)
+	{
+		printf ("\n   Enter Rx frequency (%d..%d): ", MinFreq, MaxFreq);
+		scanf("%d",&NewValue.Value);
+		if (MinMaxOption (&Value, &NewValue, MinFreq, MaxFreq))
+		{
+			MasterBlaster->testCtrl.RxFreq = (UCHAR)Value;
+			return TRUE;
+		}
+		else if (LoopCount > 1)
+		{
+			printf ("\n   ERROR ---> Invalid Rx frequency.\n");
+		}
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterPacketType (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = (int)MasterBlaster->testCtrl.Packet;
+
+	if (ToggleOption (&Value, Option, PacketTypeOption,
+				sizeof(PacketTypeOption)/sizeof(tMasterBlasterOption), PT,1))
+	{
+		MasterBlaster->testCtrl.Packet = (UCHAR)Value;
+		int index = GetPacketTypeOptionIndex(Value);
+		if(index<0){
+			printf("Fail to Get Packet Type Option Index Value(%d) Index(%d)\n", Value, index);
+			return FALSE;
+		}
+		MasterBlaster->testCtrl.DataLen = MaxDataLenOption[index];
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterDataLen (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	tMasterBlasterOption NewValue;
+	int LoopCount = 4;
+	int MaxLen = LEMode ? MB_MAX_DATALEN_LE : MB_MAX_DATALEN;
+	int MinLen = LEMode ? MB_MIN_DATALEN_LE : MB_MIN_DATALEN;
+
+	UNUSED(Option);
+	while (--LoopCount > 0)
+	{
+		printf ("\n   Enter data length (%d..%d): ", MinLen, MaxLen);
+		scanf("%d",&NewValue.Value);
+		if (MinMaxOption (&MasterBlaster->testCtrl.DataLen, &NewValue, MinLen, MaxLen))
+		{
+			return TRUE;
+		}
+		else if (LoopCount > 1)
+		{
+			printf ("\n   ERROR ---> Invalid data length.\n");
+		}
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterPower (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	char *opt = (char*)Option;
+
+	if (TpcTable.NumOfEntries > MAX_TRANSMIT_POWER_CONTROL_ENTRIES)
+	{
+		printf ("\nNumber of entries in TPC table exceeds the limit.\n");
+		sleep(3);
+		return TRUE;
+	}
+
+	if (TpcTable.NumOfEntries == 0)
+	{
+		printf ("\nThere is no entry in TPC table.\n");
+		sleep(3);
+		return TRUE;
+	}
+
+	int Value = (int)MasterBlaster->testCtrl.Power;
+
+	if (ToggleMinMaxOption (&Value, opt, PO, 0, TpcTable.NumOfEntries-1,1))
+	{
+		MasterBlaster->testCtrl.Power = (UCHAR)Value;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterBdAddr (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	char Buffer[20];
+	bdaddr_t bdaddr;
+	UNUSED(Option);
+	printf ("\n Enter BdAddr: ");
+	//   gets(Buffer);
+	scanf("%s",Buffer);
+	str2ba(Buffer,&bdaddr);
+	memcpy(MasterBlaster->bdaddr,bdaddr.b,6);
+	return TRUE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterContTxMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = (int)MasterBlaster->ContTxMode;
+
+	if (ToggleOption (&Value, Option, ContTxModeOption,
+				sizeof(ContTxModeOption)/sizeof(tMasterBlasterOption), CT,1))
+	{
+		MasterBlaster->ContTxMode = (UCHAR)Value;
+		if (MasterBlaster->ContTxMode == ENABLE)
+		{
+			// Enable continous Tx should disable continous Rx
+			MasterBlaster->ContRxMode = DISABLE;
+			MasterBlaster->LERxMode = DISABLE;
+			MasterBlaster->LETxMode = DISABLE;
+			LEMode = FALSE;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterContTxType (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = (int)MasterBlaster->ContTxType;
+
+	if (ToggleOption (&Value, Option, ContTxTypeOption,
+				sizeof(ContTxTypeOption)/sizeof(tMasterBlasterOption), CX,1))
+	{
+		MasterBlaster->ContTxType = (UCHAR)Value;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterLERxMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = MasterBlaster->LERxMode;
+
+	if (ToggleOption (&Value, Option, ContRxModeOption,
+				sizeof(ContRxModeOption)/sizeof(tMasterBlasterOption), LR, 1))
+	{
+		MasterBlaster->LERxMode = (UCHAR)Value;
+		if (MasterBlaster->LERxMode == ENABLE)
+		{
+			/* Enable continous Tx should disable other modes */
+			MasterBlaster->LETxMode = DISABLE;
+			MasterBlaster->ContTxMode = DISABLE;
+			MasterBlaster->ContRxMode = DISABLE;
+			if (MasterBlaster->testCtrl.RxFreq > 39)
+			{
+				MasterBlaster->testCtrl.RxFreq = 39;
+			}
+			LEMode = TRUE;
+		}
+		else
+		{
+			LEMode = FALSE;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterLETxMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = MasterBlaster->LETxMode;
+
+	if (ToggleOption (&Value, Option, ContTxModeOption,
+				sizeof(ContTxModeOption)/sizeof(tMasterBlasterOption), LT, 1))
+	{
+		MasterBlaster->LETxMode = (UCHAR)Value;
+		if (MasterBlaster->LETxMode == ENABLE)
+		{
+			/* Enable continous Tx should disable other modes */
+			MasterBlaster->LERxMode = DISABLE;
+			MasterBlaster->ContTxMode = DISABLE;
+			MasterBlaster->ContRxMode = DISABLE;
+			if (MasterBlaster->testCtrl.TxFreq > MB_MAX_FREQUENCY_LE)
+			{
+				MasterBlaster->testCtrl.TxFreq = 39;
+			}
+			LEMode = TRUE;
+		}
+		else
+		{
+			LEMode = FALSE;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterLETxPktPayload(tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = MasterBlaster->LETxParms.PktPayload;
+
+	if (ToggleOption(&Value, Option, LETxPktPayloadOption,
+				sizeof(LETxPktPayloadOption)/sizeof(tMasterBlasterOption), LTM, 1))
+	{
+		MasterBlaster->LETxParms.PktPayload = (UCHAR)Value;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterContRxMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = (int)MasterBlaster->ContRxMode;
+	printf("\n N op\n");
+	if (ToggleOption (&Value, Option, ContRxModeOption,
+				sizeof(ContRxModeOption)/sizeof(tMasterBlasterOption), CR,1))
+	{
+		MasterBlaster->ContRxMode = (UCHAR)Value;
+		if (MasterBlaster->ContRxMode == ENABLE)
+		{
+			// Enable continous Tx should disable continous Rx
+			MasterBlaster->ContTxMode = DISABLE;
+			MasterBlaster->LERxMode = DISABLE;
+			MasterBlaster->LETxMode = DISABLE;
+			LEMode = FALSE;
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+int SetMasterBlasterBERType (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	int Value = (int)MasterBlaster->BERType;
+	if (ToggleOption (&Value, Option, BERPacketTypeOption,
+				sizeof(BERPacketTypeOption)/sizeof(tMasterBlasterOption), SB, 1))
+	{
+		MasterBlaster->BERType = (UCHAR)Value;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int SetMasterBlasterNothing (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option)
+{
+	UNUSED(MasterBlaster);
+	UNUSED(Option);
+
+	return TRUE;
+}
+
+//----------------------------------------------------------------------------
+
+int ToggleOption (int *Value, tMasterBlasterOption *Option, tMasterBlasterOption *OptionArray,
+		int Size, int FieldID, int Step)
+{
+	char Opt = Option->Name[0];
+
+	int Backward = ((Opt - 'A' + 'a') == MasterBlasterMenu[FieldID].Alias[0]);
+	int i;
+	for (i = 0; i < Size; ++i)
+	{
+		if (*Value == OptionArray[i].Value)
+		{
+			if (Backward)
+			{
+				i = ((i - Step) < 0) ? (Size - Step + i) : (i - Step);
+			}
+			else
+			{
+				i = (i + Step) % Size;
+			}
+			*Value = OptionArray[i].Value;
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+//----------------------------------------------------------------------------
+
+int MinMaxOption (int *Value,  tMasterBlasterOption *Option, int Min, int Max)
+{
+	int NewValue = Option->Value;
+
+	if (NewValue < Min || NewValue > Max)
+	{
+		return FALSE;
+	}
+	*Value = NewValue;
+	return TRUE;
+}
+
+//----------------------------------------------------------------------------
+
+int ToggleMinMaxOption (int *Value, char *Option, int FieldID, int Min, int Max, int Step)
+{
+	char Opt = *Option;
+	int Backward = ((Opt - 'A' + 'a') == MasterBlasterMenu[FieldID].Alias[0]);
+
+	if (Backward)
+	{
+		*Value = ((*Value - Step) < Min) ? (Max + 1 - (Step - (*Value - Min))) : (*Value - Step);
+	}
+	else
+	{
+		*Value = ((*Value + Step) > Max) ? (Min + (Step - (Max + 1 - *Value))) : (*Value + Step);
+	}
+	return TRUE;
+
+}
+
+//----------------------------------------------------------------------------
+
diff --git a/btconfig/btconfig.h b/btconfig/btconfig.h
new file mode 100644
index 0000000..52e2621
--- /dev/null
+++ b/btconfig/btconfig.h
@@ -0,0 +1,445 @@
+/*
+ * Copyright (c) 2013,2016 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of The Linux Foundation nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _BTCONFIG_H_
+#define _BTCONFIG_H_
+#define VERSION		"2.14"
+//#define DUMP_DEBUG 1
+//#define DEBUG 1 // @@ boyi @@
+#ifdef ANDROID
+#define FW_PATH_AR "/etc/firmware/ar3k/"
+#else
+#define FW_PATH_AR "/lib/firmware/ar3k/"
+#endif
+#define BDADDR_FILE "ar3kbdaddr.pst"
+#define PS_ASIC_FILE                    "PS_ASIC.pst"
+#define PS_FPGA_FILE                    "PS_FPGA.pst"
+#define PATCH_FILE        "RamPatch.txt"
+#define ROM_DEV_TYPE      0xdeadc0de
+#define FPGA_ROM_VERSION  0x99999999
+
+#define PS_RAM_SIZE 2048
+#define TRUE	1
+#define FALSE	0
+#define LINE_SIZE_MAX		3000
+#define PS_RESET		2
+
+#define PS_WRITE		1
+#define HCI_PS_CMD_HDR_LEN 7
+
+#define PS_RESET_PARAM_LEN 6
+#define HCI_MAX_CMD_SIZE   260
+#define PS_RESET_CMD_LEN   (HCI_PS_CMD_HDR_LEN + PS_RESET_PARAM_LEN)
+
+#define PS_ID_MASK         0xFF
+
+#define HCI_VENDOR_CMD_OGF    0x3F
+#define HCI_PS_CMD_OCF        0x0B
+#define HCI_CHG_BAUD_CMD_OCF  0x0C
+#define HCI_CMD_OGF_HOST_CTL  0x03
+#define HCI_CMD_OGF_INFO_PARAM 0x04
+
+#define HCI_CMD_OCF_RESET     0x0003
+#define HCI_CMD_OCF_READ_BD_ADDR  0x0009
+
+#define WRITE_BDADDR_CMD_LEN 14
+#define WRITE_BAUD_CMD_LEN   6
+#define MAX_CMD_LEN          WRITE_BDADDR_CMD_LEN
+
+#define BD_ADDR_SIZE		6
+#define BD_ADDR_PSTAG		1
+#define PS_READ			0
+#define PS_READ_RAW		3
+
+#define WRITE_PATCH		8
+#define ENABLE_PATCH		11
+
+
+#define PS_WRITE_RAW		4
+#define PS_GET_LENGTH		5
+#define PS_SET_ACCESS_MODE	6
+#define PS_SET_ACCESS_PRIORITY	7
+#define PS_WRITE		1
+#define PS_DYNMEM_OVERRIDE	10
+#define PS_VERIFY_CRC		9
+#define CHANGE_BDADDR		15
+#define PS_COMMAND_HEADER	4
+#define HCI_EVENT_SIZE		7
+#define PS_RETRY_COUNT		3
+#define RAM_PS_REGION		(1<<0)
+#define RAM_PATCH_REGION	(1<<1)
+#define RAM_DYN_MEM_REGION	(1<<2)
+#define RAMPS_MAX_PS_DATA_PER_TAG       244
+#define RAMPS_MAX_PS_TAGS_PER_FILE      50
+#define PSTAG_RF_TEST_BLOCK_START      (300)
+#define PSTAG_SYSTEM_BLOCK_START	(1)
+#define BT_SOC_INIT_TOOL_START_MAGIC_WORD 0xB1B1
+#define PSTAG_RF_PARAM_TABLE0        (PSTAG_RF_TEST_BLOCK_START+0)
+#define PSTAG_SYSCFG_PARAM_TABLE0    (PSTAG_SYSTEM_BLOCK_START+18)
+#define PATCH_MAX_LEN                     20000
+#define DYN_MEM_MAX_LEN                   40
+#define SKIP_BLANKS(str) while (*str == ' ') str++
+#define MAX_RADIO_CFG_TABLE_SIZE	1000
+#define MAX_BYTE_LENGTH    244
+#define DEBUG_EVENT_TYPE_PS		0x02
+#define DEBUG_EVENT_TYPE_MEMBLK		0x03
+#define HCI_EVENT_HEADER_SIZE		0x03
+#define HI_MAGIC_NUMBER	((const unsigned short int) 0xFADE)
+#define HI_VERSION	(0x0300)  //Version 3.0
+#define EEPROM_CONFIG	0x00020C00
+#define FPGA_REGISTER	0x4FFC
+#define MAX_EVENT_SIZE	260
+
+// Vendor specific command OCF
+#define OCF_PS	0x000B
+#define OCF_MEMOP	0x0014
+#define OGF_TEST_CMD	0x06
+#define OCF_HOST_INTEREST	0x000A
+#define OCF_CONT_TX_TESTER	0x0023
+#define OCF_TX_TESTER		0x001B
+#define OCF_SLEEP_MODE		0x0004
+#define OCF_READ_MEMORY		0x0005
+#define OCF_WRITE_MEMORY	0x0006
+#define OCF_DISABLE_TX		0x002D
+#define OCF_TEST_MODE_SEQN_TRACKING	0x0018
+#define OCF_READ_VERSION	0x001E
+#define OCF_AUDIO_CMD		0x0013
+#define OCF_GET_BERTYPE		0x005C
+#define OCF_RX_TESTER		0x005B
+
+#define UCHAR unsigned char
+#define BOOL unsigned short
+#define UINT16 unsigned short int
+#define UINT32 unsigned int
+#define SINT16 signed short int
+#define UINT8 unsigned char
+#define SINT8 signed char
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define htobs(d) (d)
+#define htobl(d) (d)
+#define btohs(d) (d)
+#define btohl(d) (d)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#define htobs(d) bswap_16(d)
+#define htobl(d) bswap_32(d)
+#define btohs(d) bswap_16(d)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define btohl(d) bswap_32(d)
+#else
+#error "Unknown byte order"
+#endif
+#define MAX_TAGS              50
+#define PS_HDR_LEN            4
+#define HCI_VENDOR_CMD_OGF    0x3F
+#define HCI_PS_CMD_OCF        0x0B
+#define PS_EVENT_LEN 100
+#define HCI_EV_SUCCESS        0x00
+
+#define BT_PORT 2398
+
+/* For ROME QCA61x4 chipset */
+#define EVT_VENDOR			(0xFF)
+#define EVT_CMD_COMPLETE		(0x0E)
+#define HCI_COMMAND_PKT			(0x01)
+#define HCI_MAX_EVENT_SIZE		(260)
+
+#define MAX_SIZE_PER_TLV_SEGMENT	(243)
+#define EDL_PATCH_CMD_LEN		(1)
+
+#define EDL_PATCH_VER_REQ_CMD		(0x19)
+#define EDL_PATCH_TLV_REQ_CMD		(0x1E)
+
+#define EDL_CMD_REQ_RES_EVT		(0x00)
+#define EDL_PATCH_VER_RES_EVT		(0x19)
+#define EDL_APP_VER_RES_EVT		(0x02)
+#define EDL_TVL_DNLD_RES_EVT		(0x04)
+#define EDL_CMD_EXE_STATUS_EVT		(0x00)
+#define EDL_SET_BAUDRATE_RSP_EVT	(0x92)
+#define EDL_NVM_ACCESS_CODE_EVT		(0x0B)
+
+#define HCI_PATCH_CMD_OCF		(0)
+
+#define FW_PATH_ROME 			"/lib/firmware/qca"
+#define FLOW_CTL			(0x0001)
+#define BAUDRATE_CHANGE_SUCCESS		(0x01)
+#define CC_MIN_SIZE 			(0x7)
+#define HCI_CMD_SUCCESS			(0x0)
+
+enum qca_bardrate_type {
+	QCA_BAUDRATE_115200 	= 0,
+	QCA_BAUDRATE_57600,
+	QCA_BAUDRATE_38400,
+	QCA_BAUDRATE_19200,
+	QCA_BAUDRATE_9600,
+	QCA_BAUDRATE_230400,
+	QCA_BAUDRATE_250000,
+	QCA_BAUDRATE_460800,
+	QCA_BAUDRATE_500000,
+	QCA_BAUDRATE_720000,
+	QCA_BAUDRATE_921600,
+	QCA_BAUDRATE_1000000,
+	QCA_BAUDRATE_1250000,
+	QCA_BAUDRATE_2000000,
+	QCA_BAUDRATE_3000000,
+	QCA_BAUDRATE_4000000,
+	QCA_BAUDRATE_1600000,
+	QCA_BAUDRATE_3200000,
+	QCA_BAUDRATE_3500000,
+	QCA_BAUDRATE_AUTO 	= 0xFE,
+	QCA_BAUDRATE_RESERVED
+};
+
+enum qca_tlv_type {
+	TLV_TYPE_PATCH = 1,
+	TLV_TYPE_NVM
+};
+
+struct patch_data {
+	int8_t type;
+	int64_t len;
+	uint8_t *data;
+};
+#ifndef ANDROID
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+	const char *s = src;
+	size_t n = size;
+
+	if (n && --n)
+		do {
+			if (!(*dst++ = *src++))
+				break;
+		} while (--n);
+
+	if (!n) {
+		if (size)
+			*dst = '\0';
+		while (*src++);
+	}
+	return src - s - 1;
+}
+#endif //strlcpy is present on the string.h on android but not on the x86. hence use this instead.
+typedef struct tPsTagEntry
+{
+	int   TagId;
+	UCHAR   TagLen;
+	UCHAR    TagData[RAMPS_MAX_PS_DATA_PER_TAG];
+} tPsTagEntry, *tpPsTagEntry;
+
+typedef struct tRamPatch
+{
+	int   Len;
+	UCHAR    Data[PATCH_MAX_LEN];
+} tRamPatch, *ptRamPatch;
+
+typedef struct tRamDynMemOverride
+{
+	int   Len;
+	UCHAR    Data[DYN_MEM_MAX_LEN];
+} tRamDynMemOverride, *ptRamDynMemOverride;
+
+tPsTagEntry PsTagEntry[RAMPS_MAX_PS_TAGS_PER_FILE];
+tRamPatch   RamPatch[50];
+tRamDynMemOverride RamDynMemOverride;
+
+enum MB_FILEFORMAT {
+	MB_FILEFORMAT_PS,
+	MB_FILEFORMAT_PATCH,
+	MB_FILEFORMAT_DY,
+};
+enum RamPsSection
+{
+	RAM_PS_SECTION,
+	RAM_PATCH_SECTION,
+	RAM_DYN_MEM_SECTION
+};
+
+enum eType {
+	eHex,
+	edecimal,
+};
+
+struct ST_PS_DATA_FORMAT {
+	enum eType   eDataType;
+	BOOL    bIsArray;
+};
+#define CONV_DEC_DIGIT_TO_VALUE(c) ((c) - '0')
+#define IS_HEX(c)   (IS_BETWEEN((c), '0', '9') || IS_BETWEEN((c), 'a', 'f') || IS_BETWEEN((c), 'A', 'F'))
+#define IS_BETWEEN(x, lower, upper) (((lower) <= (x)) && ((x) <= (upper)))
+#define IS_DIGIT(c) (IS_BETWEEN((c), '0', '9'))
+#define CONV_HEX_DIGIT_TO_VALUE(c) (IS_DIGIT(c) ? ((c) - '0') : (IS_BETWEEN((c), 'A', 'Z') ? ((c) - 'A' + 10) : ((c) - 'a' + 10)))
+#define BYTES_OF_PS_DATA_PER_LINE    16
+struct ST_READ_STATUS {
+	unsigned uTagID;
+	unsigned uSection;
+	unsigned uLineCount;
+	unsigned uCharCount;
+	unsigned uByteCount;
+};
+
+//DUT MODE related
+#define MC_BCAM_COMPARE_ADDRESS           0x00008080
+#define HCI_3_PATCH_SPACE_LENGTH_1            (0x80)
+#define HCI_3_PATCH_SPACE_LENGTH_2            (0x279C)
+#define MEM_BLK_DATA_MAX                (244)
+#define MC_BCAM_VALID_ADDRESS                    0x00008100
+
+//Audio stat
+
+typedef struct tAudio_Stat {
+	UINT16      RxSilenceInsert;
+	UINT16      RxAirPktDump;
+	UINT16      RxCmplt;
+	UINT16      TxCmplt;
+	UINT16      MaxPLCGenInterval;
+	UINT16      RxAirPktStatusGood;
+	UINT16      RxAirPktStatusError;
+	UINT16      RxAirPktStatusLost;
+	UINT16      RxAirPktStatusPartial;
+	SINT16      SampleMin;
+	SINT16      SampleMax;
+	UINT16      SampleCounter;
+	UINT16      SampleStatEnable;
+} tAudioStat;
+
+//DMA stats
+
+typedef struct tBRM_Stats {
+  // DMA Stats
+  UINT32 DmaIntrs;
+
+  // Voice Stats
+  UINT16 VoiceTxDmaIntrs;
+  UINT16 VoiceTxErrorIntrs;
+  UINT16 VoiceTxDmaErrorIntrs;
+  UINT16 VoiceTxPktAvail;
+  UINT16 VoiceTxPktDumped;
+  UINT16 VoiceTxDmaSilenceInserts;
+
+  UINT16 VoiceRxDmaIntrs;
+  UINT16 VoiceRxErrorIntrs;
+  UINT16 VoiceRxGoodPkts;
+  UINT16 VoiceRxErrCrc;
+  UINT16 VoiceRxErrUnderOverFlow;
+  UINT16 VoiceRxPktDumped;
+
+  UINT16 VoiceTxReapOnError;
+  UINT16 VoiceRxReapOnError;
+  UINT16 VoiceSchedulingError;
+  UINT16 SchedOnVoiceError;
+
+  UINT16 Temp1;
+  UINT16 Temp2;
+
+  // Control Stats
+  UINT16 ErrWrongLlid;
+  UINT16 ErrL2CapLen;
+  UINT16 ErrUnderOverFlow;
+  UINT16 RxBufferDumped;
+  UINT16 ErrWrongLmpPktType;
+  UINT16 ErrWrongL2CapPktType;
+  UINT16 HecFailPkts;
+  UINT16 IgnoredPkts;
+  UINT16 CrcFailPkts;
+  UINT16 HwErrRxOverflow;
+
+  UINT16 CtrlErrNoLmpBufs;
+
+  // ACL Stats
+  UINT16 DataTxBuffers;
+  UINT16 DataRxBuffers;
+  UINT16 DataRxErrCrc;
+  UINT16 DataRxPktDumped;
+  UINT16 LmpTxBuffers;
+  UINT16 LmpRxBuffers;
+  UINT16 ForceOverQosJob;
+
+  // Sniff Stats
+  UINT16 SniffSchedulingError;
+  UINT16 SniffIntervalNoCorr;
+
+  // Test Mode Stats
+  UINT16 TestModeDroppedTxPkts;
+  UINT16 TestModeDroppedLmps;
+
+  // Error Stats
+  UINT16 TimePassedIntrs;
+  UINT16 NoCommandIntrs;
+
+} tBRM_Stats;
+
+typedef struct tSYSUTIL_ChipId {
+  char *pName;
+  UINT32 HwRev;
+} tSYSUTIL_ChipId;
+
+typedef struct tSU_RevInfo {
+  tSYSUTIL_ChipId *pChipId;
+  tSYSUTIL_ChipId *pChipRadioId;
+  UINT32 ChipRadioId;
+  UINT32 SubRadioId;
+  UINT32 RomVersion;
+  UINT32 RomBuildNumber;
+  UINT32 BuildVersion;
+  UINT32 BuildNumber;
+  UINT16 RadioFormat;
+  UINT16 RadioContent;
+  UINT16 SysCfgFormat;
+  UINT16 SysCfgContent;
+  UINT8 ProductId;
+} tSU_RevInfo;
+
+typedef struct {
+	UINT8 b[6];
+} __attribute__((packed)) bdaddr_t;
+
+typedef struct {
+	UINT16 opcode;		/* OCF & OGF */
+	UINT8	plen;
+} __attribute__((packed)) hci_command_hdr;
+
+typedef struct {
+	UINT8	evt;
+	UINT8	plen;
+} __attribute__((packed)) hci_event_hdr;
+
+typedef struct {
+	UINT8	ncmd;
+	UINT16	opcode;
+} __attribute__ ((packed)) evt_cmd_complete;
+
+#define HCI_COMMAND_HEADER_SIZE 3
+#define HCI_OPCODE_PACK(ogf, ocf) (UINT16)((ocf & 0x03ff)|(ogf << 10))
+
+#endif
+
diff --git a/btconfig/commands_btconfig.txt b/btconfig/commands_btconfig.txt
new file mode 100644
index 0000000..838661c
--- /dev/null
+++ b/btconfig/commands_btconfig.txt
@@ -0,0 +1,213 @@
+Command complete event
+[0]: 04 
+[1]: 0E 
+[2]: Following parameter length 
+[3]: Number of HCI comand. Usually [01]
+[4]: OCF 
+[5]: OGF 
+[6]: Return status. [00] means successfully executed
+
+Master blaster mode
+[0] mb
+[1] cmd
+[2] power = 3
+[3] freq = 3
+[4] packet = DM1
+[5] {Tx|Rx}
+[6]
+
+btconfig /dev/ttyHS0 mb cmd 3 3 DM1 TX
+
+General format
+For ROME over UART: #btconfig <command , parameters >
+FOR smd based devices: #btconfig /dev/smd3 <command , parameters >
+
+==================RESET COMMAND=================
+127|root@android:/ # btconfig /dev/smd3 reset
+btconfig /dev/smd3 reset
+Done intiailizing fd = /dev/smd3
+ 03
+ 0c
+ 00
+
+*************Data read begin *************
+[e][4][1][3][c][0]
+*************Data read end **************
+
+HCI Reset Pass
+Reset Done
+==================================================
+
+
+================INQUIRY ==========================
+
+root@android:/ # btconfig /dev/smd3 hciinq 33 8b 9e 12 5
+btconfig /dev/smd3 hciinq 33 8b 9e 12 5
+Done intiailizing fd = /dev/smd3
+inq command ++ argc = 6 argv = 33 8b 9e 12 5
+
+INQUIRY:
+Command Status Received
+[f][4][0][1][1][4]
+INQ RESULT EVENT RECEIVED
+[2][f][1][4d][35][67][15][19][0][0][2][0][4][1][12][84][33]
+INQ RESULT EVENT RECEIVED
+[2][f][1][9b][92][64][15][19][0][1][2][0][8][4][34][36][2b]
+INQ RESULT EVENT RECEIVED
+[2][f][1][35][2][7d][8c][3][0][1][2][0][4][1][6e][65][39]
+INQ RESULT EVENT RECEIVED
+[2][f][1][50][60][89][c6][a0][0][1][2][0][c][2][5a][eb][4d]
+INQ RESULT EVENT RECEIVED
+[2][f][1][99][61][80][80][20][10][1][2][0][c][2][5c][84][40]
+INQ COMPLETE EVENT RECEIVED
+
+=================================================
+
+
+================READ BD ADDRESS ==================
+root@android:/ # btconfig /dev/smd3 rba
+btconfig /dev/smd3 rba
+Done intiailizing fd = /dev/smd3
+
+*************Data read begin *************
+[e][a][1][9][10][0][22][44][66][56][55][99]
+*************Data read end **************
+iRet: 12
+
+BD ADDRESS:
+99:55:56:66:44
+=================================================
+
+
+================WRITE BD ADDRESS ==================
+root@android:/ # btconfig /dev/smd3 wba 00:55:77:77:88:00
+btconfig /dev/smd3 wba 00:55:77:77:88:00
+Done intiailizing fd = /dev/smd3
+
+*************Data read begin *************
+[e][4][1][3][c][0]
+*************Data read end **************
+
+*************Data read begin *************
+[e][a][1][9][10][0][0][88][77][77][55][0]
+*************Data read end **************
+
+BD address changed
+=================================================
+
+
+
+================CREATE CONNECTION ==================
+root@android:/ # btconfig /dev/smd3 conn 00:15:83:64:B3:14
+btconfig /dev/smd3 conn 00:15:83:64:B3:14
+Done intiailizing fd = /dev/smd3
+
+ Connect test
+14:Command Status Received
+[f][4][0][1][5][4]
+Other event received, Breaking
+[12][8][0][14][b3][64][83][15][0][1]
+CONNECTION COMPLETE EVENT RECEIVED WITH HANDLE: 0x0001
+[3][b][0][1][0][14][b3][64][83][15][0][1][0]
+=================================================
+
+================DISCONNECTION REQ ==================
+root@android:/ # btconfig /dev/smd3 disc 0001 16
+btconfig /dev/smd3 disc 0001 16
+Done intiailizing fd = /dev/smd3
+
+HCI_Disconnect: Handle :0001 Reason Code: 0x16
+Command Status Received
+[f][4][0][1][6][4]
+DISCONNECTION COMPLETE EVENT RECEIVED WITH REASON CODE: 0x16
+[5][4][0][1][0][16]
+=================================================
+
+================SET EVENT FILTER ==================
+
+root@android:/ # btconfig /dev/smd3 hcisetevtflt 01 00
+btconfig /dev/smd3 hcisetevtflt 01 00
+Done intiailizing fd = /dev/smd3
+
+*************Data read begin *************
+[e][4][1][5][c][0]
+*************Data read end **************
+
+Set Event Filter
+=================================================
+
+
+================ENABLE DUT MODE =================
+root@android:/ # btconfig /dev/smd3 edutm
+btconfig /dev/smd3 edutm
+Done intiailizing fd = /dev/smd3
+
+*************Data read begin *************
+[e][4][1][1a][c][0]
+*************Data read end **************
+
+*************Data read begin *************
+[e][4][1][3][18][0]
+*************Data read end **************
+
+Device is in test mode ...
+
+=================================================
+
+================WRITE SCAN MODE =================
+root@android:/ # btconfig /dev/smd3  wsm
+btconfig /dev/smd3  wsm
+Done intiailizing fd = /dev/smd3
+
+Usage:
+
+ wsm [0|1|2|3]
+
+Example:
+        wsm 0   (Scan disabled)
+        wsm 1   (Inquiry scan enabled)
+        wsm 2   (Page scan enabled)
+        wsm 3   (Inquiry and Page scan enabled)
+
+root@android:/ # btconfig /dev/smd3  wsm 2
+btconfig /dev/smd3  wsm 2
+Done intiailizing fd = /dev/smd3
+
+*************Data read begin *************
+[e][4][1][1a][c][0]
+*************Data read end **************
+
+Scan Mode set to :2
+=================================================
+===========PIN CONNECTIVITY TEST=================
+Usage:
+pinconntest 0B
+
+root@android:/ # btconfig /dev/smd3 pinconntest 0B
+btconfig /dev/smd3 pinconntest 0B
+Done intiailizing fd = /dev/smd3
+
+
+PIN CONNECTIVITY TEST:
+Other event received, Breaking
+[e][f][1][c][fc][0][b][3][2][0][0][3][0][0][4][0][0]
+Other event received, Breaking
+[e][4][1][0][0][0]
+
+=================================================
+===========VENDOR SPECIFIC COMMAND===============
+usage:
+venspeccmd arg[1] arg[2] ........
+
+
+
+root@android:/ # btconfig /dev/smd3 venspeccmd 03
+btconfig /dev/smd3 venspeccmd 03
+Done intiailizing fd = /dev/smd3
+Vendor Specific command
+Other event received, Breaking
+[ff][5][0][0][0][8][3]
+Other event received, Breaking
+[e][4][1][0][0][0]
+Please note that
+
diff --git a/btconfig/masterblaster.h b/btconfig/masterblaster.h
new file mode 100644
index 0000000..f65b4fd
--- /dev/null
+++ b/btconfig/masterblaster.h
@@ -0,0 +1,426 @@
+/*
+ * Copyright (c) 2013,2016 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *          notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *          notice, this list of conditions and the following disclaimer in the
+ *          documentation and/or other materials provided with the distribution.
+ *        * Neither the name of The Linux Foundation nor
+ *          the names of its contributors may be used to endorse or promote
+ *          products derived from this software without specific prior written
+ *          permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _MASTERBLASTER_H_
+#define _MASTERBLASTER_H_
+#include "btconfig.h"
+
+#define INVALID_MASTERBLASTER_FIELD    (-1)
+#define UNUSED(x) (x=x)
+// Bluetooth Packet Type Identifiers
+#define  MAX_TRANSMIT_POWER_CONTROL_ENTRIES    15
+
+#define LC_JTAG_MODEM_REGS_ADDRESS               0x00020800
+#define AGC_BYPASS_ADDRESS                       0x0000040c
+#define AGC_BYPASS_ENABLE_MASK                   0x00000001
+#define AGC_BYPASS_ENABLE_LSB                    0
+#define AGC_BYPASS_ENABLE_SET(x)                 (((x) << AGC_BYPASS_ENABLE_LSB) & AGC_BYPASS_ENABLE_MASK)
+#define LC_DEV_PARAM_CTL_ADDRESS                 0x00020010
+#define LC_DEV_PARAM_CTL_FREQ_HOP_EN_MASK        0x00000001
+#define LC_DEV_PARAM_CTL_RX_FREQ_MASK            0x00007f00
+#define LC_DEV_PARAM_CTL_WHITEN_EN_MASK          0x00008000
+#define LC_DEV_PARAM_CTL_RX_FREQ_SET(x)          (((x) << LC_DEV_PARAM_CTL_RX_FREQ_LSB) & LC_DEV_PARAM_CTL_RX_FREQ_MASK)
+#define LC_DEV_PARAM_CTL_RX_FREQ_LSB             8
+
+#define CORR_PARAM1_ADDRESS                      0x00000048
+#define CORR_PARAM1_TIM_THR_MASK                 0xfc000000
+#define CORR_PARAM1_TIM_THR_LSB                  26
+#define CORR_PARAM1_TIM_THR_SET(x)               (((x) << CORR_PARAM1_TIM_THR_LSB) & CORR_PARAM1_TIM_THR_MASK)
+
+typedef struct tBtHost_Interest {
+  UINT16 MagicNumber;
+  UINT16 Version;
+  UINT32 TraceDataAddr;
+  UINT32 GlobalDmaStats;   // BRM Global DMA Statistics
+  UINT32 TpcTableAddr;     // SysCfg Transmit power table
+  UINT32 AudioStatAddr;
+  UINT32 AudioInternalAddr;
+  UINT32 SysCfgAddr;
+  UINT32 ReservedRamAddr;
+  UINT32 HostConfigAddr;
+  UINT32 RamVersionAddr;
+  // Version 1.01
+  UINT32 BrmGlobalDataAddr;  // BRM Global Context pointer
+  UINT32 LeGlobalDataAddr;   // LE Global Context pointer
+  // Version 1.02
+  UINT32 MmGlobalDataAddr;
+} tBtHostInterest;
+
+typedef struct PsSysCfgTransmitPowerControlEntry {
+    SINT8               TxPowerLevel;
+    UINT32              RadioConfig;
+    UINT32              EdrRadioConfig;
+    SINT16              Slope;
+    SINT16              EdrSlope;
+    UINT8               TxFreqCorr;
+    UINT8               EdrTxFreqCorr;
+} tPsSysCfgTransmitPowerControlEntry;
+
+typedef struct PsSysCfgTransmitPowerControlTable {
+  int  NumOfEntries;
+  tPsSysCfgTransmitPowerControlEntry t[MAX_TRANSMIT_POWER_CONTROL_ENTRIES];
+} tPsSysCfgTransmitPowerControlTable;
+typedef UCHAR tBRM_PktType;
+
+enum {
+   TxTest_PktType_NULL    = 0x00,
+   TxTest_PktType_POLL    = 0x01,
+   TxTest_PktType_FHS     = 0x02,
+   TxTest_PktType_DM1     = 0x03,
+   TxTest_PktType_DH1     = 0x04,
+   TxTest_PktType_HV1     = 0x05,
+   TxTest_PktType_HV2     = 0x06,
+   TxTest_PktType_HV3     = 0x07,
+   TxTest_PktType_DV      = 0x08,
+   TxTest_PktType_AUX1    = 0x09,
+   TxTest_PktType_DM3     = 0x0A,
+   TxTest_PktType_DH3     = 0x0B,
+   TxTest_PktType_DM5     = 0x0E,
+   TxTest_PktType_DH5     = 0x0F,
+   TxTest_PktType_2DH1    = 0x24,
+   TxTest_PktType_2DH3    = 0x2A,
+   TxTest_PktType_2DH5    = 0x2E,
+   TxTest_PktType_3DH1    = 0x28,
+   TxTest_PktType_3DH3    = 0x2B,
+   TxTest_PktType_3DH5    = 0x2F,
+   TxTest_PktType_Invalid = 0xff,
+};
+
+typedef UCHAR tBRM_eSCO_PktType;
+
+enum {
+   TxTest_PktType_EV3     = 0x17,
+   TxTest_PktType_EV4     = 0x1C,
+   TxTest_PktType_EV5     = 0x1D,
+   TxTest_PktType_2EV3    = 0x36,
+   TxTest_PktType_2EV5    = 0x3C,
+   TxTest_PktType_3EV3    = 0x37,
+   TxTest_PktType_3EV5    = 0x3D,
+};
+
+typedef UCHAR tBRM_PktMode;
+
+enum {
+   eBRM_Mode_Basic = 0,
+   eBRM_Mode_2Mbps = 2,
+   eBRM_Mode_3Mbps = 3
+};
+
+// tBRM_TestMode
+enum {
+   eBRM_TestMode_Pause = 0,
+   eBRM_TestMode_TX_0,
+   eBRM_TestMode_TX_1,
+   eBRM_TestMode_TX_1010,
+   eBRM_TestMode_TX_PRBS,
+   eBRM_TestMode_Loop_ACL,
+   eBRM_TestMode_Loop_SCO,
+   eBRM_TestMode_Loop_ACL_No_Whitening,
+   eBRM_TestMode_Loop_SCO_No_Whitening,
+   eBRM_TestMode_TX_11110000,
+   eBRM_TestMode_Rx,
+   eBRM_TestMode_Exit = 255,
+};
+enum {
+   Cont_Tx_Raw_1MHz = 0,
+   Cont_Tx_Raw_2MHz,
+   Cont_Tx_Raw_3MHz,
+   Cont_Tx_Regular,
+   CW_Single_Tone,
+};
+typedef UCHAR tBRM_TestMode;
+
+typedef struct tBRM_TestControl {
+   tBRM_TestMode       Mode;
+   UCHAR               HopMode;
+   UCHAR               TxFreq;
+   UCHAR               RxFreq;
+   UCHAR               Power;
+// UCHAR               PollPeriod;
+   UCHAR               Packet;
+   UCHAR               SkipRxSlot;
+   int              DataLen;
+} tBRM_TestControl;
+
+typedef struct tLE_TxParms {
+   UCHAR PktPayload;
+} tLE_TxParms;
+
+typedef struct tBRM_Control_packet {
+   tBRM_TestControl testCtrl;
+   UCHAR bdaddr[6];
+   UCHAR ContTxMode;    // Continuous TX Mode
+   UCHAR ContTxType;
+   UCHAR ContRxMode;    // Continuous RX Mode
+   UCHAR BERType;
+   UCHAR LERxMode;
+   UCHAR LETxMode;
+   tLE_TxParms LETxParms;
+} tBRM_Control_packet;
+
+
+#define DM1_MAX_PAYLOAD             17
+#define DH1_MAX_PAYLOAD             27
+#define DM3_MAX_PAYLOAD             121
+#define DH3_MAX_PAYLOAD             183
+#define DM5_MAX_PAYLOAD             224
+#define DH5_MAX_PAYLOAD             339
+#define AUX1_MAX_PAYLOAD            29
+#define E2_DH1_MAX_PAYLOAD          54
+#define E2_DH3_MAX_PAYLOAD          367
+#define E2_DH5_MAX_PAYLOAD          679
+#define E3_DH1_MAX_PAYLOAD          83
+#define E3_DH3_MAX_PAYLOAD          552
+#define E3_DH5_MAX_PAYLOAD          1021
+
+enum E_MasterBlasterFieldID
+{
+   CR = 0,
+   CT,
+   LR,
+   LT,
+   LTM,
+   CX,
+   TM,
+   HM,
+   TF,
+   RF,
+   PT,
+   DL,
+   PO,
+   BA,
+   SB,
+   GB,
+   RX,
+   TX,
+   EN,
+   ST,
+   EX,
+   EXX,
+};
+
+enum E_MasterBlasterTestFlag
+{
+   MB_NO_TEST = 0,
+   MB_RX_TEST,
+   MB_TX_TEST,
+   MB_CONT_RX_TEST,
+   MB_CONT_TX_TEST,
+   MB_LE_RX_TEST,
+   MB_LE_TX_TEST,
+};
+
+enum E_DisableEnable
+{
+   DISABLE = 0,
+   ENABLE = 1,
+};
+
+#define MB_MIN_DATALEN			0
+#define MB_MAX_DATALEN			1021
+#define MB_MIN_FREQUENCY		0
+#define MB_MAX_FREQUENCY		79
+#define MB_MIN_FREQUENCY_LE		0
+#define MB_MAX_FREQUENCY_LE		39
+#define MB_MIN_DATALEN_LE		0
+#define MB_MAX_DATALEN_LE		37
+typedef struct STR_MasterBlasterOption
+{
+   char *Name;
+   int Value;
+} tMasterBlasterOption;
+
+typedef struct STR_MasterBlasterField
+{
+   char *Name;
+   char *Alias;
+   char *Usage;
+   int Default;
+   tMasterBlasterOption *Options;
+   int (*pFunc)(tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+} tMasterBlasterField;
+
+static tMasterBlasterOption TestModeOption[] =
+{
+   {"TX_0",                   eBRM_TestMode_TX_0},
+   {"TX_1",                   eBRM_TestMode_TX_1},
+   {"TX_1010",                eBRM_TestMode_TX_1010},
+   {"TX_PRBS",                eBRM_TestMode_TX_PRBS},
+   {"TX_11110000",            eBRM_TestMode_TX_11110000},
+   {"RX",                     eBRM_TestMode_Rx},
+};
+
+static tMasterBlasterOption HopModeOption[] =
+{
+   {"Disable",                DISABLE},
+   {"Enable",                 ENABLE},
+};
+
+static tMasterBlasterOption PacketTypeOption[] =
+{
+   {"DM1",                    TxTest_PktType_DM1},
+   {"DM3",                    TxTest_PktType_DM3},
+   {"DM5",                    TxTest_PktType_DM5},
+   {"DH1",                    TxTest_PktType_DH1},
+   {"DH3",                    TxTest_PktType_DH3},
+   {"DH5",                    TxTest_PktType_DH5},
+   {"2-DH1",                  TxTest_PktType_2DH1},
+   {"2-DH3",                  TxTest_PktType_2DH3},
+   {"2-DH5",                  TxTest_PktType_2DH5},
+   {"3-DH1",                  TxTest_PktType_3DH1},
+   {"3-DH3",                  TxTest_PktType_3DH3},
+   {"3-DH5",                  TxTest_PktType_3DH5},
+};
+
+static int MaxDataLenOption[] =
+{
+   DM1_MAX_PAYLOAD,
+   DM3_MAX_PAYLOAD,
+   DM5_MAX_PAYLOAD,
+   DH1_MAX_PAYLOAD,
+   DH3_MAX_PAYLOAD,
+   DH5_MAX_PAYLOAD,
+   E2_DH1_MAX_PAYLOAD,
+   E2_DH3_MAX_PAYLOAD,
+   E2_DH5_MAX_PAYLOAD,
+   E3_DH1_MAX_PAYLOAD,
+   E3_DH3_MAX_PAYLOAD,
+   E3_DH5_MAX_PAYLOAD,
+};
+
+enum {
+   eBRM_BERMode_ALL = 0, // ALL type
+   eBRM_BERMode_ALL_DATA, // All type except dm1,dm3,dm5
+   eBRM_BERMode_DM1,
+   eBRM_BERMode_DM3,
+   eBRM_BERMode_DM5,
+   eBRM_BERMode_DH1,
+   eBRM_BERMode_DH3,
+   eBRM_BERMode_DH5,
+   eBRM_BERMode_2DH1,
+   eBRM_BERMode_2DH3,
+   eBRM_BERMode_2DH5,
+   eBRM_BERMode_3DH1,
+   eBRM_BERMode_3DH3,
+   eBRM_BERMode_3DH5,
+};
+
+static tMasterBlasterOption BERPacketTypeOption[] =
+{
+   {"ALL",                  eBRM_BERMode_ALL},
+   {"ALL_DATA",             eBRM_BERMode_ALL_DATA},
+   {"DM1",                  eBRM_BERMode_DM1},
+   {"DM3",                  eBRM_BERMode_DM3},
+   {"DM5",                  eBRM_BERMode_DM5},
+   {"DH1",                  eBRM_BERMode_DH1},
+   {"DH3",                  eBRM_BERMode_DH3},
+   {"DH5",                  eBRM_BERMode_DH5},
+   {"2DH1",                 eBRM_BERMode_2DH1},
+   {"2DH3",                 eBRM_BERMode_2DH3},
+   {"2DH5",                 eBRM_BERMode_2DH5},
+   {"3DH1",                 eBRM_BERMode_3DH1},
+   {"3DH3",                 eBRM_BERMode_3DH3},
+   {"3DH5",                 eBRM_BERMode_3DH5},
+};
+
+static tMasterBlasterOption ContTxModeOption[] =
+{
+   {"Disable",                DISABLE},
+   {"Enable",                 ENABLE},
+};
+
+static tMasterBlasterOption ContTxTypeOption[] =
+{
+   {"Raw_1MHz",                  Cont_Tx_Raw_1MHz},
+   {"Raw_2MHz",                  Cont_Tx_Raw_2MHz},
+   {"Raw_3MHz",                  Cont_Tx_Raw_3MHz},
+   {"Regular_BT_Packet_Format",  Cont_Tx_Regular},
+   {"CW_Single_Tone",		 CW_Single_Tone},
+};
+
+static tMasterBlasterOption ContRxModeOption[] =
+{
+   {"Disable",                DISABLE},
+   {"Enable",                 ENABLE},
+};
+
+static tMasterBlasterOption LETxPktPayloadOption[] =
+{
+   {"Random_9",               0},
+   {"11110000",               1},
+   {"10101010",               2},
+   {"Random_15",              3},
+   {"11111111",               4},
+   {"00000000",               5},
+   {"00001111",               6},
+   {"01010101",               7},
+};
+
+//----------------------------------------------------------------------------
+// Prototypes
+//----------------------------------------------------------------------------
+
+void InitMasterBlaster (tBRM_Control_packet *MasterBlaster, bdaddr_t *BdAddr, UCHAR *SkipRxSlot);
+
+int CheckField (tBRM_Control_packet MasterBlaster, char *FieldAlias);
+int GetTestModeOptionIndex (int Mode);
+int GetPacketTypeOptionIndex (int PacketType);
+
+void PrintMasterBlasterMenu (tBRM_Control_packet *MasterBlaster);
+int SetMasterBlasterTestMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterHopMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterPacketType (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterTxFreq (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterRxFreq (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterPower (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterDataLen (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterBdAddr (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterContTxMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterContTxType (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterNothing (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterContRxMode (tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterLERxMode(tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterLETxMode(tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterLETxPktPayload(tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+int SetMasterBlasterBERType(tBRM_Control_packet *MasterBlaster, tMasterBlasterOption *Option);
+
+int ToggleOption (int *Value, tMasterBlasterOption *Option, tMasterBlasterOption *OptionArray,
+                     int Size, int FieldID, int Step);
+int MinMaxOption (int *Value, tMasterBlasterOption *Option, int Min, int Max);
+int ToggleMinMaxOption (int *Value, char *Option, int FieldID, int Min, int Max, int Step);
+
+//----------------------------------------------------------------------------
+// Variables
+//----------------------------------------------------------------------------
+
+extern tMasterBlasterField MasterBlasterMenu[];
+extern tPsSysCfgTransmitPowerControlTable  TpcTable;
+
+#endif // _MASTERBLASTER_H_
+
diff --git a/btsnoop_dump/Android.mk b/btsnoop_dump/Android.mk
new file mode 100644
index 0000000..f114c3f
--- /dev/null
+++ b/btsnoop_dump/Android.mk
@@ -0,0 +1,16 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=     \
+    btsnoop_dump.c
+
+LOCAL_C_INCLUDES :=
+
+LOCAL_MODULE_TAGS := debug optional
+
+LOCAL_MODULE:= btsnoop
+
+LOCAL_SHARED_LIBRARIES += libcutils
+
+include $(BUILD_EXECUTABLE)
diff --git a/btsnoop_dump/btsnoop_dump.c b/btsnoop_dump/btsnoop_dump.c
new file mode 100644
index 0000000..a34299b
--- /dev/null
+++ b/btsnoop_dump/btsnoop_dump.c
@@ -0,0 +1,363 @@
+/******************************************************************************
+Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+******************************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <dirent.h>
+
+#include <private/android_filesystem_config.h>
+#include <android/log.h>
+
+#include <cutils/log.h>
+
+#define MAX_FILE_SIZE 1024*1024*20
+
+#define LOGD0(t,s) __android_log_write(ANDROID_LOG_DEBUG, t, s)
+
+static int file_descriptor = -1;
+uint32_t file_size = 0;
+
+#define LOCAL_SOCKET_NAME "bthcitraffic"
+#define BTSNOOP_PATH "/data/media/0"
+#define BTSOOP_PORT 8872
+
+//#define __SNOOP_DUMP_DBG__
+
+static void snoop_log(const char *fmt_str, ...)
+{
+    static char buffer[1024];
+    va_list ap;
+
+    va_start(ap, fmt_str);
+    vsnprintf(buffer, 1024, fmt_str, ap);
+    va_end(ap);
+
+    LOGD0("btsnoop_dump: ", buffer);
+}
+
+int btsnoop_file_name (char file_name[256])
+{
+    struct tm *tmp;
+    time_t t;
+    char time_string[64];
+
+    t = time(NULL);
+    tmp = localtime(&t);
+    if (tmp == NULL)
+    {
+        snoop_log("Error : get localtime");
+        return -1;
+    }
+
+    if (strftime(time_string, 64, "%Y%m%d%H%M%S", tmp) == 0)
+    {
+        snoop_log("Error : strftime :");
+        return -1;
+    }
+    snprintf(file_name, 256, BTSNOOP_PATH"/hci_snoop%s.cfa", time_string);
+    return 0;
+}
+
+int snoop_open_file (void)
+{
+    char file_name[2][256];
+    int snoop_files_found = 0;
+    struct DIR* p_dir;
+    struct dirent* p_dirent;
+
+    p_dir = opendir(BTSNOOP_PATH);
+    if(p_dir == NULL)
+    {
+        snoop_log("snoop_log_open: Unable to open the Dir entry\n");
+        file_descriptor = -1;
+        return -1;
+    }
+    while ((p_dirent = readdir(p_dir)) != NULL)
+    {
+        int ret;
+
+        if ((ret = strncmp(p_dirent->d_name, "hci_snoop", strlen("hci_snoop"))) == 0)
+        {
+            snoop_files_found++;
+        }
+        if (snoop_files_found > 2)
+        {
+            snoop_log("snoop_log_open: Error : More than two snoop files : Abort");
+            file_descriptor = -1;
+            return -1;
+        }
+        else if (ret == 0)
+        {
+            strlcpy(file_name[snoop_files_found - 1], p_dirent->d_name, 256);
+#ifdef __SNOOP_DUMP_DBG__
+            snoop_log("snoop_log_open: snoop file found : %s", file_name[snoop_files_found - 1]);
+#endif //__SNOOP_DUMP_DBG__
+        }
+    }
+    closedir(p_dir);
+    if (snoop_files_found == 2)
+    {
+        char del_file[256];
+
+        /* Delete the oldest File */
+        if (strncmp(file_name[0], file_name[1], 256) < 0)
+        {
+            snprintf(del_file, 256, BTSNOOP_PATH"/%s", file_name[0]);
+#ifdef __SNOOP_DUMP_DBG__
+            snoop_log("snoop_log_open: old file to delete : %s", del_file);
+#endif //__SNOOP_DUMP_DBG__
+            unlink(del_file);
+        }
+        else
+        {
+            snprintf(del_file, 256, BTSNOOP_PATH"/%s", file_name[1]);
+#ifdef __SNOOP_DUMP_DBG__
+            snoop_log("snoop_log_open: old file to delete : %s", del_file);
+#endif //__SNOOP_DUMP_DBG__
+            unlink(del_file);
+        }
+    }
+
+    if (btsnoop_file_name(file_name[0]) != 0)
+    {
+        snoop_log("snoop_log_open: error : could not get snoop file name !!");
+        return -1;
+    }
+
+    snoop_log("snoop_log_open: new file : %s", file_name[0]);
+    file_descriptor = open(file_name[0], \
+                              O_WRONLY|O_CREAT|O_TRUNC, \
+                              S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH);
+    if (file_descriptor == -1)
+    {
+        snoop_log("snoop_log_open: Unable to open snoop log file\n");
+        file_descriptor = -1;
+        return -1;
+    }
+
+    file_size = 0;
+    write(file_descriptor, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
+    return 0;
+}
+
+int snoop_connect_to_source (void)
+{
+    struct sockaddr_un serv_addr;
+
+    int sk, ret, retry_count = 0, addr_len;
+
+    snoop_log("snoop_connect_to_source :");
+    /* Create Socket to connect to BT Traffic source*/
+    sk = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (sk < 0)
+    {
+        snoop_log("Can't create client socket : %s\n", strerror(errno));
+        return -1;
+    }
+    else
+    {
+        memset(&serv_addr, 0, sizeof(serv_addr));
+        serv_addr.sun_family = AF_LOCAL;
+        memcpy(&serv_addr.sun_path[1], LOCAL_SOCKET_NAME, strlen(LOCAL_SOCKET_NAME));
+        addr_len =  strlen(LOCAL_SOCKET_NAME) + 1;
+        addr_len += sizeof(serv_addr.sun_family);
+        do
+        {
+            ret = connect(sk, &serv_addr, addr_len);
+            if (ret < 0)
+            {
+                snoop_log("Can't connect to BT traffic source : %s\n",strerror(errno));
+                retry_count++;
+                sleep (1);
+            }
+        } while((ret < 0) && (retry_count < 10));
+
+        if (ret < 0)
+        {
+            close(sk);
+            return -1;
+        }
+
+        snoop_log("Connected to bthcitraffic : sock fd : %d", sk);
+        return sk;
+    }
+}
+
+int read_block (int sock, unsigned char *pBuf, int len)
+{
+    int bytes_recv = 0, ret;
+    do
+    {
+#ifdef __SNOOP_DUMP_DBG__
+        snoop_log("read_block : waiting to read");
+#endif //__SNOOP_DUMP_DBG__
+
+        ret = recv(sock, &pBuf[bytes_recv], len - bytes_recv, 0);
+#ifdef __SNOOP_DUMP_DBG__
+        snoop_log("read_block : read returned %d", ret);
+#endif //__SNOOP_DUMP_DBG__
+        if ( (ret == -1) && (errno != EAGAIN) )
+        {
+            bytes_recv = ret;
+            snoop_log("Error Packet header : Connection Closed : %s\n", strerror(errno));
+            break;
+        }
+        else if (ret == 0)
+        {
+            snoop_log("Disconnected from bthcitraffic : Exiting...");
+            close (sock);
+            break;
+        }
+        bytes_recv += ret;
+    } while(bytes_recv < len);
+
+#ifdef __SNOOP_DUMP_DBG__
+    snoop_log("bytes read = %d", bytes_recv);
+#endif //__SNOOP_DUMP_DBG__
+    return bytes_recv;
+}
+
+static unsigned char read_buf[1200];
+
+int snoop_process (int sk)
+{
+    int bytes_recv = 0;
+    struct stat st;
+    uint32_t sizeoffile = 0, length;
+
+    if (file_descriptor == -1)
+    {
+        if (snoop_open_file() != 0)
+        {
+            return -1;
+        }
+    }
+
+/*
+    24 Bytes snoop Header
+    Initial 4 bytes have the length of the HCI packet
+    Read 8 bytes which have orignal length and included length
+*/
+    bytes_recv = read_block (sk, &read_buf[0], 8);
+    if ((bytes_recv == 0) || (bytes_recv == -1))
+    {
+        snoop_log("Error in reading the Header : ");
+        return -1;
+    }
+
+    length = read_buf[0] << 24 | read_buf[1] << 16 | read_buf[2] << 8 | read_buf[3];
+
+#if 1
+#ifdef __SNOOP_DUMP_DBG__
+    snoop_log("Length of Frame %ld : byte %0x %0x %0x %0x", length,
+        read_buf[0], read_buf[1], read_buf[2], read_buf[3]);
+
+    snoop_log("File Size = %d", file_size);
+#endif //__SNOOP_DUMP_DBG__
+
+    if (file_size > MAX_FILE_SIZE)
+    {
+        if (file_descriptor != -1)
+        {
+            close(file_descriptor);
+            file_descriptor = -1;
+            if (snoop_open_file() != 0)
+            {
+                return -1;
+            }
+        }
+    }
+#endif
+
+/*
+    Read rest of snoop header(16 Bytes) and HCI Packet
+*/
+    bytes_recv = read_block (sk, &read_buf[8], length + 16);
+    if ((bytes_recv == 0) || (bytes_recv == -1))
+    {
+        snoop_log("Error reading snoop packet : ");
+        return -1;
+    }
+
+    file_size += (bytes_recv + 8);
+
+    write(file_descriptor, read_buf, bytes_recv + 8);
+
+    return 0;
+}
+
+int main (int argc, char * argv[])
+{
+    int sk, ret, bytes_recv;
+
+    snoop_log ("btsnoop dump starting");
+
+    /* set the file creation mask to allow read/write */
+    umask(0111);
+
+    sk = snoop_connect_to_source();
+
+/*
+       16 Bytes : Read and discard snoop file header
+*/
+    bytes_recv = read_block (sk, &read_buf[0], 16);
+    if ((bytes_recv == 0) || (bytes_recv == -1))
+    {
+        snoop_log("Error in reading the snoop file Header : ");
+        return -1;
+    }
+
+    if (snoop_open_file() != 0)
+    {
+        return -1;
+    }
+
+    if (sk != -1)
+    {
+        do
+        {
+            ret = snoop_process(sk);
+        } while(ret != -1);
+    }
+
+    snoop_log("btsnoop dump terminated");
+    return 0;
+}
+
diff --git a/bttestapp/Android.mk b/bttestapp/Android.mk
old mode 100644
new mode 100755
index 582d6a1..4858ba2
--- a/bttestapp/Android.mk
+++ b/bttestapp/Android.mk
@@ -5,13 +5,15 @@ LOCAL_MODULE_TAGS := optional
 
 LOCAL_SRC_FILES := \
         $(call all-java-files-under, src)
-
+LOCAL_SRC_FILES := $(filter-out src/org/codeaurora/bluetooth/bttestapp/PbapTestActivity.java,$(LOCAL_SRC_FILES))
+LOCAL_SRC_FILES := $(filter-out src/org/codeaurora/bluetooth/bttestapp/services/IPbapServiceCallback.java,$(LOCAL_SRC_FILES))
+LOCAL_SRC_FILES := $(filter-out src/org/codeaurora/bluetooth/bttestapp/services/PbapAuthAcitivty.java,$(LOCAL_SRC_FILES))
 LOCAL_PACKAGE_NAME := BTTestApp
 LOCAL_CERTIFICATE := platform
 
 LOCAL_MODULE_OWNER := qcom
 
-LOCAL_STATIC_JAVA_LIBRARIES := com.android.vcard android.bluetooth.client.pbap android.bluetooth.client.map
+LOCAL_STATIC_JAVA_LIBRARIES := com.android.vcard  android.bluetooth.client.map
 
 LOCAL_PROGUARD_ENABLED := disabled
 
diff --git a/bttestapp/AndroidManifest.xml b/bttestapp/AndroidManifest.xml
old mode 100644
new mode 100755
index f9fc12b..58fbce9
--- a/bttestapp/AndroidManifest.xml
+++ b/bttestapp/AndroidManifest.xml
@@ -13,7 +13,7 @@
 
     <uses-sdk
         android:minSdkVersion="17"
-        android:targetSdkVersion="17" />
+        android:targetSdkVersion="23" />
 
     <application
         android:allowBackup="true"
@@ -40,10 +40,10 @@
             android:name=".AvrcpTestActivity"
             android:configChanges="orientation|keyboardHidden|screenSize"
             android:launchMode="singleTop" />
-        <activity
+        <!--activity
             android:name=".PbapTestActivity"
             android:configChanges="orientation|keyboardHidden|screenSize"
-            android:launchMode="singleTop" />
+            android:launchMode="singleTop" /-->
         <activity
             android:name=".MapTestActivity"
             android:configChanges="orientation|keyboardHidden|screenSize"
@@ -58,14 +58,14 @@
             </intent-filter>
         </service>
 -->
-        <activity android:name=".services.PbapAuthActivity"
+        <!--activity android:name=".services.PbapAuthActivity"
             android:configChanges="orientation|keyboardHidden|screenSize"
             android:excludeFromRecents="true"
             android:theme="@*android:style/Theme.Holo.Dialog.Alert">
             <intent-filter>
                 <category android:name="android.intent.category.DEFAULT" />
             </intent-filter>
-        </activity>
+        </activity-->
 
         <receiver android:name=".BluetoothConnectionReceiver" >
             <intent-filter>
diff --git a/bttestapp/res/values/strings.xml b/bttestapp/res/values/strings.xml
index 73ea04e..dac8cb8 100644
--- a/bttestapp/res/values/strings.xml
+++ b/bttestapp/res/values/strings.xml
@@ -214,12 +214,10 @@
     <string name="map_report_notif_title_memory_full">Memory full</string>
     <string name="map_report_notif_title_memory_available">Memory available</string>
     <string name="map_report_notif_title_message_deleted">Message deleted</string>
-    <string name="map_report_notif_title_read_status_changed">Read Status Changed</string>
     <string name="map_report_notif_received">Received new %1$s message</string>
     <string name="map_report_notif_handle">Handle: %1$s</string>
     <string name="map_report_notif_shifted">Message %1$s shifted</string>
     <string name="map_report_notif_fromto">From %1$s to %2$s</string>
-    <string name="map_report11_notif_received_param">From: %1$s Priority: %2$s Handle: %3$s</string>
 
     <string-array name="map_message_type_array">
         <item>SMS_GSM</item>
diff --git a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/AvrcpTestActivity.java b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/AvrcpTestActivity.java
deleted file mode 100644
index fe1ef2c..0000000
--- a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/AvrcpTestActivity.java
+++ /dev/null
@@ -1,985 +0,0 @@
-/*
- * Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *        * Redistributions of source code must retain the above copyright
- *            notice, this list of conditions and the following disclaimer.
- *        * Redistributions in binary form must reproduce the above copyright
- *            notice, this list of conditions and the following disclaimer in the
- *            documentation and/or other materials provided with the distribution.
- *        * Neither the name of The Linux Foundation nor
- *            the names of its contributors may be used to endorse or promote
- *            products derived from this software without specific prior written
- *            permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-package org.codeaurora.bluetooth.bttestapp;
-
-import android.app.ActionBar;
-import android.app.DialogFragment;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothAvrcpController;
-import android.bluetooth.BluetoothAvrcpInfo;
-import android.bluetooth.BluetoothProfile;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.ServiceConnection;
-import android.os.Bundle;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
-import android.os.SystemProperties;
-import android.util.Log;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.MotionEvent;
-import android.widget.Button;
-import android.widget.Toast;
-import android.widget.ToggleButton;
-import android.view.View;
-import android.view.View.OnTouchListener;
-import android.database.ContentObserver;
-import android.database.Cursor;
-import android.content.ContentResolver;
-import android.os.Handler;
-import android.os.Process;
-import android.net.Uri;
-import android.widget.TextView;
-import android.app.Activity;
-import java.util.concurrent.TimeUnit;
-
-import org.codeaurora.bluetooth.bttestapp.R;
-import org.codeaurora.bluetooth.bttestapp.util.Logger;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.locks.ReentrantLock;
-import android.database.CursorIndexOutOfBoundsException;
-import android.database.sqlite.SQLiteCantOpenDatabaseException;
-import android.database.sqlite.SQLiteException;
-
-public class AvrcpTestActivity extends MonkeyActivity implements IBluetoothConnectionObserver {
-
-    private final String TAG = "AvrcpTestActivity";
-    private boolean ffPressed = false;
-
-    private ActionBar mActionBar = null;
-    private UpdateThread mUpdateThread;
-    private PressandHoldHandler mPressandHoldHandler;
-    private View appView;
-    private Activity mLocalActivity;
-    private final ReentrantLock mLock = new ReentrantLock();
-    BluetoothAvrcpController mAvrcpController;
-    ProfileService mProfileService = null;
-    BluetoothDevice mDevice;
-    BluetoothAvrcpShareContentObserver mAvrcpDataObserver = null;
-    private class PlayerSettings
-    {
-        public byte attr_Id;
-        public byte attr_val;
-        public byte [] supported_values; // app shld check these values before Setting Player Attributes.
-    };
-    ArrayList<PlayerSettings> plSetting= null;
-    int remoteSupportedFeatures = 0;
-    public static final int KEY_STATE_PRESSED = 0;
-    public static final int KEY_STATE_RELEASED = 1;
-    public static final int AVRC_ID_PLAY = 0x44;
-    public static final int AVRC_ID_PAUSE = 0x46;
-    public static final int AVRC_ID_VOL_UP = 0x41;
-    public static final int AVRC_ID_VOL_DOWN = 0x42;
-    public static final int AVRC_ID_STOP = 0x45;
-    public static final int AVRC_ID_FF = 0x49;
-    public static final int AVRC_ID_REWIND = 0x48;
-    public static final int AVRC_ID_FORWARD = 0x4B;
-    public static final int AVRC_ID_BACKWARD = 0x4C;
-
-    public static final int SEND_PASS_THROUGH_CMD = 1;
-
-    private TextView mRepeatStatus;
-    private TextView mShuffleStatus;
-    private TextView mGenreStatus;
-    private TextView mArtistName;
-    private TextView mAlbumName;
-    private TextView mPlayTime;
-    private TextView mScanStatus;
-    private TextView mPlayStatus;
-    private TextView mEqualizerStatus;
-    private TextView mTrackNumber;
-    private TextView mTitleName;
-    private ToggleButton mCTStartButton;
-    private Button ffButton;
-    private Button rwButton;
-
-    private String repeatText;
-    private String shuffleText;
-    private String genreText;
-    private String artistText;
-    private String albumText;
-    private String playText;
-    private String scanText;
-    private String playStatusText;
-    private String equalizerText;
-    private String trackNumText;
-    private String titleNameText;
-
-    private final BroadcastReceiver mAvrcpControllerReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            BluetoothDevice device = (BluetoothDevice)
-                    intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-
-            if (action.equals(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED)) {
-                int prevState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, 0);
-                int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
-                onReceiveActionConnectionStateChanged(device, prevState, state, intent.getExtras());
-            }
-        }
-
-        private void onReceiveActionConnectionStateChanged(BluetoothDevice device,
-                int prevState, int state, Bundle features) {
-            Logger.v(TAG, "onReceiveActionConnectionStateChanged: AVRCP: " +
-                    device.getAddress() + " (" +
-                    String.valueOf(prevState) + " -> " +
-                    String.valueOf(state) + ")");
-            if (state ==  BluetoothProfile.STATE_DISCONNECTED) {
-                if (device.equals(mDevice))
-                    mDevice = null;
-                if (plSetting != null)
-                    plSetting.clear();
-                remoteSupportedFeatures = 0;
-                unregisterMetaDataObserver();
-                resetDisplay();
-                mCTStartButton.setChecked(false);
-                Toast.makeText(mLocalActivity, "Device " + device + " AVRCP Disconnected", Toast.LENGTH_SHORT).show();
-            }
-            else if(state == BluetoothProfile.STATE_CONNECTED) {
-                mDevice = device;
-                Toast.makeText(mLocalActivity, "Device " + device + " AVRCP Connected", Toast.LENGTH_SHORT).show();
-            }
-        }
-    };
-    private View.OnTouchListener onTouchListenerRW = new View.OnTouchListener() {
-        @Override
-        public boolean onTouch(View v, MotionEvent me) {
-            v.onTouchEvent(me);
-            Log.d(TAG," onTouch for RW " + me.getAction());
-            if (me.getAction() == MotionEvent.ACTION_UP){
-                if ((mAvrcpController != null) && mDevice != null &&
-                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_REWIND, KEY_STATE_RELEASED);
-                    if (mPressandHoldHandler != null)
-                        mPressandHoldHandler.sendMessageAtFrontOfQueue(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_REWIND,KEY_STATE_RELEASED));
-                    } else {
-                        Logger.e(TAG, "passthru command not sent, connection unavailable");
-                    }
-            }
-            else if (me.getAction() == MotionEvent.ACTION_DOWN) {
-                if ((mAvrcpController != null) && mDevice != null &&
-                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_REWIND, KEY_STATE_PRESSED);
-                	if ((mPressandHoldHandler != null)&&(!mPressandHoldHandler.hasMessages(SEND_PASS_THROUGH_CMD)))
-                        mPressandHoldHandler.sendMessage(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_REWIND,KEY_STATE_PRESSED));
-                    } else {
-                        Logger.e(TAG, "passthru command not sent, connection unavailable");
-                    }
-            }
-            return true;
-        }
-    };
-    private View.OnTouchListener onTouchListenerFF = new View.OnTouchListener() {
-        @Override
-        public boolean onTouch(View v, MotionEvent me) {
-            v.onTouchEvent(me);
-            Log.d(TAG," onTouch for FF " + me.getAction());
-            if (me.getAction() == MotionEvent.ACTION_UP){
-                if ((mAvrcpController != null) && mDevice != null &&
-                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FF, KEY_STATE_RELEASED);
-                        if (mPressandHoldHandler != null)
-                            mPressandHoldHandler.sendMessageAtFrontOfQueue(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_FF,KEY_STATE_RELEASED));
-                    } else {
-                        Logger.e(TAG, "passthru command not sent, connection unavailable");
-                    }
-            }
-            else if (me.getAction() == MotionEvent.ACTION_DOWN) {
-                if ((mAvrcpController != null) && mDevice != null &&
-                        BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-                        if ((mPressandHoldHandler != null)&&(!mPressandHoldHandler.hasMessages(SEND_PASS_THROUGH_CMD)))
-                            mPressandHoldHandler.sendMessage(mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD,AVRC_ID_FF,KEY_STATE_PRESSED));
-                        //mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FF, KEY_STATE_PRESSED);
-                    } else {
-                        Logger.e(TAG, "passthru command not sent, connection unavailable");
-                    }
-            }
-            return true;
-        }
-    };
-    private final class PressandHoldHandler extends Handler {
-        private PressandHoldHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            Log.d(TAG," Recvd Msg " + msg.what);
-            int keyState = msg.arg2;
-            int keyCode = msg.arg1;
-            switch(msg.what) {
-            case SEND_PASS_THROUGH_CMD:
-                if (keyState == KEY_STATE_PRESSED) {
-                    Message msgsend = mPressandHoldHandler.obtainMessage(SEND_PASS_THROUGH_CMD, keyCode, keyState);
-                    mPressandHoldHandler.sendMessageDelayed(msgsend, 1000);
-                    if ((mAvrcpController != null) && mDevice != null &&
-                            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-                            mAvrcpController.sendPassThroughCmd(mDevice, keyCode, keyState);
-                    }
-                }
-                else if(keyState == KEY_STATE_RELEASED) {
-                    if (mPressandHoldHandler.hasMessages(SEND_PASS_THROUGH_CMD))
-                        mPressandHoldHandler.removeMessages(SEND_PASS_THROUGH_CMD);
-                    if ((mAvrcpController != null) && mDevice != null &&
-                            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-                            mAvrcpController.sendPassThroughCmd(mDevice, keyCode, keyState);
-                    }
-                }
-                break;
-            }
-        }
-    }
-    private class BluetoothAvrcpShareContentObserver extends ContentObserver {
-        public BluetoothAvrcpShareContentObserver() {
-            super(new Handler());
-        }
-        @Override
-        public void onChange(boolean selfChange) {
-            updateFromAvrcpContentProvider();
-        }
-    };
-    private void updateFromAvrcpContentProvider() {
-        Logger.e(TAG," AVRCP DB updated");
-        if (mUpdateThread == null)
-        {
-            Logger.e(TAG, "Starting a new Thread ");
-            mUpdateThread = new UpdateThread();
-            mUpdateThread.start();
-        }
-    }
-    private class UpdateThread extends Thread {
-        public UpdateThread() {
-            super(" BT_TESTAPP AVRCP UpdateThread");
-        }
-        @Override
-        public void run() {
-            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-            Uri avrcpDataUri = BluetoothAvrcpInfo.CONTENT_URI;
-            String[] mSelectionArgs = {""}; mSelectionArgs[0] = "";
-            Cursor cursor = getContentResolver().query(avrcpDataUri, null, null, null,
-                    BluetoothAvrcpInfo._ID);
-
-            if (cursor != null) {
-                int num_rows = cursor.getCount();
-                int index;
-                cursor.moveToFirst();
-                int num_colums = cursor.getColumnCount();
-                Logger.e(TAG," number of rows " + num_rows + " num Col " + num_colums);
-                mLock.lock();
-                try {
-                while(num_colums > 0){
-                    switch(num_colums) {
-                    case 1: // Track Num
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TRACK_NUM);
-                        if (index == -1)
-                            break;
-                        int track_num = cursor.getInt(index);
-                        if (track_num == BluetoothAvrcpInfo.TRACK_NUM_INVALID) {
-                            trackNumText = "NOT_SUP";
-                            break;
-                        }
-                        StringBuffer str = new StringBuffer();
-                        str.append(String.valueOf(track_num));
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACKS);
-                        if (index > 0) {
-                            str.append(" | ");
-                            str.append(String.valueOf(cursor.getInt(index)));
-                        }
-                        trackNumText = str.toString();
-                        Logger.e(TAG, " Number of Tracks " + trackNumText);
-                        break;
-                    case 2: // TRACK Title
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TITLE);
-                        if (index == -1)
-                            break;
-                        titleNameText = cursor.getString(index);
-                        Logger.e(TAG, " Track Title " + titleNameText);
-                        break;
-                    case 3: // Artist Name
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.ARTIST_NAME);
-                        if (index == -1)
-                            break;
-                        artistText = cursor.getString(index);
-                        Logger.e(TAG, " Artist Name " + artistText);
-                        break;
-                    case 4: // Album Name
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.ALBUM_NAME);
-                        if (index == -1)
-                            break;
-                        albumText = cursor.getString(index);
-                        Logger.e(TAG, " album_name " + albumText);
-                        break;
-                    case 5: // play time
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAYING_TIME);
-                        if (index == -1)
-                            break;
-                        long playing_time = cursor.getLong(index);
-                        long minutes = TimeUnit.MILLISECONDS.toMinutes(playing_time);
-                        playing_time = playing_time - (60*minutes*1000);
-                        long seconds = TimeUnit.MILLISECONDS.toSeconds(playing_time);
-                        StringBuffer strPlayTime = new StringBuffer();
-                        strPlayTime.append(String.valueOf(minutes));
-                        strPlayTime.append(":");
-                        strPlayTime.append(String.valueOf(seconds));
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACK_TIME);
-                        if (index > 0) {
-                            strPlayTime.append(" | ");
-                            long totalTrackTime = cursor.getLong(index);
-                            minutes = TimeUnit.MILLISECONDS.toMinutes(totalTrackTime);
-                            totalTrackTime = totalTrackTime - (60*minutes*1000);
-                            seconds = TimeUnit.MILLISECONDS.toSeconds(totalTrackTime);
-                            strPlayTime.append(String.valueOf(minutes));
-                            strPlayTime.append(":");
-                            strPlayTime.append(String.valueOf(seconds));
-                        }
-                        playText = strPlayTime.toString();
-                        Logger.e(TAG, " playing_time " + playText);
-                        break;
-                    case 6: //Genre
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.GENRE);
-                        if (index == -1)
-                            break;
-                        genreText = cursor.getString(index);
-                        Logger.e(TAG, " genre  " + genreText);
-                        break;
-                    case 7:// play Status
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAY_STATUS);
-                        if (index == -1)
-                            break;
-                        playStatusText = cursor.getString(index);
-                        Logger.e(TAG, " playStatus  " + playStatusText);
-                        break;
-                    case 8:// Repeat Status
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.REPEAT_STATUS);
-                        if (index == -1)
-                            break;
-                        repeatText = cursor.getString(index);
-                        Logger.e(TAG, " repetStatus  " + repeatText);
-                        break;
-                    case 9:// ShuffleStatus
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.SHUFFLE_STATUS);
-                        if (index == -1)
-                            break;
-                        shuffleText = cursor.getString(index);
-                        Logger.e(TAG, " ShuffleStatus  " + shuffleText);
-                        break;
-                    case 10:// Scan Status
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.SCAN_STATUS);
-                        if (index == -1)
-                            break;
-                        scanText = cursor.getString(index);
-                        Logger.e(TAG, " Scan Status  " + scanText);
-                        break;
-                    case 11:// Eq Status
-                        index = cursor.getColumnIndex(BluetoothAvrcpInfo.EQUALIZER_STATUS);
-                        if (index == -1)
-                            break;
-                        equalizerText = cursor.getString(index);
-                        Logger.e(TAG, " Equalizer Status  " + equalizerText);
-                        break;
-                    }
-                    num_colums --;
-                }
-                } // try end
-                catch(CursorIndexOutOfBoundsException e) {
-                    Log.d(TAG," CursorIndexOutOfBoundsException happended");
-                }
-                catch(SQLiteCantOpenDatabaseException e) {
-                    Log.d(TAG," SQLiteCantOpenDatabaseException happended");
-                }
-                catch(SQLiteException e) {
-                    Log.d(TAG," SQLiteException happended");
-                }
-                finally {
-                    if(cursor != null)
-                        cursor.close();
-                    mLock.unlock();
-                }
-            }
-            else {
-                Logger.v(TAG," Cursor is NULL");
-            }
-            mLocalActivity.runOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    mLock.lock();
-                    try {
-                        mTrackNumber.setText(trackNumText);
-                        mTitleName.setText(titleNameText);
-                        mEqualizerStatus.setText(equalizerText);
-                        mArtistName.setText(artistText);
-                        mScanStatus.setText(scanText);
-                        mShuffleStatus.setText(shuffleText);
-                        mRepeatStatus.setText(repeatText);
-                        mPlayStatus.setText(playStatusText);
-                        mGenreStatus.setText(genreText);
-                        mPlayTime.setText(playText);
-                        mAlbumName.setText(albumText);
-                    }
-                    finally {
-                        mLock.unlock();
-                    }
-                }
-            });
-            mUpdateThread =  null;
-        }
-    }
-    private final ServiceConnection mAvrcpControllerServiceConnection = new ServiceConnection() {
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-            Logger.v(TAG, "onServiceConnected()");
-            mProfileService = ((ProfileService.LocalBinder) service).getService();
-            mAvrcpController = mProfileService.getAvrcpController();
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-            Logger.v(TAG, "onServiceDisconnected()");
-            mProfileService = null;
-            mAvrcpController = null;
-            mDevice = null;
-            remoteSupportedFeatures = 0;
-            if (plSetting != null)
-                plSetting.clear();
-            unregisterMetaDataObserver();
-            resetDisplay();
-            mCTStartButton.setChecked(false);
-        }
-    };
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        Logger.v(TAG, "onCreate()");
-
-        ActivityHelper.initialize(this, R.layout.activity_avrcp_test);
-        BluetoothConnectionReceiver.registerObserver(this);
-        ActivityHelper.setActionBarTitle(this, R.string.title_avrcp_test);
-        mLocalActivity = this;
-        initializeViewFragments();
-        // bind to app service
-        HandlerThread thread = new HandlerThread("BT-TestAppPressandHoldHandler");
-        thread.start();
-        Looper looper = thread.getLooper();
-        mPressandHoldHandler = new PressandHoldHandler(looper);
-        Intent intent = new Intent(this, ProfileService.class);
-        bindService(intent, mAvrcpControllerServiceConnection, BIND_AUTO_CREATE);
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
-        registerReceiver(mAvrcpControllerReceiver, filter);
-    }
-
-    @Override
-    protected void onDestroy() {
-        Logger.v(TAG, "onDestroy");
-        mDevice = null;
-        remoteSupportedFeatures = 0;
-        if (plSetting != null)
-            plSetting.clear();
-        unregisterMetaDataObserver();
-        unregisterReceiver(mAvrcpControllerReceiver);
-        unbindService(mAvrcpControllerServiceConnection);
-        BluetoothConnectionReceiver.removeObserver(this);
-        mPressandHoldHandler.removeCallbacksAndMessages(null);
-        Looper looper = mPressandHoldHandler.getLooper();
-        if (looper != null) {
-            looper.quit();
-        }
-        super.onDestroy();
-    }
-
-    @Override
-    protected void onResume() {
-        Logger.v(TAG, "onResume");
-        super.onResume();
-    }
-
-    @Override
-    protected void onPause() {
-        Logger.v(TAG, "onPause");
-        super.onPause();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        mActionBarMenu = menu;
-        return true;
-    }
-
-    @Override
-    public void onDeviceChanged(BluetoothDevice device) {
-        Logger.v(TAG, "onDeviceChanged() BD = "+ device.getAddress());
-        mDevice = device;
-    }
-
-    @Override
-    public void onDeviceDisconected() {
-        Logger.v(TAG, "onDeviceDisconected");
-        mDevice = null;
-        remoteSupportedFeatures = 0;
-    }
-
-    private void prepareActionBar() {
-        Logger.v(TAG, "prepareActionBar()");
-
-        mActionBar = getActionBar();
-        if (mActionBar != null) {
-            mActionBar.setTitle(R.string.title_avrcp_test);
-            mActionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);
-        }
-    }
-    public boolean isDeviceConnected() {
-        return ((mAvrcpController != null) && mDevice != null &&
-                BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice)));
-    }
-    public void registerMetaDataObserver() {
-       if(!isDeviceConnected()) {
-           Logger.e(TAG," Device not Connected");
-           return;
-       }
-       if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA) == 0) {
-           Logger.e(TAG," Device does not support MetaData");
-           return;
-       }
-       /* check if DataObserver is already registered */
-       if (mAvrcpDataObserver != null)
-           return;
-       Uri avrcpDataUri = BluetoothAvrcpInfo.CONTENT_URI;
-       mAvrcpDataObserver = new BluetoothAvrcpShareContentObserver();
-       getContentResolver().registerContentObserver(avrcpDataUri, true, mAvrcpDataObserver);
-       Logger.v(TAG," Registered Content Observer");
-    }
-    public void unregisterMetaDataObserver() {
-        Logger.d(TAG," unregisterMetaDataObserver");
-        if (mAvrcpDataObserver == null)
-            return;
-        getContentResolver().unregisterContentObserver(mAvrcpDataObserver);
-        mAvrcpDataObserver = null;
-    }
-    public void onClickPassthruPlay(View v) {
-        Logger.v(TAG, "onClickPassthruPlay()");
-        if ((mAvrcpController != null) && mDevice != null &&
-            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PLAY, KEY_STATE_PRESSED);
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PLAY, KEY_STATE_RELEASED);
-        } else {
-            Logger.e(TAG, "passthru command not sent, connection unavailable");
-        }
-    }
-    public void onClickPassthruVolUp(View v) {
-        Logger.v(TAG, "onClickPassthruVolUp()");
-        boolean isA2dpSinkEnabled = SystemProperties.getBoolean("persist.service.bt.a2dp.sink", false);
-        if (isA2dpSinkEnabled) {
-            Logger.v(TAG, "Sink Enabled, not sending VOL UP ");
-            return;
-        }
-        if ((mAvrcpController != null) && mDevice != null &&
-            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_UP, KEY_STATE_PRESSED);
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_UP, KEY_STATE_RELEASED);
-        } else {
-            Logger.e(TAG, "passthru command not sent, connection unavailable");
-        }
-    }
-    public void onClickPassthruVolDown(View v) {
-        Logger.v(TAG, "onClickPassthruVolDown()");
-        boolean isA2dpSinkEnabled = SystemProperties.getBoolean("persist.service.bt.a2dp.sink", false);
-        if (isA2dpSinkEnabled) {
-            Logger.v(TAG, "Sink Enabled, not sending VOL DOWN ");
-            return;
-        }
-        if ((mAvrcpController != null) && mDevice != null &&
-            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_DOWN, KEY_STATE_PRESSED);
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_VOL_DOWN, KEY_STATE_RELEASED);
-        } else {
-            Logger.e(TAG, "passthru command not sent, connection unavailable");
-        }
-    }
-    public void onClickPassthruForward(View v) {
-        Logger.v(TAG, "onClickPassthruForward()");
-        if ((mAvrcpController != null) && mDevice != null &&
-            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FORWARD, KEY_STATE_PRESSED);
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_FORWARD, KEY_STATE_RELEASED);
-        } else {
-            Logger.e(TAG, "passthru command not sent, connection unavailable");
-        }
-    }
-    public void onClickPassthruBackward(View v) {
-        Logger.v(TAG, "onClickPassthruBackward()");
-        if ((mAvrcpController != null) && mDevice != null &&
-            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_BACKWARD, KEY_STATE_PRESSED);
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_BACKWARD, KEY_STATE_RELEASED);
-        } else {
-            Logger.e(TAG, "passthru command not sent, connection unavailable");
-        }
-    }
-    public void onClickToggleRepeat(View v) {
-        Logger.v(TAG, "onClickToggleRepeat()");
-        if ((mAvrcpController == null) ||
-            (mDevice == null)||
-            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
-               return;
-        }
-        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
-            return;
-        }
-        if ((plSetting == null)||(plSetting.isEmpty())) {
-            BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
-            updatePlayerSettings(mMetaData);
-        }
-
-        if ((plSetting == null)||(plSetting.isEmpty())||(repeatText == null)) {
-            Log.w(TAG," not supported, return");
-            return;
-        }
-        for (PlayerSettings sett: plSetting) {
-            Log.d(TAG," finding the current value " + sett.attr_Id);
-            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_REPEAT_STATUS) {
-                int repeat_status;
-                mLock.lock();
-                try {
-                    if(repeatText.equals("REPEAT_OFF"))
-                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_OFF;
-                    else if (repeatText.equals("REPEAT_SINGLE_TRACK_REPEAT"))
-                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_SINGLE_TRACK_REPEAT;
-                    else if (repeatText.equals("REPEAT_GROUP_REPEAT"))
-                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_GROUP_REPEAT;
-                    else if (repeatText.equals("REPEAT_ALL_TRACK_REPEAT"))
-                        repeat_status = BluetoothAvrcpInfo.REPEAT_STATUS_ALL_TRACK_REPEAT;
-                    else {
-                        Log.d(TAG," Repeat not supported ");
-                        return;
-                    }
-                }
-                finally {
-                    mLock.unlock();
-                }
-                for (int zz = 0; zz < sett.supported_values.length; zz++) {
-                    if (repeat_status == sett.supported_values[zz]) {
-                        repeat_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
-                        break;
-                    }
-                }
-                mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, repeat_status);
-                break;
-            }
-        }
-    }
-    public void onClickToggleEq(View v) {
-        Logger.v(TAG, "onClickToggleEq()");
-        if ((mAvrcpController == null) ||
-            (mDevice == null)||
-            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
-               return;
-        }
-        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
-            return;
-        }
-        if ((plSetting == null)||(plSetting.isEmpty())) {
-            BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
-            updatePlayerSettings(mMetaData);
-        }
-        if ((plSetting == null)||(plSetting.isEmpty())||(equalizerText == null)) {
-            Log.w(TAG," not supported, return");
-            return;
-        }
-        for (PlayerSettings sett: plSetting) {
-            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_EQUALIZER_STATUS) {
-                int eq_status;
-                mLock.lock();
-                try {
-                    if(equalizerText.equals("EQUALIZER_OFF"))
-                        eq_status = BluetoothAvrcpInfo.EQUALIZER_STATUS_OFF;
-                    else if (equalizerText.equals("EQUALIZER_ON"))
-                        eq_status = BluetoothAvrcpInfo.EQUALIZER_STATUS_ON;
-                    else {
-                        Log.d(TAG," Equalizer not supported ");
-                        return;
-                    }
-                }
-                finally {
-                    mLock.unlock();
-                }
-                for (int zz = 0; zz < sett.supported_values.length; zz ++) {
-                    if (eq_status == sett.supported_values[zz]) {
-                        eq_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
-                        break;
-                    }
-                }
-                mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, eq_status);
-                break;
-            }
-        }
-    }
-    public void onClickToggleScan(View v) {
-        Logger.v(TAG, "onClickToggleScan()");
-        if ((mAvrcpController == null) ||
-            (mDevice == null)||
-            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
-               return;
-        }
-        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
-            return;
-        }
-        if ((plSetting == null)||(plSetting.isEmpty())) {
-            BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
-            updatePlayerSettings(mMetaData);
-        }
-        if ((plSetting == null)||(plSetting.isEmpty())||(scanText == null)) {
-            Log.w(TAG," not supported, return");
-            return;
-        }
-        for (PlayerSettings sett: plSetting) {
-            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_SCAN_STATUS) {
-                int scan_status;
-                mLock.lock();
-                try {
-                    if(scanText.equals("SCAN_OFF"))
-                        scan_status = BluetoothAvrcpInfo.SCAN_STATUS_OFF;
-                    else if (scanText.equals("SCAN_GROUP_SCAN"))
-                        scan_status = BluetoothAvrcpInfo.SCAN_STATUS_GROUP_SCAN;
-                    else if (scanText.equals("SCAN_ALL_TRACK_SCAN"))
-                        scan_status = BluetoothAvrcpInfo.SCAN_STATUS_ALL_TRACK_SCAN;
-                    else {
-                        Log.d(TAG," Scan not supported ");
-                        return;
-                    }
-                }
-                finally {
-                    mLock.unlock();
-                }
-                for (int zz = 0; zz < sett.supported_values.length; zz ++) {
-                    if (scan_status == sett.supported_values[zz]) {
-                        scan_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
-                        break;
-                    }
-                }
-                mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, scan_status);
-                break;
-            }
-        }
-    }
-    public void onClickToggleShuffle(View v) {
-        Logger.v(TAG, "onClickToggleShuffle()");
-        if ((mAvrcpController == null) ||
-            (mDevice == null)||
-            (BluetoothProfile.STATE_CONNECTED != (mAvrcpController.getConnectionState(mDevice)))) {
-               return;
-        }
-        if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)==0) {
-            return;
-        }
-        if ((plSetting == null)||(plSetting.isEmpty())) {
-            BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
-            updatePlayerSettings(mMetaData);
-        }
-        if ((plSetting == null)||(plSetting.isEmpty())||(shuffleText == null)) {
-            Log.w(TAG," not supported, return");
-            return;
-        }
-        for (PlayerSettings sett: plSetting) {
-            if (sett.attr_Id == BluetoothAvrcpInfo.ATTRIB_SHUFFLE_STATUS) {
-                int shuffle_status;
-                mLock.lock();
-                try {
-                    if(shuffleText.equals("SHUFFLE_OFF"))
-                        shuffle_status = BluetoothAvrcpInfo.SHUFFLE_STATUS_OFF;
-                    else if (shuffleText.equals("SHUFFLE_GROUP_SHUFFLE"))
-                        shuffle_status = BluetoothAvrcpInfo.SHUFFLE_STATUS_GROUP_SHUFFLE;
-                    else if (shuffleText.equals("SHUFFLE_ALL_TRACK_SHUFFLE"))
-                        shuffle_status = BluetoothAvrcpInfo.SHUFFLE_STATUS_ALL_TRACK_SHUFFLE;
-                    else {
-                        Log.d(TAG," Shuffle not supported ");
-                        return;
-                    }
-                }
-                finally {
-                    mLock.unlock();
-                }
-                for (int zz = 0; zz < sett.supported_values.length; zz ++) {
-                    if (shuffle_status == sett.supported_values[zz]) {
-                        shuffle_status = sett.supported_values[(zz + 1)%sett.supported_values.length];
-                        break;
-                    }
-                }
-                mAvrcpController.setPlayerApplicationSetting(sett.attr_Id, shuffle_status);
-                break;
-            }
-        }
-    }
-
-    public void onClickPassthruPause(View v) {
-        Logger.v(TAG, "onClickPassthruPause()");
-        if ((mAvrcpController != null) && mDevice != null &&
-            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PAUSE, KEY_STATE_PRESSED);
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_PAUSE, KEY_STATE_RELEASED);
-        } else {
-            Logger.e(TAG, "passthru command not sent, connection unavailable");
-        }
-    }
-
-    public void onClickPassthruStop(View v) {
-        Logger.v(TAG, "onClickPassthruStop()");
-        if ((mAvrcpController != null) && mDevice != null &&
-            BluetoothProfile.STATE_DISCONNECTED != (mAvrcpController.getConnectionState(mDevice))){
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_STOP, KEY_STATE_PRESSED);
-            mAvrcpController.sendPassThroughCmd(mDevice, AVRC_ID_STOP, KEY_STATE_RELEASED);
-        } else {
-            Logger.e(TAG, "passthru command not sent, connection unavailable");
-        }
-
-    }
-
-    private void updatePlayerSettings(BluetoothAvrcpInfo mData) {
-        if (plSetting != null) {
-            plSetting.clear();
-        }
-        plSetting = new ArrayList<PlayerSettings>();
-        if (mData == null)
-            return;
-        byte[] plAttributes = mData.getSupportedPlayerAttributes();
-        for (int zz = 0; zz < plAttributes.length; zz++) {
-            PlayerSettings playerSetting = new PlayerSettings();
-            playerSetting.attr_Id = plAttributes[zz];
-            playerSetting.supported_values = new byte[mData.getNumSupportedPlayerAttributeVal(playerSetting.attr_Id)];
-            byte[] plAttribSupportedValues = mData.getSupportedPlayerAttributeVlaues(playerSetting.attr_Id);
-            for (int xx = 0; xx < playerSetting.supported_values.length; xx++) {
-                playerSetting.supported_values[xx] = plAttribSupportedValues[xx];
-            }
-            plSetting.add(playerSetting);
-        }
-    }
-    private void resetDisplay() {
-        mLocalActivity.runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                mLock.lock();
-                trackNumText = "NOT_SUPP";
-                titleNameText = BluetoothAvrcpInfo.TITLE_INVALID;
-                equalizerText = BluetoothAvrcpInfo.EQUALIZER_STATUS_INVALID;
-                artistText = BluetoothAvrcpInfo.ARTIST_NAME_INVALID;
-                scanText = BluetoothAvrcpInfo.SCAN_STATUS_INVALID;
-                shuffleText = BluetoothAvrcpInfo.SHUFFLE_STATUS_INVALID;
-                repeatText = BluetoothAvrcpInfo.REPEAT_STATUS_INVALID;
-                playStatusText = BluetoothAvrcpInfo.PLAY_STATUS_INVALID;
-                genreText = BluetoothAvrcpInfo.GENRE_INVALID;
-                playText = BluetoothAvrcpInfo.PLAY_STATUS_INVALID;
-                albumText = BluetoothAvrcpInfo.ALBUM_NAME_INVALID;
-                try {
-                    mTrackNumber.setText(trackNumText);
-                    mTitleName.setText(titleNameText);
-                    mEqualizerStatus.setText(equalizerText);
-                    mArtistName.setText(artistText);
-                    mScanStatus.setText(scanText);
-                    mShuffleStatus.setText(shuffleText);
-                    mRepeatStatus.setText(repeatText);
-                    mPlayStatus.setText(playStatusText);
-                    mGenreStatus.setText(genreText);
-                    mPlayTime.setText(playText);
-                    mAlbumName.setText(albumText);
-                }
-                finally {
-                    mLock.unlock();
-                }
-            }
-        });
-    }
-    private void initializeViewFragments() {
-         Log.v(TAG,"initializeViewFragments");
-         mShuffleStatus = (TextView) findViewById(R.id.shuffle_status);
-         mRepeatStatus = (TextView) findViewById(R.id.repeat_status);
-         mGenreStatus = (TextView) findViewById(R.id.genre_name);
-         mArtistName = (TextView) findViewById(R.id.artist_name);
-         mAlbumName = (TextView) findViewById(R.id.album_name);
-         mPlayTime = (TextView) findViewById(R.id.playing_time);
-         mScanStatus = (TextView) findViewById(R.id.scan_status);
-         mPlayStatus = (TextView) findViewById(R.id.play_status);
-         mEqualizerStatus = (TextView) findViewById(R.id.equalizer_status);
-         mTrackNumber = (TextView) findViewById(R.id.track_number);
-         mTitleName = (TextView) findViewById(R.id.title_name);
-         mCTStartButton = (ToggleButton) findViewById(R.id.toggleButton1);
-         ffButton = (Button) findViewById(R.id.onClickPassthruFF);
-         rwButton = (Button) findViewById(R.id.onClickPassthruRewind);
-         ffButton.setOnTouchListener(onTouchListenerFF);
-         rwButton.setOnTouchListener(onTouchListenerRW);
-    }
-    public void onCTStartToggleClicked(View view) {
-        // Is the toggle on?
-        boolean on = ((ToggleButton) view).isChecked();
-        Log.v(TAG, "onCTStartToggleClicked is_on: " + on);
-        if ((mAvrcpController != null)&&(on)) {
-            List<BluetoothDevice> deviceList = mAvrcpController.getConnectedDevices();
-            if (deviceList.size() > 0) {
-                mDevice = deviceList.get(0);
-                if (mAvrcpController.getConnectionState(mDevice) != BluetoothProfile.STATE_CONNECTED) {
-                    mCTStartButton.setChecked(false);
-                    Toast.makeText(mLocalActivity, "Device Not Connected", Toast.LENGTH_SHORT).show();
-                    return;
-                }
-                remoteSupportedFeatures = mAvrcpController.getSupportedFeatures(mDevice);
-                Log.d(TAG," getSupportedFeatures " + remoteSupportedFeatures);
-                if ((remoteSupportedFeatures & BluetoothAvrcpInfo.BTRC_FEAT_METADATA)!=0) {
-                    BluetoothAvrcpInfo mMetaData = mAvrcpController.getSupportedPlayerAppSetting(mDevice);
-                    updatePlayerSettings(mMetaData);
-                    registerMetaDataObserver();
-                    int[] elementAttribute = new int[1];
-                    elementAttribute[0] = BluetoothAvrcpInfo.MEDIA_ATTRIBUTE_ALL;
-                    mAvrcpController.getMetaData(elementAttribute);
-                }
-                else {
-                    unregisterMetaDataObserver();
-                    resetDisplay();
-                    mCTStartButton.setChecked(false);
-                    Toast.makeText(mLocalActivity, "Device Don't Support MetaData", Toast.LENGTH_SHORT).show();
-                }
-            }
-            else {  // no device connected
-               mCTStartButton.setChecked(false);
-               Toast.makeText(mLocalActivity, "Device Not Connected", Toast.LENGTH_SHORT).show();
-            }
-        } else if(mAvrcpController != null){
-              unregisterMetaDataObserver();
-              resetDisplay();
-        }
-    }
-}
diff --git a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MainActivity.java b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MainActivity.java
old mode 100644
new mode 100755
index 216f924..d8607de
--- a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MainActivity.java
+++ b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MainActivity.java
@@ -116,15 +116,10 @@ public class MainActivity extends MonkeyActivity {
                 if (uuids != null) {
                     for (Parcelable uuid : uuids) {
                          Log.v(TAG, "Received UUID: " + uuid.toString());
-                        if (BluetoothUuid.PBAP_PSE.equals(uuid)) {
+                       /* if (BluetoothUuid.PBAP_PSE.equals(uuid)) {
                             mServicesFragment.addService(ServicesFragment.Service.Type.PBAP, null);
-                        } else if (BluetoothUuid.Handsfree_AG.equals(uuid)) {
+                        } else */if (BluetoothUuid.Handsfree_AG.equals(uuid)) {
                             mServicesFragment.addService(ServicesFragment.Service.Type.HFP, null);
-                        } else if (BluetoothUuid.AvrcpTarget.equals(uuid) ||
-                                    BluetoothUuid.AudioSource.equals(uuid) ||
-                                    BluetoothUuid.AudioSink.equals(uuid)) {
-                            Log.v(TAG, "Adding AVRCP");
-                            mServicesFragment.addService(ServicesFragment.Service.Type.AVRCP, null);
                         }
                     }
                 }
diff --git a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MapTestActivity.java b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MapTestActivity.java
index 6c5a0b9..a5cbd9d 100644
--- a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MapTestActivity.java
+++ b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/MapTestActivity.java
@@ -1517,7 +1517,7 @@ public class MapTestActivity extends MonkeyActivity implements GetTextDialogList
             return false;
         }
 
-        if (!cli.getMessage(handle, charset, attachments)) {
+        if (!cli.getMessage(handle, attachments)) {
             return false;
         }
 
diff --git a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ProfileService.java b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ProfileService.java
old mode 100644
new mode 100755
index d857779..d4ce312
--- a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ProfileService.java
+++ b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ProfileService.java
@@ -54,12 +54,12 @@ import android.bluetooth.client.map.BluetoothMapBmessage;
 import android.bluetooth.client.map.BluetoothMapEventReport;
 import android.bluetooth.client.map.BluetoothMapMessage;
 import android.bluetooth.client.map.BluetoothMasClient;
-import android.bluetooth.client.pbap.BluetoothPbapCard;
+/*import android.bluetooth.client.pbap.BluetoothPbapCard;
 import android.bluetooth.client.pbap.BluetoothPbapClient;
+import org.codeaurora.bluetooth.bttestapp.services.IPbapServiceCallback;
+import org.codeaurora.bluetooth.bttestapp.services.PbapAuthActivity; */
 import org.codeaurora.bluetooth.bttestapp.R;
 import org.codeaurora.bluetooth.bttestapp.services.IMapServiceCallback;
-import org.codeaurora.bluetooth.bttestapp.services.IPbapServiceCallback;
-import org.codeaurora.bluetooth.bttestapp.services.PbapAuthActivity;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -108,12 +108,12 @@ public class ProfileService extends Service {
 
     private BluetoothAvrcpController mAvrcpController = null;
 
-    private BluetoothPbapClient mPbapClient = null;
+  /*  private BluetoothPbapClient mPbapClient = null;
 
     private IPbapServiceCallback mPbapCallback = null;
 
     private final PbapSessionData mPbapSessionData = new PbapSessionData();
-
+*/
     private HashMap<Integer, BluetoothMasClient> mMapClients = null;
 
     private HashMap<Integer, IMapServiceCallback> mMapCallbacks = null;
@@ -126,12 +126,12 @@ public class ProfileService extends Service {
 
     private final IBinder mBinder = new LocalBinder();
 
-    class PbapSessionData {
+/*    class PbapSessionData {
         ArrayList<VCardEntry> pullPhoneBook = null;
         ArrayList<BluetoothPbapCard> pullVcardListing = null;
         VCardEntry pullVcardEntry = null;
     }
-
+*/
     class MapSessionData {
         ArrayList<String> getFolderListing;
         ArrayList<BluetoothMapMessage> getMessagesListing;
@@ -143,7 +143,7 @@ public class ProfileService extends Service {
             return ProfileService.this;
         }
     }
-
+/*
     private final Handler mPbapHandler = new Handler() {
 
         @Override
@@ -239,7 +239,7 @@ public class ProfileService extends Service {
             }
         }
     };
-
+*/
     private final Handler mMapHandler = new Handler() {
 
         @SuppressWarnings("unchecked")
@@ -398,8 +398,6 @@ public class ProfileService extends Service {
 
         public final int MESSAGE_SHIFT_NOTIFICATION_ID = 20008;
 
-        public final int READ_STATUS_CHANGED_NOTIFICATION_ID = 20009;
-
         private final NotificationManager mNotificationManager;
 
         MapNotificationSender() {
@@ -435,9 +433,6 @@ public class ProfileService extends Service {
                 case MESSAGE_SHIFT:
                     notifyMessageShift(eventReport);
                     break;
-                case READ_STATUS_CHANGED:
-                    notifyReadStatusChanged(eventReport);
-                    break;
                 default:
                     Log.e(TAG, "Unknown MAP report type (" + eventReport.getType().toString()
                             + ")!");
@@ -474,25 +469,12 @@ public class ProfileService extends Service {
             click.putExtra(EXTRA_MAP_INSTANCE_ID, instanceId);
             click.putExtra(EXTRA_MAP_MESSAGE_HANDLE, eventReport.getHandle());
 
-            if (eventReport.getVersion() != null && eventReport.getVersion()
-                .equals(BluetoothMapEventReport.EXTENDED_EVENT_REPORT_1_1)) {
-
-                send(NEW_MESSAGE_NOTIFICATION_ID,
-                        String.format(getString(R.string.map_report_notif_received,
-                        eventReport.getMsgType().toString())),
-                        String.format(getString(R.string.map_report11_notif_received_param,
-                        eventReport.getSenderName(), eventReport.getPriority(),
-                        eventReport.getHandle())),
-                        click);
-            } else {
-                send(NEW_MESSAGE_NOTIFICATION_ID,
-                       String.format(getString(R.string.map_report_notif_received,
-                       eventReport.getMsgType().toString())),
-                       String.format(getString(R.string.map_report_notif_handle,
-                       eventReport.getHandle())),
-                       click);
-
-            }
+            send(NEW_MESSAGE_NOTIFICATION_ID,
+                    String.format(getString(R.string.map_report_notif_received, eventReport
+                            .getMsgType().toString())),
+                    String.format(getString(R.string.map_report_notif_handle,
+                            eventReport.getHandle())),
+                    click);
         }
 
         private void notifyDeliverySuccess(BluetoothMapEventReport eventReport) {
@@ -549,13 +531,6 @@ public class ProfileService extends Service {
                     String.format(getString(R.string.map_report_notif_fromto,
                             eventReport.getOldFolder(), eventReport.getFolder())));
         }
-
-        private void notifyReadStatusChanged(BluetoothMapEventReport eventReport) {
-                send(READ_STATUS_CHANGED_NOTIFICATION_ID,
-                        getString(R.string.map_report_notif_title_read_status_changed),
-                        String.format(getString(R.string.map_report_notif_handle,
-                                eventReport.getHandle())));
-        }
     }
 
     BroadcastReceiver mReceiver = new BroadcastReceiver() {
@@ -598,18 +573,18 @@ public class ProfileService extends Service {
                 } else {
                     Log.d(TAG,"AVRCP connection state change not updated");
                 }
-            } else if (PBAP_AUTH_ACTION_RESPONSE.equals(action)) {
+            }/* else if (PBAP_AUTH_ACTION_RESPONSE.equals(action)) {
                 String key = intent.getStringExtra(PBAP_AUTH_EXTRA_KEY);
                 mPbapClient.setAuthResponse(key);
             } else if (PBAP_AUTH_ACTION_CANCEL.equals(action)) {
                 mPbapClient.setAuthResponse(null);
-            } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
+            } */else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
                 BluetoothDevice dev = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
 
                 if (dev.equals(mDevice)) {
-                    if (mPbapClient != null) {
+                /*    if (mPbapClient != null) {
                         mPbapClient.disconnect();
-                    }
+                    }*/
 
                     for (BluetoothMasClient cli : mMapClients.values()) {
                         cli.disconnect();
@@ -620,9 +595,9 @@ public class ProfileService extends Service {
             } else if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)) {
                 int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
                 if (state == BluetoothAdapter.STATE_TURNING_OFF) {
-                    if (mPbapClient != null) {
+                    /*if (mPbapClient != null) {
                         mPbapClient.disconnect();
-                    }
+                    }*/
 
                     for (BluetoothMasClient cli : mMapClients.values()) {
                         cli.disconnect();
@@ -666,7 +641,7 @@ public class ProfileService extends Service {
         }
     };
 
-    private void createPbapAuthNotification() {
+/*    private void createPbapAuthNotification() {
         NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
 
         Intent click = new Intent(this, PbapAuthActivity.class);
@@ -700,7 +675,7 @@ public class ProfileService extends Service {
         Intent intent = new Intent(PBAP_AUTH_ACTION_TIMEOUT);
         sendBroadcast(intent);
     }
-
+*/
     private void checkAndStop(boolean unbind, boolean disconnect) {
         boolean canStop = true;
 
@@ -712,10 +687,10 @@ public class ProfileService extends Service {
                 canStop = false;
             }
 
-            if (mPbapClient != null
+            /*if (mPbapClient != null
                     && mPbapClient.getState() != BluetoothPbapClient.ConnectionState.DISCONNECTED) {
                 canStop = false;
-            }
+            }*/
 
             for (BluetoothMasClient cli : mMapClients.values()) {
                 if (cli.getState() != BluetoothMasClient.ConnectionState.DISCONNECTED) {
@@ -798,11 +773,10 @@ public class ProfileService extends Service {
 
         unregisterReceiver(mReceiver);
 
-        if (mPbapClient != null) {
-            mPbapClient.removeSdp();
+/*        if (mPbapClient != null) {
             mPbapClient.disconnect();
         }
-
+*/
         for (BluetoothMasClient cli : mMapClients.values()) {
             cli.disconnect();
         }
@@ -817,10 +791,10 @@ public class ProfileService extends Service {
             mHfpClient.disconnect(mDevice);
         }
 
-        if (mPbapClient != null) {
+/*        if (mPbapClient != null) {
             mPbapClient.disconnect();
         }
-
+*/
         for (BluetoothMasClient cli : mMapClients.values()) {
             cli.disconnect();
         }
@@ -835,10 +809,7 @@ public class ProfileService extends Service {
             Log.v(TAG, "Current device: none");
         }
 
-        if (mPbapClient != null)
-            mPbapClient.removeSdp();
-
-        mPbapClient = null;
+ //       mPbapClient = null;
         mMapClients = new HashMap<Integer, BluetoothMasClient>();
         mMapSessionData = new HashMap<Integer, MapSessionData>();
     }
@@ -851,13 +822,13 @@ public class ProfileService extends Service {
         return mAvrcpController;
     }
 
-    public BluetoothPbapClient getPbapClient() {
+/*    public BluetoothPbapClient getPbapClient() {
         if (mDevice == null) {
             return null;
         }
 
         if (mPbapClient == null) {
-            mPbapClient = new BluetoothPbapClient(mDevice, mPbapHandler);
+            mPbapClient = new BluetoothPbapClient(mDevice, null, mPbapHandler);
         }
 
         return mPbapClient;
@@ -870,12 +841,11 @@ public class ProfileService extends Service {
     public PbapSessionData getPbapSessionData() {
         return mPbapSessionData;
     }
-
+*/
     public void setMasInstances(SdpMasRecord masrec) {
-            // SDP records might be changed while discovery, hence remove already
-            // existing MAS client & recreate the new one
+            // no need to recreate already existing MAS client
             if (mMapClients.containsKey(masrec.getMasInstanceId())) {
-               mMapClients.remove(masrec.getMasInstanceId());
+               return;
             }
 
             BluetoothMasClient client = new BluetoothMasClient(mDevice, masrec, mMapHandler);
diff --git a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ServicesFragment.java b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ServicesFragment.java
old mode 100644
new mode 100755
index 48533e7..a9bac0e
--- a/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ServicesFragment.java
+++ b/bttestapp/src/org/codeaurora/bluetooth/bttestapp/ServicesFragment.java
@@ -54,9 +54,8 @@ import android.widget.Switch;
 import android.widget.TextView;
 
 import android.bluetooth.BluetoothA2dpSink;
-import android.bluetooth.BluetoothAvrcpController;
 import android.bluetooth.client.map.BluetoothMasClient;
-import android.bluetooth.client.pbap.BluetoothPbapClient;
+//import android.bluetooth.client.pbap.BluetoothPbapClient;
 import org.codeaurora.bluetooth.bttestapp.R;
 
 import org.json.JSONArray;
@@ -99,19 +98,6 @@ public class ServicesFragment extends ListFragment {
                 }
 
                 connEvent = true;
-
-            } else if (ProfileService.ACTION_AVRCP_CONNECTION_STATE.equals(action)) {
-                connState = intent.getBooleanExtra(ProfileService.EXTRA_CONNECTED, false);
-
-                Service srv = new Service(Service.Type.AVRCP, null);
-                idx = mAdapter.getItemPos(srv);
-
-                if (idx < 0) {
-                    Log.w(TAG, "Cannot find AVRCP service item");
-                }
-                Log.v(TAG, "idx: " + idx + " connection state: " + connState);
-                connEvent = true;
-
             } else if (ProfileService.ACTION_PBAP_CONNECTION_STATE.equals(action)) {
                 connState = intent.getBooleanExtra(ProfileService.EXTRA_CONNECTED, false);
 
@@ -166,12 +152,7 @@ public class ServicesFragment extends ListFragment {
                 if (connEvent) {
                     swSrv.setChecked(connState);
                     Service srv = (Service)mAdapter.getItem(idx);
-                    if (srv.mType.equals(Service.Type.AVRCP)) {
-                        Log.w(TAG, "not enabling checkbox as it is AVRCP");
-                        swSrv.setEnabled(false);
-                    } else {
-                        swSrv.setEnabled(true);
-                    }
+                    swSrv.setEnabled(true);
                     swNotif.setEnabled(connState);
                     swNotif.setChecked(false);
                 }
@@ -317,7 +298,7 @@ public class ServicesFragment extends ListFragment {
                         break;
                     }
 
-                    case PBAP: {
+                 /*   case PBAP: {
                         BluetoothPbapClient cli = mActivity.mProfileService.getPbapClient();
 
                         if (cli == null || bluetoothOn == false) {
@@ -346,7 +327,7 @@ public class ServicesFragment extends ListFragment {
                         }
 
                         break;
-                    }
+                    } */
 
                     case MAP: {
                         BluetoothMasClient cli = mActivity.mProfileService
@@ -384,28 +365,6 @@ public class ServicesFragment extends ListFragment {
 
                         break;
                     }
-
-                    case AVRCP: {
-                        Log.v(TAG, "getView: AVRCP");
-                        BluetoothAvrcpController cli = mActivity.mProfileService.getAvrcpController();
-
-                        if (cli == null || bluetoothOn == false) {
-                            swSrv.setChecked(false);
-                            swSrv.setEnabled(false);
-                            break;
-                        }
-
-                        if (cli.getConnectionState(mActivity.mDevice) != BluetoothProfile.STATE_DISCONNECTED) {
-                            Log.v(TAG, "AVRCP Connected: setChecked to True");
-                            swSrv.setChecked(true);
-                            swSrv.setEnabled(false);
-                        } else {
-                            Log.v(TAG, "AVRCP Not Connected: setChecked to False");
-                            swSrv.setChecked(false);
-                            swSrv.setEnabled(false);
-                        }
-                        break;
-                    }
                 }
             }
 
@@ -464,7 +423,7 @@ public class ServicesFragment extends ListFragment {
                         }
                         break;
 
-                    case PBAP:
+                   /* case PBAP:
                         if (isChecked) {
                             if (mActivity.mProfileService.getPbapClient()!= null)
                                 mActivity.mProfileService.getPbapClient().connect();
@@ -475,7 +434,7 @@ public class ServicesFragment extends ListFragment {
                             buttonView.setEnabled(false);
                         }
                         break;
-
+                     */
                     case MAP:
                         BluetoothMasClient cli = mActivity.mProfileService
                             .getMapClient(srv.mSdpMasRecord.getMasInstanceId());
@@ -497,9 +456,6 @@ public class ServicesFragment extends ListFragment {
                             }
                         }
                         break;
-                    case AVRCP:
-                        // not to be handled
-                        break;
                 }
             }
         }
@@ -555,10 +511,10 @@ public class ServicesFragment extends ListFragment {
         if (BluetoothAdapter.getDefaultAdapter().isEnabled() == false) return;
 
         switch (srv.mType) {
-            case PBAP:
+            /*case PBAP:
                 intent = new Intent(getActivity(), PbapTestActivity.class);
                 break;
-
+             */
             case HFP:
                 if (mActivity.mProfileService.getHfpClient() != null)
                     intent = new Intent(getActivity(), HfpTestActivity.class);
@@ -572,16 +528,6 @@ public class ServicesFragment extends ListFragment {
                 intent = new Intent(getActivity(), MapTestActivity.class);
                 intent.putExtra(ProfileService.EXTRA_MAP_INSTANCE_ID, srv.mSdpMasRecord.getMasInstanceId());
                 break;
-
-            case AVRCP:
-                if (mActivity.mProfileService.getAvrcpController() != null)
-                    intent = new Intent(getActivity(), AvrcpTestActivity.class);
-                else {
-                    Log.e(TAG, "AVRCP is not connected");
-                    return;
-                }
-                break;
-
             default:
                 // this should never happen!
                 throw new IllegalArgumentException();
diff --git a/hal/include/hardware/vendor.h b/hal/include/hardware/vendor.h
new file mode 100644
index 0000000..d912a47
--- /dev/null
+++ b/hal/include/hardware/vendor.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 The Linux Foundation. All rights reserved
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_INCLUDE_BT_VENDOR_H
+#define ANDROID_INCLUDE_BT_VENDOR_H
+
+#include <hardware/bluetooth.h>
+
+__BEGIN_DECLS
+
+#define BT_PROFILE_VENDOR_ID "vendor"
+#define BT_PROFILE_WIPOWER_VENDOR_ID "wipower"
+
+/** Callback when bredr cleanup is done.
+ */
+typedef void (*  btvendor_bredr_cleanup_callback)(bool status);
+typedef void (*  btvendor_snooplog_status_callback)(bool status);
+
+
+/** BT-Vendor callback structure. */
+typedef struct {
+    /** set to sizeof(BtVendorCallbacks) */
+    size_t      size;
+    btvendor_bredr_cleanup_callback  bredr_cleanup_cb;
+    btvendor_snooplog_status_callback  update_snooplog_status_cb;
+} btvendor_callbacks_t;
+
+/** Represents the standard BT-Vendor interface.
+ */
+typedef struct {
+
+    /** set to sizeof(BtVendorInterface) */
+    size_t          size;
+
+    /**
+     * Register the BtVendor callbacks
+     */
+    bt_status_t (*init)( btvendor_callbacks_t* callbacks );
+
+    /** Does SSR cleanup */
+    void (*ssrcleanup)(void);
+
+    /** Does BREDR cleanup */
+    void (*bredrcleanup)(void);
+
+    /** Generate level 6 logs */
+    void (*capture_vnd_logs)(void);
+
+    /** Closes the interface. */
+    void  (*cleanup)( void );
+
+    bool (*interop_db_match)( int feature, int type, void *value);
+
+} btvendor_interface_t;
+
+__END_DECLS
+
+#endif /* ANDROID_INCLUDE_BT_VENDOR_H */
+
diff --git a/hal/include/hardware/wipower.h b/hal/include/hardware/wipower.h
new file mode 100644
index 0000000..eb3a0ee
--- /dev/null
+++ b/hal/include/hardware/wipower.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_INCLUDE_WIPOWER_H
+#define ANDROID_INCLUDE_WIPOWER_H
+
+#include <stdint.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <stdbool.h>
+
+#include <hardware/hardware.h>
+#include <hardware/bluetooth.h>
+
+__BEGIN_DECLS
+
+typedef enum {
+   OFF =0,
+   ON
+} wipower_state_t;
+
+
+typedef struct {
+
+unsigned char optional;
+unsigned short rect_voltage;
+unsigned short rect_current;
+unsigned short out_voltage;
+unsigned short out_current;
+unsigned char temp;
+unsigned short rect_voltage_min;
+unsigned short rect_voltage_set;
+unsigned short rect_voltage_max;
+unsigned char alert;
+unsigned short rfu1;
+unsigned char rfu2;
+
+}__attribute__((packed)) wipower_dyn_data_t;
+
+/** Bluetooth Enable/Disable Callback. */
+typedef void (*wipower_state_changed_callback)(wipower_state_t state);
+
+
+typedef void (*wipower_alerts)(unsigned char alert);
+
+
+typedef void (*wipower_dynamic_data)(wipower_dyn_data_t* alert_data);
+
+
+typedef void (*wipower_power_apply)(unsigned char power_flag);
+
+typedef void (*callback_thread_event)(bt_cb_thread_evt evt);
+
+/** Bluetooth DM callback structure. */
+typedef struct {
+    /** set to sizeof(wipower_callbacks_t) */
+    size_t size;
+    wipower_state_changed_callback wipower_state_changed_cb;
+    wipower_alerts wipower_alert;
+    wipower_dynamic_data wipower_data;
+    wipower_power_apply wipower_power_event;
+    callback_thread_event callback_thread_event;
+} wipower_callbacks_t;
+
+
+/** Represents the standard Wipower interface. */
+typedef struct {
+    /** set to sizeof(wipower_interface_t) */
+    size_t size;
+
+    /** Initialize Wipower modules*/
+    int (*init)(wipower_callbacks_t *wp_callbacks);
+
+    /** Enable/Disable Wipower charging */
+    int (*enable)(bool enable);
+
+    int (*set_current_limit)(short value);
+
+    unsigned char (*get_current_limit)(void);
+
+    wipower_state_t (*get_state)(void);
+
+    /** Enable/Disable Wipower charging */
+    int (*enable_alerts)(bool enable);
+
+    int (*enable_data_notify)(bool enable);
+    int (*enable_power_apply)(bool enable, bool on, bool time_flag);
+} wipower_interface_t;
+
+
+__END_DECLS
+
+#endif /* ANDROID_INCLUDE_WIPOWER_H */
diff --git a/hiddtestapp/Android.mk b/hiddtestapp/Android.mk
index 13de015..b05b668 100644
--- a/hiddtestapp/Android.mk
+++ b/hiddtestapp/Android.mk
@@ -1,6 +1,7 @@
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
+ifeq (0,1)
 LOCAL_MODULE_TAGS := optional
 
 LOCAL_SRC_FILES := \
@@ -14,3 +15,4 @@ LOCAL_PROGUARD_ENABLED := disabled
 include $(BUILD_PACKAGE)
 
 include $(call all-makefiles-under,$(LOCAL_PATH))
+endif
diff --git a/hidtestapp/Android.mk b/hidtestapp/Android.mk
new file mode 100644
index 0000000..f78e3aa
--- /dev/null
+++ b/hidtestapp/Android.mk
@@ -0,0 +1,20 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_TAGS := optional
+src_dirs:= src/org/codeaurora/bluetooth/hidtestapp \
+
+LOCAL_SRC_FILES := \
+        $(call all-java-files-under, $(src_dirs)) \
+
+LOCAL_PACKAGE_NAME := HidTestApp
+LOCAL_CERTIFICATE := platform
+
+LOCAL_PROGUARD_ENABLED := disabled
+
+LOCAL_MULTILIB:= 32
+
+include $(BUILD_PACKAGE)
+
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/hidtestapp/AndroidManifest.xml b/hidtestapp/AndroidManifest.xml
new file mode 100644
index 0000000..174b77c
--- /dev/null
+++ b/hidtestapp/AndroidManifest.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="org.codeaurora.bluetooth.hidtestapp">
+
+    <uses-sdk
+        android:minSdkVersion="14"
+        android:targetSdkVersion="23" />
+
+    <uses-permission android:name="android.permission.BLUETOOTH" />
+    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
+    <uses-permission android:name="android.permission.BLUETOOTH_STACK" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/qti"
+        android:label="@string/app_name" >
+        <activity
+            android:name="org.codeaurora.bluetooth.hidtestapp.HidTestApp"
+            android:configChanges="orientation|keyboardHidden|screenSize"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/hidtestapp/ReleaseNote.txt b/hidtestapp/ReleaseNote.txt
new file mode 100644
index 0000000..1f9b976
--- /dev/null
+++ b/hidtestapp/ReleaseNote.txt
@@ -0,0 +1,41 @@
+============================
+﻿Version 1.0
+============================
+Steps:
+1) Install the hid.apk
+2) Enter BD Address of remote device in format AA:BB:CC:DD:EE:FF
+3) Enter the command to be executed, refer below for details.
+NOTE: This step would be required before running PTS test case, as after
+connecting with PTS, input keyboard doesnot work from DUT, or as another
+option, please connect DUT with any other remote BT keyboard and use it
+for entering text once connected with PTS.
+4) Press execute
+
+TC_HOS_HID_BV_01_C - Verify host can send correct Get Report command .
+getreport 1 1 0
+
+TC_HOS_HID_BV_02_C - Verify host can send Force the IUT to send a Set_Report command to the PTS.
+setreport 2 a
+
+TC_HOS_HID_BV_03_C - Verify host can send Get protocol Command.
+getprotocolmode
+
+TC_HOS_HID_BV_04_C - Verify host can send Set protocol command.
+setprotocolmode 0
+
+TC_HOS_HID_BV_05_C - Verify host can send correct Get idle command.
+getidle
+TC_HOS_HID_BV_06_C - Verify host can send correct Set idle command.
+setidle 10
+
+TC_HOS_DAT_BV_01_C - Verify Host correctly send report shorter than MTU.
+senddata <data shorter than mtu>
+
+TC_HOS_DAT_BV_02_C - Verify Host send reports correctly larger than MTU.
+senddata <data larger than mtu>
+
+TC_HOS_HDT_BV_01_I/TC_HOS_HDT_BV_02_I - Verify Host correctly send send data.
+senddata <data to be sent>
+
+TC_HOS_HCR_BV_03 - Verify Host correctly send virtual unplug.
+virtualunplug
diff --git a/hidtestapp/res/drawable/qti.png b/hidtestapp/res/drawable/qti.png
new file mode 100755
index 0000000..36233d1
Binary files /dev/null and b/hidtestapp/res/drawable/qti.png differ
diff --git a/hidtestapp/res/layout/hidtestapp.xml b/hidtestapp/res/layout/hidtestapp.xml
new file mode 100644
index 0000000..643071c
--- /dev/null
+++ b/hidtestapp/res/layout/hidtestapp.xml
@@ -0,0 +1,57 @@
+<!--
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <EditText
+        android:id="@+id/id_et_btaddress"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:padding="10dp"
+        android:hint="@string/txt_hint_btaddress"
+        />
+    <EditText
+        android:id="@+id/id_et_btcommand"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:padding="10dp"
+        android:hint="@string/txt_hint_command"
+        />
+    <Button
+        android:id="@+id/id_btn_execute"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:padding="10dp"
+        android:text="@string/btn_label"
+        />
+</LinearLayout>
diff --git a/hidtestapp/res/values/strings.xml b/hidtestapp/res/values/strings.xml
new file mode 100644
index 0000000..1535138
--- /dev/null
+++ b/hidtestapp/res/values/strings.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+-->
+<resources>
+    <string name="app_name">hid</string>
+    <string name="btn_label">Execute</string>
+    <string name="txt_hint_btaddress">BD Address</string>
+    <string name="txt_hint_command">HID Command</string>
+</resources>
diff --git a/hidtestapp/src/org/codeaurora/bluetooth/hidtestapp/HidTestApp.java b/hidtestapp/src/org/codeaurora/bluetooth/hidtestapp/HidTestApp.java
new file mode 100644
index 0000000..9ab7623
--- /dev/null
+++ b/hidtestapp/src/org/codeaurora/bluetooth/hidtestapp/HidTestApp.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.codeaurora.bluetooth.hidtestapp;
+
+import android.app.Activity;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.IBluetooth;
+import android.bluetooth.IBluetoothInputDevice;
+import android.bluetooth.BluetoothInputDevice;
+import android.bluetooth.BluetoothProfile.ServiceListener;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+import android.widget.Toast;
+
+public class HidTestApp extends Activity implements OnClickListener {
+	private static final String TAG = "HidTestApp";
+	private static BluetoothInputDevice mService = null;
+	private BluetoothAdapter mAdapter;
+	private BluetoothDevice mRemoteDevice;
+	private Context mContext;
+
+	private EditText mEtBtAddress, mEtBtCommand;
+	private Button mBtnExecute;
+
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		// TODO Auto-generated method stub
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.hidtestapp);
+		Log.i(TAG, "On Create ");
+		mEtBtAddress = (EditText) findViewById(R.id.id_et_btaddress);
+		mEtBtCommand = (EditText) findViewById(R.id.id_et_btcommand);
+		mBtnExecute = (Button) findViewById(R.id.id_btn_execute);
+		mBtnExecute.setOnClickListener(this);
+		mContext = getApplicationContext();
+		mAdapter = BluetoothAdapter.getDefaultAdapter();
+		init();
+	}
+
+	@Override
+	protected void onDestroy() {
+		// TODO Auto-generated method stub
+		super.onDestroy();
+		deinit();
+	}
+
+	@Override
+	public void onClick(View v) {
+		if (v == mBtnExecute) {
+			executeCommand();
+		}
+
+	}
+
+	private boolean executeCommand() {
+
+		boolean isValid = true;
+		String address = mEtBtAddress.getText().toString().trim();
+		String command = mEtBtCommand.getText().toString().trim();
+		Log.e(TAG, "address = " + address);
+		Log.e(TAG, "command = " + command);
+		if (address.length() != 17) {
+			mEtBtAddress.setError("Enter Proper Address");
+			isValid = false;
+		} else if (command.length() == 0) {
+			mEtBtCommand.setError("Enter proper command");
+			isValid = false;
+		}
+
+		if (isValid) {
+		    /* Make sure that all the address bytes are in upper case */
+			String addSplit[] = address.split(":");
+			address = addSplit[0].toUpperCase() + ":" + addSplit[1].toUpperCase() + ":" +
+				addSplit[2].toUpperCase() + ":" + addSplit[3].toUpperCase() + ":" +
+				addSplit[4].toUpperCase() + ":" + addSplit[5].toUpperCase();
+			Log.e(TAG, "address = " + address);
+			try {
+				mRemoteDevice = mAdapter.getRemoteDevice(address);
+			} catch (IllegalArgumentException e) {
+				Toast.makeText(mContext, "Invalid BD Address", Toast.LENGTH_LONG).show();
+				return false;
+			}
+			String[] separated = command.split(" ");
+			int len = separated.length;
+
+			if (len > 0) {
+				if (separated[0].equals("getreport")) {
+					if (len != 4) {
+						Toast.makeText(mContext, "Invalid getreport command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+						try {
+							int reportType = Integer.parseInt(separated[1]);
+							int reportId = Integer.parseInt(separated[2]);
+							int bufferSize = Integer.parseInt(separated[3]);
+							Log.v(TAG," reportType " + reportType);
+							Log.v(TAG," reportId " + reportId);
+							Log.v(TAG," bufferSize " + bufferSize);
+							getReport(mRemoteDevice, (byte)reportType, (byte)reportId, bufferSize);
+							Toast.makeText(mContext, "getreport command sent", Toast.LENGTH_LONG).show();
+						} catch(NumberFormatException e) {
+							Toast.makeText(mContext, "getreport input parameters exception",
+                                                               Toast.LENGTH_LONG).show();
+						}
+					}
+				} else if (separated[0].equals("setreport")) {
+					if (len != 3) {
+						Toast.makeText(mContext, "Invalid setreport command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+						try {
+							int reportType = Integer.parseInt(separated[1]);
+							Log.v(TAG," reportType " + reportType);
+							Log.v(TAG," report " + separated[2]);
+							setReport(mRemoteDevice, (byte)reportType, separated[2]);
+							Toast.makeText(mContext, "setreport command sent", Toast.LENGTH_LONG).show();
+						} catch(NumberFormatException e) {
+							Toast.makeText(mContext, "setreport input parameters exception",
+                                                               Toast.LENGTH_LONG).show();
+						}
+					}
+				}  else if (separated[0].equals("virtualunplug")) {
+					if (len != 1) {
+						Toast.makeText(mContext, "Invalid virtualunplug command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+					    virtualUnplug(mRemoteDevice);
+						Toast.makeText(mContext, "virtualunplug command sent", Toast.LENGTH_LONG).show();
+					}
+				} else if (separated[0].equals("getprotocolmode")) {
+					if (len != 1) {
+						Toast.makeText(mContext, "Invalid getprotocolmode command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+					    getProtocolMode(mRemoteDevice);
+						Toast.makeText(mContext, "getprotocolmode command sent", Toast.LENGTH_LONG).show();
+					}
+				} else if (separated[0].equals("setprotocolmode")) {
+					if (len != 2) {
+						Toast.makeText(mContext, "Invalid setprotocolmode command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+						try {
+							int mode = Integer.parseInt(separated[1]);
+							Log.v(TAG," mode " + mode);
+							setProtocolMode(mRemoteDevice, mode);
+							Toast.makeText(mContext, "setprotocolmode command sent", Toast.LENGTH_LONG).show();
+						} catch(NumberFormatException e) {
+							Toast.makeText(mContext, "setprotocolmode input parameters exception",
+                                                               Toast.LENGTH_LONG).show();
+						}
+					}
+				} else if (separated[0].equals("getidle")) {
+					if (len != 1) {
+						Toast.makeText(mContext, "Invalid getidle command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+					    getIdleTime(mRemoteDevice);
+						Toast.makeText(mContext, "getidle command sent", Toast.LENGTH_LONG).show();
+					}
+				} else if (separated[0].equals("setidle")) {
+					if (len != 2) {
+						Toast.makeText(mContext, "Invalid setidle command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+						try {
+							int idleTime = Integer.parseInt(separated[1]);
+							Log.v(TAG," idleTime " + idleTime);
+							setIdleTime(mRemoteDevice, (byte)idleTime);
+							Toast.makeText(mContext, "setidle command sent", Toast.LENGTH_LONG).show();
+						} catch(NumberFormatException e) {
+							Toast.makeText(mContext, "setidle input parameters exception",
+                                                               Toast.LENGTH_LONG).show();
+						}
+					}
+				} else if (separated[0].equals("senddata")) {
+					if (len != 2) {
+						Toast.makeText(mContext, "Invalid senddata command", Toast.LENGTH_LONG).show();
+						isValid = false;
+					} else {
+						Log.v(TAG," report " + separated[1]);
+						sendData(mRemoteDevice, separated[1]);
+						Toast.makeText(mContext, "senddata command sent", Toast.LENGTH_LONG).show();
+					}
+				} else {
+					Toast.makeText(mContext, "Invalid command", Toast.LENGTH_LONG).show();
+					Log.v(TAG," Invalid command " + separated[0]);
+					isValid = false;
+				}
+			}
+		}
+		return isValid;
+
+	}
+
+    public void init() {
+        if (!mAdapter.getProfileProxy(mContext, mServiceListener,
+                BluetoothProfile.INPUT_DEVICE)) {
+            Log.w(TAG, "Cannot obtain profile proxy");
+            return;
+        }
+    }
+
+    public void deinit() {
+        if (mService != null) {
+            mAdapter.closeProfileProxy(BluetoothProfile.INPUT_DEVICE, mService);
+        }
+    }
+
+    boolean getProtocolMode(BluetoothDevice device) {
+        if (mService == null) return false;
+        return mService.getProtocolMode(device);
+    }
+
+    boolean setProtocolMode(BluetoothDevice device, int mode) {
+        if (mService == null) return false;
+        return mService.setProtocolMode(device, mode);
+    }
+
+    boolean virtualUnplug(BluetoothDevice device) {
+        if (mService == null) return false;
+        return mService.virtualUnplug(device);
+    }
+
+    boolean getReport(BluetoothDevice device, byte reportType, byte reportId, int bufferSize) {
+        if (mService == null) return false;
+        return mService.getReport(device, reportType, reportId, bufferSize);
+    }
+
+    boolean setReport(BluetoothDevice device, byte reportType, String report) {
+        if (mService == null) return false;
+        return mService.setReport(device, reportType, report);
+    }
+
+    boolean sendData(BluetoothDevice device, String report) {
+        if (mService == null) return false;
+        return mService.sendData(device, report);
+    }
+
+    boolean getIdleTime(BluetoothDevice device) {
+        if (mService == null) return false;
+        return mService.getIdleTime(device);
+    }
+
+    boolean setIdleTime(BluetoothDevice device, byte idleTime) {
+        if (mService == null) return false;
+        return mService.setIdleTime(device, idleTime);
+    }
+
+    private final ServiceListener mServiceListener = new ServiceListener() {
+
+        @Override
+        public void onServiceConnected(int profile, BluetoothProfile proxy) {
+            if (profile != BluetoothProfile.INPUT_DEVICE) return;
+
+            Log.i(TAG, "Profile proxy connected");
+
+            mService = (BluetoothInputDevice) proxy;
+
+        }
+
+        @Override
+        public void onServiceDisconnected(int profile) {
+            if (profile != BluetoothProfile.INPUT_DEVICE) return;
+
+            Log.i(TAG, "Profile proxy disconnected");
+
+            mService = null;
+        }
+    };
+}
diff --git a/libbt-logClient/Android.mk b/libbt-logClient/Android.mk
new file mode 100644
index 0000000..c04666c
--- /dev/null
+++ b/libbt-logClient/Android.mk
@@ -0,0 +1,34 @@
+LOCAL_PATH := $(call my-dir)
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_QCOM),true)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+        src/bt_vendor_logc.c
+
+LOCAL_C_INCLUDES += \
+        $(LOCAL_PATH)/include \
+        system/bt/include \
+
+LOCAL_SHARED_LIBRARIES := \
+        libcutils \
+        liblog
+
+LOCAL_MODULE := libbt-logClient
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := SHARED_LIBRARIES
+LOCAL_MODULE_OWNER := qcom
+
+ifdef TARGET_2ND_ARCH
+LOCAL_MODULE_PATH_32 := $(TARGET_OUT_VENDOR)/lib
+LOCAL_MODULE_PATH_64 := $(TARGET_OUT_VENDOR)/lib64
+else
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR_SHARED_LIBRARIES)
+endif
+
+#include $(LOCAL_PATH)/vnd_buildcfg.mk
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif # BOARD_HAVE_BLUETOOTH_QCOM
diff --git a/libbt-logClient/src/bt_vendor_logc.c b/libbt-logClient/src/bt_vendor_logc.c
new file mode 100644
index 0000000..7e428b5
--- /dev/null
+++ b/libbt-logClient/src/bt_vendor_logc.c
@@ -0,0 +1,294 @@
+/******************************************************************************
+Copyright (c) 2016, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Filename:      bt_vendor_logc.c
+ *
+ *  Description:   Bluetooth logger client
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_loglib"
+
+#include <utils/Log.h>
+#include <cutils/properties.h>
+#include <string.h>
+#include <fcntl.h>
+#include <termios.h>
+#include "bt_logger_lib.h"
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <linux/un.h>
+#include <sys/poll.h>
+
+#define SOCKET_NAME "btloggersock"
+
+#define CONN_MAX_TRIALS 2
+#define TIME_STR_SIZE 13
+
+#define VND_PKT_SIZE_BLOCKS 2
+#define VND_PKT_HEADER_SIZE 3   //(VND_PKT_SIZE_BLOCKS + 1)
+#define VND_PKT_BODY_SIZE 1021
+#define VND_LOG_BUFF_SIZE 1024  // (VND_PKT_HEADER_SIZE+VND_PKT_BODY_SIZE)
+#define VND_LOG_INFO_SIZE 6     // 5 bytes tid + 1
+
+#define DBG 1
+
+// Re-run |fn| system call until the system call doesn't cause EINTR.
+#define BTLOG_NO_INTR(fn) do {} while ((fn) == -1 && errno == EINTR)
+
+/******************************************************************************
+**  Externs
+******************************************************************************/
+
+
+/******************************************************************************
+**  Variables
+******************************************************************************/
+int client_sock;
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+void lib_log(const char *fmt_str, ...)
+{
+    if (DBG) {
+        static char buff[1024];
+        va_list ap;
+
+        va_start(ap, fmt_str);
+        vsnprintf(buff, 1024, fmt_str, ap);
+        va_end(ap);
+
+        ALOGE("%s", buff);
+    }
+}
+
+
+int connect_to_logger_server(void)
+{
+    struct sockaddr_un serv_addr;
+    int sock, ret = -1, i, addr_len;
+
+    BTLOG_NO_INTR(sock = socket(AF_LOCAL, SOCK_STREAM, 0));
+    if (sock < 0) {
+        lib_log("%s, client socket creation failed: %s\n", __func__, strerror(errno));
+        return -1;
+    }
+
+    memset(&serv_addr, 0, sizeof(serv_addr));
+    serv_addr.sun_family = AF_LOCAL;
+    strlcpy(&serv_addr.sun_path[1], SOCKET_NAME, strlen(SOCKET_NAME) + 1);
+    addr_len =  strlen(SOCKET_NAME) + 1;
+    addr_len += sizeof(serv_addr.sun_family);
+
+    for (i = 0; (ret < 0) && (i < CONN_MAX_TRIALS); i++) {
+        BTLOG_NO_INTR(ret = connect(sock, (struct sockaddr*)&serv_addr, addr_len));
+        if (ret < 0) {
+            lib_log("%s, failed to connect to logger process: %s\n", __func__, strerror(errno));
+            usleep(100000);
+        }
+    }
+
+    if (ret < 0) {
+        close(sock);
+        return -1;
+    }
+
+    lib_log("%s, Connected to logger process, socket fd: %d", __func__, sock);
+    return sock;
+}
+
+static void send_log(char *buff, int buff_size)
+{
+    int ret = 0;
+
+    if (client_sock < 0) {
+        return;
+    }
+
+    BTLOG_NO_INTR(ret = send(client_sock, buff, buff_size, 0));
+    if ( ret < 0 && errno == ECONNRESET) {
+        lib_log("%s, Connection closed", __func__);
+        close(client_sock);
+        return;
+    }
+
+    return;
+}
+
+unsigned short int format_time_str(char *curr_time)
+{
+    struct timeval tval;
+    unsigned short int t_size, t_hh, t_mm, t_ss;
+
+    gettimeofday(&tval, NULL);
+    t_hh = tval.tv_sec / 3600;
+    tval.tv_sec = tval.tv_sec % 3600;
+    t_mm = tval.tv_sec / 60;
+    t_ss = tval.tv_sec % 60;
+
+    t_size = snprintf(curr_time, TIME_STR_SIZE, "%.2d:%.2d:%.2d:%.3d", t_hh, t_mm, t_ss, (int)(tval.tv_usec / 1000));
+    return t_size;
+}
+
+unsigned short int create_log_info(const char *tag, char *buff)
+{
+    pid_t tid;
+    unsigned short int tag_size, time_size, info_size;
+    char time_str[TIME_STR_SIZE];
+
+    time_size = format_time_str(time_str);
+
+    tag_size = strlen(tag) + 2;
+    tid = gettid();
+
+    info_size = snprintf(&buff[VND_PKT_HEADER_SIZE], VND_LOG_INFO_SIZE + tag_size + time_size, "%s\t%d\t%s:\t", time_str, tid, tag) - 1;
+    return info_size;
+}
+
+/*****************************************************************************
+**
+**   BLUETOOTH VENDOR LOGGER LIBRARY FUNCTIONS
+**
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function         init
+**
+** Description      First function to be called after linking to the library.
+**                  Modules call this function to initiate logging with
+**                  Bluetooth Logger Process.
+**                  It open a client socket and connects to server socket of
+**                  Logger process.
+**
+** Parameters:      Void
+
+** Returns          true if socket connection is successful, false otherwise.
+**
+*******************************************************************************/
+static int init(void)
+{
+    lib_log("%s", __func__);
+
+    client_sock = connect_to_logger_server();
+    if (client_sock < 0)
+        return -1;
+    return true;
+}
+
+/*******************************************************************************
+**
+** Function         send_log
+**
+** Description      It is called to send logs to Logger process.
+**                  It formats the log string received and writes to the socket
+**                  to Bluetooth Logger Process.
+**
+** Parameters:      String
+
+** Returns          void
+**
+*******************************************************************************/
+static void send_log_msg(const char *tag, const char *fmt_str, va_list ap)
+{
+    int info_size, log_size = 0;
+    char buffer[VND_LOG_BUFF_SIZE];
+
+    buffer[0] = VENDOR_LOGGER_LOGS;
+
+    info_size = create_log_info(tag, buffer);
+
+    if (info_size + VND_PKT_HEADER_SIZE < VND_LOG_BUFF_SIZE)
+        log_size = vsnprintf(&buffer[VND_PKT_HEADER_SIZE + info_size], VND_PKT_BODY_SIZE - info_size, fmt_str, ap);
+
+    log_size += info_size;
+    *(( unsigned short*)(&buffer[1])) = log_size;
+
+    send_log(buffer, VND_PKT_HEADER_SIZE + log_size);
+
+    return;
+}
+
+static void send_log_data(const char *tag, const char *fmt_str, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt_str);
+    send_log_msg(tag, fmt_str, ap);
+    va_end(ap);
+
+    return;
+}
+
+static void send_event(char evt)
+{
+    send_log(&evt, 1);
+}
+
+/*******************************************************************************
+**
+** Function         cleanup
+**
+** Description      It is called during cleanup after BT is turned Off
+**                  Will send the safe shutdown packet to BT Logger process
+**                  and then close the client connection with server socket.
+**
+** Parameters:      Void
+
+** Returns          true if socket connection is closed successfully, false
+**                  otherwise.
+**
+*******************************************************************************/
+static int cleanup(void)
+{
+    lib_log(__func__);
+    if (client_sock > 0) {
+        send_event(STOP_LOGGING_SIGNAL);
+        close(client_sock);
+        client_sock = -1;
+    }
+    return true;
+}
+
+const bt_logger_interface_t BLUETOOTH_LOGGER_LIB_INTERFACE = {
+    sizeof(bt_logger_interface_t),
+    init,
+    send_log_msg,
+    send_log_data,
+    send_event,
+    cleanup
+};
diff --git a/src/org/codeaurora/bluetooth/dun/BluetoothDunPermissionActivity.java b/src/org/codeaurora/bluetooth/dun/BluetoothDunPermissionActivity.java
index 74ffd94..c1c3380 100644
--- a/src/org/codeaurora/bluetooth/dun/BluetoothDunPermissionActivity.java
+++ b/src/org/codeaurora/bluetooth/dun/BluetoothDunPermissionActivity.java
@@ -220,7 +220,8 @@ public class BluetoothDunPermissionActivity extends AlertActivity implements
         }
         Intent i = getIntent();
         if (i.hasExtra(BluetoothDunService.EXTRA_BLUETOOTH_DEVICE)) {
-            intent.putExtra(BluetoothDunService.EXTRA_BLUETOOTH_DEVICE, i.getParcelableExtra(BluetoothDunService.EXTRA_BLUETOOTH_DEVICE));
+            intent.putExtra(BluetoothDunService.EXTRA_BLUETOOTH_DEVICE,
+                (BluetoothDevice)i.getParcelableExtra(BluetoothDunService.EXTRA_BLUETOOTH_DEVICE));
         }
         sendBroadcast(intent);
     }
diff --git a/src/org/codeaurora/bluetooth/dun/BluetoothDunReceiver.java b/src/org/codeaurora/bluetooth/dun/BluetoothDunReceiver.java
index 65f8ce1..60f3dc7 100644
--- a/src/org/codeaurora/bluetooth/dun/BluetoothDunReceiver.java
+++ b/src/org/codeaurora/bluetooth/dun/BluetoothDunReceiver.java
@@ -34,13 +34,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.util.Log;
 import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.app.ActivityManager;
-import android.app.ActivityThread;
-import android.content.pm.UserInfo;
-import android.os.Binder;
-import android.os.Process;
 
 public class BluetoothDunReceiver extends BroadcastReceiver {
 
@@ -48,33 +41,6 @@ public class BluetoothDunReceiver extends BroadcastReceiver {
 
     private static final boolean V = BluetoothDunService.VERBOSE;
 
-    public static boolean checkCaller() {
-        boolean ok;
-        // Get the caller's user id then clear the calling identity
-        // which will be restored in the finally clause.
-        int callingUser = UserHandle.getCallingUserId();
-        int callingUid = Binder.getCallingUid();
-        long ident = Binder.clearCallingIdentity();
-
-        try {
-            // With calling identity cleared the current user is the foreground user.
-            int foregroundUser = ActivityManager.getCurrentUser();
-            ok = (foregroundUser == callingUser);
-            if (!ok) {
-                // Always allow SystemUI/System access.
-                int systemUiUid = ActivityThread.getPackageManager().getPackageUid(
-                        "com.android.systemui", UserHandle.USER_OWNER);
-                ok = (systemUiUid == callingUid) || (Process.SYSTEM_UID == callingUid);
-            }
-        } catch (Exception ex) {
-            Log.e(TAG, "checkIfCallerIsSelfOrForegroundUser: Exception ex=" + ex);
-            ok = false;
-        } finally {
-            Binder.restoreCallingIdentity(ident);
-        }
-        return ok;
-    }
-
     @Override
     public void onReceive(Context context, Intent intent) {
 
@@ -84,11 +50,6 @@ public class BluetoothDunReceiver extends BroadcastReceiver {
 
         if (V) Log.v(TAG, "DunReceiver onReceive ");
 
-        if (!checkCaller()) {
-            Log.w(TAG, "onReceive received for non-active user, ignoring");
-            return;
-        }
-
         Intent in = new Intent();
         in.putExtras(intent);
         in.setClass(context, BluetoothDunService.class);
diff --git a/src/org/codeaurora/bluetooth/dun/BluetoothDunService.java b/src/org/codeaurora/bluetooth/dun/BluetoothDunService.java
index ea98ebe..db77578 100644
--- a/src/org/codeaurora/bluetooth/dun/BluetoothDunService.java
+++ b/src/org/codeaurora/bluetooth/dun/BluetoothDunService.java
@@ -28,6 +28,7 @@
 
 package org.codeaurora.bluetooth.dun;
 
+import android.app.Service;
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
@@ -35,10 +36,14 @@ import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothDun;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.IBluetoothDun;
+import android.net.ConnectivityManager;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
 import android.os.Message;
+import android.os.ServiceManager;
 import android.util.Log;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -65,6 +70,8 @@ import android.content.ComponentName;
 import android.os.RemoteException;
 import org.codeaurora.bluetooth.R;
 import android.content.SharedPreferences;
+import android.telephony.TelephonyManager;
+import com.android.internal.telephony.ITelephony;
 
 /**
  * Provides Bluetooth Dun profile, as a service in the BluetoothExt APK.
@@ -267,6 +274,10 @@ public class BluetoothDunService extends Service {
 
     private BluetoothAdapter mAdapter;
 
+    private DunServiceMessageHandler mDunHandler;
+
+    private ITelephony mTelephonyService;
+
     /**
      * package and class name to which we send intent to check DUN profile
      * access permission
@@ -298,6 +309,18 @@ public class BluetoothDunService extends Service {
 
         mAdapter = BluetoothAdapter.getDefaultAdapter();
         mDunBinder = initBinder();
+
+        HandlerThread thread = new HandlerThread("BluetoothDunHandler");
+        thread.start();
+        Looper looper = thread.getLooper();
+        mDunHandler = new DunServiceMessageHandler(looper);
+
+        mTelephonyService = ITelephony.Stub.asInterface(ServiceManager.getService("phone"));
+        if (mTelephonyService == null) {
+            Log.e(TAG, "Failed to get Telephony Service interface");
+        } else {
+            Log.i(TAG, "Telephony Service interface got Successfully");
+        }
     }
 
     @Override
@@ -330,6 +353,14 @@ public class BluetoothDunService extends Service {
         closeDunService();
         if(mDunHandler != null) {
             mDunHandler.removeCallbacksAndMessages(null);
+            Looper looper = mDunHandler.getLooper();
+            if (looper != null) {
+                looper.quit();
+                Log.i(TAG, "Quit looper");
+            }
+
+            mDunHandler = null;
+            Log.i(TAG, "Remove Handler");
         }
     }
 
@@ -343,38 +374,45 @@ public class BluetoothDunService extends Service {
         return new BluetoothDunBinder(this);
     }
 
-    private final Handler mDunHandler = new Handler() {
+    private final class DunServiceMessageHandler extends Handler {
+        private DunServiceMessageHandler(Looper looper) {
+            super(looper);
+        }
+
         @Override
-            public void handleMessage(Message msg) {
-                switch (msg.what) {
-                    case MESSAGE_START_LISTENER:
-                        if (mAdapter.isEnabled()) {
-                            startRfcommListenerThread();
+        public void handleMessage(Message msg) {
+            Log.i(TAG, "DunServiceMessageHandler: " +  msg.what);
+            switch (msg.what) {
+                case MESSAGE_START_LISTENER:
+                    if (mAdapter.isEnabled()) {
+                        startRfcommListenerThread();
+                    }
+                    break;
+                case MESSAGE_DUN_USER_TIMEOUT:
+                    synchronized(mAuthLock) {
+                        if (!mIsWaitingAuthorization) {
+                            // already handled, ignore it
+                            break;
                         }
-                        break;
-                    case MESSAGE_DUN_USER_TIMEOUT:
-                        {
-                            synchronized(mAuthLock) {
-                                if (!mIsWaitingAuthorization) {
-                                    // already handled, ignore it
-                                    break;
-                                }
 
-                                mIsWaitingAuthorization = false;
-                            }
-                            Intent intent = new Intent(USER_CONFIRM_TIMEOUT_ACTION);
-                            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
-                            sendBroadcast(intent);
-                            removeDunNotification(DUN_NOTIFICATION_ID_ACCESS);
-                            /* close the rfcomm socket and restart the listener thread */
-                            closeRfcommSocket();
-                            startRfcommListenerThread();
-
-                            if (VERBOSE) Log.v(TAG, "DUN user Authorization Timeout");
-                        }
-                        break;
-                }
+                        mIsWaitingAuthorization = false;
+                    }
+                    Intent intent = new Intent(USER_CONFIRM_TIMEOUT_ACTION);
+                    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
+                    sendBroadcast(intent);
+                    removeDunNotification(DUN_NOTIFICATION_ID_ACCESS);
+                    /* close the rfcomm socket and restart the listener thread */
+                    closeRfcommSocket();
+                    startRfcommListenerThread();
+
+                    if (VERBOSE) Log.v(TAG, "DUN user Authorization Timeout");
+                    break;
+                 default:
+                    if (VERBOSE)
+                        Log.v(TAG, "DunServiceMessageHandler: " +  msg.what + " not handled");
+                    break;
             }
+        }
     };
 
     // process the intent from DUN receiver
@@ -517,7 +555,10 @@ public class BluetoothDunService extends Service {
 
             mIsWaitingAuthorization = false;
             closeRfcommSocket();
-            startRfcommListenerThread();
+
+            if (mDunHandler != null) {
+                mDunHandler.sendMessage(mDunHandler.obtainMessage(MESSAGE_START_LISTENER));
+            }
         } else if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
 
             if (intent.hasExtra(BluetoothDevice.EXTRA_DEVICE)) {
@@ -543,7 +584,7 @@ public class BluetoothDunService extends Service {
     }
 
     private void startRfcommListenerThread() {
-        if (VERBOSE) Log.v(TAG, "DUN Service startRfcommListenerThread");
+        Log.i(TAG, "startRfcommListenerThread " + mAcceptThread);
 
         synchronized(mAcceptLock) {
             // if it is already running,close it
@@ -816,18 +857,23 @@ public class BluetoothDunService extends Service {
         }
 
         deleteIntent.setAction(DUN_ACCESS_DISALLOWED_ACTION);
-        notification = new Notification(android.R.drawable.stat_sys_data_bluetooth,
-            getString(R.string.dun_notif_ticker), System.currentTimeMillis());
-        notification.setLatestEventInfo(this, getString(R.string.dun_notif_ticker),
-                getString(R.string.dun_notif_message, name), PendingIntent
-                        .getActivity(this, 0, clickIntent, 0));
-
-        notification.flags |= Notification.FLAG_AUTO_CANCEL;
-        notification.flags |= Notification.FLAG_ONLY_ALERT_ONCE;
-        notification.defaults = Notification.DEFAULT_SOUND;
-        notification.deleteIntent = PendingIntent.getBroadcast(this, 0, deleteIntent, 0);
-        nm.notify(DUN_NOTIFICATION_ID_ACCESS, notification);
 
+        notification = new Notification.Builder(this)
+                .setContentTitle(getString(R.string.dun_notif_ticker))
+                .setTicker(getString(R.string.dun_notif_ticker))
+                .setContentText(getString(R.string.dun_notif_message, name))
+                .setSmallIcon(android.R.drawable.stat_sys_data_bluetooth)
+                .setAutoCancel(true)
+                .setPriority(Notification.PRIORITY_MAX)
+                .setOnlyAlertOnce(true)
+                .setDefaults(Notification.DEFAULT_SOUND)
+                .setContentIntent(PendingIntent.getActivity(this, 0, clickIntent, 0))
+                .setDeleteIntent(PendingIntent.getBroadcast(this, 0, deleteIntent, 0))
+                .setColor(this.getColor(
+                        com.android.internal.R.color.system_notification_accent_color))
+                .build();
+        notification.flags |= Notification.FLAG_NO_CLEAR; // Cannot be set with the builder.
+        nm.notify(DUN_NOTIFICATION_ID_ACCESS, notification);
 
         if (VERBOSE) Log.v(TAG, "Awaiting Authorization : DUN Connection : " + device.getName());
 
@@ -901,7 +947,7 @@ public class BluetoothDunService extends Service {
                                  USER_CONFIRM_TIMEOUT_VALUE);
                     }
                     stopped = true; // job done ,close this thread;
-                    if (VERBOSE) Log.v(TAG, "SocketAcceptThread stopped ");
+                    Log.i(TAG, "SocketAcceptThread stopped ");
                 } catch (IOException ex) {
                     stopped=true;
                     Log.w(TAG, "Handled Accept thread exception: " + ex.toString());
@@ -925,6 +971,8 @@ public class BluetoothDunService extends Service {
 
         private boolean stopped = false;
         private boolean IntExit = false;
+        private boolean mIsATDReceived = false;
+        private boolean mDunArbitrationStarted = false;
         private OutputStream mDundOutputStream = null;
         private InputStream mRfcommInputStream = null;
         ByteBuffer IpcMsgBuffer = ByteBuffer.allocate(DUN_MAX_IPC_MSG_LEN);
@@ -974,7 +1022,7 @@ public class BluetoothDunService extends Service {
             while (!stopped) {
                 try {
                     if (VERBOSE)
-                        Log.v(TAG, "Reading the DUN requests from Rfcomm channel");
+                        Log.v(TAG, "Reading the DUN request from Rfcomm channel");
                     /* Read the DUN request from Rfcomm channel */
                     NumRead = mRfcommInputStream.read(IpcMsgBuffer.array(), DUN_IPC_MSG_OFF_MSG,
                                                                                 DUN_MAX_MSG_LEN);
@@ -982,6 +1030,24 @@ public class BluetoothDunService extends Service {
                         IntExit = true;
                         break;
                     } else if (NumRead != 0) {
+
+                        if (mIsATDReceived == false && isATDCommand(IpcMsgBuffer)) {
+                            mIsATDReceived = true;
+                            ConnectivityManager cm = (ConnectivityManager)
+                                    getSystemService(Context.CONNECTIVITY_SERVICE);
+                            // Disable Mobile data call
+                            if (cm != null) {
+                                if (cm.getMobileDataEnabled()) {
+                                    mDunArbitrationStarted = enableDataConnectivity(false);
+                                } else {
+                                    mDunArbitrationStarted = false;
+                                    Log.i(TAG, "Embedded data call was already disabled");
+                                }
+                            } else {
+                                Log.e(TAG, "ConnectivityManager service interface is null");
+                            }
+                        }
+
                         /* Write the same DUN request to the DUN server socket with
                            some additional parameters */
                         IpcMsgBuffer.put(DUN_IPC_MSG_OFF_MSG_TYPE, DUN_IPC_MSG_DUN_REQUEST);
@@ -1044,6 +1110,10 @@ public class BluetoothDunService extends Service {
                 }
             }
 
+            if (mDunArbitrationStarted) {
+                mDunArbitrationStarted = enableDataConnectivity(true);
+            }
+
             if (IntExit && !stopped) {
                 if (VERBOSE) Log.v(TAG, "starting the listener thread ");
                 /* start the listener thread */
@@ -1058,6 +1128,70 @@ public class BluetoothDunService extends Service {
             stopped = true;
             interrupt();
         }
+
+        private boolean isATDCommand(ByteBuffer rfcommData) {
+            String[] atdCommands = {"ATDT*98", "ATDT*99", "ATDT#777", "ATD*98", "ATD*99",
+                    "ATD#777"};
+            String temp =   new String(rfcommData.array(),
+                    rfcommData.arrayOffset() + DUN_IPC_MSG_OFF_MSG,
+                    rfcommData.remaining()-DUN_IPC_MSG_OFF_MSG);
+
+            Log.i(TAG, "rfcomm data: " + temp);
+            if (temp != null) {
+                for (int i = 0; i < atdCommands.length; i++) {
+                    if (temp.contains(atdCommands[i])) {
+                        Log.w(TAG, "ATD Received");
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        private boolean enableDataConnectivity(boolean value) {
+            boolean result = false;
+            int RETRY_COUNT = 3;
+
+            if (mTelephonyService == null) {
+                Log.e(TAG, "Telephony Service interface is null");
+                return result;
+            }
+
+            if (value == true) {
+                try {
+                    int retry_count = RETRY_COUNT;
+                    while (retry_count > 0) {
+                        result = mTelephonyService.enableDataConnectivity();
+                        if (result == true) {
+                            Log.i(TAG, "Success: enableDataConnectivity");
+                            break;
+                        } else {
+                            Log.i(TAG, "Failure: enableDataConnectivity");
+                            retry_count--;
+                        }
+                    }
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Exception - Data Call Not Enabled");
+                }
+            } else if (value == false) {
+                try {
+                    int retry_count = RETRY_COUNT;
+                    while (retry_count > 0) {
+                        result = mTelephonyService.disableDataConnectivity();
+                        if (result == true) {
+                            Log.i(TAG, "Success: disableDataConnectivity");
+                            break;
+                        } else {
+                            Log.i(TAG, "Failure: disableDataConnectivity");
+                            retry_count--;
+                        }
+                    }
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Exception - Data Call Not Disabled");
+                }
+           }
+           return result;
+        }
     }
 
 
diff --git a/src/org/codeaurora/bluetooth/ftp/BluetoothFtpReceiver.java b/src/org/codeaurora/bluetooth/ftp/BluetoothFtpReceiver.java
index 3690ca5..6f443e6 100644
--- a/src/org/codeaurora/bluetooth/ftp/BluetoothFtpReceiver.java
+++ b/src/org/codeaurora/bluetooth/ftp/BluetoothFtpReceiver.java
@@ -33,13 +33,6 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.util.Log;
 import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.app.ActivityManager;
-import android.app.ActivityThread;
-import android.content.pm.UserInfo;
-import android.os.Binder;
-import android.os.Process;
 
 public class BluetoothFtpReceiver extends BroadcastReceiver {
 
@@ -47,43 +40,11 @@ public class BluetoothFtpReceiver extends BroadcastReceiver {
 
         private static final boolean V = Log.isLoggable(BluetoothFtpService.LOG_TAG, Log.VERBOSE) ? true : false;
 
-        public static boolean checkCaller() {
-            boolean ok;
-            // Get the caller's user id then clear the calling identity
-            // which will be restored in the finally clause.
-            int callingUser = UserHandle.getCallingUserId();
-            int callingUid = Binder.getCallingUid();
-            long ident = Binder.clearCallingIdentity();
-
-            try {
-                // With calling identity cleared the current user is the foreground user.
-                int foregroundUser = ActivityManager.getCurrentUser();
-                ok = (foregroundUser == callingUser);
-                if (!ok) {
-                    // Always allow SystemUI/System access.
-                    int systemUiUid = ActivityThread.getPackageManager().getPackageUid(
-                            "com.android.systemui", UserHandle.USER_OWNER);
-                    ok = (systemUiUid == callingUid) || (Process.SYSTEM_UID == callingUid);
-                }
-            } catch (Exception ex) {
-                Log.e(TAG, "checkIfCallerIsSelfOrForegroundUser: Exception ex=" + ex);
-                ok = false;
-            } finally {
-                Binder.restoreCallingIdentity(ident);
-            }
-            return ok;
-        }
-
         @Override
         public void  onReceive  (Context context, Intent intent) {
 
             if(V) Log.v(TAG,"BluetoothFtpReceiver onReceive :" + intent.getAction());
 
-            if (!checkCaller()) {
-                Log.w(TAG, "onReceive received for non-active user, ignoring");
-                return;
-            }
-
             Intent in = new Intent();
             in.putExtras(intent);
             in.setClass(context, BluetoothFtpService.class);
diff --git a/src/org/codeaurora/bluetooth/ftp/BluetoothFtpService.java b/src/org/codeaurora/bluetooth/ftp/BluetoothFtpService.java
index c231e41..82ab61e 100644
--- a/src/org/codeaurora/bluetooth/ftp/BluetoothFtpService.java
+++ b/src/org/codeaurora/bluetooth/ftp/BluetoothFtpService.java
@@ -402,12 +402,14 @@ public class BluetoothFtpService extends Service {
 
     private void startRfcommSocketListener() {
         VERBOSE = Log.isLoggable(BluetoothFtpService.LOG_TAG, Log.VERBOSE) ? true : false;
-        Log.v(TAG, "Ftp Service startRfcommSocketListener");
 
         if (mRfcommAcceptThread == null) {
+            Log.d(TAG, "Ftp Service startRfcommSocketListener");
             mRfcommAcceptThread = new RfcommSocketAcceptThread();
             mRfcommAcceptThread.setName("BluetoothFtpRfcommAcceptThread");
             mRfcommAcceptThread.start();
+        } else {
+            Log.d(TAG, "Ftp Service Already ON: startRfcommSocketListener");
         }
     }
     private final boolean initRfcommSocket() {
@@ -485,7 +487,6 @@ public class BluetoothFtpService extends Service {
         } catch (IOException ex) {
             Log.e(TAG, "CloseSocket error: " + ex);
         }
-
         if (mRfcommAcceptThread != null) {
             try {
                 mRfcommAcceptThread.shutdown();
@@ -553,22 +554,14 @@ public class BluetoothFtpService extends Service {
             mServerSession = null;
         }
 
-        if (mRfcommAcceptThread != null) {
-            try {
-                mRfcommAcceptThread.shutdown();
-                mRfcommAcceptThread.join();
-                mRfcommAcceptThread = null;
-            } catch (InterruptedException ex) {
-                Log.w(TAG, "mAcceptThread close error" + ex);
-            }
-        }
-
         try {
             Log.v(TAG, "stopObexServerSession, closeRfcommSocket");
             closeRfcommSocket(false, true);
         } catch (IOException e) {
             Log.e(TAG, "closeSocket error: " + e.toString());
         }
+        // Extra check to startListener if already not available
+        // This will not actually restart listener on every connect/disconnect.
         // Last obex transaction is finished, we start to listen for incoming
         // connection again
         if (mAdapter.isEnabled()) {
@@ -694,7 +687,6 @@ public class BluetoothFtpService extends Service {
                         mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler
                                 .obtainMessage(MSG_INTERNAL_USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
                     }
-                    stopped = true; // job done ,close this thread;
                 } catch (IOException ex) {
                     stopped = true; //IO exception, close the thread
                     Log.v(RTAG, "Accept exception: " + ex.toString());
diff --git a/src/org/codeaurora/bluetooth/sap/BluetoothSapReceiver.java b/src/org/codeaurora/bluetooth/sap/BluetoothSapReceiver.java
index 2c036be..a9b23ea 100644
--- a/src/org/codeaurora/bluetooth/sap/BluetoothSapReceiver.java
+++ b/src/org/codeaurora/bluetooth/sap/BluetoothSapReceiver.java
@@ -34,13 +34,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.util.Log;
 import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.app.ActivityManager;
-import android.app.ActivityThread;
-import android.content.pm.UserInfo;
-import android.os.Binder;
-import android.os.Process;
 
 public class BluetoothSapReceiver extends BroadcastReceiver {
 
@@ -48,33 +41,6 @@ public class BluetoothSapReceiver extends BroadcastReceiver {
 
     private static final boolean V = BluetoothSapService.VERBOSE;
 
-    public static boolean checkCaller() {
-        boolean ok;
-        // Get the caller's user id then clear the calling identity
-        // which will be restored in the finally clause.
-        int callingUser = UserHandle.getCallingUserId();
-        int callingUid = Binder.getCallingUid();
-        long ident = Binder.clearCallingIdentity();
-
-        try {
-            // With calling identity cleared the current user is the foreground user.
-            int foregroundUser = ActivityManager.getCurrentUser();
-            ok = (foregroundUser == callingUser);
-            if (!ok) {
-                // Always allow SystemUI/System access.
-                int systemUiUid = ActivityThread.getPackageManager().getPackageUid(
-                        "com.android.systemui", UserHandle.USER_OWNER);
-                ok = (systemUiUid == callingUid) || (Process.SYSTEM_UID == callingUid);
-            }
-        } catch (Exception ex) {
-            Log.e(TAG, "checkIfCallerIsSelfOrForegroundUser: Exception ex=" + ex);
-            ok = false;
-        } finally {
-            Binder.restoreCallingIdentity(ident);
-        }
-        return ok;
-    }
-
     @Override
     public void onReceive(Context context, Intent intent) {
 
@@ -82,11 +48,6 @@ public class BluetoothSapReceiver extends BroadcastReceiver {
             return;
         }
 
-        if (!checkCaller()) {
-            Log.w(TAG, "onReceive received for non-active user, ignoring");
-            return;
-        }
-
         if (V) Log.v(TAG, "SapReceiver onReceive ");
 
         Intent in = new Intent();
diff --git a/system_bt_ext/conf/interop_database.conf b/system_bt_ext/conf/interop_database.conf
new file mode 100644
index 0000000..df9ff8a
--- /dev/null
+++ b/system_bt_ext/conf/interop_database.conf
@@ -0,0 +1,313 @@
+# Below are the guidelines/instructions for editing this database file.
+# Note 1: User should turn of the BT, before updating this database file.
+# Note 2: Maximum length of the line should not be more than 1023 characters.
+# Note 3: Line started with the # is treated as comments.
+# Note 4: Comment lines in between the entries are not allowed.
+# Note 5: All duplicated entries including main BL types will be ignored.
+#
+#1. Below are the four tags for blacklist
+#   A. Address_Based   C. Manufacturer_based
+#   B. Name_Based      D. Vndr_Prdt_Based
+#   E. SSR_Max_Lat_Based
+##
+#   A. Address_Based :  This tag refers to Address based blacklist
+#   Input Type       :   Input value should be only 3 to 6 bytes of BD address
+#   Format Type      :   Address should be in XX:XX:XX format
+#   Examples         :   00:01:03 = Address_Based
+###
+#   B. Name_Based :   This tag refers to Name based blacklist.
+#   Input type    :   Input should be only string and length of the string
+#                     should not be more than 248 characters.
+#   Format Type   :   string
+#   Examples      :   Sample Headset name = Name_Based
+####
+#   C. Manufacturer_Based :  This tag refers to Manufacturer based blacklist
+#   Input type  : Input should be in Hexadecimal Number of Manufacturer
+#   Format Type : 2 Bytes Hexadecimal Value
+#   Examples    : 0X0023 = Manufacturer_Based
+#####
+#   D. Vndr_Prdt_Based : This tag refers to vendor and product based blacklist
+#   Input type  : Input should be in Hexadecimal value
+#   Format Type : 4 bytes hex value( 2bytes of vendor  and 2 bytes of product),
+#                 Vendor and product hex values should be separated with delimiter(-).
+#   Examples    : 0X00AB-0X00BC = Vndr_Prdt_Based
+#####
+#   E. SSR_Max_Lat_Based : This tag refers to SSR Max LAtency based blacklist
+#   Input type  : Input value should be combination of first 3 bytes of BD address and
+#                 Hexadecimal value of SSR Max Latency
+#   Format Type : Address should be in XX:XX:XX format followed by 2 bytes hex value
+#                 of max latency Address and Max Latency should be separated with delimiter(-).
+#   Examples    : 00:01:03-0X00AB = SSR_Max_Lat_Based
+# ******************************* Start of Blacklist Database ********************************
+#Disable secure connections
+#This is for pre BT 4.1/2 devices that do not handle secure mode very well.
+[INTEROP_DISABLE_LE_SECURE_CONNECTIONS]
+08:62:66 = Address_Based
+38:2C:4A:C9 = Address_Based
+38:2C:4A:E6 = Address_Based
+54:A0:50:D9 = Address_Based
+AC:9E:17 = Address_Based
+F0:79:59 = Address_Based
+80:E4:DA:70 = Address_Based
+1C:96:5A = Address_Based
+80:EA:CA = Address_Based
+
+# Some devices have proven problematic during the pairing process, often
+# requiring multiple retries to complete pairing. To avoid degrading the user
+# experience for those devices, automatically re-try pairing if page
+# timeouts are received during pairing.
+[INTEROP_AUTO_RETRY_PAIRING]
+9C:DF:03 = Address_Based
+
+# Devices requiring this workaround do not handle Bluetooth Absolute Volume
+# control correctly, leading to undesirable (potentially harmful) volume levels
+# or general lack of controlability.
+[INTEROP_DISABLE_ABSOLUTE_VOLUME]
+A0:E9:DB = Address_Based
+00:14:02 = Address_Based
+1C:48:F9 = Address_Based
+44:5E:F3 = Address_Based
+D4:9C:28 = Address_Based
+00:18:6B = Address_Based
+B8:AD:3E = Address_Based
+00:11:B1 = Address_Based
+A4:15:66 = Address_Based
+00:14:F1 = Address_Based
+00:26:7E = Address_Based
+90:03:B7 = Address_Based
+04:F8:C2 = Address_Based
+
+# Disable automatic pairing with headsets/car-kits
+# Some car kits do not react kindly to a failed pairing attempt and
+# do not allow immediate re-pairing. Blacklist these so that the initial
+# pairing attempt makes it to the user instead
+[INTEROP_DISABLE_AUTO_PAIRING]
+34:C7:31 = Address_Based
+00:07:04 = Address_Based
+E0:75:0A = Address_Based
+Audi = Name_Based
+BMW = Name_Based
+Parrot = Name_Based
+Car = Name_Based
+NISSAN = Name_Based
+
+# Use a fixed pin for specific keyboards
+# Keyboards should use a variable pin at all times. However, some keyboards
+# require a fixed pin of all 0000. This workaround enables auto pairing for
+# those keyboards.
+[INTEROP_KEYBOARD_REQUIRES_FIXED_PIN]
+00:0F:F6 = Address_Based
+
+# Some headsets have audio jitter issues because of increased re-transmissions as the
+# 3 Mbps packets have a lower link margin, and are more prone to interference. We can
+# disable 3DH packets (use only 2DH packets) for the ACL link to improve sensitivity
+# when streaming A2DP audio to the headset. Air sniffer logs show reduced
+# re-transmissions after switching to 2DH packets.
+# Disable 3Mbps packets and use only 2Mbps packets for ACL links when streaming audio.
+[INTEROP_2MBPS_LINK_ONLY]
+00:18:91 = Address_Based
+00:21:4F = Address_Based
+20:15:06 = Address_Based
+
+# Some HID devices have proven problematic behaviour if SDP is initiated again
+# while HID connection is in progress or if more than 1 SDP connection is created
+# with those HID devices rsulting in issues of connection failure with such devices.
+# To avoid degrading the user experience with those devices, SDP is not attempted
+# as part of pairing process.
+[INTEROP_DISABLE_SDP_AFTER_PAIRING]
+04:0C:CE = Address_Based
+00:07:61 = Address_Based
+00:1D:D8 = Address_Based
+00:1F:20 = Address_Based
+6C:5D:63 = Address_Based
+28:18:78 = Address_Based
+60:45:BD = Address_Based
+00:90:E1 = Address_Based
+Apple Magic Mouse = Name_Based
+Bluetooth Laser Travel Mouse = Name_Based
+Microsoft Bluetooth Notebook Mouse 5000 = Name_Based
+Logitech MX Revolution Mouse = Name_Based
+Microsoft Sculpt Touch Mouse = Name_Based
+Tero's Game Controller = Name_Based
+ipega media gamepad controller = Name_Based
+0x004C = Manufacturer_Based
+
+# Some HID pointing devices have proven problematic behaviour if pairing is initiated with
+# them, resulting in no response for authentication request and ultimately resulting
+# in connection failure.
+# To avoid degrading the user experience with those devices, authentication request
+# is not requested explictly.
+[INTEROP_DISABLE_AUTH_FOR_HID_POINTING]
+00:12:A1 = Address_Based
+Targus BT Laser Notebook Mouse = Name_Based
+
+# HID Keyboards that claim support for multitouch functionality have issue with
+# normal functioning of keyboard because of issues in USB HID kernel driver.
+# To avoid degrading the user experience with those devices, digitizer record
+# is removed from the report descriptor.
+[INTEROP_REMOVE_HID_DIG_DESCRIPTOR]
+Motorola Keyboard KZ500 = Name_Based
+Motorola Keyboard KZ500 v122 = Name_Based
+0x22b8-0x093D = Vndr_Prdt_Based
+
+# Some HID devices have problematic behaviour where when hid link is in Sniff
+# and DUT is in Slave role for SCO link ( not eSCO) any solution cannot maintain
+# the link as  SCO scheduling over a short period will overlap with Sniff link due to
+# slave drift.
+# To avoid degrading the user experience with those devices, sniff is disabled from
+# link policy when sco is active, and enabled when sco is disabled.
+[INTEROP_DISABLE_SNIFF_DURING_SCO]
+20:4C:10 = Address_Based
+0x004C = Manufacturer_Based
+
+# Few carkits take long time to start sending AT commands
+# Increase AG_CONN TIMEOUT so that AG connection go through
+[INTEROP_INCREASE_AG_CONN_TIMEOUT]
+00:14:09 = Address_Based
+
+# Some HOGP devices do not respond well when we switch from default LE conn parameters
+# to preferred conn params immediately post connection. Disable automatic switching to
+# preferred conn params for such devices and allow them to explicity ask for it.
+[INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS]
+BSMBB09DS = Name_Based
+ELECOM = Name_Based
+
+# Few remote devices do not understand AVRCP version greater than 1.3. For these
+# devices, we would like to blacklist them and advertise AVRCP version as 1.3
+[INTEROP_ADV_AVRCP_VER_1_3]
+A0:56:B2 = Address_Based
+MB Bluetooth = Name_Based
+
+# Fallback to AVRCP version 1.4 for remote to initiate browse connection
+[INTEROP_STORE_REMOTE_AVRCP_VERSION_1_4]
+00:02:5B:4A = Address_Based
+
+# Disable role switch for headsets/car-kits
+# Some car kits allow role switch but when DUT initiates role switch
+# Remote will go to bad state and its leads to LMP time out.
+[INTEROP_DISABLE_ROLE_SWITCH]
+FC:C2:DE = Address_Based
+00:26:B4 = Address_Based
+00:04:3E = Address_Based
+00:23:01 = Address_Based
+1C:48:F9 = Address_Based
+00:54:AF = Address_Based
+00:26:E8 = Address_Based
+00:37:6D = Address_Based
+9C:3A:AF = Address_Based
+00:18:91 = Address_Based
+0C:E0:E4 = Address_Based
+00:07:04 = Address_Based
+A4:15:66 = Address_Based
+D0:13:1E = Address_Based
+8F:20:B4 = Address_Based
+A8:B9:B3 = Address_Based
+00:0D:F0 = Address_Based
+
+# Disable role switch policy for headsets/car-kits
+# Some car kits initiate a role switch but won't initiate encryption
+# after role switch complete
+[INTEROP_DISABLE_ROLE_SWITCH_POLICY]
+00:0D:FD = Address_Based
+00:1B:DC = Address_Based
+00:07:04 = Address_Based
+A4:15:66 = Address_Based
+00:54:AF = Address_Based
+
+# certain remote A2DP sinks have issue playing back Music in AAC format.
+# disable AAC for those headsets so that it switch to SBC
+# 1. remote sending 128 instead of 128k as bitrate (cadillac::28:a1:83,buick_verona::ac:7a:4d,maruti_brezzai:28:a1:83)
+# 2. remote flowing off for media packets (parrotzik_2.0/Honda2k17::A0:14:3D
+# 3. Remote CK is restarting though Audio works for sometime (Tesla_s::90:03:b7)
+# 4. remote supporting only 44.1Khz (BIG-JAM-BOX::00-21-3c,JVC CK::00:1D:86,BMW CK::9C:DF:03)
+[INTEROP_DISABLE_AAC_CODEC]
+28:A1:83 = Address_Based
+AC:7A:4D = Address_Based
+A0:14:3D = Address_Based
+90:03:B7 = Address_Based
+00:21:3c = Address_Based
+00:1D:86 = Address_Based
+9C:DF:03 = Address_Based
+
+#Enable AAC encoder only for whitelist devices
+# minijambox(e0:d1:e6)
+# Lg hbsA100/1100(b8-ad-3e), lg hbs730(00:18:6b)
+# Sony MDR-1RBT(00:18:09), MDR-1ABT(ac:9b:0a)
+# Beats solo3(20:3c:ae), solo2(04:88:e2), airpods(4c:32:75)
+# Parrot zik1(90:03:b7)>zik1 works,but tesla has same address & has reboot issues
+# OPPO (iLike 00:14:07)
+# Nokia Purity Pro(94:20:53)
+# Astell&Kern XB10(88:E6:03)
+# Plantronics BackbeatPrp+(0C:E0:E4)
+[INTEROP_ENABLE_AAC_CODEC]
+e0:d1:e6 = Address_Based
+b8:ad:3e = Address_Based
+00:18:6b = Address_Based
+00:18:09 = Address_Based
+ac:9b:0a = Address_Based
+20:3c:ae = Address_Based
+04:88:e2 = Address_Based
+4c:32:75 = Address_Based
+00:14:07 = Address_Based
+94:20:53 = Address_Based
+88:E6:03 = Address_Based
+0C:E0:E4 = Address_Based
+
+# Devices requiring this workaround do not handle Bluetooth PBAP 1.2
+# version correctly, leading them to go in bad state. So for better
+# interoperability respond with PBAP 1.1 as supported version.
+[INTEROP_ADV_PBAP_VER_1_1]
+00:00:31 = Address_Based
+00:00:41 = Address_Based
+00:00:6a = Address_Based
+00:00:7f = Address_Based
+00:01:0a = Address_Based
+Discovery Sport = Name_Based
+
+# Honor remote avdtp start, certain carkits send avdt_start along with avrcp
+# passthrough cmd. If DUT suspends remote start and initiate avdtp start, remote
+# suspends DUT's start request. So honor remote start for certain devices.
+[INTEROP_REMOTE_AVDTP_START]
+bc:30:7e = Address_Based
+a4:08:ea = Address_Based
+Audi = Name_Based
+Porsche = Name_Based
+
+# Devices requiring this workaround do not handle SSR max latency values as mentioned,
+# in their SDP HID Record properly and lead to connection timeout or lags. To prevent
+# such scenarios, device requiring this workaorund need to use specific ssr max latency
+# values.
+[INTEROP_UPDATE_HID_SSR_MAX_LAT]
+00:1B:DC-0x0012 = SSR_Max_Lat_Based
+DC:2C:26-0x0000 = SSR_Max_Lat_Based
+54:46:6B-0x0001 = SSR_Max_Lat_Based
+
+#Ensure that call active indicator is sent prior to SCO connection
+#request by adding some delay. Some remotes are very strict in the
+#order of call indicator and SCO connection request.
+#1 04:52:c7 - Bose Mini II sound link
+[INTEROP_DELAY_SCO_FOR_MT_CALL]
+04:52:c7 = Address_Based
+
+# Some remotes ara taking longer to respond to +BCS during codec negotiation.
+# Disable codec negotiation and directly initiate SCO connection for those.
+# 1. M12 - 00:08:8a:f0:1d:8a
+[INTEROP_DISABLE_CODEC_NEGOTIATION]
+00:08:8a = Address_Based
+JABRA EASYGO = Name_Based
+
+# some remotes are going into sniff mode during SCO connection process and taking time
+# for SCO connection  to complete. For such devices, disable sniff when SCO is connecting
+# and enable it after SCO disconnection
+[INTEROP_DISABLE_SNIFF_POLICY_DURING_SCO]
+00:24:1C = Address_Based
+# Disallow sending Player Application Setting Commands for some CK as they are unable
+# to send Passthrough Command while Streaming is in progress
+[INTEROP_DISABLE_PLAYER_APPLICATION_SETTING_CMDS]
+00:09:93 = Address_Based
+
+#Some device reports support for hf indicator, but it's HFP version as 1.5. The
+#behaviour violates spec and shall cause problem when DUT support HFP1.7, thus
+#blacklisting such devices and remove remote's hf indicator bit if not support HFP1.7.
+[INTEROP_DISABLE_HF_INDICATOR]
+98:7b:f3 = Address_Based
diff --git a/system_bt_ext/device/include/interop_config.h b/system_bt_ext/device/include/interop_config.h
new file mode 100644
index 0000000..6b0c98b
--- /dev/null
+++ b/system_bt_ext/device/include/interop_config.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *
+ *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *  Not a Contribution.
+ *  Copyright (C) 2014 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include <stdbool.h>
+#include <errno.h>
+#include "device/include/interop_database.h"
+#include "device/include/interop.h"
+
+
+typedef struct {
+  bt_bdaddr_t addr;
+  size_t length;
+  uint16_t max_lat;
+  interop_feature_t feature;
+} interop_hid_ssr_max_lat_t;
+
+typedef enum {
+    INTEROP_BL_TYPE_ADDR = 0,
+    INTEROP_BL_TYPE_NAME,
+    INTEROP_BL_TYPE_MANUFACTURE,
+    INTEROP_BL_TYPE_VNDR_PRDT,
+    INTEROP_BL_TYPE_SSR_MAX_LAT,
+
+} interop_bl_type;
+
+typedef enum {
+    INTEROP_ENTRY_TYPE_STATIC = 1 << 0,
+    INTEROP_ENTRY_TYPE_DYNAMIC = 1 << 1
+} interop_entry_type;
+
+typedef struct {
+    interop_bl_type bl_type;
+    interop_entry_type bl_entry_type;
+
+    union {
+        interop_addr_entry_t addr_entry;
+        interop_name_entry_t name_entry;
+        interop_manufacturer_t mnfr_entry;
+        interop_hid_multitouch_t vnr_pdt_entry;
+        interop_hid_ssr_max_lat_t ssr_max_lat_entry;
+    } entry_type;
+
+} interop_db_entry_t;
+
+// API's for adding entries to dynamic interop database
+void interop_database_add_addr(const uint16_t feature, const bt_bdaddr_t *addr, size_t length);
+void interop_database_add_name(const uint16_t feature, const char *name);
+void interop_database_add_manufacturer(const interop_feature_t feature, uint16_t manufacturer);
+void interop_database_add_vndr_prdt(const interop_feature_t feature, uint16_t vendor_id, uint16_t product_id);
+void interop_database_add_addr_max_lat(const interop_feature_t feature, const bt_bdaddr_t *addr,
+          size_t length, uint16_t max_lat);
+
+// API's for removing entries from dynamic interop database
+bool interop_database_remove_addr(const interop_feature_t feature, const bt_bdaddr_t *addr);
+bool interop_database_remove_name( const interop_feature_t feature, const char *name);
+bool interop_database_remove_manufacturer( const interop_feature_t feature, uint16_t manufacturer);
+bool interop_database_remove_vndr_prdt(const interop_feature_t feature, uint16_t vendor_id, uint16_t product_id);
+bool interop_database_remove_addr_max_lat(const interop_feature_t feature,
+          const bt_bdaddr_t *addr, size_t length, uint16_t max_lat);
+
+// API's to match entries with in dynamic interop database
+bool interop_database_match_addr(const interop_feature_t feature, const bt_bdaddr_t *addr);
+bool interop_database_match_name( const interop_feature_t feature, const char *name);
+bool interop_database_match_manufacturer(const interop_feature_t feature, uint16_t manufacturer);
+bool interop_database_match_vndr_prdt(const interop_feature_t feature, uint16_t vendor_id, uint16_t product_id);
+bool interop_database_match_addr_get_max_lat(const interop_feature_t feature,
+          const bt_bdaddr_t *addr, uint16_t *max_lat);
+
diff --git a/system_bt_ext/device/src/interop.c b/system_bt_ext/device/src/interop.c
new file mode 100644
index 0000000..43b97f8
--- /dev/null
+++ b/system_bt_ext/device/src/interop.c
@@ -0,0 +1,1205 @@
+/******************************************************************************
+ *
+ *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *  Not a Contribution.
+ *  Copyright (C) 2014 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_device_interop"
+
+#include <assert.h>
+#include <ctype.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <hardware/bluetooth.h>
+
+#include "bt_types.h"
+#include "osi/include/config.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+#include "osi/include/compat.h"
+#include "osi/include/list.h"
+#include "device/include/interop_database.h"
+#include "device/include/interop_config.h"
+#include "btcore/include/bdaddr.h"
+#include "osi/include/allocator.h"
+#include "device/include/interop.h"
+#include "btcore/include/module.h"
+
+#if defined(OS_GENERIC)
+static const char *INTEROP_FILE_PATH = "interop_database.conf";
+#else  // !defined(OS_GENERIC)
+static const char *INTEROP_DYNAMIC_FILE_PATH = "/data/misc/bluedroid/interop_database_dynamic.conf";
+static const char *INTEROP_STATIC_FILE_PATH = "/etc/bluetooth/interop_database.conf";
+#endif  // defined(OS_GENERIC)
+
+list_t *interop_list = NULL;
+bool interop_is_initialized = false;
+// protects operations on |interop_list|
+pthread_mutex_t interop_list_lock;
+
+// protects operations on |config|
+static pthread_mutex_t file_lock;
+static config_t *config_static;
+static config_t *config_dynamic;
+
+#define CASE_RETURN_STR(const) case const: return #const;
+// Macro used to find the total number of feature_types
+#define  NO_OF_FEATURES(x)  (sizeof(x) / sizeof((x)[0]))
+
+#define SECTION_MAX_LENGTH    (249)
+#define KEY_MAX_LENGTH      (249)
+#define VALID_VNDR_PRDT_LEN   (13)
+#define VALID_MNFR_STR_LEN    (6)
+#define VALID_SSR_LAT_LEN   (15)
+#define VENDOR_VALUE_SEPARATOR  "-"
+
+#define ADDR_BASED    "Address_Based"
+#define NAME_BASED    "Name_Based"
+#define MNFR_BASED    "Manufacturer_Based"
+#define VNDR_PRDT_BASED   "Vndr_Prdt_Based"
+#define SSR_MAX_LAT_BASED   "SSR_Max_Lat_Based"
+
+struct config_t {
+  list_t *sections;
+};
+
+typedef struct {
+  char *key;
+  char *value;
+} interop_entry_t;
+
+typedef struct {
+  char *name;
+  list_t *entries;
+} interop_section_t;
+
+// Config realted functions
+static void interop_config_cleanup(void);
+static void interop_free_entry_(void *data);
+static void interop_lazy_init_(void);
+
+//This function is used to initialize the interop list and load the entries from file
+static void load_config();
+static void interop_database_add_( interop_db_entry_t *db_entry, bool persist);
+static bool interop_database_remove_( interop_db_entry_t *entry);
+static bool interop_database_match_( interop_db_entry_t *entry, interop_db_entry_t **ret_entry, interop_entry_type entry_type);
+static void interop_config_write(UNUSED_ATTR UINT16 event, UNUSED_ATTR char *p_param);
+
+
+// Interface functions
+
+bool interop_match_addr(const interop_feature_t feature,
+                const bt_bdaddr_t *addr)
+{
+  assert(addr);
+  return (interop_database_match_addr(feature, addr));
+}
+
+bool interop_match_name(const interop_feature_t feature,
+                    const char *name)
+{
+  assert(name);
+  return (interop_database_match_name(feature, name));
+}
+
+bool interop_match_manufacturer(const interop_feature_t feature,
+                    uint16_t manufacturer)
+{
+  return (interop_database_match_manufacturer(feature, manufacturer));
+}
+
+bool interop_match_vendor_product_ids(const interop_feature_t feature,
+    uint16_t vendor_id, uint16_t product_id)
+{
+  return interop_database_match_vndr_prdt(feature, vendor_id, product_id);
+}
+
+bool interop_match_addr_get_max_lat(const interop_feature_t feature,
+    const bt_bdaddr_t *addr, uint16_t *max_lat)
+{
+  return interop_database_match_addr_get_max_lat(feature, addr, max_lat);
+}
+
+void interop_database_add(const uint16_t feature, const bt_bdaddr_t *addr,
+                              size_t length)
+{
+  assert(addr);
+  assert(length > 0);
+  assert(length < sizeof(bt_bdaddr_t));
+  interop_database_add_addr(feature, addr,length);
+}
+
+static const char* interop_feature_string_(const interop_feature_t feature)
+{
+  switch (feature) {
+    CASE_RETURN_STR(INTEROP_DISABLE_LE_SECURE_CONNECTIONS)
+    CASE_RETURN_STR(INTEROP_AUTO_RETRY_PAIRING)
+    CASE_RETURN_STR(INTEROP_DISABLE_ABSOLUTE_VOLUME)
+    CASE_RETURN_STR(INTEROP_DISABLE_AUTO_PAIRING)
+    CASE_RETURN_STR(INTEROP_KEYBOARD_REQUIRES_FIXED_PIN)
+    CASE_RETURN_STR(INTEROP_2MBPS_LINK_ONLY)
+    CASE_RETURN_STR(INTEROP_DISABLE_SDP_AFTER_PAIRING)
+    CASE_RETURN_STR(INTEROP_DISABLE_AUTH_FOR_HID_POINTING)
+    CASE_RETURN_STR(INTEROP_REMOVE_HID_DIG_DESCRIPTOR)
+    CASE_RETURN_STR(INTEROP_DISABLE_SNIFF_DURING_SCO)
+    CASE_RETURN_STR(INTEROP_INCREASE_AG_CONN_TIMEOUT)
+    CASE_RETURN_STR(INTEROP_DISABLE_LE_CONN_PREFERRED_PARAMS)
+    CASE_RETURN_STR(INTEROP_ADV_AVRCP_VER_1_3)
+    CASE_RETURN_STR(INTEROP_DISABLE_AAC_CODEC)
+    CASE_RETURN_STR(INTEROP_ENABLE_AAC_CODEC)
+    CASE_RETURN_STR(INTEROP_DYNAMIC_ROLE_SWITCH)
+    CASE_RETURN_STR(INTEROP_DISABLE_ROLE_SWITCH)
+    CASE_RETURN_STR(INTEROP_DISABLE_ROLE_SWITCH_POLICY)
+    CASE_RETURN_STR(INTEROP_HFP_1_7_BLACKLIST)
+    CASE_RETURN_STR(INTEROP_STORE_REMOTE_AVRCP_VERSION_1_4)
+    CASE_RETURN_STR(INTEROP_ADV_PBAP_VER_1_1)
+    CASE_RETURN_STR(INTEROP_REMOTE_AVDTP_START)
+    CASE_RETURN_STR(INTEROP_UPDATE_HID_SSR_MAX_LAT)
+    CASE_RETURN_STR(INTEROP_DELAY_SCO_FOR_MT_CALL)
+    CASE_RETURN_STR(INTEROP_DISABLE_CODEC_NEGOTIATION)
+    CASE_RETURN_STR(INTEROP_DISABLE_SNIFF_POLICY_DURING_SCO)
+    CASE_RETURN_STR(INTEROP_DISABLE_PLAYER_APPLICATION_SETTING_CMDS)
+    CASE_RETURN_STR(INTEROP_DISABLE_HF_INDICATOR)
+    CASE_RETURN_STR(END_OF_INTEROP_LIST)
+  }
+  return "UNKNOWN";
+}
+
+void interop_database_clear()
+{
+  pthread_mutex_lock(&interop_list_lock);
+
+  if (!interop_is_initialized && interop_list) {
+    list_clear(interop_list);
+  }
+  pthread_mutex_unlock(&interop_list_lock);
+}
+
+// Module life-cycle functions
+
+static future_t *interop_init(void)
+{
+  interop_lazy_init_();
+  interop_is_initialized = true;
+  return future_new_immediate(FUTURE_SUCCESS);
+}
+
+static future_t *interop_clean_up(void)
+{
+  pthread_mutex_lock(&interop_list_lock);
+  list_free(interop_list);
+  interop_list = NULL;
+  interop_is_initialized = false;
+  pthread_mutex_unlock(&interop_list_lock);
+  pthread_mutex_destroy(&interop_list_lock);
+  interop_config_cleanup();
+
+  return future_new_immediate(FUTURE_SUCCESS);
+}
+
+EXPORT_SYMBOL module_t interop_module = {
+  .name = INTEROP_MODULE,
+  .init = interop_init,
+  .start_up = NULL,
+  .shut_down = NULL,
+  .clean_up = interop_clean_up,
+  .dependencies = {NULL},
+};
+
+// Local functions
+
+static void interop_free_entry_(void *data)
+{
+  interop_db_entry_t *entry = (interop_db_entry_t *)data;
+  osi_free(entry);
+}
+
+static void interop_lazy_init_(void)
+{
+  pthread_mutex_init(&interop_list_lock, NULL);
+  if (interop_list == NULL) {
+    interop_list = list_new(interop_free_entry_);
+    load_config();
+  }
+}
+
+// interop config related functions
+
+static int interop_config_init(void)
+{
+  struct stat sts;
+  pthread_mutex_init(&file_lock, NULL);
+  pthread_mutex_lock(&file_lock);
+
+  if (!stat(INTEROP_STATIC_FILE_PATH, &sts) && sts.st_size) {
+    if(!(config_static = config_new(INTEROP_STATIC_FILE_PATH))) {
+      LOG_WARN(LOG_TAG, "%s unable to load static config file for : %s",
+         __func__, INTEROP_STATIC_FILE_PATH);
+    }
+  }
+  if(!config_static  && !(config_static = config_new_empty())) {
+    goto error;
+  }
+
+  if (!stat(INTEROP_DYNAMIC_FILE_PATH, &sts) && sts.st_size) {
+    if(!(config_dynamic = config_new(INTEROP_DYNAMIC_FILE_PATH))) {
+      LOG_WARN(LOG_TAG, "%s unable to load dynamic config file for : %s",
+         __func__, INTEROP_DYNAMIC_FILE_PATH);
+    }
+  }
+  if(!config_dynamic  && !(config_dynamic = config_new_empty())) {
+    goto error;
+  }
+  pthread_mutex_unlock(&file_lock);
+  return 0;
+
+error:
+  config_free(config_static);
+  config_free(config_dynamic);
+  pthread_mutex_unlock(&file_lock);
+  pthread_mutex_destroy(&file_lock);
+  config_static = NULL;
+  config_dynamic = NULL;
+  return -1;
+}
+
+static void interop_config_flush(void)
+{
+  assert(config_dynamic != NULL);
+  interop_config_write(0, NULL);
+}
+
+static bool interop_config_remove(const char *section, const char *key)
+{
+  assert(config_dynamic != NULL);
+  assert(section != NULL);
+  assert(key != NULL);
+
+  pthread_mutex_lock(&file_lock);
+  bool ret = config_remove_key(config_dynamic, section, key);
+  pthread_mutex_unlock(&file_lock);
+
+  return ret;
+}
+
+static bool interop_config_set_str(const char *section, const char *key,
+                          const char *value)
+{
+  assert(config_dynamic != NULL);
+  assert(section != NULL);
+  assert(key != NULL);
+  assert(value != NULL);
+
+  pthread_mutex_lock(&file_lock);
+  config_set_string(config_dynamic, section, key, value);
+  pthread_mutex_unlock(&file_lock);
+
+  return true;
+}
+
+static int get_feature(char *section)
+{
+  interop_feature_t feature;
+
+  for ( feature = BEGINING_OF_INTEROP_LIST;
+        feature < END_OF_INTEROP_LIST; feature++ ) {
+    if (!strncmp( section, interop_feature_string_(feature),
+                      strlen(section)))
+      return feature;
+  }
+  return -1;
+}
+
+static void interop_database_add_( interop_db_entry_t *db_entry,
+                          bool persist)
+{
+  interop_db_entry_t *ret_entry = NULL;
+
+  if (!interop_database_match_(db_entry, &ret_entry,
+        INTEROP_ENTRY_TYPE_STATIC | INTEROP_ENTRY_TYPE_DYNAMIC)) {
+    pthread_mutex_lock(&interop_list_lock);
+
+    if (interop_list) {
+      list_append(interop_list, db_entry);
+    }
+    pthread_mutex_unlock(&interop_list_lock);
+  } else {
+    //return as the entry is already present
+    LOG_DEBUG(LOG_TAG, "Entry is already present in the list");
+    return;
+  }
+
+  if (!persist) {
+    //return if the persist option is not set
+    return;
+  }
+
+  // add it to the config file as well
+  switch (db_entry->bl_type) {
+    case INTEROP_BL_TYPE_ADDR:
+      {
+        interop_feature_t feature =
+              db_entry->entry_type.addr_entry.feature;
+        bdstr_t bdstr = { '\0' };
+        bdaddr_to_string(&db_entry->entry_type.addr_entry.addr,
+                    bdstr, sizeof(bdstr));
+        bdstr[(db_entry->entry_type.addr_entry.length * 3) - 1] = '\0';
+        interop_config_set_str(interop_feature_string_(feature),
+                  bdstr, ADDR_BASED);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_NAME:
+      {
+        interop_feature_t feature =
+            db_entry->entry_type.name_entry.feature;
+        interop_config_set_str(interop_feature_string_(feature),
+          db_entry->entry_type.name_entry.name, NAME_BASED);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_MANUFACTURE:
+      {
+        interop_feature_t feature =
+            db_entry->entry_type.mnfr_entry.feature;
+        char m_facturer[KEY_MAX_LENGTH] = { '\0' };
+        snprintf(m_facturer, sizeof(m_facturer), "0x%04x",
+            db_entry->entry_type.mnfr_entry.manufacturer);
+        interop_config_set_str(interop_feature_string_(feature),
+            m_facturer, MNFR_BASED);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_VNDR_PRDT:
+      {
+        interop_feature_t feature =
+          db_entry->entry_type.vnr_pdt_entry.feature;
+        char m_vendor[KEY_MAX_LENGTH] = { '\0' };
+        snprintf(m_vendor, sizeof(m_vendor), "0x%04x-0x%04x",
+            db_entry->entry_type.vnr_pdt_entry.vendor_id,
+            db_entry->entry_type.vnr_pdt_entry.product_id);
+        interop_config_set_str(interop_feature_string_(feature),
+            m_vendor, VNDR_PRDT_BASED);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_SSR_MAX_LAT:
+      {
+        interop_feature_t feature =
+          db_entry->entry_type.ssr_max_lat_entry.feature;
+        char m_vendor[KEY_MAX_LENGTH] = { '\0' };
+        bdstr_t bdstr = { '\0' };
+        bdaddr_to_string(&db_entry->entry_type.addr_entry.addr,
+                    bdstr, sizeof(bdstr));
+        bdstr[(db_entry->entry_type.addr_entry.length * 3) - 1] = '\0';
+        snprintf(m_vendor, sizeof(m_vendor), "%s-0x%04x",
+            bdstr, db_entry->entry_type.ssr_max_lat_entry.max_lat);
+        interop_config_set_str(interop_feature_string_(feature),
+            m_vendor, SSR_MAX_LAT_BASED);
+        interop_config_flush();
+        break;
+      }
+  }
+}
+
+static bool interop_database_match_( interop_db_entry_t *entry,
+                interop_db_entry_t **ret_entry, interop_entry_type entry_type)
+{
+  assert(entry);
+  bool found = false;
+  pthread_mutex_lock(&interop_list_lock);
+  if (interop_list == NULL || list_length(interop_list) == 0) {
+    pthread_mutex_unlock(&interop_list_lock);
+    return false;
+  }
+
+  const list_node_t *node = list_begin(interop_list);
+
+  while (node != list_end(interop_list)) {
+    interop_db_entry_t *db_entry = list_node(node);
+    assert(db_entry);
+
+    if (entry->bl_type != db_entry->bl_type) {
+      node = list_next(node);
+      continue;
+    }
+
+    if((entry_type == INTEROP_ENTRY_TYPE_STATIC) ||
+       (entry_type == INTEROP_ENTRY_TYPE_DYNAMIC)) {
+      if (entry->bl_entry_type != db_entry->bl_entry_type) {
+        node = list_next(node);
+        continue;
+      }
+    }
+
+    switch (db_entry->bl_type) {
+      case INTEROP_BL_TYPE_ADDR:
+        {
+          interop_addr_entry_t *src = &entry->entry_type.addr_entry;
+          interop_addr_entry_t *cur = &db_entry->entry_type.addr_entry;
+          if ( (src->feature == cur->feature) &&
+              (!memcmp( &src->addr, &cur->addr, cur->length)) ) {
+            src->length = cur->length;
+            if (ret_entry) {
+              *ret_entry = db_entry;
+            }
+            found = true;
+          }
+          break;
+        }
+      case INTEROP_BL_TYPE_NAME:
+        {
+          interop_name_entry_t *src = &entry->entry_type.name_entry;
+          interop_name_entry_t *cur = &db_entry->entry_type.name_entry;
+
+          if ((src->feature == cur->feature) &&
+              (strlen(src->name) == cur->length) &&
+              (strncasecmp(src->name, cur->name, cur->length) == 0)) {
+            if (ret_entry) {
+              *ret_entry = db_entry;
+            }
+            found = true;
+          }
+          break;
+        }
+      case INTEROP_BL_TYPE_MANUFACTURE:
+        {
+          interop_manufacturer_t *src = &entry->entry_type.mnfr_entry;
+          interop_manufacturer_t *cur = &db_entry->entry_type.mnfr_entry;
+
+          if (src->feature  == cur->feature &&
+              src->manufacturer  == cur->manufacturer) {
+            if (ret_entry) {
+              *ret_entry = db_entry;
+            }
+            found = true;
+          }
+          break;
+        }
+      case INTEROP_BL_TYPE_VNDR_PRDT:
+        {
+          interop_hid_multitouch_t *src = &entry->entry_type.vnr_pdt_entry;
+          interop_hid_multitouch_t *cur = &db_entry->entry_type.vnr_pdt_entry;
+
+          if ( (src->feature  == cur->feature) &&
+              (src->vendor_id == cur->vendor_id) &&
+              (src->product_id == cur->product_id) ) {
+            if (ret_entry) {
+              *ret_entry = db_entry;
+            }
+            found = true;
+          }
+          break;
+        }
+      case INTEROP_BL_TYPE_SSR_MAX_LAT:
+        {
+          interop_hid_ssr_max_lat_t *src = &entry->entry_type.ssr_max_lat_entry;
+          interop_hid_ssr_max_lat_t *cur = &db_entry->entry_type.ssr_max_lat_entry;
+
+          if ( (src->feature  == cur->feature) &&
+              (!memcmp( &src->addr, &cur->addr, cur->length)) ) {
+            src->length = cur->length;
+            if (ret_entry) {
+              *ret_entry = db_entry;
+            }
+            found = true;
+          }
+          break;
+        }
+    }
+
+    if (found) {
+      break;
+    }
+    node = list_next(node);
+  }
+  pthread_mutex_unlock(&interop_list_lock);
+  return found;
+}
+
+static bool interop_database_remove_( interop_db_entry_t *entry)
+{
+  bool status = true;
+  interop_db_entry_t *ret_entry = NULL;
+
+  if (!interop_database_match_(entry, &ret_entry, INTEROP_ENTRY_TYPE_DYNAMIC)) {
+    LOG_ERROR(LOG_TAG, "%s Entry not found in the list", __func__);
+    return false;
+  }
+
+  // first remove it from linked list
+  pthread_mutex_lock(&interop_list_lock);
+  list_remove(interop_list, (void*)ret_entry);
+  pthread_mutex_unlock(&interop_list_lock);
+
+  // remove it from the file
+  switch (entry->bl_type) {
+    case INTEROP_BL_TYPE_ADDR:
+      {
+        interop_addr_entry_t *src = &entry->entry_type.addr_entry;
+
+        interop_feature_t feature = src->feature;
+        bdstr_t bdstr = { '\0' };
+        bdaddr_to_string(&src->addr, bdstr, sizeof(bdstr));
+        bdstr[(src->length * 3) - 1] = '\0';
+        interop_config_remove(interop_feature_string_(feature), bdstr);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_NAME:
+      {
+        interop_name_entry_t *src = &entry->entry_type.name_entry;
+        interop_feature_t feature = src->feature;
+        interop_config_remove(interop_feature_string_(feature),
+            src->name);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_MANUFACTURE:
+      {
+        interop_manufacturer_t *src = &entry->entry_type.mnfr_entry;
+        interop_feature_t feature = src->feature;
+        char m_facturer[KEY_MAX_LENGTH] = { '\0' };
+        snprintf(m_facturer, sizeof(m_facturer), "0x%04x",
+            src->manufacturer);
+        interop_config_remove(interop_feature_string_(feature),
+            m_facturer);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_VNDR_PRDT:
+      {
+        interop_hid_multitouch_t *src = &entry->entry_type.vnr_pdt_entry;
+
+        interop_feature_t feature = src->feature;
+        char m_vendor[KEY_MAX_LENGTH] = { '\0' };
+        snprintf(m_vendor, sizeof(m_vendor), "0x%04x-0x%04x",
+            src->vendor_id, src->product_id);
+        interop_config_remove(interop_feature_string_(feature),
+            m_vendor);
+        interop_config_flush();
+        break;
+      }
+    case INTEROP_BL_TYPE_SSR_MAX_LAT:
+      {
+        interop_hid_ssr_max_lat_t *src = &entry->entry_type.ssr_max_lat_entry;
+
+        interop_feature_t feature = src->feature;
+        char m_vendor[KEY_MAX_LENGTH] = { '\0' };
+        bdstr_t bdstr = { '\0' };
+        bdaddr_to_string(&src->addr, bdstr, sizeof(bdstr));
+        bdstr[(src->length * 3) - 1] = '\0';
+        snprintf(m_vendor, sizeof(m_vendor), "%s-0x%04x",
+            bdstr, src->max_lat);
+        interop_config_remove(interop_feature_string_(feature),
+            m_vendor);
+        interop_config_flush();
+        break;
+      }
+    default:
+    status = false;
+  }
+
+  return status;
+}
+
+static char *trim(char *str)
+{
+  while (isspace(*str))
+    ++str;
+
+  if (!*str)
+    return str;
+
+  char *end_str = str + strlen(str) - 1;
+  while (end_str > str && isspace(*end_str))
+    --end_str;
+
+  end_str[1] = '\0';
+  return str;
+}
+
+static bool get_vendor_product_id(char *vendorstr, uint16_t *vendor,
+                uint16_t *product)
+{
+  char *token;
+  char *saveptr;
+  char *e;
+  bool ret_value = false;
+
+  if ( (token = strtok_r(vendorstr, VENDOR_VALUE_SEPARATOR,
+                  &saveptr)) != NULL) {
+    trim(token);
+    errno = 0;
+    *vendor = (uint16_t)strtoul(token, &e, 16);
+    if ( *e || errno == EINVAL || errno == ERANGE )
+      return false;
+  }
+  if ( (token = strtok_r(NULL, VENDOR_VALUE_SEPARATOR, &saveptr)) != NULL) {
+    trim(token);
+    errno = 0;
+    *product = (uint16_t)strtoul(token, &e, 16);
+    if ( (e != NULL) || errno != EINVAL || errno != ERANGE )
+      ret_value = true;
+  }
+  return ret_value;
+}
+
+static bool get_addr_maxlat(char *str, char *bdaddrstr,
+               uint16_t *max_lat)
+{
+    char *token;
+    char *saveptr;
+    char *e;
+    bool ret_value = false;
+
+  if ( (token = strtok_r(str, VENDOR_VALUE_SEPARATOR,
+                  &saveptr)) != NULL) {
+    trim(token);
+    errno = 0;
+    strlcpy(bdaddrstr, token, strlen(token) + 1);
+    if ( errno == EINVAL || errno == ERANGE )
+      return false;
+  }
+  if ( (token = strtok_r(NULL, VENDOR_VALUE_SEPARATOR, &saveptr)) != NULL) {
+    trim(token);
+    errno = 0;
+    *max_lat = (uint16_t)strtoul(token, &e, 16);
+    if ( (e != NULL) || errno != EINVAL || errno != ERANGE )
+      ret_value = true;
+  }
+  return ret_value;
+}
+
+bool load_to_database(int feature, char *key, char *value, interop_entry_type entry_type)
+{
+  if ( !strncasecmp( value, ADDR_BASED, strlen(ADDR_BASED)) ) {
+    bdstr_t bdstr = { '\0' };
+    bt_bdaddr_t addr;
+    int len = 0;
+    char append_str[] = ":00";
+
+    len = (strlen(key) + 1) / 3;
+    if ( len < 3 && len > 6 ) {
+      LOG_WARN(LOG_TAG, "%s Ignoring as invalid entry for Address %s",
+      __func__, key);
+      return false;
+    }
+
+    snprintf(bdstr, sizeof(bdstr), "%s", key);
+    for ( int i = 6;  i > len; i-- )
+      strlcat(bdstr, append_str, sizeof(bdstr_t));
+
+    if (!string_is_bdaddr(bdstr)) {
+      LOG_WARN(LOG_TAG,
+      "%s Bluetooth Address %s is invalid, not added to interop list",
+      __func__, key);
+      return false;
+    }
+    string_to_bdaddr(bdstr, &addr);
+
+    interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+    entry->bl_type = INTEROP_BL_TYPE_ADDR;
+    entry->bl_entry_type = entry_type;
+    bdaddr_copy(&entry->entry_type.addr_entry.addr, &addr);
+    entry->entry_type.addr_entry.feature = feature;
+    entry->entry_type.addr_entry.length = len;
+    interop_database_add_(entry, false);
+
+  } else if ( !strncasecmp( value, NAME_BASED, strlen(NAME_BASED)) ) {
+    if ( strlen(key) > KEY_MAX_LENGTH - 1) {
+      LOG_WARN(LOG_TAG, " ignoring %s due to invalid length", key);
+      return false;
+    }
+    interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+    entry->bl_type = INTEROP_BL_TYPE_NAME;
+    entry->bl_entry_type = entry_type;
+    memcpy(&entry->entry_type.name_entry.name, key, strlen(key));
+    entry->entry_type.name_entry.feature = feature;
+    entry->entry_type.name_entry.length = strlen(key);
+    interop_database_add_(entry, false);
+
+  } else if ( !strncasecmp( value, MNFR_BASED, strlen(MNFR_BASED))) {
+
+    uint16_t manufacturer;
+    char *e;
+
+    if ( strlen(key) != VALID_MNFR_STR_LEN ) {
+      LOG_WARN(LOG_TAG,
+      " ignoring %s due to invalid Manufacturer id in config file", key);
+      return false;
+    }
+
+    manufacturer = (uint16_t)strtoul(key, &e, 16);
+    errno = 0;
+    if( *e || errno == EINVAL || errno == ERANGE )
+       return false;
+    interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+    entry->bl_type = INTEROP_BL_TYPE_MANUFACTURE;
+    entry->bl_entry_type = entry_type;
+    entry->entry_type.mnfr_entry.feature = feature;
+    entry->entry_type.mnfr_entry.manufacturer = manufacturer;
+    interop_database_add_(entry, false);
+
+  } else if ( !strncasecmp( value, VNDR_PRDT_BASED, strlen(VNDR_PRDT_BASED))) {
+
+    uint16_t vendor_id;
+    uint16_t product_id;
+    char tmp_key[KEY_MAX_LENGTH] = { '\0' };
+
+    if ( strlen(key) != VALID_VNDR_PRDT_LEN ) {
+      LOG_WARN(LOG_TAG,
+      " ignoring %s due to invalid vendor/product id in config file",key);
+      return false;
+    }
+
+    strlcpy(tmp_key, key, KEY_MAX_LENGTH);
+    if (!get_vendor_product_id(tmp_key, &vendor_id, &product_id)) {
+      LOG_WARN(LOG_TAG, " Error in parsing vendor/product id %s", key);
+      return false;
+    }
+
+    interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+    entry->bl_type = INTEROP_BL_TYPE_VNDR_PRDT;
+    entry->bl_entry_type = entry_type;
+    entry->entry_type.vnr_pdt_entry.feature = feature;
+    entry->entry_type.vnr_pdt_entry.vendor_id = vendor_id;
+    entry->entry_type.vnr_pdt_entry.product_id = product_id;
+    interop_database_add_(entry, false);
+  } else if ( !strncasecmp( value, SSR_MAX_LAT_BASED, strlen(SSR_MAX_LAT_BASED))) {
+
+    uint16_t max_lat;
+    char tmp_key[KEY_MAX_LENGTH] = { '\0' };
+    char bdaddr_str[KEY_MAX_LENGTH] = { '\0' };
+
+    if ( strlen(key) != VALID_SSR_LAT_LEN ) {
+      LOG_WARN(LOG_TAG,
+      " ignoring %s due to invalid key for ssr max lat in config file",key);
+      return false;
+    }
+
+    strlcpy(tmp_key, key, KEY_MAX_LENGTH);
+    if (!get_addr_maxlat(tmp_key, bdaddr_str, &max_lat)) {
+      LOG_WARN(LOG_TAG, " Error in parsing address and max_lat %s", key);
+      return false;
+    }
+
+    bdstr_t bdstr = { '\0' };
+    bt_bdaddr_t addr;
+    int len = 0;
+    char append_str[] = ":00";
+
+    len = (strlen(bdaddr_str) + 1) / 3;
+    if ( len < 3 && len > 6 ) {
+      LOG_WARN(LOG_TAG, "%s Ignoring as invalid entry for Address %s",
+      __func__, bdaddr_str);
+      return false;
+    }
+
+    snprintf(bdstr, sizeof(bdstr), "%s", bdaddr_str);
+    for ( int i = 6;  i > len; i-- )
+      strlcat(bdstr, append_str, sizeof(bdstr_t));
+
+    if (!string_is_bdaddr(bdstr)) {
+      LOG_WARN(LOG_TAG,
+      "%s Bluetooth Address %s is invalid, not added to interop list",
+      __func__, key);
+      return false;
+    }
+    string_to_bdaddr(bdstr, &addr);
+    interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+    entry->bl_type = INTEROP_BL_TYPE_SSR_MAX_LAT;
+    entry->bl_entry_type = entry_type;
+    entry->entry_type.ssr_max_lat_entry.feature = feature;
+    bdaddr_copy(&entry->entry_type.ssr_max_lat_entry.addr, &addr);
+    entry->entry_type.ssr_max_lat_entry.length = len;
+    entry->entry_type.ssr_max_lat_entry.max_lat = max_lat;
+    interop_database_add_(entry, false);
+  }
+  LOG_WARN(LOG_TAG, " feature:: %d, key :: %s, value :: %s",
+                    feature, key, value);
+  return true;
+}
+
+static void load_config()
+{
+  if ( interop_config_init() != -1) {
+    pthread_mutex_lock(&file_lock);
+    for (const list_node_t *node = list_begin(config_static->sections);
+       node != list_end(config_static->sections); node = list_next(node)) {
+      int feature = -1;
+      interop_section_t *sec = list_node(node);
+      if ( (feature = get_feature(sec->name)) != -1 ) {
+        for (const list_node_t *node_entry = list_begin(sec->entries);
+           node_entry != list_end(sec->entries);
+           node_entry = list_next(node_entry)) {
+          interop_entry_t *entry = list_node(node_entry);
+          load_to_database(feature, entry->key, entry->value, INTEROP_ENTRY_TYPE_STATIC);
+        }
+      }
+    }
+    for (const list_node_t *node = list_begin(config_dynamic->sections);
+       node != list_end(config_dynamic->sections); node = list_next(node)) {
+      int feature = -1;
+      interop_section_t *sec = list_node(node);
+      if ( (feature = get_feature(sec->name)) != -1 ) {
+        for (const list_node_t *node_entry = list_begin(sec->entries);
+           node_entry != list_end(sec->entries);
+           node_entry = list_next(node_entry)) {
+          interop_entry_t *entry = list_node(node_entry);
+          load_to_database(feature, entry->key, entry->value, INTEROP_ENTRY_TYPE_DYNAMIC);
+        }
+      }
+    }
+    pthread_mutex_unlock(&file_lock);
+  }
+  else {
+    LOG_ERROR(LOG_TAG, "Error in initializing interop static config file");
+  }
+}
+
+static void interop_config_write(UNUSED_ATTR UINT16 event, UNUSED_ATTR char *p_param)
+{
+  assert(config_dynamic != NULL);
+
+  pthread_mutex_lock(&file_lock);
+  config_save(config_dynamic, INTEROP_DYNAMIC_FILE_PATH);
+  // sync the file as well
+  int fd = open (INTEROP_DYNAMIC_FILE_PATH, O_WRONLY | O_APPEND, 0660);
+  if (fd != -1) {
+    fsync (fd);
+    close (fd);
+  }
+  pthread_mutex_unlock(&file_lock);
+}
+
+static void interop_config_cleanup(void)
+{
+  interop_config_flush();
+
+  pthread_mutex_lock(&file_lock);
+  config_free(config_static);
+  config_static = NULL;
+  config_free(config_dynamic);
+  config_dynamic = NULL;
+  pthread_mutex_unlock(&file_lock);
+  pthread_mutex_destroy(&file_lock);
+}
+
+void interop_database_add_addr(const uint16_t feature, const bt_bdaddr_t *addr,
+                                size_t length)
+{
+  assert(addr);
+  assert(length > 0);
+  assert(length < sizeof(bt_bdaddr_t));
+
+  interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+  entry->bl_type = INTEROP_BL_TYPE_ADDR;
+  entry->bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  memcpy(&entry->entry_type.addr_entry.addr, addr, length);
+  entry->entry_type.addr_entry.feature = feature;
+  entry->entry_type.addr_entry.length = length;
+  interop_database_add_(entry, true);
+}
+
+void interop_database_add_name(const uint16_t feature, const char *name)
+{
+  assert(name);
+  interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+  entry->bl_type = INTEROP_BL_TYPE_NAME;
+  entry->bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  memcpy(&entry->entry_type.name_entry.name, name, strlen(name));
+  entry->entry_type.name_entry.feature = feature;
+  entry->entry_type.name_entry.length = strlen(name);
+  interop_database_add_(entry, true);
+}
+
+void interop_database_add_manufacturer(const interop_feature_t feature,
+                    uint16_t manufacturer)
+{
+
+  interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+  entry->bl_type = INTEROP_BL_TYPE_MANUFACTURE;
+  entry->bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  entry->entry_type.mnfr_entry.feature = feature;
+  entry->entry_type.mnfr_entry.manufacturer = manufacturer;
+  interop_database_add_(entry, true);
+}
+
+void interop_database_add_vndr_prdt(const interop_feature_t feature,
+                  uint16_t vendor_id, uint16_t product_id)
+{
+
+  interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+  entry->bl_type = INTEROP_BL_TYPE_VNDR_PRDT;
+  entry->bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  entry->entry_type.vnr_pdt_entry.feature = feature;
+  entry->entry_type.vnr_pdt_entry.vendor_id = vendor_id;
+  entry->entry_type.vnr_pdt_entry.product_id = product_id;
+  interop_database_add_(entry, true);
+}
+
+void interop_database_add_addr_max_lat(const interop_feature_t feature,
+                  const bt_bdaddr_t *addr, size_t length, uint16_t max_lat)
+{
+
+  assert(addr);
+  assert(length > 0);
+  assert(length < sizeof(bt_bdaddr_t));
+
+  interop_db_entry_t *entry = osi_calloc(sizeof(interop_db_entry_t));
+  entry->bl_type = INTEROP_BL_TYPE_SSR_MAX_LAT;
+  entry->bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  memcpy(&entry->entry_type.ssr_max_lat_entry.addr, addr, length);
+  entry->entry_type.ssr_max_lat_entry.feature = feature;
+  entry->entry_type.ssr_max_lat_entry.length = length;
+  entry->entry_type.ssr_max_lat_entry.max_lat = max_lat;
+  interop_database_add_(entry, true);
+}
+
+bool interop_database_match_manufacturer(const interop_feature_t feature,
+                      uint16_t manufacturer)
+{
+
+  interop_db_entry_t entry;
+  interop_db_entry_t *ret_entry = NULL;
+
+  entry.bl_type = INTEROP_BL_TYPE_MANUFACTURE;
+  entry.entry_type.mnfr_entry.feature = feature;
+  entry.entry_type.mnfr_entry.manufacturer = manufacturer;
+
+  if (interop_database_match_(&entry, &ret_entry, INTEROP_ENTRY_TYPE_STATIC | INTEROP_ENTRY_TYPE_DYNAMIC)) {
+    LOG_WARN(LOG_TAG, "%s() Device with manufacturer id: %d is a match for interop "
+      "workaround %s", __func__, manufacturer, interop_feature_string_(feature));
+    return true;
+  }
+
+  return false;
+}
+
+bool interop_database_match_name( const interop_feature_t feature, const char *name)
+{
+  assert(name);
+
+  interop_db_entry_t entry;
+  interop_db_entry_t *ret_entry = NULL;
+
+  entry.bl_type = INTEROP_BL_TYPE_NAME;
+  strlcpy(entry.entry_type.name_entry.name, name, KEY_MAX_LENGTH);
+  entry.entry_type.name_entry.feature = feature;
+  entry.entry_type.name_entry.length = strlen(entry.entry_type.name_entry.name);
+
+  if (interop_database_match_(&entry, &ret_entry, INTEROP_ENTRY_TYPE_STATIC  | INTEROP_ENTRY_TYPE_DYNAMIC)) {
+    LOG_WARN(LOG_TAG,
+    "%s() Device with name: %s is a match for interop workaround %s", __func__,
+      name, interop_feature_string_(feature));
+    return true;
+  }
+
+  return false;
+}
+
+bool interop_database_match_addr(const interop_feature_t feature, const bt_bdaddr_t *addr)
+{
+  assert(addr);
+
+  interop_db_entry_t entry;
+  interop_db_entry_t *ret_entry = NULL;
+
+  entry.bl_type = INTEROP_BL_TYPE_ADDR;
+  memcpy(&entry.entry_type.addr_entry.addr, addr, sizeof(bt_bdaddr_t));
+  entry.entry_type.addr_entry.feature = feature;
+  entry.entry_type.addr_entry.length = sizeof(bt_bdaddr_t);
+
+  if (interop_database_match_(&entry, &ret_entry, INTEROP_ENTRY_TYPE_STATIC  | INTEROP_ENTRY_TYPE_DYNAMIC)) {
+    bdstr_t bdstr = { '\0' };
+    LOG_WARN(LOG_TAG, "%s() Device %s is a match for interop workaround %s.",
+      __func__, bdaddr_to_string(addr, bdstr, sizeof(bdstr)),
+      interop_feature_string_(feature));
+    return true;
+  }
+
+  return false;
+}
+
+bool interop_database_match_vndr_prdt(const interop_feature_t feature,
+                   uint16_t vendor_id, uint16_t product_id)
+{
+
+  interop_db_entry_t entry;
+  interop_db_entry_t *ret_entry = NULL;
+
+  entry.bl_type = INTEROP_BL_TYPE_VNDR_PRDT;
+
+  entry.entry_type.vnr_pdt_entry.feature = feature;
+  entry.entry_type.vnr_pdt_entry.vendor_id = vendor_id;
+  entry.entry_type.vnr_pdt_entry.product_id = product_id;
+  if (interop_database_match_(&entry, &ret_entry,  INTEROP_ENTRY_TYPE_STATIC  | INTEROP_ENTRY_TYPE_DYNAMIC)) {
+    LOG_WARN(LOG_TAG,
+      "%s() Device with vendor_id: %d product_id: %d is a match for "
+      "interop workaround %s", __func__, vendor_id, product_id,
+      interop_feature_string_(feature));
+    return true;
+  }
+
+  return false;
+}
+
+bool interop_database_match_addr_get_max_lat(const interop_feature_t feature,
+                   const bt_bdaddr_t *addr, uint16_t *max_lat)
+{
+
+  interop_db_entry_t entry;
+  interop_db_entry_t *ret_entry = NULL;
+
+  entry.bl_type = INTEROP_BL_TYPE_SSR_MAX_LAT;
+
+  entry.entry_type.ssr_max_lat_entry.feature = feature;
+  memcpy(&entry.entry_type.ssr_max_lat_entry.addr, addr, sizeof(bt_bdaddr_t));
+  entry.entry_type.ssr_max_lat_entry.feature = feature;
+  entry.entry_type.ssr_max_lat_entry.length = sizeof(bt_bdaddr_t);
+  if (interop_database_match_(&entry, &ret_entry, INTEROP_ENTRY_TYPE_STATIC  | INTEROP_ENTRY_TYPE_DYNAMIC)) {
+      bdstr_t bdstr = { '\0' };
+      LOG_WARN(LOG_TAG, "%s() Device %s is a match for interop workaround %s.",
+        __func__, bdaddr_to_string(addr, bdstr, sizeof(bdstr)),
+        interop_feature_string_(feature));
+      *max_lat = ret_entry->entry_type.ssr_max_lat_entry.max_lat;
+    return true;
+  }
+
+  return false;
+}
+
+bool interop_database_remove_name( const interop_feature_t feature, const char *name)
+{
+  assert(name);
+
+  interop_db_entry_t entry;
+
+  entry.bl_type = INTEROP_BL_TYPE_NAME;
+  entry.bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  strlcpy(entry.entry_type.name_entry.name, name, KEY_MAX_LENGTH);
+  entry.entry_type.name_entry.feature = feature;
+  entry.entry_type.name_entry.length = strlen(entry.entry_type.name_entry.name);
+  if (interop_database_remove_(&entry)) {
+    LOG_WARN(LOG_TAG,
+      "%s() Device with name: %s is removed from interop workaround %s",
+      __func__, name, interop_feature_string_(feature));
+    return true;
+  }
+
+  return false;
+}
+
+bool interop_database_remove_manufacturer( const interop_feature_t feature,
+                          uint16_t manufacturer)
+{
+
+  interop_db_entry_t entry;
+
+  entry.bl_type = INTEROP_BL_TYPE_MANUFACTURE;
+  entry.bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  entry.entry_type.mnfr_entry.feature = feature;
+  entry.entry_type.mnfr_entry.manufacturer = manufacturer;
+  if (interop_database_remove_(&entry)) {
+    LOG_WARN(LOG_TAG,
+      "%s() Device with manufacturer id: %d is removed from interop "
+      "workaround %s", __func__, manufacturer,
+      interop_feature_string_(feature));
+    return true;
+  }
+
+  return false;
+}
+
+
+bool interop_database_remove_addr(const interop_feature_t feature,
+                    const bt_bdaddr_t *addr)
+{
+  assert(addr);
+
+  interop_db_entry_t entry;
+
+  entry.bl_type = INTEROP_BL_TYPE_ADDR;
+  entry.bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+  memcpy(&entry.entry_type.addr_entry.addr, addr, sizeof(bt_bdaddr_t));
+  entry.entry_type.addr_entry.feature = feature;
+  entry.entry_type.addr_entry.length = sizeof(bt_bdaddr_t);
+  if (interop_database_remove_(&entry)) {
+    bdstr_t bdstr = { '\0' };
+    LOG_WARN(LOG_TAG,
+      "%s() Device %s is a removed from interop workaround %s.",
+      __func__, bdaddr_to_string(addr, bdstr, sizeof(bdstr)),
+      interop_feature_string_(feature));
+    return true;
+  }
+
+  return false;
+}
+
+bool interop_database_remove_vndr_prdt(const interop_feature_t feature,
+          uint16_t vendor_id, uint16_t product_id)
+{
+
+  interop_db_entry_t entry;
+
+  entry.bl_type = INTEROP_BL_TYPE_VNDR_PRDT;
+  entry.bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+
+  entry.entry_type.vnr_pdt_entry.feature = feature;
+  entry.entry_type.vnr_pdt_entry.vendor_id = vendor_id;
+  entry.entry_type.vnr_pdt_entry.product_id = product_id;
+
+  if (interop_database_remove_(&entry)) {
+    LOG_WARN(LOG_TAG,
+      "%s() Device with vendor_id: %d product_id: %d is removed from"
+      "interop workaround %s", __func__, vendor_id, product_id,
+      interop_feature_string_(feature));
+    return true;
+  }
+  return false;
+}
+
+bool interop_database_remove_addr_max_lat(const interop_feature_t feature,
+          const bt_bdaddr_t *addr, size_t length, uint16_t max_lat)
+{
+
+  interop_db_entry_t entry;
+
+  entry.bl_type = INTEROP_BL_TYPE_SSR_MAX_LAT;
+  entry.bl_entry_type = INTEROP_ENTRY_TYPE_DYNAMIC;
+
+  memcpy(&entry.entry_type.ssr_max_lat_entry.addr, addr, sizeof(bt_bdaddr_t));
+  entry.entry_type.ssr_max_lat_entry.feature = feature;
+  entry.entry_type.ssr_max_lat_entry.length = sizeof(bt_bdaddr_t);
+  entry.entry_type.ssr_max_lat_entry.max_lat = max_lat;
+
+  if (interop_database_remove_(&entry)) {
+      bdstr_t bdstr = { '\0' };
+      LOG_WARN(LOG_TAG,
+        "%s() Device %s is a removed from interop workaround %s.",
+        __func__, bdaddr_to_string(addr, bdstr, sizeof(bdstr)),
+        interop_feature_string_(feature));
+    return true;
+  }
+  return false;
+}
+
diff --git a/wipower-host/Android.mk b/wipower-host/Android.mk
index 20d13f5..b26fd6d 100644
--- a/wipower-host/Android.mk
+++ b/wipower-host/Android.mk
@@ -2,4 +2,3 @@ ifeq ($(BOARD_USES_WIPOWER),true)
 LOCAL_PATH := $(call my-dir)
 include $(call all-subdir-makefiles)
 endif
-
diff --git a/wipower-host/a4wp/Android.mk b/wipower-host/a4wp/Android.mk
index edf6dd4..f66ce75 100644
--- a/wipower-host/a4wp/Android.mk
+++ b/wipower-host/a4wp/Android.mk
@@ -15,6 +15,7 @@ LOCAL_JAVA_LIBRARIES += android.wipower
 LOCAL_REQUIRED_MODULES := bluetooth.default
 
 LOCAL_PROGUARD_ENABLED := disabled
+LOCAL_PRIVILEGED_MODULE := true
 
 LOCAL_MULTILIB := 32
 LOCAL_JNI_SHARED_LIBRARIES := libwipower_jni
diff --git a/wipower-host/a4wp/AndroidManifest.xml b/wipower-host/a4wp/AndroidManifest.xml
index 690bc66..99bda19 100644
--- a/wipower-host/a4wp/AndroidManifest.xml
+++ b/wipower-host/a4wp/AndroidManifest.xml
@@ -34,11 +34,14 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
     <original-package android:name="org.codeaurora.bt_wipower" />
 
+    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
+    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
     <uses-permission android:name="android.permission.ACCESS_BLUETOOTH_SHARE" />
     <uses-permission android:name="android.permission.BLUETOOTH" />
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
     <uses-permission android:name="android.permission.WAKE_LOCK" />
     <uses-permission android:name="android.permission.BLUETOOTH_STACK" />
+    <uses-permission android:name="android.permission.BLUETOOTH_PRIVILEGED" />
     <uses-feature android:name="android.hardware.bluetooth_le" android:required="true" />
     <application android:process="com.android.bluetooth"
         android:persistent="false"
@@ -57,6 +60,15 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
             android:exported="true"
             android:name=".a4wp.BTEventHandler">
             <intent-filter>
+               <action android:name="com.quicinc.wbc.action.ACTION_PTU_PRESENT" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.AIRPLANE_MODE" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.bluetooth.adapter.action.BLE_STATE_CHANGED" />
+            </intent-filter>
+            <intent-filter>
                 <action android:name="android.bluetooth.adapter.action.STATE_CHANGED" />
             </intent-filter>
         </receiver>
diff --git a/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/A4wpService.java b/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/A4wpService.java
index e8bf7e5..d2cd211 100644
--- a/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/A4wpService.java
+++ b/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/A4wpService.java
@@ -84,9 +84,11 @@ public class A4wpService extends Service
     private BluetoothDevice mDevice = null;
     private PowerManager.WakeLock mWakeLock = null;
 
+    private static boolean sDebug = false;
+
     // Advertising variables
-    private final static int START_ADVERTISING = 1;
-    private final static int STOP_ADVERTISING = 0;
+    private static final int START_ADVERTISING = 1;
+    private static final int STOP_ADVERTISING = 0;
 
     private static final UUID A4WP_SERVICE_UUID = UUID.fromString("6455fffe-a146-11e2-9e96-0800200c9a67");
     //PRU writes
@@ -102,26 +104,26 @@ public class A4wpService extends Service
     private static final Object mLock = new Object();
     private int mState = BluetoothProfile.STATE_DISCONNECTED;
 
-    private final static short DEFAULT_FIELDS = 0x0000;
-    private final static short DEFAULT_PROTOCOL_REV = 0x0000;
-    private final static short DEFAULT_RFU = 0x0000;
+    private static final short DEFAULT_FIELDS = 0x0000;
+    private static final short DEFAULT_PROTOCOL_REV = 0x0001;
+    private static final short DEFAULT_RFU = 0x0000;
     //03 if MTP, Has to be 04 for fluid.
-    private final static byte DEFAULT_CATEGORY = 0x0003;
-    private final static byte DEFAULT_CAPABILITIES = 0x00;
-    private final static byte DEFAULT_HW_VERSION = 0x0007;
-    private final static byte DEFAULT_FW_VERSION = 0x0006;
-    private final static byte DEFAULT_MAX_POWER_DESIRED = 0x0032;  // 5Watts
-    private final static short DEFAULT_VRECT_MIN = 7100;       // 7.1 Volts
-    private final static short DEFAULT_VRECT_MAX = 19300;       // 19.3 Volts
-    private final static short DEFAULT_VRECT_SET = 7200;       // 7.2 Volts
-    private final static short DEFAULT_DELTA_R1 = 0x0001;
-    private final static int DEFAULT_RFU_VAL = 0x0000;
+    private static final byte DEFAULT_CATEGORY = 0x0003;
+    private static final byte DEFAULT_CAPABILITIES = 0x00;
+    private static final byte DEFAULT_HW_VERSION = 0x0007;
+    private static final byte DEFAULT_FW_VERSION = 0x0006;
+    private static final byte DEFAULT_MAX_POWER_DESIRED = 0x0032;  // 5Watts
+    private static final short DEFAULT_VRECT_MIN = 7100;       // 7.1 Volts
+    private static final short DEFAULT_VRECT_MAX = 19300;       // 19.3 Volts
+    private static final short DEFAULT_VRECT_SET = 7200;       // 7.2 Volts
+    private static final short DEFAULT_DELTA_R1 = 0x0001;
+    private static final int DEFAULT_RFU_VAL = 0x0000;
     private static final int MSB_MASK = 0xFF00;
     private static final int LSB_MASK= 0x00FF;
     // On charge port disbaled need to be set to 10.2 Volts
-    private final static short VRECT_MIN_CHG_DISABLED = 10200;
+    private static final short VRECT_MIN_CHG_DISABLED = 10200;
     // Populate Vrectmin, Vrectmax, Vrectset and temperature in the optional fields
-    private final static byte OPTIONAL_FIELD_MASK = 0x3C;
+    private static final byte OPTIONAL_FIELD_MASK = 0x3C;
 
     //Timeout value set to 5Sec which enures we advertise in limited mode
     private static final int WIPOWER_ADV_TIMEOUT = 5000;
@@ -156,9 +158,25 @@ public class A4wpService extends Service
     private static final int VRECT_MAX_MSB = 15;
     private static final int PRU_ALERT = 16;
 
+    /*
+     * PRU ALERT fields in BSS 1.3 are defined as follows
+     * Bit 7    6    5    4          3              2    1            0
+     *     OVP, OCP, OTP, Self_prot, Charge Complt, USB, Charge Port, PowerSharing Resp
+     */
+    private static final byte PRU_ALERT_OVER_VOLTAGE_DETECT_BIT = (byte) 0x80;
+    private static final byte PRU_ALERT_OVER_CURRENT_DETECT_BIT = 0x40;
+    private static final byte PRU_ALERT_OVER_TEMPERATURE_DETECT_BIT = 0x20;
+    private static final byte PRU_ALERT_SELF_PROTECT_DETECT_BIT = 0x10;
+    private static final byte PRU_ALERT_CHARGE_COMPLETE_BIT = 0x08;
+    private static final byte PRU_ALERT_WIRE_CHARGER_DETECT_BIT = 0x04;
+    private static final byte PRU_ALERT_CHARGE_PORT_ENABLED_BIT = 0x02;
+    private static final byte PRU_ALERT_PWR_SHARE_RESP_BIT = 0x01;
+
     private static boolean mWipowerBoot = false;
     private static boolean isChargePortSet = false;
-    static boolean mChargeComplete = true;
+    static boolean mChargeComplete = false;
+    static boolean mUSBCharging = false;
+    static boolean mOverTemperature = false;
     static boolean mOutputControl = false;
     private static boolean mDiscInitiated = false; // If TRUE, means A4WP app has initiated the disconnection with PTU
     private static boolean mEnablePruAlerts = false;  // Are PRU Alerts enabled
@@ -181,13 +199,12 @@ public class A4wpService extends Service
         if (!isChargePortSet) {
             VRECT_DYN = (short)toUnsigned(value[VRECT_LSB]);
             VRECT_DYN |= (short)(toUnsigned(value[VRECT_MSB]) << 8);
-            if (DEFAULT_VRECT_MIN <= VRECT_DYN && mOutputControl) {
+            if (VRECT_MIN_CHG_DISABLED <= VRECT_DYN && mOutputControl) {
                 mWipowerManager.startCharging();
                 isChargePortSet = true;
             }
-        }
-        if (isChargePortSet) {
-            if ((byte)(value[PRU_ALERT] & CHARGE_PORT_MASK) == CHARGE_PORT_MASK) {
+        } else {
+            if ((byte)(value[PRU_ALERT] & CHARGE_PORT_MASK) == 0) {
                 if ((value[IRECT_LSB] <= IRECT_MASK_LSB && value[IRECT_MSB] == IRECT_MASK_MSB)
                      && (value[VRECT_LSB] > VRECT_MASK || value[VRECT_MSB] > VRECT_MASK)) {
                      mWipowerManager.startCharging();
@@ -197,17 +214,26 @@ public class A4wpService extends Service
     }
 
     private synchronized void initiateDisconnection() {
-        Log.v(LOGTAG, "initiateDisconnection:" + " mDiscInitiated:" + mDiscInitiated + " mState:" + mState);
+        if (sDebug) Log.v(LOGTAG, "initiateDisconnection:" + " mDiscInitiated:" + mDiscInitiated + " mState:" + mState);
         if ((mDiscInitiated == false) && (mState == BluetoothProfile.STATE_CONNECTED))
         {
             if (mBluetoothGattServer != null && mDevice != null) {
-                Log.v(LOGTAG, "initiateDisconnection:" + " dropping Connection");
+                if (sDebug) Log.v(LOGTAG, "initiateDisconnection:" + " dropping Connection");
                 mDiscInitiated = true;
                 mBluetoothGattServer.cancelConnection(mDevice);
+                mWipowerManager.enableDataNotification(false);
                 mWipowerManager.enablePowerApply(false, false, false);
-                if (mChargeComplete == true) {
+                if ((mChargeComplete == true) || (mUSBCharging == true)) {
+                    /*
+                     * If charge is complete or USB wire charging is in progress, then MTP
+                     * needs to connect after 600 ms of continuous PTU power.
+                     */
                     mWipowerManager.enablePowerApply(true, true, true);
                 } else {
+                    /*
+                     * Device needs to be charged, so start advertising after 30 ms detecting PTU power.
+                     * Connect on the long beacon.
+                     */
                     mWipowerManager.enablePowerApply(true, true, false);
                 }
             }
@@ -220,36 +246,84 @@ public class A4wpService extends Service
         @Override
         public void onWbcEventUpdate(int what, int arg1, int arg2) {
             Log.v(LOGTAG, "onWbcEventUpdate rcvd: " + what + ", " + arg1 + ", " + arg2);
-            if ((what == WbcTypes.WBC_EVENT_TYPE_CHARGING_REQUIRED_STATUS)){
-                mWipowerManager.enablePowerApply(false, false, false);
-                if ((arg1 == WbcTypes.WBC_BATTERY_STATUS_CHARGING_NOT_REQUIRED)){
-                    // this will set charge complete bit in pru alert
-                    // eventally leading to a possible disconnect from ptu
-                    mChargeComplete = true;
-                    if (mPruAlert != null)
-                    {
-                       byte  alert = 0;
-                       alert = (byte) (alert | CHARGE_COMPLETE_BIT);
-                       mPruAlert.sendPruAlert(alert);
+
+            switch (what) {
+                case WbcTypes.WBC_EVENT_TYPE_CHARGE_COMPLETE:
+                    if (arg1 == WbcTypes.WBC_BATTERY_STATUS_CHARGE_COMPLETE) {
+                        // this will set charge complete bit in pru alert
+                        // eventally leading to a possible disconnect from ptu
+                        mChargeComplete = true;
+                        if (mPruAlert != null) {
+                            byte  alert = 0;
+                            alert = (byte) (alert | PRU_ALERT_CHARGE_COMPLETE_BIT);
+                            mPruAlert.sendPruAlert(alert);
+                        }
+                        mWipowerManager.enablePowerApply(false, false, false);
+                        mWipowerManager.enablePowerApply(true, true, true);
+                    } else {
+                        mChargeComplete = false;
+                        if ((mUSBCharging == false) &&  (mState == BluetoothProfile.STATE_DISCONNECTED)) {
+                            mWipowerManager.enableDataNotification(false);
+                            mWipowerManager.enablePowerApply(false, false, false);
+                            mWipowerManager.enablePowerApply(true, true, false);
+                        }
                     }
-                    if ((mState == BluetoothProfile.STATE_DISCONNECTED) && (mWipowerManager != null))
+                    break;
+                case WbcTypes.WBC_EVENT_TYPE_PTU_PRESENCE_STATUS:
+                    // Do nothing.
+                    break;
+                case WbcTypes.WBC_EVENT_TYPE_USB_CHARGING_PRESENT:
+                    if (arg1 == WbcTypes.WBC_USB_CHARGING_PRESENT) {
+                        mUSBCharging = true;
+                        // Set the wire charger bit here and send alert.
+                        if (mPruAlert != null) {
+                            byte alert = 0;
+                            alert = (byte) (alert | PRU_ALERT_WIRE_CHARGER_DETECT_BIT);
+                            mPruAlert.sendPruAlert(alert);
+                        }
+                        mWipowerManager.enablePowerApply(false, false, false);
                         mWipowerManager.enablePowerApply(true, true, true);
-                } else {
-                    // We could be in 600mS scan state here and since charging needs to be resumed
-                    // send enable power apply command to scan for short beacons */
-                    mChargeComplete = false;
-                    if ((mState == BluetoothProfile.STATE_DISCONNECTED) && (mWipowerManager != null))
-                        mWipowerManager.enablePowerApply(true, true, false);
-                }
-            } else if (what == WbcTypes.WBC_EVENT_TYPE_PTU_PRESENCE_STATUS) {
-                if (arg1 == WbcTypes.WBC_PTU_STATUS_NOT_PRESENT) {
-                    initiateDisconnection();
-                }
+                    } else {
+                        mUSBCharging = false;
+                        if ((mChargeComplete == false) &&  (mState == BluetoothProfile.STATE_DISCONNECTED)) {
+                            mWipowerManager.enableDataNotification(false);
+                            mWipowerManager.enablePowerApply(false, false, false);
+                            mWipowerManager.enablePowerApply(true, true, false);
+                        }
+                    }
+                    break;
+                case WbcTypes.WBC_EVENT_TYPE_BATTERY_OVERHEAT:
+                    mWipowerManager.enablePowerApply(false, false, false);
+                    // Set the over-temperature bit here and send alert.
+                    if (arg1 == WbcTypes.WBC_BATTERY_OVERHEAT) {
+                        mOverTemperature = true;
+                        if (mPruAlert != null) {
+                            byte  alert = 0;
+                            alert = (byte) (alert | PRU_ALERT_OVER_TEMPERATURE_DETECT_BIT);
+                            mPruAlert.sendPruAlert(alert);
+                        }
+                    }
+                    else {
+                        mOverTemperature = false;
+                        if ((mChargeComplete == false) &&  mUSBCharging == false && (mState == BluetoothProfile.STATE_DISCONNECTED)) {
+                            mWipowerManager.enablePowerApply(false, false, false);
+                            mWipowerManager.enablePowerApply(true, true, false);
+                        }
+                    }
+                    break;
+                case WbcTypes.WBC_EVENT_TYPE_WIPOWER_CHARGING_ACTIVE_STATUS:
+                    // Do nothing.
+                    break;
+                default:
+                    Log.v(LOGTAG, "onWbcEventUpdate: Unrecognized event received");
+                    break;
             }
-            Log.v(LOGTAG, "onWbcEventUpdate: charge complete " +  mChargeComplete);
+            if (sDebug) Log.v(LOGTAG, "onWbcEventUpdate: charge complete " +  mChargeComplete);
+            if (sDebug) Log.v(LOGTAG, "onWbcEventUpdate: USB charging " +  mUSBCharging);
         }
     };
 
+
     private  void acquire_wake_lock(boolean wake) {
         if (wake == true) {
             if (mWakeLock == null) {
@@ -387,7 +461,7 @@ public class A4wpService extends Service
             int intValue= 0;
             intValue = ((value[0]<< 8) & 0x0000ff00) | ((value[1] << 0) & 0x000000ff);
 
-            Log.v(LOGTAG, "processPruAlertRequest. Value: " + intValue);
+            if (sDebug) Log.v(LOGTAG, "processPruAlertRequest. Value: " + intValue);
 
             if ((intValue & PRU_ALERT_NOTIFY_BIT) == PRU_ALERT_NOTIFY_BIT) {
                 Log.v(LOGTAG, "processPruAlertRequest. PRU Alerts Enabled");
@@ -492,7 +566,7 @@ public class A4wpService extends Service
         public double getPower() {
             double val = ((mPower&0xfc)>>2);
             val = 0.5*(val+1);
-            Log.v(LOGTAG, "getPower<=" + val);
+            if (sDebug) Log.v(LOGTAG, "getPower<=" + val);
             if (val > 22) val = 22.0;
             return val;
         }
@@ -500,7 +574,7 @@ public class A4wpService extends Service
         public double getMaxSrcImpedence() {
             double val = ((mMaxSrcImpedence&0xf8)>>3);
             val = 50 + (val*10);
-            Log.v(LOGTAG, "getSrcImpedence<=" + val);
+            if (sDebug) Log.v(LOGTAG, "getSrcImpedence<=" + val);
             if (val > 375) val = 375.0;
             return val;
         }
@@ -508,14 +582,14 @@ public class A4wpService extends Service
         public double getMaxLoadResistance() {
             double val = ((mMaxLoadResistance&0xf8)>>3);
             val = 5 * (val+1);
-            Log.v(LOGTAG, "getMaxLoadResistance<=" + val);
+            if (sDebug) Log.v(LOGTAG, "getMaxLoadResistance<=" + val);
             if (val > 55) val = 55.0;
             return val;
         }
 
         public float getMaxDevicesSupported() {
             int val = mMaxDevicesSupported +1;
-            Log.v(LOGTAG, "getMaxDevicesSupported<=" + val);
+            if (sDebug) Log.v(LOGTAG, "getMaxDevicesSupported<=" + val);
             if (val > 8) val = 8;
             return val;
         }
@@ -621,7 +695,7 @@ public class A4wpService extends Service
           */
          public boolean getPermission() {
 
-             Log.v(LOGTAG, "getPermission" + mPermission);
+             if (sDebug) Log.v(LOGTAG, "getPermission" + mPermission);
              if (mPermission == 0x00) return true;
              else return false;
          }
@@ -703,15 +777,13 @@ public class A4wpService extends Service
 
     private int processPtuStaticParam(byte[] value) {
         int status = 0;
-        Log.v(LOGTAG, "processPtuStaticParam>");
+        if (sDebug) Log.v(LOGTAG, "processPtuStaticParam>");
         mPtuStaticParam = new PtuStaticParam(value);
         mPtuStaticParam.print();
 
         return status;
     }
 
-    private static final byte CHARGE_COMPLETE_BIT = 0x08;
-
     /**
      * Wipower callbacks
      */
@@ -720,8 +792,9 @@ public class A4wpService extends Service
         @Override
         public void onWipowerReady() {
             Log.v(LOGTAG, "onWipowerReady");
+            mWipowerManager.enableDataNotification(false);
             mWipowerManager.enablePowerApply(false, false, false);
-            if (mChargeComplete == true) {
+            if ((mChargeComplete == true) || (mUSBCharging == true)) {
                 mWipowerManager.enablePowerApply(true, true, true);
             } else {
                 mWipowerManager.enablePowerApply(true, true, false);
@@ -745,17 +818,17 @@ public class A4wpService extends Service
 
         @Override
         public void onWipowerAlert(byte alert) {
-            Log.v(LOGTAG, "onWipowerAlert: " + alert + " alert recieved");
+            if (sDebug) Log.v(LOGTAG, "onWipowerAlert: " + alert + " alert recieved");
             mPruAlert.sendPruAlert(alert);
         }
 
 
         @Override
         public void onWipowerData(WipowerDynamicParam data) {
-            Log.v(LOGTAG, "onWipowerData Alert");
+            if (sDebug) Log.v(LOGTAG, "onWipowerData Alert");
             byte[] value = data.getValue();
             chkDynParamsAndStartCharging(value);
-            Log.v(LOGTAG, "calling SetValue");
+            if (sDebug) Log.v(LOGTAG, "calling SetValue");
             mPruDynamicParam.setValue(value);
         }
 
@@ -782,11 +855,13 @@ public class A4wpService extends Service
                     mWipowerManager.enableAlertNotification(false);
                     mEnablePruAlerts  = false;
                     mWipowerManager.stopCharging();
-                    mWipowerManager.enablePowerApply(false, false, false);
-                    if (mChargeComplete != true) {
-                        mWipowerManager.enablePowerApply(true, true, false);
-                    } else {
+                    mWipowerManager.enablePowerApply(false, false, false); // Always reset the FW state machine
+                    if ((mChargeComplete == true) || (mUSBCharging == true)) {
                         mWipowerManager.enablePowerApply(true, true, true);
+
+                    } else {
+                        mWipowerManager.enablePowerApply(true, true, false);
+
                     }
                     if(SystemProperties.getBoolean("persist.a4wp.skipwakelock", false) == false) {
                         /* Drop wake lock once the connection is dropped gracefully */
@@ -843,7 +918,7 @@ public class A4wpService extends Service
 
                 if (value != null)
                 {
-                     Log.v(LOGTAG, "device=" + id + "requestId=" + requestId + "status=" + status + "offset=" + offset + "value=" + value[0]);
+                     if (sDebug) Log.v(LOGTAG, "device=" + id + "requestId=" + requestId + "status=" + status + "offset=" + offset + "value=" + value[0]);
                      mBluetoothGattServer.sendResponse(device, requestId, status, offset, value);
                 }
         }
@@ -885,6 +960,9 @@ public class A4wpService extends Service
                     value = mPruStaticParam.getValue();
                     mDevice = device;
                     mState = BluetoothProfile.STATE_CONNECTED;
+                    /* intiate a server connect so that gatt will maintain
+                    ** this as a vote in its existing  LE connections.*/
+                    mBluetoothGattServer.connect(mDevice, false);
                     mWipowerManager.enableDataNotification(true);
                 }
                 else if (id == A4WP_PRU_DYNAMIC_UUID) {
@@ -893,11 +971,29 @@ public class A4wpService extends Service
                          return;
                     }
                     value = mPruDynamicParam.getValue();
+
+                    /*
+                     * TODO: Populate all PRU ALERT fields in the PRU dynamic parameter. Populate
+                     * charge complete, Wire charge detect, Over Temp Protection on WBC feedback.
+                     */
                     if (mChargeComplete == true) {
-                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] | CHARGE_COMPLETE_BIT);
+                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] | PRU_ALERT_CHARGE_COMPLETE_BIT);
+                    } else {
+                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] & (~PRU_ALERT_CHARGE_COMPLETE_BIT));
+                    }
+
+                    if (mUSBCharging == true) {
+                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] | PRU_ALERT_WIRE_CHARGER_DETECT_BIT);
+                    } else {
+                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] & (~PRU_ALERT_WIRE_CHARGER_DETECT_BIT));
+                    }
+
+                    if (mOverTemperature == true) {
+                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] | PRU_ALERT_OVER_TEMPERATURE_DETECT_BIT);
                     } else {
-                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] & (~CHARGE_COMPLETE_BIT));
+                        value[PRU_ALERT] = (byte)(value[PRU_ALERT] & (~PRU_ALERT_OVER_TEMPERATURE_DETECT_BIT));
                     }
+
                     value[OPTIONAL_FIELDS] = (byte)OPTIONAL_FIELD_MASK;
                     value[VRECT_MAX_LSB] = (byte)(LSB_MASK & DEFAULT_VRECT_MAX);
                     value[VRECT_MAX_MSB] = (byte)((MSB_MASK & DEFAULT_VRECT_MAX) >> 8);
@@ -920,7 +1016,7 @@ public class A4wpService extends Service
                     }
                    value = mPruControl.getValue();
                 }
-                if (mBluetoothGattServer != null) {
+                if (mBluetoothGattServer != null && mDiscInitiated != true) {
                     mBluetoothGattServer.sendResponse(device, requestId, status, offset, value);
                 }
         }
@@ -933,6 +1029,7 @@ public class A4wpService extends Service
 
     private void closeServer() {
         if (mBluetoothGattServer != null) {
+            if (sDebug) Log.v(LOGTAG, "disconnect and closeServer");
             if (mDevice != null) mBluetoothGattServer.cancelConnection(mDevice);
             mBluetoothGattServer.close();
         }
@@ -949,8 +1046,9 @@ public class A4wpService extends Service
         public void onStartSuccess(AdvertiseSettings settingsInEffect) {
             Log.d(LOGTAG, "advertise success " + mIndex);
             if (mWipowerManager != null) {
+                mWipowerManager.enableDataNotification(false);
                 mWipowerManager.enablePowerApply(false, false, false);
-                if (mChargeComplete == true) {
+                if ((mChargeComplete == true) || (mUSBCharging == true)) {
                     mWipowerManager.enablePowerApply(true, true, true);
                 } else {
                     mWipowerManager.enablePowerApply(true, true, false);
@@ -985,7 +1083,7 @@ public class A4wpService extends Service
             .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)
             .setConnectable(true).build();
 
-        Log.d(LOGTAG, " Calling mAdvertiser.startAdvertising");
+        if (sDebug) Log.d(LOGTAG, " Calling mAdvertiser.startAdvertising");
         if(mAdvertiser != null)
             mAdvertiser.startAdvertising(mAdvertiseSettings, mAdvertisementData, mAdvertiseCallback);
         else
@@ -996,6 +1094,7 @@ public class A4wpService extends Service
     {
        /* to be completed */
        if (mAdvertiseCallback != null &&  mAdvertiser != null) {
+           if (sDebug) Log.d(LOGTAG, "stop advertising on service destroy");
            mAdvertiser.stopAdvertising(mAdvertiseCallback);
        }
     }
@@ -1004,7 +1103,7 @@ public class A4wpService extends Service
         BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
         if (bluetoothManager == null) return false;
 
-        mBluetoothGattServer = bluetoothManager.openGattServer(this, mGattCallbacks);
+        mBluetoothGattServer = bluetoothManager.openGattServer(this, mGattCallbacks, BluetoothDevice.TRANSPORT_LE);
         Log.d(LOGTAG,"calling start server......");
         if (mBluetoothGattServer == null) {
             Log.e(LOGTAG,"mBluetoothGattServer is NULL");
@@ -1058,7 +1157,13 @@ public class A4wpService extends Service
 
         mBluetoothGattServer.addService(a4wpService);
         Log.d(LOGTAG, "calling StartAdvertising");
-        StartAdvertising();
+
+        try {
+            StartAdvertising();
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Failed to start advertising");
+            return false;
+        }
 
         return true;
     }
@@ -1068,14 +1173,16 @@ public class A4wpService extends Service
         Log.v(LOGTAG, "onCreate");
         super.onCreate();
 
+        sDebug = SystemProperties.getBoolean("persist.a4wp.logging", false);
+
         // Ensure Bluetooth is enabled
         mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
-        if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) {
+        if (mBluetoothAdapter == null || !mBluetoothAdapter.isLeEnabled()) {
             Log.d(LOGTAG, "Bluetooth is not available or enabled - exiting...");
             return;
         }
 
-        Log.v(LOGTAG, "calling startService");
+        if (sDebug) Log.v(LOGTAG, "calling startService");
         startServer();
         //Initialize PRU Static param
         mPruStaticParam = new PruStaticParam();
@@ -1083,13 +1190,22 @@ public class A4wpService extends Service
         mPruAlert = new PruAlert((byte)0);
         mPruControl = new PruControl();
 
+        if (sDebug) Log.v(LOGTAG, "onCreate: charge complete " + mChargeComplete);
+
+        /*
+         * What happens when WiPowerManager or WbcManager is NULL? This is not being checked?
+         * This should be checked for NULL to ensure the appropriate classes/services are created.
+         * The system properties determine if the wipower is supported or not. If properties are
+         * not set, then need to abort all WiPower functionality including this class.
+         */
         mWipowerManager = WipowerManager.getWipowerManger(this, mWipowerCallback);
         if (mWipowerManager != null)
              mWipowerManager.registerCallback(mWipowerCallback);
         mWbcManager = WbcManager.getInstance();
         if (mWbcManager != null) {
-            mChargeComplete = (mWbcManager.getChargingRequired() == 0);
-            Log.v(LOGTAG, "onCreate: charge complete " + mChargeComplete);
+            mChargeComplete = (mWbcManager.getChargeComplete() == 1);
+            mUSBCharging = (mWbcManager.getUSBChargingPresent() == 1);
+            Log.v(LOGTAG, "onCreate: charge complete " + mChargeComplete + " mUSBCharging " + mUSBCharging);
             mWbcManager.register(mWbcCallback);
         }
     }
@@ -1097,8 +1213,17 @@ public class A4wpService extends Service
     @Override
     public void onDestroy() {
         Log.v(LOGTAG, "onDestroy");
-        if (mWipowerManager != null)
+        try {
+          stopAdvertising();
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Failed to stop advertising");
+            return;
+        }
+
+        closeServer();
+        if (mWipowerManager != null) {
              mWipowerManager.unregisterCallback(mWipowerCallback);
+        }
         if (mWbcManager != null)
              mWbcManager.unregister(mWbcCallback);
         if(SystemProperties.getBoolean("persist.a4wp.skipwakelock", false) == false) {
@@ -1121,7 +1246,9 @@ public class A4wpService extends Service
 
         //mWipowerBoot is used to hold power enable command till the service is been registered completely
         if (mWipowerBoot == true && mWipowerManager != null) {
-            if (mChargeComplete == true) {
+            mWipowerManager.enableDataNotification(false);
+            mWipowerManager.enablePowerApply(false, false, false);
+            if ((mChargeComplete == true) || (mUSBCharging == true)) {
                 mWipowerManager.enablePowerApply(true, true, true);
             } else {
                 mWipowerManager.enablePowerApply(true, true, false);
@@ -1131,6 +1258,6 @@ public class A4wpService extends Service
             //release wake lock in case if held during crashes or on BT restart.
             acquire_wake_lock(false);
         }
-        return START_STICKY;
+        return START_NOT_STICKY;
    }
 }
diff --git a/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/BTEventHandler.java b/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/BTEventHandler.java
index d59d5f6..37b2a9b 100644
--- a/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/BTEventHandler.java
+++ b/wipower-host/a4wp/src/org/codeaurora/bluetooth/a4wp_app/BTEventHandler.java
@@ -37,42 +37,180 @@ import android.content.Context;
 import android.content.Intent;
 import android.os.SystemProperties;
 import android.util.Log;
+import android.provider.Settings;
+import android.content.ContentResolver;
+import android.os.UserHandle;
+import com.quicinc.wbc.WbcTypes;
+import com.quicinc.wbc.WbcManager;
 
 import java.lang.Object;
 
 public class BTEventHandler extends BroadcastReceiver {
-    private static final String TAG = "BTEventHandler";
-    private static final boolean V = true/*Constants.VERBOSE*/;
+    private static final String TAG = "BTEventHandler-A4WP";
+    private static boolean V = false/*Constants.VERBOSE*/;
+    private static boolean wait_for_gattdereg = false;
     private int state;
+    private BluetoothAdapter mBluetoothAdapter;
+    static boolean mPtuPresence = false;
+    private WbcManager mWbcManager;
+    static boolean wait_for_bt = false;
+
 
     @Override
     public void onReceive(Context context, Intent intent) {
+       String action = intent.getAction();
+       mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+       ContentResolver cr = context.getContentResolver();
+
+       V = SystemProperties.getBoolean("persist.a4wp.logging", false);
+       /* 1> if State changes from BT-ON to BLE-ALWAYS when MTP is
+       ** still on pad, pad detection will be broadcasted to register
+       ** a4wp service
+       ** 2> Register A4WP if BT is turned-on.
+       */
+       if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+           state = intent.getIntExtra
+                          (BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+            if (BluetoothAdapter.STATE_OFF == state) {
+               wait_for_gattdereg = false;
+               if(mBluetoothAdapter.isLeEnabled()) {
+                   if (mWbcManager != null) {
+                       mPtuPresence = (mWbcManager.getPtuPresence() == 0);
+                          if (V) Log.d(TAG, "broadcast pad detection mPtuPresence: " + mPtuPresence);
+                          if (mPtuPresence == true)
+                              context.sendBroadcastAsUser(new Intent(WbcTypes.ACTION_PTU_PRESENT), UserHandle.ALL);
+                   }
+               }
+            } else if (BluetoothAdapter.STATE_ON == state) {
+                if(SystemProperties.get("bluetooth.a4wp").equals("true")) {
+                    if (V) Log.d(TAG, "Service Already registered - BTON");
+                    return;
+                } else {
+                    if(SystemProperties.getBoolean("persist.bluetooth.a4wp", false) == false) {
+                        Log.e(TAG, "A4WP is not supported");
+                        return;
+                    }
+                    ComponentName service = context.startService
+                                      (new Intent(context, A4wpService.class));
+                    if (service != null) {
+                        Log.d(TAG, "A4wp service started successfully -  BTON");
+                        SystemProperties.set("bluetooth.a4wp", "true");
+                        wait_for_bt = false;
+                        return;
+                    } else {
+                        Log.e(TAG, "Could Not Start A4wp Service");
+                        return;
+                    }
+                }
+            }
+       }
+
+       /*
+       ** 1> In airplane mode no charging is to be done as all radios are to be turned off.
+       ** 2> if user turns on BT in airplane mode, need to ensure BT is turned on and charging
+       **    starts in BT on.
+       ** 3> If BT was on before airplane mode entry, post airplane mode exit need to esnure
+       **    charging resumes back in BT on state.
+       */
+
+       int airplaneModeOn = Settings.System.getInt(cr, Settings.System.AIRPLANE_MODE_ON, 0);
+       int persist_state = Settings.Global.getInt(cr, Settings.Global.BLUETOOTH_ON, -1);
+       if (airplaneModeOn == 1 && persist_state == 2) {
+          wait_for_bt = true;
+       }
+       /* 1> Enable Wipower-BLEOn when placed on PAD. if other app has already
+       **    enabled BLE start a4wp service and enable BLE to hold app count so
+       **    that even if other app disbles BLE a4wp will continue to hold BLE
+       **    enabled.
+       ** 2> Enable BLE_SCAN_ALWAYS_AVAILABLE in UI so that BLE Always on
+       **    feature is enabled, App needs special permission and has to be
+       **    priv app to do this.
+       ** 3> if normal BT was turned on and then placed on pad enable BLE
+       **    so that it continues to hold BLE Always on even after BT is
+       **    turned off.
+       */
+       if (action.equals("com.quicinc.wbc.action.ACTION_PTU_PRESENT") && (airplaneModeOn != 1) && (wait_for_bt == false)) {
+            if (mBluetoothAdapter != null) {
+                if (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_ON) {
+                    if (V) Log.d(TAG, "Enable BLE");
+                    Settings.Global.putInt(context.getContentResolver(),Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, 1);
+                    mBluetoothAdapter.enableBLE();
+                }
+                if ((mBluetoothAdapter.isLeEnabled()) ||
+                    (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_ON)) {
+                    if(SystemProperties.getBoolean("persist.bluetooth.a4wp", false) == false) {
+                        Log.e(TAG, "A4WP is not supported");
+                        return;
+                    }
+                    if(SystemProperties.get("bluetooth.a4wp").equals("true")) {
+                        Log.e(TAG, "Service Already registered: PTU Detect");
+                       return;
+                    }
+                    if (wait_for_gattdereg == false) {
+                        ComponentName service = context.startService
+                                          (new Intent(context, A4wpService.class));
+                        if (service != null) {
+                            Log.e(TAG, "A4wp service started successfully: PTU Detect");
+                            wait_for_gattdereg = false;
+                            SystemProperties.set("bluetooth.a4wp", "true");
+                        } else {
+                            Log.e(TAG, "Could Not Start A4wp Service");
+                            return;
+                        }
+                    }
+                }
+                Settings.Global.putInt(context.getContentResolver(),Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, 1);
+                mBluetoothAdapter.enableBLE();
+            }
+        }
+
+        /* A4WP service will not be registered if wipower OTP is not programmed */
         if(SystemProperties.getBoolean("persist.bluetooth.a4wp", false) == false) {
             Log.e(TAG, "A4WP is not supported");
             return;
         }
 
-        String action = intent.getAction();
-
+        if(!(SystemProperties.get("bluetooth.a4wp").equals("true"))) {
+            Log.d(TAG, "no pad detected");
+            return;
+        }
 
-        if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+        /* Pad detection enables BLE, On success "BLE On intent" will be
+        ** broadcasted, based on this intent A4WPService will be registered
+        */
+        if ((action.equals(BluetoothAdapter.ACTION_BLE_STATE_CHANGED)) ||
+            (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)))
+        {
             state = intent.getIntExtra
                            (BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
-            if (BluetoothAdapter.STATE_ON == state) {
-                if (V) Log.v(TAG, "Received BLUETOOTH_STATE_ON");
-                ComponentName service = context.startService
-                                      (new Intent(context, A4wpService.class));
-                if (service != null) {
-                    Log.e(TAG, "A4wp service started successfully");
-                } else {
-                    Log.e(TAG, "Could Not Start A4wp Service");
+            if (V) Log.d(TAG, "BLE state changed " + state);
+
+            if ((BluetoothAdapter.STATE_BLE_ON == state))
+            {
+                if (V) Log.v(TAG, "Received BLUETOOTH_BLE_STATE_ON");
+                if(SystemProperties.get("bluetooth.a4wp").equals("true")) {
+                    if (V) Log.d(TAG, "Service Already registered");
                     return;
                 }
-            } else if (BluetoothAdapter.STATE_OFF == state) {
-                if (V) Log.v(TAG, "Received BLUETOOTH_STATE_OFF");
+                if (wait_for_gattdereg == false) {
+                    ComponentName service = context.startService
+                                      (new Intent(context, A4wpService.class));
+                    if (service != null) {
+                        SystemProperties.set("bluetooth.a4wp", "true");
+                        Log.e(TAG, "A4wp service started successfully: BLE On");
+                    } else {
+                        Log.e(TAG, "Could Not Start A4wp Service");
+                        return;
+                    }
+                }
+            } else if ( BluetoothAdapter.STATE_BLE_TURNING_OFF == state ||
+                        BluetoothAdapter.STATE_TURNING_ON == state ||
+                        BluetoothAdapter.STATE_TURNING_OFF == state ) {
+                wait_for_gattdereg = true;
+                if (V) Log.d(TAG, "Deregister-A4WPService");
+                SystemProperties.set("bluetooth.a4wp", "false");
                 context.stopService(new Intent(context, A4wpService.class));
-
-           }
+            }
         }
     }
 }
diff --git a/wipower-host/core/include/wipower_const.h b/wipower-host/core/include/wipower_const.h
new file mode 100644
index 0000000..0296744
--- /dev/null
+++ b/wipower-host/core/include/wipower_const.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of The Linux Foundation nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _WIPOWER_CONSTANTS_H_
+#define _WIPOWER_CONSTANTS_H_
+
+#define WP_HCI_VS_CMD 0xFC1F
+
+#define WP_HCI_CMD_SET_CURRENT_LIMIT 0x16
+#define WP_HCI_CMD_SET_CHARGE_OUTPUT 0x17
+#define WP_HCI_CMD_ENABLE_ALERT      0x18
+#define WP_HCI_CMD_ENABLE_DATA       0x19
+#define WP_HCI_CMD_GET_CURRENT_LIMIT 0x1A
+#define WP_HCI_CMD_GET_CHARGE_OUTPUT 0x1B
+#define WP_HCI_CMD_ENABLE_POWER      0x1C
+
+#define WP_HCI_EVENT_ALERT    0x15
+#define WP_HCI_EVENT_DATA     0x16
+#define WP_HCI_EVENT_POWER_ON 0x17
+
+/*
+ * enable: 0x00 disabled, 0x01 enabled: enable/disable detection command
+ * on: 0x00 power down  [event on PRU placed on to PTU]
+ *     0x01 power up    [event on PRU taken out of PTU]
+ * time_flag: if true then host advertises on 600ms and if false its for 30ms
+ * i.e. for PTU to short beacon on long beacon detection on charge complete or
+ * charge required.
+ */
+int enable_power_apply(bool enable, bool on, bool time_flag);
+
+#endif /*_WIPOWER_CONSTANTS_H_*/
diff --git a/wipower-host/core/src/wipower.c b/wipower-host/core/src/wipower.c
new file mode 100644
index 0000000..2f41b33
--- /dev/null
+++ b/wipower-host/core/src/wipower.c
@@ -0,0 +1,560 @@
+/*
+ * Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of The Linux Foundation nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <utils/Log.h>
+#include <pthread.h>
+#include <string.h>
+
+#include <hardware/wipower.h>
+#include <hardware/bluetooth.h>
+
+#include "bta_api.h"
+#include "btm_api.h"
+#include "btif_common.h"
+#include "wipower_const.h"
+
+pthread_mutex_t signal_mutex;
+pthread_cond_t signal_cv;
+
+/* #define LOG_NDDEBUG 0 */
+
+#define WIP_LOG_TAG "wipower"
+#define DBG false
+#define HCI_EVENT_WAIT_TIMEOUT 2
+
+#define WIPOWER_ADV_30MS_MSB 0x00
+#define WIPOWER_ADV_30MS_LSB 0x1E
+#define WIPOWER_ADV_600MS_LSB 0x58
+#define WIPOWER_ADV_600MS_MSB 0x02
+
+/*1 seconds timeout*/
+#define WIPOWER_DATA_IDLE_TIMEOUT (600)
+
+wipower_callbacks_t *wipower_hal_cbacks = NULL;
+wipower_dyn_data_t wipower_dyn_data;
+
+unsigned char gStatus;
+wipower_state_t gState;
+unsigned char gCurrentLimit;
+timer_t  wp_data_timer;
+/* adv_inst is captured during MultiAdvertiser and
+** need to track same for wipower instance */
+extern UINT8 wipower_inst_id;
+
+char power_removal_event[] = {0x17, 0x00};
+void dispatch_wp_events (UINT16 len, char* p_param);
+
+static void wp_data_timeout() {
+    if (DBG)
+        ALOGI("%s",__FUNCTION__);
+    int len = 2;
+
+    /*Imitate the power removal event as part of the
+     * timeout so that App layer disconnect GATT*/
+    /*Event is part of payload, Length used as Event*/
+    btif_transfer_context(dispatch_wp_events, (UINT16)len,
+          (char*)power_removal_event, len, NULL);
+    if (wipower_hal_cbacks) {
+        ALOGE("dispatch_wp_events :Sending associate event to jni");
+        wipower_hal_cbacks->callback_thread_event(DISASSOCIATE_JVM);
+    }
+
+}
+
+static void wipower_data_timer_stop()
+{
+    int status = -1;
+    struct itimerspec ts;
+
+    ts.it_value.tv_sec = 0;
+    ts.it_value.tv_nsec = 0;
+    ts.it_interval.tv_sec = 0;
+    ts.it_interval.tv_nsec = 0;
+    if (wp_data_timer != 0)
+         status = timer_settime(wp_data_timer, 0, &ts, 0);
+    if(status == -1)
+         ALOGE("%s:Failed to stop wp data timer",__FUNCTION__);
+    else if(status == 0)
+         ALOGI("%s: wp data timer Stopped",__FUNCTION__);
+}
+
+static void wipower_data_timer_start()
+{
+    int status = -1;
+    struct itimerspec ts;
+    uint32_t timeout_ms;
+
+    timeout_ms = WIPOWER_DATA_IDLE_TIMEOUT;
+    ts.it_value.tv_sec = timeout_ms/1000;
+    ts.it_value.tv_nsec = 1000000*(timeout_ms%1000);
+    ts.it_interval.tv_sec = 0;
+    ts.it_interval.tv_nsec = 0;
+
+    if (wp_data_timer != 0)
+        status = timer_settime(wp_data_timer, 0, &ts, 0);
+    if (status == -1)
+        ALOGE("%s:Failed to set wack timer",__FUNCTION__);
+    if (DBG)
+        ALOGI("%s:set timer passed: %d",__FUNCTION__, status);
+}
+
+void dispatch_enable_event (UINT16 event, char* p_param) {
+    wipower_state_t state = OFF;
+
+    unsigned char stat =  *p_param;
+    if (DBG)
+        ALOGI("%s: %x", __func__, stat);
+
+    if (stat == 0x00) state = ON;
+    else  state = OFF;
+
+    if (wipower_hal_cbacks) {
+        wipower_hal_cbacks->wipower_state_changed_cb(state);
+    } else {
+        ALOGE("wipower_hal_cbacks not registered");
+    }
+}
+
+
+void enable_cb(tBTM_VSC_CMPL *p1) {
+    unsigned char status = 0xFF;
+
+    if (p1->param_len) {
+        status = p1->p_param_buf[p1->param_len-2];
+
+        if (DBG)
+            ALOGI("%s: %x", __func__, status);
+
+    }
+
+    btif_transfer_context(dispatch_enable_event, 0/*Event is not used*/,
+          (char*)&status, sizeof(status), NULL);
+}
+
+void set_current_limit_cb(tBTM_VSC_CMPL *p1) {
+    gStatus = 0xFF;
+    unsigned char status = 0x00;
+
+    if (p1->param_len) {
+        status = p1->p_param_buf[p1->param_len-2];
+
+        if (DBG)
+            ALOGI("%s: %x", __func__, status);
+
+        if (status == 0) {
+                gStatus = 0x00;
+        }
+    }
+}
+
+void get_current_limit_cb(tBTM_VSC_CMPL *p1) {
+    gStatus = 0xFF;
+    unsigned char status = 0x00;
+
+    if (p1->param_len) {
+        status = p1->p_param_buf[p1->param_len-2];
+
+        if (status == 0) {
+            gStatus = 0x00;
+            gCurrentLimit = p1->p_param_buf[p1->param_len-2];
+        }
+    }
+    if (DBG)
+        ALOGI("%s->%x", __func__, gCurrentLimit);
+}
+
+void get_state_cb(tBTM_VSC_CMPL *p1) {
+    gStatus = 0xFF;
+    unsigned char status = 0x00;
+
+    if (p1->param_len) {
+        status = p1->p_param_buf[p1->param_len-3];
+        if(DBG)
+            ALOGI("%s: %x", __func__, status);
+
+        if (status == 0) {
+            gStatus = 0x00;
+            gState =  p1->p_param_buf[p1->param_len-1];
+        }
+    }
+}
+
+void enable_alert_cb(tBTM_VSC_CMPL *p1) {
+    gStatus = 0xFF;
+    unsigned char status = 0x00;
+
+    if (p1->param_len) {
+        status = p1->p_param_buf[p1->param_len-2];
+        if (DBG)
+            ALOGI("%s: %x", __func__, status);
+
+        if (status == 0) {
+                gStatus = 0x00;
+        }
+    }
+}
+
+void enable_data_cb(tBTM_VSC_CMPL *p1) {
+    gStatus = 0xFF;
+    unsigned char status = 0x00;
+
+    if (p1->param_len) {
+        status = p1->p_param_buf[p1->param_len-2];
+        if (DBG)
+            ALOGI("%s: %x", __func__, status);
+
+        if (status == 0) {
+                gStatus = 0x00;
+        }
+    }
+}
+
+void enable_power_cb(tBTM_VSC_CMPL *p1) {
+    gStatus = 0xFF;
+    unsigned char status = 0x00;
+
+    if (p1->param_len) {
+        status = p1->p_param_buf[p1->param_len-2];
+
+        if (DBG)
+            ALOGI("%s: %x", __func__, status);
+
+        if (status == 0) {
+                gStatus = 0x00;
+        }
+    }
+}
+
+void dispatch_wp_events (UINT16 len, char* p_param) {
+    if (DBG)
+        ALOGI("%s->", __func__);
+
+    unsigned char event = p_param[0];
+    switch(event) {
+    case WP_HCI_EVENT_ALERT: {
+        if (len != 2) {
+            ALOGE("WP_HCI_EVENT_ALERT:Error! Length"); return;
+        } else {
+            unsigned char alert = p_param[1];
+            if (wipower_hal_cbacks) {
+                wipower_hal_cbacks->wipower_alert(alert);
+                if (DBG)
+                    ALOGI("alert event forwarded to app layer");
+            } else {
+                ALOGE("wipower_hal_cbacks not registered");
+            }
+        }
+    } break;
+    case WP_HCI_EVENT_DATA: {
+        if (len != 21) {
+            ALOGE("WP_HCI_EVENT_DATA: Error! Length"); return;
+        } else {
+            memcpy(&wipower_dyn_data, &p_param[1], 20);
+            if (wipower_hal_cbacks) {
+                wipower_hal_cbacks->wipower_data(&wipower_dyn_data);
+                if (DBG)
+                    ALOGI("wp data event forwarded to app layer");
+            } else {
+                ALOGE("wipower_hal_cbacks not registered");
+            }
+            wipower_data_timer_stop();
+            wipower_data_timer_start();
+        }
+
+    } break;
+    case WP_HCI_EVENT_POWER_ON: {
+        if (len != 2) {
+            ALOGE("WP_HCI_EVENT_POWER_ON: Error! Length"); return;
+        } else {
+            if (wipower_hal_cbacks) {
+               ALOGE("dispatch_wp_events :Sending associate event to jni");
+               wipower_hal_cbacks->callback_thread_event(ASSOCIATE_JVM);
+            }
+            unsigned char alert = p_param[1];
+            if (wipower_hal_cbacks) {
+                wipower_hal_cbacks->wipower_power_event(alert);
+                if (DBG)
+                    ALOGI("wp power-on event forwarded to app layer");
+            } else {
+                ALOGE("wipower_hal_cbacks not registered");
+            }
+
+        }
+
+    } break;
+    }
+
+}
+
+void wp_events(UINT8 len, UINT8 *p) {
+    if (DBG)
+        ALOGI("%s-> %d", __func__, len);
+
+    /*Event is part of payload, Length used as Event*/
+    btif_transfer_context(dispatch_wp_events, (UINT16)len,
+          (char*)p, len, NULL);
+}
+
+/** Enable Wireless charging/Start Wireless charging */
+int enable(bool enable)
+{
+    UINT8 en[2];
+    if (DBG)
+        ALOGI("enable: %d", enable);
+
+    if (!btif_is_enabled()) {
+        ALOGE("%s: btif main adapter is NOT fully enabled", __func__);
+        return -1;
+    }
+
+    en[0] = WP_HCI_CMD_SET_CHARGE_OUTPUT;
+
+    if (enable) {
+        en[1] = 1;
+    } else {
+        en[1]= 0;
+    }
+
+    BTM_VendorSpecificCommand(WP_HCI_VS_CMD, 2, en, enable_cb);
+
+    return 0;
+}
+
+
+int set_current_limit(short value)
+{
+    UINT8 curr_limit[2];
+    int status = -1;
+
+    if (!btif_is_enabled()) {
+        ALOGE("%s: btif main adapter is NOT fully enabled", __func__);
+        return status;
+    }
+
+    curr_limit[0] = WP_HCI_CMD_SET_CURRENT_LIMIT;
+    curr_limit[1] = value;
+
+    gStatus = 0xFF;
+    BTM_VendorSpecificCommand(WP_HCI_VS_CMD, 2, curr_limit, set_current_limit_cb);
+
+    if (gStatus == 0) {
+        status = 0;
+    }
+    status = 0;
+    if (DBG)
+        ALOGI("set_current_limit: Status %x", status);
+    return status;
+}
+
+unsigned char get_current_limit(void)
+{
+    unsigned char val =  0;
+    UINT8 get_limit = 0;
+
+    if (!btif_is_enabled()) {
+        ALOGE("%s: btif main adapter is NOT fully enabled", __func__);
+        return val;
+    }
+
+    get_limit = WP_HCI_CMD_GET_CURRENT_LIMIT;
+    gStatus = 0xFF;
+    BTM_VendorSpecificCommand(WP_HCI_VS_CMD, 1, &get_limit, get_current_limit_cb);
+
+    val = gCurrentLimit;
+
+    if (DBG)
+        ALOGI("get_current_limit: value %x", val);
+    return val;
+}
+
+wipower_state_t get_state(void)
+{
+    wipower_state_t state = OFF;
+    UINT8 get_state = 0;
+
+    if (!btif_is_enabled()) {
+        ALOGE("%s: btif main adapter is NOT fully enabled", __func__);
+        return state;
+    }
+
+    get_state = WP_HCI_CMD_GET_CHARGE_OUTPUT;
+    gStatus = 0xFF;
+    BTM_VendorSpecificCommand(WP_HCI_VS_CMD, 1, &get_state, get_state_cb);
+
+    if (gStatus == 0x00) {
+        state = gState;
+    }
+    if (DBG)
+        ALOGI("%s: %x", __func__, state);
+    return state;
+}
+
+int enable_alerts(bool enable)
+{
+    UINT8 en[2];
+    int status = -1;
+
+    if (!btif_is_enabled()) {
+        ALOGE("%s: btif main adapter is NOT fully enabled", __func__);
+        return status;
+    }
+
+    en[0] = WP_HCI_CMD_ENABLE_ALERT;
+    if (enable) {
+        en[1] = 1;
+    } else {
+        en[1] = 0;
+    }
+
+    BTM_VendorSpecificCommand(WP_HCI_VS_CMD, 2, en, enable_alert_cb);
+
+
+    status = gStatus;
+    if (DBG)
+        ALOGI("%s: Status %x", __func__, status);
+    return status;
+}
+
+int enable_data_notify(bool enable)
+{
+    UINT8 en[2];
+    int status = -1;
+    struct sigevent se;
+    int ret;
+
+    if (!btif_is_enabled()) {
+        ALOGE("%s: btif main adapter is NOT fully enabled", __func__);
+        return status;
+    }
+
+    en[0] = WP_HCI_CMD_ENABLE_DATA;
+    if (enable) {
+        en[1] = 1;
+    } else {
+        en[1] = 0;
+    }
+
+    BTM_VendorSpecificCommand(WP_HCI_VS_CMD, 2, en, enable_data_cb);
+
+    status = gStatus;
+    if (DBG)
+        ALOGI("enable_data_notify: Status %x", status);
+
+    if (enable) {
+        se.sigev_notify_function = wp_data_timeout;
+        se.sigev_notify = SIGEV_THREAD;
+        se.sigev_value.sival_ptr = &wp_data_timer;
+        se.sigev_notify_attributes = NULL;
+
+        ret = timer_create(CLOCK_MONOTONIC, &se, &wp_data_timer);
+        if (ret < 0) {
+            ALOGE("%s: Error while creating timer", __func__);
+            return -1;
+        }
+        wipower_data_timer_start();
+    }
+    else {
+        if (wp_data_timer != 0)
+            timer_delete(wp_data_timer);
+    }
+
+    return status;
+}
+
+int enable_power_apply(bool enable, bool on, bool time_flag)
+{
+    UINT8 en[6];
+    if (DBG)
+        ALOGI("%s:%d", __func__, enable);
+
+    if (!btif_is_enabled()) {
+        ALOGE("%s: btif main adapter is NOT fully enabled", __func__);
+        return -1;
+    }
+
+    en[0] = WP_HCI_CMD_ENABLE_POWER;
+    if (enable) {
+        en[1] = 1;
+    } else {
+        en[1] = 0;
+    }
+
+    /* 30ms beacon is used to advertise if charge is required
+     * else uses 600ms beacon to advertise on charge completeion */
+
+    en[2] = on;
+    if (time_flag == true) {
+        en[3] = WIPOWER_ADV_600MS_LSB;
+        en[4] = WIPOWER_ADV_600MS_MSB;
+    } else {
+        en[3] = WIPOWER_ADV_30MS_LSB;
+        en[4] = WIPOWER_ADV_30MS_MSB;
+    }
+    en[5] = wipower_inst_id;
+    BTM_VendorSpecificCommand(WP_HCI_VS_CMD, 6, en, enable_power_cb);
+    return 0;
+}
+
+int init(wipower_callbacks_t *wp_callbacks) {
+    bool enable = true;
+    int ret = 0;
+
+    wipower_hal_cbacks = wp_callbacks;
+    ALOGV("BTM_RegisterForVSEvents: enetering init");
+
+    tBTM_STATUS res = BTM_RegisterForVSEvents(wp_events, enable);
+    if (res != BTM_SUCCESS) {
+        ALOGE("Failure of BTM_RegisterForVSEvents %d", res);
+        ret = -1;
+    }
+
+    return ret;
+}
+
+static const wipower_interface_t wipowerInterface = {
+    sizeof(wipowerInterface),
+    /* Initialize wipower module*/
+    init,
+    /** Enable wireless charging */
+    enable,
+    set_current_limit,
+    get_current_limit,
+    get_state,
+    enable_alerts,
+    enable_data_notify,
+    enable_power_apply
+};
+
+const wipower_interface_t* get_wipower_interface ()
+{
+    ALOGI("get wp interface>>");
+    return &wipowerInterface;
+}
diff --git a/wipower-host/jni/Android.mk b/wipower-host/jni/Android.mk
index e44ce54..fb5c6ba 100644
--- a/wipower-host/jni/Android.mk
+++ b/wipower-host/jni/Android.mk
@@ -8,7 +8,8 @@ LOCAL_SRC_FILES:= \
 
 LOCAL_C_INCLUDES += \
     $(JNI_H_INCLUDE) \
-        packages/apps/Bluetooth/jni
+        packages/apps/Bluetooth/jni \
+		vendor/qcom/opensource/bluetooth/hal/include
 
 
 LOCAL_REQUIRED_MODULES := bluetooth.default
diff --git a/wipower-host/jni/android_hardware_wipower.cpp b/wipower-host/jni/android_hardware_wipower.cpp
index 02d70f6..346b901 100644
--- a/wipower-host/jni/android_hardware_wipower.cpp
+++ b/wipower-host/jni/android_hardware_wipower.cpp
@@ -39,6 +39,7 @@
 #include <sys/ioctl.h>
 #include "android_hardware_wipower.h"
 #include "com_android_bluetooth.h"
+#include <hardware/vendor.h>
 
 #define CHECK_CALLBACK_ENV                                                      \
    if (!checkCallbackThread()) {                                                \
@@ -210,7 +211,7 @@ static void android_wipower_wipowerJNI_initNative (JNIEnv* env, jobject obj) {
 
 
     //Get WiPower Interface
-    sWipowerInterface = (const wipower_interface_t*)btInf->get_profile_interface(WIPOWER_PROFILE_ID);
+    sWipowerInterface = (const wipower_interface_t*)btInf->get_profile_interface(BT_PROFILE_WIPOWER_VENDOR_ID);
     if (sWipowerInterface == NULL) {
         ALOGE("%s: Get wipower interface: %x",__FUNCTION__, (unsigned int)sWipowerInterface);
         return;
diff --git a/wipower-host/wipower_service/AndroidManifest.xml b/wipower-host/wipower_service/AndroidManifest.xml
index bc7643e..5bb6cd1 100644
--- a/wipower-host/wipower_service/AndroidManifest.xml
+++ b/wipower-host/wipower_service/AndroidManifest.xml
@@ -39,6 +39,7 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
     <uses-permission android:name="android.permission.WAKE_LOCK" />
     <uses-permission android:name="android.permission.BLUETOOTH_STACK" />
+    <uses-permission android:name="android.permission.BLUETOOTH_PRIVILEGED" />
     <uses-feature android:name="android.hardware.bluetooth_le" android:required="true" />
     <application android:process="com.android.bluetooth"
         android:name=".wipower.WipowerApp"
@@ -52,6 +53,9 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            android:enabled="true"
            android:process="com.android.bluetooth">
             <intent-filter>
+                <action android:name="com.quicinc.wbc.action.ACTION_PTU_PRESENT" />
+            </intent-filter>
+            <intent-filter>
                 <action android:name="android.bluetooth.adapter.action.STATE_CHANGED" />
             </intent-filter>
         </receiver>
diff --git a/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/BTEventHandler.java b/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/BTEventHandler.java
index ad1e33d..53b157e 100644
--- a/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/BTEventHandler.java
+++ b/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/BTEventHandler.java
@@ -41,39 +41,81 @@ import android.util.Log;
 import java.lang.Object;
 
 public class BTEventHandler extends BroadcastReceiver {
-    private static final String TAG = "BTEventHandler";
-    private static final boolean V = false/*Constants.VERBOSE*/;
+    private static final String TAG = "BTEventHandler-Wipower";
+    private static boolean V = false/*Constants.VERBOSE*/;
     private int state;
+    private BluetoothAdapter mBluetoothAdapter;
 
     @Override
     public void onReceive(Context context, Intent intent) {
-        if(SystemProperties.getBoolean("ro.bluetooth.wipower", false) == false) {
+        if(SystemProperties.getBoolean("persist.bluetooth.a4wp", false) == false) {
             Log.e(TAG, "WipowerService is not supported");
             return;
         }
 
+        Intent in = new Intent();
+        in.putExtras(intent);
+        in.setClass(context, WipowerService.class);
         String action = intent.getAction();
+        in.putExtra("action",action);
 
-        if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+        V = SystemProperties.getBoolean("persist.a4wp.logging", false);
+
+        if (V) {
             state = intent.getIntExtra
-                           (BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
-            if (BluetoothAdapter.STATE_ON == state) {
-                if (V) Log.e(TAG, "Received BLUETOOTH_STATE_ON");
+                      (BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+            Log.d(TAG, "action: " + action + "state: " + state);
+        }
 
-                ComponentName service = context.startService
-                                      (new Intent(context, WipowerService.class));
+        if (action.equals("com.quicinc.wbc.action.ACTION_PTU_PRESENT")) {
+            mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+            if (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_ON ||
+                mBluetoothAdapter.isLeEnabled()) {
+                if(SystemProperties.get("bluetooth.wipower").equals("true")) {
+                    Log.e(TAG, "Wipower Service is running");
+                    return;
+                }
+                ComponentName service = context.startService(in);
                 if (service != null) {
-                    Log.e(TAG, "WipowerService started successfully");
+                    Log.d(TAG, "WipowerService started successfully - PTU");
+                    SystemProperties.set("bluetooth.wipower", "true");
                 } else {
                     Log.e(TAG, "Could Not Start Wipower Service ");
                     return;
                 }
+            }
+        }
 
+        if ((action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)))
+        {
+            state = intent.getIntExtra
+                           (BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+            if (V) Log.d(TAG, "State: " + state);
 
-            } else if (BluetoothAdapter.STATE_OFF == state) {
-                if (V) Log.v(TAG, "Received BLUETOOTH_STATE_OFF");
-                context.stopService(new Intent(context, WipowerService.class));
-           }
+            if ((BluetoothAdapter.STATE_ON == state))
+            {
+                if(SystemProperties.get("bluetooth.wipower").equals("true")) {
+                    Log.e(TAG, "Wipower Service is running");
+                    return;
+                }
+                ComponentName service = context.startService(in);
+                if (service != null) {
+                    Log.d(TAG, "WipowerService started successfully");
+                    SystemProperties.set("bluetooth.wipower", "true");
+                } else {
+                    Log.e(TAG, "Could Not Start Wipower Service ");
+                    return;
+                }
+            } else if ( BluetoothAdapter.STATE_OFF == state ) {
+               mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+               if (!(mBluetoothAdapter.isLeEnabled())) {
+                   Log.v(TAG, "stopping wipower service on BLE off");
+                   context.startService(in);
+                   SystemProperties.set("bluetooth.wipower", "false");
+               } else {
+                   Log.v(TAG, "le is still enbaled - do not stop service");
+               }
+            }
         }
     }
 }
diff --git a/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/WipowerService.java b/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/WipowerService.java
index 524810d..0e64d71 100644
--- a/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/WipowerService.java
+++ b/wipower-host/wipower_service/src/org/codeaurora/bluetooth/wipower/WipowerService.java
@@ -54,6 +54,7 @@ import android.wipower.IWipower;
 import android.wipower.IWipowerManagerCallback;
 import android.os.RemoteCallbackList;
 import android.os.RemoteException;
+import android.os.StrictMode;
 
 /**
  * Class which executes A4WP service
@@ -65,63 +66,88 @@ public class WipowerService extends Service
     private BluetoothAdapter mBluetoothAdapter = null;
     private BluetoothGattServer mBluetoothGattServer = null;
     private BluetoothDevice mDevice = null;
+    private int mStartId = -1;
 
     private static final Object mLock = new Object();
     private int mState = BluetoothProfile.STATE_DISCONNECTED;
 
+
+    private static final String BLUETOOTH_PRIVILEGED =
+        android.Manifest.permission.BLUETOOTH_PRIVILEGED;
+    private void enforcePrivilegedPermission() {
+        enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED,
+           "Need BLUETOOTH_PRIVILEGED permission");
+    }
+
+    static {
+        Log.v(LOGTAG, "Calling classInitNative");
+        classInitNative();
+    }
+
     public boolean startCharging() {
+        enforcePrivilegedPermission();
         int ret = enableNative(true);
         return (ret==0) ? true : false;
     }
 
     public boolean stopCharging() {
+        enforcePrivilegedPermission();
         int ret = enableNative(false);
         return (ret==0) ? true : false;
     }
 
     public int getState() {
+        enforcePrivilegedPermission();
         int ret = getStateNative();
         return ret;
     }
 
     public boolean setCurrentLimit(byte value) {
+        enforcePrivilegedPermission();
         int ret = setCurrentLimitNative(value);
         return (ret==0) ? true : false;
     }
 
     public byte getCurrentLimit() {
+        enforcePrivilegedPermission();
         byte ret = getCurrentLimitNative();
         return ret;
     }
 
     public boolean enableAlert(boolean enable) {
+        enforcePrivilegedPermission();
         int ret = enableAlertNative(enable);
         return (ret==0) ? true : false;
     }
 
     public boolean enableData(boolean enable) {
+        enforcePrivilegedPermission();
         int ret = enableDataNative(enable);
         return (ret==0) ? true : false;
     }
 
     public boolean enablePowerApply(boolean enable, boolean on, boolean time_flag) {
+        enforcePrivilegedPermission();
         Log.v(LOGTAG, "enablePowerApply: Calling Native enablei: " + enable + " on: " + on);
         int ret = enablePowerApplyNative(enable, on, time_flag);
         return (ret==0) ? true : false;
     }
 
     public void registerCallback(IWipowerManagerCallback callback) {
+        enforcePrivilegedPermission();
         mCallbacks.register(callback);
     }
 
     public void unregisterCallback(IWipowerManagerCallback callback) {
+        enforcePrivilegedPermission();
         mCallbacks.unregister(callback);
     }
 
-    private static class WipowerBinder extends IWipower.Stub {
+    private class WipowerBinder extends IWipower.Stub {
         private WipowerService mService;
 
          public WipowerBinder(WipowerService svc) {
+             enforcePrivilegedPermission();
              Log.e(LOGTAG, ">In Constructor");
              mService = svc;
          }
@@ -218,6 +244,7 @@ public class WipowerService extends Service
 
 
         public void registerCallback(IWipowerManagerCallback callback) {
+            enforcePrivilegedPermission();
             if (mService == null) {
                 Log.e(LOGTAG, "registerCallback:Service not found");
             } else {
@@ -227,7 +254,8 @@ public class WipowerService extends Service
         }
 
         public void unregisterCallback(IWipowerManagerCallback callback) {
-           if (mService == null) {
+            enforcePrivilegedPermission();
+            if (mService == null) {
                 Log.e(LOGTAG, "unregisterCallback:Service not found");
             } else {
                 mService.unregisterCallback(callback);
@@ -241,7 +269,6 @@ public class WipowerService extends Service
 
     public WipowerService() {
         Log.v(LOGTAG, "WipowerService");
-
     }
 
     private boolean isAvailable() {
@@ -257,6 +284,10 @@ public class WipowerService extends Service
         Log.v(LOGTAG, "onCreate");
         super.onCreate();
 
+        Log.v(LOGTAG, "Calling InitNative");
+        initNative();
+        enforcePrivilegedPermission();
+        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().permitDiskReads().build());
         mCallbacks = new RemoteCallbackList<IWipowerManagerCallback>();
         mBinder = new WipowerBinder(this);
         Log.v(LOGTAG, "onCreate>>");
@@ -265,32 +296,52 @@ public class WipowerService extends Service
 
     @Override
     public void onDestroy() {
+        enforcePrivilegedPermission();
         Log.v(LOGTAG, "onDestroy");
     }
 
     @Override
     public IBinder onBind(Intent in) {
+        enforcePrivilegedPermission();
         Log.v(LOGTAG, "onBind");
         return mBinder;
     }
 
+    private void parseIntent(final Intent intent) {
+        String action = (intent == null) ? null : intent.getStringExtra("action");
+        if (action != null) {
+            int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+            if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+                if (BluetoothAdapter.STATE_ON == state) {
+                   Log.v(LOGTAG, "Start Service on BT On");
+
+                } else if (BluetoothAdapter.STATE_OFF == state) {
+                     if (stopSelfResult(mStartId)) {
+                         Log.d(LOGTAG, "successfully stopped wipower service");
+                     }
+                }
+            } else if (action.equals("com.quicinc.wbc.action.ACTION_PTU_PRESENT")) {
+                   Log.v(LOGTAG, "Start Service on PAD detect");
+            }
+        }
+    }
+
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
+        enforcePrivilegedPermission();
         Log.d(LOGTAG, "onStart Command called!!");
+        mStartId = startId;
+        if (intent != null) {
+            parseIntent(intent);
+        }
 
-        Log.v(LOGTAG, "Calling classInitNative");
-        classInitNative();
-
-        Log.v(LOGTAG, "Calling InitNative");
-        initNative();
-        //Make this restarable service by
-        //Android app manager
         return START_NOT_STICKY;
    }
 
 
    void stateChangeCallback (int state) {
         Log.e(LOGTAG, "stateChangeCallback: " + state);
+        enforcePrivilegedPermission();
         if (mCallbacks !=null) {
            int n = mCallbacks.beginBroadcast();
            Log.v(LOGTAG,"Broadcasting updateAdapterState() to " + n + " receivers.");
@@ -308,6 +359,7 @@ public class WipowerService extends Service
    void wipowerAlertNotify (int alert) {
         Log.e(LOGTAG, "wipowerAlertNotify: " + alert);
 
+        enforcePrivilegedPermission();
         if (mCallbacks !=null) {
         int n=mCallbacks.beginBroadcast();
         Log.d(LOGTAG,"Broadcasting wipower alert() to " + n + " receivers.");
@@ -325,6 +377,7 @@ public class WipowerService extends Service
    void wipowerPowerNotify (byte alert) {
         Log.e(LOGTAG, "wipowerPowerNotify: " + alert);
 
+        enforcePrivilegedPermission();
         if (mCallbacks !=null) {
         int n=mCallbacks.beginBroadcast();
         Log.d(LOGTAG,"Broadcasting wipower power alert() to " + n + " receivers.");
@@ -342,7 +395,7 @@ public class WipowerService extends Service
 
    void wipowerDataNotify (byte[] data) {
         Log.e(LOGTAG, "wipowerDataNotify: " + data);
-
+        enforcePrivilegedPermission();
         if (mCallbacks !=null) {
         int n = mCallbacks.beginBroadcast();
         Log.d(LOGTAG,"Broadcasting wipowerdata() to " + n + " receivers.");
